<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CatBro&#39;s Blog</title>
  <icon>https://catbro666.github.io/icon.png</icon>
  <subtitle>Volar con el viento</subtitle>
  <link href="https://catbro666.github.io/atom.xml" rel="self"/>
  
  <link href="https://catbro666.github.io/"/>
  <updated>2021-11-07T11:20:32.786Z</updated>
  <id>https://catbro666.github.io/</id>
  
  <author>
    <name>猫猫哥</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>是谁断了我的连接？—从压测碰到的一个奇怪问题聊聊Nginx的连接管理和性能调测</title>
    <link href="https://catbro666.github.io/posts/4198933e/"/>
    <id>https://catbro666.github.io/posts/4198933e/</id>
    <published>2021-11-07T09:52:11.000Z</published>
    <updated>2021-11-07T11:20:32.786Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;Nginx是目前使用最广泛的Web服务器之一，以高性能而著称，得益于其异步事件驱动架构，在高并发下仍然可以保持低消耗高性能，而模块化的设计也使其更易扩展，丰富了其功能。对于Nginx基本的介绍网上已有很多的文章，也有像《深入理解Nginx》这样的书籍讲解Nginx的架构设计与开发方法。本文不会涉及Nginx开发相关内容，而是以一个实际问题的定位过程作为引子，聊一下Nginx的连接管理和性能调测。如果你并不关心这个实际问题，可以直接跳到&lt;a href=&quot;#%E8%BF%9E%E6%8E%A5%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&quot;&gt;连接生命周期&lt;/a&gt;。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="技术向" scheme="https://catbro666.github.io/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"/>
    
    
    <category term="Nginx" scheme="https://catbro666.github.io/tags/Nginx/"/>
    
    <category term="性能调优" scheme="https://catbro666.github.io/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试—09支持动态添加和删除断点</title>
    <link href="https://catbro666.github.io/posts/1fdd30ce/"/>
    <id>https://catbro666.github.io/posts/1fdd30ce/</id>
    <published>2021-11-02T14:06:24.000Z</published>
    <updated>2021-11-11T16:44:12.551Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;前面已经支持了几种不同的方式添加断点，但是必须事先在代码中添加断点，在使用上不是那么灵活方便。本文将支持动态增删断点，只需要开一开始引入调试库即可，后续可以在调试过程中动态的添加和删除断点。事不宜迟，我们直接进入正题。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="技术向" scheme="https://catbro666.github.io/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SSL及GMVPN握手协议详解</title>
    <link href="https://catbro666.github.io/posts/59c71edb/"/>
    <id>https://catbro666.github.io/posts/59c71edb/</id>
    <published>2021-11-01T13:01:32.000Z</published>
    <updated>2021-11-01T19:05:20.248Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;之前写过一篇关于&lt;a href=&quot;../e92ef4b4&quot;&gt;SSL协议的文章&lt;/a&gt;，主要介绍了加密学的基础，并从整体上对SSL协议做了介绍。由于篇幅原因，SSL握手的详细流程没有深入介绍。本文将拆解握手流程，在消息级别对握手进行详细地介绍。还没有加密学基本概念的、或者不清楚SSL协议的基本情况的建议先看一下前面一篇的内容。另外，本文主要是针对TLSv1.2和GMVPN的情况，对于TLSv1.3暂不涉及。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="理论向" scheme="https://catbro666.github.io/categories/%E7%90%86%E8%AE%BA%E5%90%91/"/>
    
    
    <category term="SSL/TLS" scheme="https://catbro666.github.io/tags/SSL-TLS/"/>
    
  </entry>
  
  <entry>
    <title>Linux TC 流量控制介绍</title>
    <link href="https://catbro666.github.io/posts/357ad3ec/"/>
    <id>https://catbro666.github.io/posts/357ad3ec/</id>
    <published>2021-10-17T08:10:15.000Z</published>
    <updated>2021-10-17T15:48:17.799Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;前段时间在做一些测试的时候接触到了Linux tc，因为需要对数据包添加延迟，用到了tc中的netem。添加简单的延迟非常简单，像这样一条命令就搞定了：&lt;code&gt;$ tc qdisc add dev eth0 root netem delay 1s&lt;/code&gt;，你甚至不需要完全理解命令中参数的含义。但是当你想做一些更加特殊的限制的时候，（比如只对某个特定的ip端口添加延迟、或者只对入站的流量添加延迟），事情就变得有些棘手了，简单的百度貌似已经满足不了要求了。你不得不了解TC中的一些基本概念，以及tc[2]命令中相关参数的含义。&lt;/p&gt;&lt;p&gt;本文正是带你了解这些TC中的基本概念，并通过一个实际例子，将这些概念与tc命令联系起来。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="工具向" scheme="https://catbro666.github.io/categories/%E5%B7%A5%E5%85%B7%E5%90%91/"/>
    
    
    <category term="Linux" scheme="https://catbro666.github.io/tags/Linux/"/>
    
    <category term="TC" scheme="https://catbro666.github.io/tags/TC/"/>
    
    <category term="流量控制" scheme="https://catbro666.github.io/tags/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试—08支持通过包名称添加断点</title>
    <link href="https://catbro666.github.io/posts/5c25711/"/>
    <id>https://catbro666.github.io/posts/5c25711/</id>
    <published>2021-09-12T10:38:31.000Z</published>
    <updated>2021-09-12T17:33:24.560Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;在前一篇中我们支持了通过函数名称来添加断点，我们同时也提到了在Lua中一个函数的名称的并不是确定的。准确的说，Lua中的函数并没有名称，所谓名称其实是保存这个函数值的变量的名称。&lt;/p&gt;&lt;p&gt;于是通过函数名称添加断点就造成了一定的不确定性，因为函数被调用时并不一定是以这个名字被调用的。另外，多个不同的函数也可能以相同的名字进行调用。&lt;/p&gt;&lt;p&gt;所以为了解决这个问题，本篇我们将继续扩展断点的设置接口，支持通过包名来添加断点。因为包名相对更具确定性，配合行号可以进行精确定位。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="技术向" scheme="https://catbro666.github.io/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试—07支持通过函数名称添加断点</title>
    <link href="https://catbro666.github.io/posts/acdf52b7/"/>
    <id>https://catbro666.github.io/posts/acdf52b7/</id>
    <published>2021-08-26T16:09:50.000Z</published>
    <updated>2021-08-26T18:03:15.685Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;我们之前已经支持了通过函数来添加断点，并且已经支持了行号的检查和自动修正。但是通过函数来添加断点有一些限制，如果在当前的位置无法访问目标函数，那我们就无法对其添加断点。&lt;/p&gt;&lt;p&gt;于是，本篇我们将扩展断点设置的接口，支持通过函数名称添加断点，以突破这个限制。&lt;/p&gt;</summary>
    
    
    
    <category term="技术向" scheme="https://catbro666.github.io/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试—06断点行号检查与自动修正</title>
    <link href="https://catbro666.github.io/posts/fa52978d/"/>
    <id>https://catbro666.github.io/posts/fa52978d/</id>
    <published>2021-08-18T12:55:57.000Z</published>
    <updated>2021-08-20T16:50:19.830Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;前面两篇我们对性能做了一个优化，接下来继续来丰富调试器的特性。&lt;/p&gt;&lt;p&gt;我们前面提到过，函数内并不是所有行都是有效行，空行和注释行就不是有效行。我们之前在添加断点的时候，并没有对行号进行检查，任何行号都能成功添加断点。所以如果添加的断点行号是无效的，那么永远也不会断到那里。但是钩子里并不知道它是无效的，call事件仍然会以为函数有断点从而启动line事件，造成CPU的浪费。&lt;/p&gt;&lt;p&gt;所以本篇，我们将对断点的行号进行检查，对于不在函数范围内的行号直接添加断点失败；在函数范围内的行号则自动修正为下一个有效的行号；另外支持不指定行号，默认为函数的第一个有效行。&lt;/p&gt;</summary>
    
    
    
    <category term="技术向" scheme="https://catbro666.github.io/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试--05优化断点信息数据结构</title>
    <link href="https://catbro666.github.io/posts/2e777dd3/"/>
    <id>https://catbro666.github.io/posts/2e777dd3/</id>
    <published>2021-08-17T12:40:09.000Z</published>
    <updated>2021-08-18T12:49:42.679Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;在上一篇&lt;a href=&quot;../c1ecd715/&quot;&gt;04优化钩子事件处理&lt;/a&gt;中，我们在钩子函数中引入了call和return事件的处理，对性能进行了优化。&lt;/p&gt;&lt;p&gt;细心的同学可能已经发现了，我们的hook函数中call事件和line都需要对整个断点表进行遍历，这其中其实是存在着一些冗余的。因为call事件只关心函数是否有断点，而line事件则只关心本函数内有哪些断点。所以我们可以想办法优化一下断点信息的数据结构，进一步提升性能。&lt;/p&gt;</summary>
    
    
    
    <category term="技术向" scheme="https://catbro666.github.io/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试--04优化钩子事件处理</title>
    <link href="https://catbro666.github.io/posts/c1ecd715/"/>
    <id>https://catbro666.github.io/posts/c1ecd715/</id>
    <published>2021-08-16T11:52:15.000Z</published>
    <updated>2021-08-17T12:45:36.647Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;在第一篇的&lt;a href=&quot;../f9a188a7/&quot;&gt;01最小实现&lt;/a&gt;中，我们实现了一个断点调试的最小实现，在设置钩子函数时只加了line事件，显然这会对性能有很大的影响。而后来两篇&lt;a href=&quot;../f6e9079c&quot;&gt;02通用变量打印&lt;/a&gt;和&lt;a href=&quot;../a05a2f5f&quot;&gt;03通用变量修改及调用栈回溯&lt;/a&gt;则是提供了一些辅助的调试接口，并没有对钩子函数进行修改。&lt;/p&gt;&lt;p&gt;我们本篇将在钩子中引入call和return事件的处理，尝试对性能进行优化。&lt;/p&gt;</summary>
    
    
    
    <category term="技术向" scheme="https://catbro666.github.io/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试--03通用变量修改及调用栈回溯</title>
    <link href="https://catbro666.github.io/posts/a05a2f5f/"/>
    <id>https://catbro666.github.io/posts/a05a2f5f/</id>
    <published>2021-08-15T04:41:09.000Z</published>
    <updated>2021-08-15T04:56:36.440Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;在前面两篇&lt;a href=&quot;../f9a188a7/&quot;&gt;01最小实现&lt;/a&gt;及&lt;a href=&quot;../f6e9079c&quot;&gt;02通用变量打印&lt;/a&gt;中，我们已经实现了设置断点、删除断点及通用变量打印接口。&lt;/p&gt;&lt;p&gt;本篇将继续新增两个辅助的调试接口：调用栈回溯打印接口、通用变量设置接口。前者打印调用栈的回溯信息，后者可以方便地修改变量的值，支持局部变量、upvalue以及全局的&lt;code&gt;_ENV&lt;/code&gt;中的变量。&lt;/p&gt;</summary>
    
    
    
    <category term="技术向" scheme="https://catbro666.github.io/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试--02通用变量打印</title>
    <link href="https://catbro666.github.io/posts/f6e9079c/"/>
    <id>https://catbro666.github.io/posts/f6e9079c/</id>
    <published>2021-08-15T04:19:48.000Z</published>
    <updated>2021-08-15T04:29:50.188Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;在前一篇&lt;a href=&quot;../f9a188a7/&quot;&gt;01最小实现&lt;/a&gt;中，我们实现了Lua断点调试的的一个最小实现。我们编写了一个模块，提供了两个基本的接口：设置断点和删除断点。&lt;/p&gt;&lt;p&gt;虽然我们已经支持在断点进行变量的打印，但是需要自己指定层数以及变量索引，使用起来不是很方便。要进行upvalue打印的话，操作会更加麻烦。为了提升调试的方便性，我们决定封装一个通用的变量打印函数，可以通过变量名查找到对应变量的值进行打印。支持局部变量、upvalue以及全局的&lt;code&gt;_ENV&lt;/code&gt;中的变量。&lt;/p&gt;</summary>
    
    
    
    <category term="技术向" scheme="https://catbro666.github.io/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试--01最小实现</title>
    <link href="https://catbro666.github.io/posts/f9a188a7/"/>
    <id>https://catbro666.github.io/posts/f9a188a7/</id>
    <published>2021-08-12T16:52:46.000Z</published>
    <updated>2021-08-14T09:58:25.352Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;说到Lua代码调试，最常用的方法应该就是加一堆print进行打印。print大法虽好，但其缺点也是显而易见的。比如效率低下，需要修改原有函数内部代码，在每个需要的地方添加print语句，运行一次只能获取一次信息，下次换个地方又得重新添加print语句。而且有时候，事先并不知道该去哪打印、或者打印什么内容，需要通过运行中获取的信息才能确定。&lt;/p&gt;&lt;p&gt;当print大法无法满足我们的需求时，就需要类似断点调试这样更高级的调试功能。本文将从零开始编写一个Lua调试器，实现类似gdb的断点调试功能。&lt;/p&gt;&lt;p&gt;本文代码已开源至&lt;a href=&quot;https://github.com/catbro666/lua-debugger&quot;&gt;Github&lt;/a&gt;，欢迎watch/star😘。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="技术向" scheme="https://catbro666.github.io/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>一篇文章搞懂密码学基础及SSL/TLS协议</title>
    <link href="https://catbro666.github.io/posts/e92ef4b4/"/>
    <id>https://catbro666.github.io/posts/e92ef4b4/</id>
    <published>2021-08-08T15:32:26.000Z</published>
    <updated>2021-11-02T14:02:19.859Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;SSL协议是现代网络通信中重要的一环，它提供了传输层上的数据安全。为了方便大家的理解，本文将先从加密学的基础知识入手，然后展开对SSL协议原理、流程以及一些重要的特性的详解，最后会扩展介绍一下国密SSL协议的差异、安全性以及TLS 1.3的关键新特性。&lt;/p&gt;&lt;p&gt;限于篇幅以及个人知识水平，本文不会涉及过于细节的内容。特别地，本文将不涉及算法的具体原理，也不涉及实际代码的实现。而是试图以图表等直观的方式来了解基本的原理以及流程。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="理论向" scheme="https://catbro666.github.io/categories/%E7%90%86%E8%AE%BA%E5%90%91/"/>
    
    
    <category term="SSL/TLS" scheme="https://catbro666.github.io/tags/SSL-TLS/"/>
    
    <category term="密码学" scheme="https://catbro666.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>自己动手实现Lua--实现TAILCALL指令</title>
    <link href="https://catbro666.github.io/posts/74970c0e/"/>
    <id>https://catbro666.github.io/posts/74970c0e/</id>
    <published>2021-07-17T08:46:43.000Z</published>
    <updated>2021-07-19T15:57:04.995Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;最近在看《自己动手实现Lua—虚拟机、编译器和标准库》。这是本挺不错的书，通过学习此书能够对Lua语言有比较深刻的理解，此外还可以对如何自己实现一门脚本语言有直观的认识。对于想学习Lua的同学，安利一下这本书。&lt;/p&gt;&lt;p&gt;废话不多说，书中留了一个作业，让读者自己实现&lt;code&gt;TAILCALL&lt;/code&gt;指令，实现尾调用的优化。本文就算是交作业吧。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="技术向" scheme="https://catbro666.github.io/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>OpenResty Lua钩子调用完整流程</title>
    <link href="https://catbro666.github.io/posts/30b81f82/"/>
    <id>https://catbro666.github.io/posts/30b81f82/</id>
    <published>2021-07-03T18:05:36.000Z</published>
    <updated>2021-08-12T12:04:21.878Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;前面一篇文章介绍了&lt;a href=&quot;../150430f0/&quot;&gt;Openresty Lua协程调度机制&lt;/a&gt;，主要关心的是核心调度函数&lt;code&gt;run_thread()&lt;/code&gt;内部发生的事情，而对于外部的事情我们并没有涉及。本篇作为其姊妹篇，准备补上剩余的部分。本篇将通过一个例子，完整介绍OpenResty中Lua钩子的调用流程，包括初始化阶段的工作、新连接进来时如何进入钩子、I/O等待时如何出去、事件触发时如何恢复、钩子正常执行结束时的操作、钩子内出错的情况。本文同样是基于&lt;code&gt;stream-lua&lt;/code&gt;模块的代码。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="技术向" scheme="https://catbro666.github.io/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="OpenResty" scheme="https://catbro666.github.io/tags/OpenResty/"/>
    
    <category term="Nginx" scheme="https://catbro666.github.io/tags/Nginx/"/>
    
    <category term="钩子" scheme="https://catbro666.github.io/tags/%E9%92%A9%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>Openresty Lua协程调度机制</title>
    <link href="https://catbro666.github.io/posts/150430f0/"/>
    <id>https://catbro666.github.io/posts/150430f0/</id>
    <published>2021-07-03T10:52:24.000Z</published>
    <updated>2021-08-12T12:12:11.209Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;OpenResty（后面简称：OR）是一个基于Nginx和Lua的高性能Web平台，它内部集成大量的Lua API以及第三方模块，可以利用它快速搭建支持高并发、极具动态性和扩展性的Web应用、Web服务或动态网关。&lt;/p&gt;&lt;p&gt;OR最大的特点就是，将Lua协程与Nginx事件驱动模型及非阻塞I/O结合起来。使用户可以在handler中使用 &lt;strong&gt;同步但是依然是非阻塞&lt;/strong&gt; 的方式编写其应用代码，而无需关心底层的协程调度以及与Nginx事件驱动模型的交互。&lt;/p&gt;&lt;p&gt;本文将先从总体上介绍OR的协程调度机制，然后结合源码以及Lua栈的情况来详细了解各个部分是如何实现的，包括其异常保护、协程初始化、协程的恢复和执行、协程的挂起、协程的执行结束、协程出错的情况。&lt;/p&gt;&lt;p&gt;本文主要关注调度函数内部的逻辑，如果想了解外部的调用流程。可以参看&lt;a href=&quot;../30b81f82/&quot;&gt;Openresty Lua钩子调用完整流程&lt;/a&gt;&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="技术向" scheme="https://catbro666.github.io/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="OpenResty" scheme="https://catbro666.github.io/tags/OpenResty/"/>
    
    <category term="Nginx" scheme="https://catbro666.github.io/tags/Nginx/"/>
    
    <category term="协程" scheme="https://catbro666.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>如何编写一个多进程性能测试程序</title>
    <link href="https://catbro666.github.io/posts/e416d910/"/>
    <id>https://catbro666.github.io/posts/e416d910/</id>
    <published>2021-06-26T12:17:38.000Z</published>
    <updated>2021-06-29T06:13:51.859Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;在工作中经常碰到需要写一些多进程/多线程的测试程序，用来测试接口的性能。本文将会从零开始一点点增加代码，最终完成一个简易的多进程测试程序编写。该程序支持实时打印测试进结果和最终测试结果的统计。&lt;/p&gt;&lt;p&gt;同时，本文还涵盖了以下知识点，可以作为学习参考：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;使用&lt;code&gt;getopt_long()&lt;/code&gt;处理命令行选项和参数&lt;/li&gt;&lt;li&gt;使用&lt;code&gt;fork()&lt;/code&gt;和&lt;code&gt;wait()&lt;/code&gt;处理多进程&lt;/li&gt;&lt;li&gt;使用&lt;code&gt;sigaction()&lt;/code&gt;配合&lt;code&gt;alarm()&lt;/code&gt;处理定时信号&lt;code&gt;SIGALRM&lt;/code&gt;&lt;/li&gt;&lt;li&gt;使用&lt;code&gt;shmget()&lt;/code&gt;、&lt;code&gt;shmat()&lt;/code&gt;、&lt;code&gt;shmdt()&lt;/code&gt;、&lt;code&gt;shmctl()&lt;/code&gt;等通过共享内存进行进程间通信&lt;/li&gt;&lt;li&gt;使用&lt;code&gt;sigaction()&lt;/code&gt;捕获&lt;code&gt;SIGINT&lt;/code&gt;和&lt;code&gt;SIGQUIT&lt;/code&gt;信号，在程序终止前做共享内存清理工作&lt;/li&gt;&lt;/ul&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="技术向" scheme="https://catbro666.github.io/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"/>
    
    
    <category term="多进程" scheme="https://catbro666.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="信号" scheme="https://catbro666.github.io/tags/%E4%BF%A1%E5%8F%B7/"/>
    
    <category term="共享内存" scheme="https://catbro666.github.io/tags/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-NexT Tag 插件的使用</title>
    <link href="https://catbro666.github.io/posts/29bfe8c9/"/>
    <id>https://catbro666.github.io/posts/29bfe8c9/</id>
    <published>2021-06-22T12:13:58.000Z</published>
    <updated>2021-06-26T11:12:07.228Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Tag Plugin&lt;/code&gt; 是一种使 Hexo 支持特殊样式内容的方法。例如，我们无法在标准 Markdown 中显示具有自定义尺寸的图像。然后我们可以使用标签插件来解决它。 Hexo 有很多可以帮助用户的标签。 Hexo 还具有主题接口，使主题能够创建自己的标签。&lt;/p&gt;</summary>
    
    
    
    <category term="工具向" scheme="https://catbro666.github.io/categories/%E5%B7%A5%E5%85%B7%E5%90%91/"/>
    
    
    <category term="Hexo" scheme="https://catbro666.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程APUE练习4.6-实现类似cp(1)的程序，保留文件中的空洞</title>
    <link href="https://catbro666.github.io/posts/aa99fc97/"/>
    <id>https://catbro666.github.io/posts/aa99fc97/</id>
    <published>2020-01-06T08:49:42.000Z</published>
    <updated>2021-06-26T11:09:28.161Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;1-题面&quot;&gt;&lt;a href=&quot;#1-题面&quot; class=&quot;headerlink&quot; title=&quot;1 题面&quot;&gt;&lt;/a&gt;1 题面&lt;/h2&gt;&lt;p&gt;编写类似&lt;code&gt;cp(1)&lt;/code&gt;的程序，它复制包含空洞的文件，但是不将字节0写到输出文件中去。&lt;/p&gt;
&lt;h2 id=&quot;2-基本思路&quot;&gt;&lt;a href=&quot;#2-基本思路&quot; class=&quot;headerlink&quot; title=&quot;2 基本思路&quot;&gt;&lt;/a&gt;2 基本思路&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;首先要搞清楚空洞的性质以判断一个文件是否有空洞，以及空洞的位置&lt;/li&gt;
&lt;li&gt;知道了空洞的位置之后，读到源文件中的空洞部分时，在目标文件中&lt;code&gt;lseek&lt;/code&gt;相应的长度&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术向" scheme="https://catbro666.github.io/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"/>
    
    
    <category term="UNIX" scheme="https://catbro666.github.io/tags/UNIX/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程APUE练习3.2-不用fcntl实现dup2的功能</title>
    <link href="https://catbro666.github.io/posts/2485f370/"/>
    <id>https://catbro666.github.io/posts/2485f370/</id>
    <published>2019-12-17T09:52:09.000Z</published>
    <updated>2021-06-26T11:09:03.174Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;题面&quot;&gt;&lt;a href=&quot;#题面&quot; class=&quot;headerlink&quot; title=&quot;题面&quot;&gt;&lt;/a&gt;题面&lt;/h2&gt;&lt;p&gt;编写与&lt;code&gt;dup2&lt;/code&gt;功能相同的函数，要求不调用&lt;code&gt;fcntl&lt;/code&gt;函数，并且要有正确的出错处理。&lt;/p&gt;
&lt;h2 id=&quot;基本思路&quot;&gt;&lt;a href=&quot;#基本思路&quot; class=&quot;headerlink&quot; title=&quot;基本思路&quot;&gt;&lt;/a&gt;基本思路&lt;/h2&gt;&lt;p&gt;不能用&lt;code&gt;fcntl&lt;/code&gt;，能够返回一个文件描述符的只有&lt;code&gt;open&lt;/code&gt;和&lt;code&gt;dup&lt;/code&gt;。而&lt;code&gt;open&lt;/code&gt;会创建一个新的文件表项，返回的fd指向新的文件表项，与&lt;code&gt;dup2&lt;/code&gt;的表现不符。&lt;code&gt;dup&lt;/code&gt;基本能满足要求，但是返回的是最小的可用fd，需要进一步操作满足要求。另外需要自己添加错误处理，以及处理oldfd与newfd相等的情况等。具体地，&lt;/p&gt;</summary>
    
    
    
    <category term="技术向" scheme="https://catbro666.github.io/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"/>
    
    
    <category term="UNIX" scheme="https://catbro666.github.io/tags/UNIX/"/>
    
  </entry>
  
</feed>

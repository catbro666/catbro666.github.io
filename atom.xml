<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CatBro&#39;s Blog</title>
  <icon>https://catbro666.github.io/icon.png</icon>
  <subtitle>Volar con el viento</subtitle>
  <link href="https://catbro666.github.io/atom.xml" rel="self"/>
  
  <link href="https://catbro666.github.io/"/>
  <updated>2022-03-20T07:37:46.257Z</updated>
  <id>https://catbro666.github.io/</id>
  
  <author>
    <name>猫猫哥</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenSSL CVE-2022-0778漏洞问题复现与非法证书构造</title>
    <link href="https://catbro666.github.io/posts/83951100/"/>
    <id>https://catbro666.github.io/posts/83951100/</id>
    <published>2022-03-19T14:53:34.000Z</published>
    <updated>2022-03-20T07:37:46.257Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;本文介绍CVE-2022 0778漏洞及其复现方法，并精心构造了具有一个非法椭圆曲线参数的证书可以触发该漏洞。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="加密与安全" scheme="https://catbro666.github.io/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
    <category term="OpenSSL" scheme="https://catbro666.github.io/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/OpenSSL/"/>
    
    
    <category term="OpenSSL" scheme="https://catbro666.github.io/tags/OpenSSL/"/>
    
    <category term="CVE" scheme="https://catbro666.github.io/tags/CVE/"/>
    
    <category term="漏洞复现" scheme="https://catbro666.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核是如何启动的</title>
    <link href="https://catbro666.github.io/posts/615fc0b5/"/>
    <id>https://catbro666.github.io/posts/615fc0b5/</id>
    <published>2022-03-12T11:01:39.000Z</published>
    <updated>2022-03-13T13:31:33.474Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;本文介绍Linux内核的引导启动以及初始化流程，从你按下电源开始到你最终进行终端登录，这期间到底发生了什么？&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://catbro666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="https://catbro666.github.io/tags/Linux/"/>
    
    <category term="内核" scheme="https://catbro666.github.io/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Nginx的共享内存管理--slab算法</title>
    <link href="https://catbro666.github.io/posts/2dc32e47/"/>
    <id>https://catbro666.github.io/posts/2dc32e47/</id>
    <published>2022-03-05T08:50:42.000Z</published>
    <updated>2022-03-10T11:27:29.774Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;初次了解到slab算法，是在学习Linux内核时。内核中采用了伙伴系统（Buddy System）算法对内存页面进行管理。但是对于小对象，还用页面分配器就显得有些浪费了，于是slab就应运而生了，内核的kmalloc()就是使用slab进行管理的。nginx中的共享内存管理使用了相同的思想，当然它没有Linux内核中的slab那么复杂。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="编程开发" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    <category term="Nginx/OpenResty" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Nginx-OpenResty/"/>
    
    
    <category term="Nginx" scheme="https://catbro666.github.io/tags/Nginx/"/>
    
    <category term="slab" scheme="https://catbro666.github.io/tags/slab/"/>
    
    <category term="共享内存" scheme="https://catbro666.github.io/tags/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>C语言中的函数调用约定</title>
    <link href="https://catbro666.github.io/posts/657c24ad/"/>
    <id>https://catbro666.github.io/posts/657c24ad/</id>
    <published>2022-01-23T12:09:28.000Z</published>
    <updated>2022-03-05T10:36:03.300Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;本文主要介绍C语言中的函数调用约定，通过汇编代码结合实时观察栈的变化情况，直观地了解函数调用的过程。本文只讨论x86/64架构、Linux/GCC环境下的情况，不过其他环境在整体思想上应该是类似的，都需要处理这些问题。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="理解计算机" scheme="https://catbro666.github.io/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="调用约定" scheme="https://catbro666.github.io/tags/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    
    <category term="C/C++" scheme="https://catbro666.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>如何在裸机上直接运行程序—王爽《汇编语言》课程设计2</title>
    <link href="https://catbro666.github.io/posts/8054db72/"/>
    <id>https://catbro666.github.io/posts/8054db72/</id>
    <published>2022-01-17T12:42:17.000Z</published>
    <updated>2022-03-05T10:43:30.687Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;平常我们的程序基本都是运行在操作系统之上，很少有机会直接在裸机上运行程序。现代操作系统需要支持多任务环境的工作方式，这要求CPU在硬件上提供支持。以Intel处理器为例，从80286/80386开始，CPU开始支持工作在保护模式，为多任务环境提供保护机制。&lt;/p&gt;&lt;p&gt;操作系统为我们提供了保护和抽象，这方便了开发和使用，但是同时也对学习者了解计算机底层工作原理造成了一定的障碍。本文通过编码实践王爽老师《汇编语言》中的课程设计2，与寄存器、内存、显存、中断、外设等进行了近距离的亲密接触，通过这次实践也算是入门汇编了吧。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="理解计算机" scheme="https://catbro666.github.io/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="8086" scheme="https://catbro666.github.io/tags/8086/"/>
    
    <category term="汇编" scheme="https://catbro666.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
    <category term="DOS" scheme="https://catbro666.github.io/tags/DOS/"/>
    
  </entry>
  
  <entry>
    <title>VIM常用快捷键和插件整理</title>
    <link href="https://catbro666.github.io/posts/d6ca5270/"/>
    <id>https://catbro666.github.io/posts/d6ca5270/</id>
    <published>2021-12-12T10:25:29.000Z</published>
    <updated>2022-03-05T10:44:58.143Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;本文不会介绍基本的VIM使用方法，如果你对VIM的几种模式、基本的编辑、移动和选取等还不了解，推荐你先看一下这篇&lt;a href=&quot;https://coolshell.cn/articles/5426.html&quot;&gt;简明 VIM 练级攻略&lt;/a&gt;，写得还是不错的，基本上最常用的命令都有了。如果你不是vim重度用户的话，知道这些命令已经足够。只能说vim的水太深，根据自身情况在编辑效率和学习成本之间做个平衡吧。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="工具" scheme="https://catbro666.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Vim" scheme="https://catbro666.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>深入理解mmap--内核代码分析及驱动demo示例</title>
    <link href="https://catbro666.github.io/posts/5ec4fb12/"/>
    <id>https://catbro666.github.io/posts/5ec4fb12/</id>
    <published>2021-12-11T13:06:53.000Z</published>
    <updated>2022-03-05T10:36:54.048Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;mmap是一个用户空间很常用的系统调用，无论是分配内存、读写大文件、链接动态库文件，还是多进程间共享内存，都可以看到其身影。本文首先介绍了进程地址空间和mmap，然后分析了内核代码以了解其实现，最后通过一个简单的demo驱动示例，加深对mmap的理解。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://catbro666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="https://catbro666.github.io/tags/Linux/"/>
    
    <category term="内存管理" scheme="https://catbro666.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="mmap" scheme="https://catbro666.github.io/tags/mmap/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试—09支持动态添加和删除断点</title>
    <link href="https://catbro666.github.io/posts/1fdd30ce/"/>
    <id>https://catbro666.github.io/posts/1fdd30ce/</id>
    <published>2021-11-11T16:51:24.000Z</published>
    <updated>2022-03-05T10:39:18.100Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;前面已经支持了几种不同的方式添加断点，但是必须事先在代码中添加断点，在使用上不是那么灵活方便。本文将支持动态增删断点，只需要开一开始引入调试库即可，后续可以在调试过程中动态的添加和删除断点。事不宜迟，我们直接进入正题。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="编程开发" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    <category term="Lua" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Lua/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>从压测碰到的诡异断连问题聊聊Nginx的连接管理和性能调测</title>
    <link href="https://catbro666.github.io/posts/4198933e/"/>
    <id>https://catbro666.github.io/posts/4198933e/</id>
    <published>2021-11-07T09:52:11.000Z</published>
    <updated>2022-03-17T09:29:41.886Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;Nginx是目前使用最广泛的Web服务器之一，以高性能而著称，得益于其异步事件驱动架构，在高并发下仍然可以保持低消耗高性能，而模块化的设计也使其更易扩展，丰富了其功能。对于Nginx基本的介绍网上已有很多的文章，也有像《深入理解Nginx》这样的书籍讲解Nginx的架构设计与开发方法。本文不会涉及Nginx开发相关内容，而是以一个实际问题的定位过程作为引子，聊一下Nginx的连接管理和性能调测。如果你并不关心这个实际问题，可以直接跳到&lt;a href=&quot;#%E8%BF%9E%E6%8E%A5%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&quot;&gt;连接生命周期&lt;/a&gt;。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="编程开发" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    <category term="Nginx/OpenResty" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Nginx-OpenResty/"/>
    
    <category term="性能" scheme="https://catbro666.github.io/categories/%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="Nginx" scheme="https://catbro666.github.io/tags/Nginx/"/>
    
    <category term="性能调优" scheme="https://catbro666.github.io/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>SSL及GMVPN握手协议详解</title>
    <link href="https://catbro666.github.io/posts/59c71edb/"/>
    <id>https://catbro666.github.io/posts/59c71edb/</id>
    <published>2021-11-01T13:01:32.000Z</published>
    <updated>2022-03-05T10:44:06.163Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;之前写过一篇关于&lt;a href=&quot;../e92ef4b4&quot;&gt;SSL协议的文章&lt;/a&gt;，主要介绍了加密学的基础，并从整体上对SSL协议做了介绍。由于篇幅原因，SSL握手的详细流程没有深入介绍。本文将拆解握手流程，在消息级别对握手进行详细地介绍。还没有加密学基本概念的、或者不清楚SSL协议的基本情况的建议先看一下前面一篇的内容。另外，本文主要是针对TLSv1.2和GMVPN的情况，对于TLSv1.3暂不涉及。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="加密与安全" scheme="https://catbro666.github.io/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="SSL/TLS" scheme="https://catbro666.github.io/tags/SSL-TLS/"/>
    
  </entry>
  
  <entry>
    <title>Linux TC 流量控制介绍</title>
    <link href="https://catbro666.github.io/posts/357ad3ec/"/>
    <id>https://catbro666.github.io/posts/357ad3ec/</id>
    <published>2021-10-17T08:10:15.000Z</published>
    <updated>2022-03-05T10:37:27.191Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;前段时间在做一些测试的时候接触到了Linux tc，因为需要对数据包添加延迟，用到了tc中的netem。添加简单的延迟非常简单，像这样一条命令就搞定了：&lt;code&gt;$ tc qdisc add dev eth0 root netem delay 1s&lt;/code&gt;，你甚至不需要完全理解命令中参数的含义。但是当你想做一些更加特殊的限制的时候，（比如只对某个特定的ip端口添加延迟、或者只对入站的流量添加延迟），事情就变得有些棘手了，简单的百度貌似已经满足不了要求了。你不得不了解TC中的一些基本概念，以及tc[2]命令中相关参数的含义。&lt;/p&gt;&lt;p&gt;本文正是带你了解这些TC中的基本概念，并通过一个实际例子，将这些概念与tc命令联系起来。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://catbro666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="https://catbro666.github.io/tags/Linux/"/>
    
    <category term="TC" scheme="https://catbro666.github.io/tags/TC/"/>
    
    <category term="流量控制" scheme="https://catbro666.github.io/tags/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试—08支持通过包名称添加断点</title>
    <link href="https://catbro666.github.io/posts/5c25711/"/>
    <id>https://catbro666.github.io/posts/5c25711/</id>
    <published>2021-09-12T10:38:31.000Z</published>
    <updated>2022-03-05T10:39:11.569Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;在前一篇中我们支持了通过函数名称来添加断点，我们同时也提到了在Lua中一个函数的名称的并不是确定的。准确的说，Lua中的函数并没有名称，所谓名称其实是保存这个函数值的变量的名称。&lt;/p&gt;&lt;p&gt;于是通过函数名称添加断点就造成了一定的不确定性，因为函数被调用时并不一定是以这个名字被调用的。另外，多个不同的函数也可能以相同的名字进行调用。&lt;/p&gt;&lt;p&gt;所以为了解决这个问题，本篇我们将继续扩展断点的设置接口，支持通过包名来添加断点。因为包名相对更具确定性，配合行号可以进行精确定位。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="编程开发" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    <category term="Lua" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Lua/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试—07支持通过函数名称添加断点</title>
    <link href="https://catbro666.github.io/posts/acdf52b7/"/>
    <id>https://catbro666.github.io/posts/acdf52b7/</id>
    <published>2021-08-26T16:09:50.000Z</published>
    <updated>2022-03-05T10:38:56.644Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;我们之前已经支持了通过函数来添加断点，并且已经支持了行号的检查和自动修正。但是通过函数来添加断点有一些限制，如果在当前的位置无法访问目标函数，那我们就无法对其添加断点。&lt;/p&gt;&lt;p&gt;于是，本篇我们将扩展断点设置的接口，支持通过函数名称添加断点，以突破这个限制。&lt;/p&gt;</summary>
    
    
    
    <category term="编程开发" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    <category term="Lua" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Lua/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试—06断点行号检查与自动修正</title>
    <link href="https://catbro666.github.io/posts/fa52978d/"/>
    <id>https://catbro666.github.io/posts/fa52978d/</id>
    <published>2021-08-18T12:55:57.000Z</published>
    <updated>2022-03-05T10:38:45.092Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;前面两篇我们对性能做了一个优化，接下来继续来丰富调试器的特性。&lt;/p&gt;&lt;p&gt;我们前面提到过，函数内并不是所有行都是有效行，空行和注释行就不是有效行。我们之前在添加断点的时候，并没有对行号进行检查，任何行号都能成功添加断点。所以如果添加的断点行号是无效的，那么永远也不会断到那里。但是钩子里并不知道它是无效的，call事件仍然会以为函数有断点从而启动line事件，造成CPU的浪费。&lt;/p&gt;&lt;p&gt;所以本篇，我们将对断点的行号进行检查，对于不在函数范围内的行号直接添加断点失败；在函数范围内的行号则自动修正为下一个有效的行号；另外支持不指定行号，默认为函数的第一个有效行。&lt;/p&gt;</summary>
    
    
    
    <category term="编程开发" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    <category term="Lua" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Lua/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试--05优化断点信息数据结构</title>
    <link href="https://catbro666.github.io/posts/2e777dd3/"/>
    <id>https://catbro666.github.io/posts/2e777dd3/</id>
    <published>2021-08-17T12:40:09.000Z</published>
    <updated>2022-03-05T10:38:21.976Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;在上一篇&lt;a href=&quot;../c1ecd715/&quot;&gt;04优化钩子事件处理&lt;/a&gt;中，我们在钩子函数中引入了call和return事件的处理，对性能进行了优化。&lt;/p&gt;&lt;p&gt;细心的同学可能已经发现了，我们的hook函数中call事件和line都需要对整个断点表进行遍历，这其中其实是存在着一些冗余的。因为call事件只关心函数是否有断点，而line事件则只关心本函数内有哪些断点。所以我们可以想办法优化一下断点信息的数据结构，进一步提升性能。&lt;/p&gt;</summary>
    
    
    
    <category term="编程开发" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    <category term="Lua" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Lua/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试--04优化钩子事件处理</title>
    <link href="https://catbro666.github.io/posts/c1ecd715/"/>
    <id>https://catbro666.github.io/posts/c1ecd715/</id>
    <published>2021-08-16T11:52:15.000Z</published>
    <updated>2022-03-05T10:37:04.044Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;在第一篇的&lt;a href=&quot;../f9a188a7/&quot;&gt;01最小实现&lt;/a&gt;中，我们实现了一个断点调试的最小实现，在设置钩子函数时只加了line事件，显然这会对性能有很大的影响。而后来两篇&lt;a href=&quot;../f6e9079c&quot;&gt;02通用变量打印&lt;/a&gt;和&lt;a href=&quot;../a05a2f5f&quot;&gt;03通用变量修改及调用栈回溯&lt;/a&gt;则是提供了一些辅助的调试接口，并没有对钩子函数进行修改。&lt;/p&gt;&lt;p&gt;我们本篇将在钩子中引入call和return事件的处理，尝试对性能进行优化。&lt;/p&gt;</summary>
    
    
    
    <category term="编程开发" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    <category term="Lua" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Lua/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试--03通用变量修改及调用栈回溯</title>
    <link href="https://catbro666.github.io/posts/a05a2f5f/"/>
    <id>https://catbro666.github.io/posts/a05a2f5f/</id>
    <published>2021-08-15T04:41:09.000Z</published>
    <updated>2022-03-05T10:38:00.203Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;在前面两篇&lt;a href=&quot;../f9a188a7/&quot;&gt;01最小实现&lt;/a&gt;及&lt;a href=&quot;../f6e9079c&quot;&gt;02通用变量打印&lt;/a&gt;中，我们已经实现了设置断点、删除断点及通用变量打印接口。&lt;/p&gt;&lt;p&gt;本篇将继续新增两个辅助的调试接口：调用栈回溯打印接口、通用变量设置接口。前者打印调用栈的回溯信息，后者可以方便地修改变量的值，支持局部变量、upvalue以及全局的&lt;code&gt;_ENV&lt;/code&gt;中的变量。&lt;/p&gt;</summary>
    
    
    
    <category term="编程开发" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    <category term="Lua" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Lua/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试--02通用变量打印</title>
    <link href="https://catbro666.github.io/posts/f6e9079c/"/>
    <id>https://catbro666.github.io/posts/f6e9079c/</id>
    <published>2021-08-15T04:19:48.000Z</published>
    <updated>2022-03-05T10:37:53.287Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;在前一篇&lt;a href=&quot;../f9a188a7/&quot;&gt;01最小实现&lt;/a&gt;中，我们实现了Lua断点调试的的一个最小实现。我们编写了一个模块，提供了两个基本的接口：设置断点和删除断点。&lt;/p&gt;&lt;p&gt;虽然我们已经支持在断点进行变量的打印，但是需要自己指定层数以及变量索引，使用起来不是很方便。要进行upvalue打印的话，操作会更加麻烦。为了提升调试的方便性，我们决定封装一个通用的变量打印函数，可以通过变量名查找到对应变量的值进行打印。支持局部变量、upvalue以及全局的&lt;code&gt;_ENV&lt;/code&gt;中的变量。&lt;/p&gt;</summary>
    
    
    
    <category term="编程开发" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    <category term="Lua" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Lua/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试--01最小实现</title>
    <link href="https://catbro666.github.io/posts/f9a188a7/"/>
    <id>https://catbro666.github.io/posts/f9a188a7/</id>
    <published>2021-08-12T16:52:46.000Z</published>
    <updated>2022-03-05T10:37:46.002Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;说到Lua代码调试，最常用的方法应该就是加一堆print进行打印。print大法虽好，但其缺点也是显而易见的。比如效率低下，需要修改原有函数内部代码，在每个需要的地方添加print语句，运行一次只能获取一次信息，下次换个地方又得重新添加print语句。而且有时候，事先并不知道该去哪打印、或者打印什么内容，需要通过运行中获取的信息才能确定。&lt;/p&gt;&lt;p&gt;当print大法无法满足我们的需求时，就需要类似断点调试这样更高级的调试功能。本文将从零开始编写一个Lua调试器，实现类似gdb的断点调试功能。&lt;/p&gt;&lt;p&gt;本文代码已开源至&lt;a href=&quot;https://github.com/catbro666/lua-debugger&quot;&gt;Github&lt;/a&gt;，欢迎watch/star😘。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="编程开发" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    <category term="Lua" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Lua/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>一篇文章搞懂密码学基础及SSL/TLS协议</title>
    <link href="https://catbro666.github.io/posts/e92ef4b4/"/>
    <id>https://catbro666.github.io/posts/e92ef4b4/</id>
    <published>2021-08-08T15:32:26.000Z</published>
    <updated>2022-03-05T10:44:18.639Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;SSL协议是现代网络通信中重要的一环，它提供了传输层上的数据安全。为了方便大家的理解，本文将先从加密学的基础知识入手，然后展开对SSL协议原理、流程以及一些重要的特性的详解，最后会扩展介绍一下国密SSL协议的差异、安全性以及TLS 1.3的关键新特性。&lt;/p&gt;&lt;p&gt;限于篇幅以及个人知识水平，本文不会涉及过于细节的内容。特别地，本文将不涉及算法的具体原理，也不涉及实际代码的实现。而是试图以图表等直观的方式来了解基本的原理以及流程。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="加密与安全" scheme="https://catbro666.github.io/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="SSL/TLS" scheme="https://catbro666.github.io/tags/SSL-TLS/"/>
    
    <category term="密码学" scheme="https://catbro666.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
</feed>

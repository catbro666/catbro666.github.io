<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CatBro&#39;s Blog</title>
  <icon>https://catbro666.github.io/icon.png</icon>
  <subtitle>Volar con el viento</subtitle>
  <link href="https://catbro666.github.io/atom.xml" rel="self"/>
  
  <link href="https://catbro666.github.io/"/>
  <updated>2022-05-09T15:48:42.250Z</updated>
  <id>https://catbro666.github.io/</id>
  
  <author>
    <name>猫猫哥</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记录一个IPsec VPN检测时ESP包解密失败问题的定位过程</title>
    <link href="https://catbro666.github.io/posts/4921760e/"/>
    <id>https://catbro666.github.io/posts/4921760e/</id>
    <published>2022-05-09T14:35:51.000Z</published>
    <updated>2022-05-09T15:48:42.250Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;本文记录一次IPsec VPN检测时ESP解密失败问题的定位过程。涉及到IPsec VPN协议、加密算法、内核xfrm框架等知识。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="排错与性能" scheme="https://catbro666.github.io/categories/%E6%8E%92%E9%94%99%E4%B8%8E%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="IPSec" scheme="https://catbro666.github.io/tags/IPSec/"/>
    
    <category term="ESP" scheme="https://catbro666.github.io/tags/ESP/"/>
    
  </entry>
  
  <entry>
    <title>systemtap与bpftrace使用评估及对比</title>
    <link href="https://catbro666.github.io/posts/46dd3f4b/"/>
    <id>https://catbro666.github.io/posts/46dd3f4b/</id>
    <published>2022-05-09T12:57:29.000Z</published>
    <updated>2022-05-09T14:26:56.601Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;eBPF和systemtap这两个非常强大的工具，它们弥补了静态调试工具的不足，可以完成很多静态调试工具无法完成的事情。例如很多跟时序相关的问题、概率性偶发的问题、压力测试下才能出现的问题、以及像云上这种不方便调试的环境，可能只能通过&lt;strong&gt;动态调试&lt;/strong&gt;的手段来定位分析问题。&lt;/p&gt;&lt;p&gt;它们将进程本身当作是一个数据库，从中获取所关心的信息进行活体分析。当然前提是你得对这个数据库本身有足够的了解，知道去哪里获取信息，以及获取什么信息。对于内核态就是对内核本身的理解，在用户态则是对用户程序的理解。&lt;/p&gt;&lt;p&gt;本文只是浅浅地试用评估了一下两者，并做了简单对比。要想熟练使用，功夫在诗外！&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="性能" scheme="https://catbro666.github.io/categories/%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="systemtap" scheme="https://catbro666.github.io/tags/systemtap/"/>
    
    <category term="eBPF" scheme="https://catbro666.github.io/tags/eBPF/"/>
    
    <category term="bpftrace" scheme="https://catbro666.github.io/tags/bpftrace/"/>
    
    <category term="动态追踪" scheme="https://catbro666.github.io/tags/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>OpenSSL的async异步框架/OpenSSL协程</title>
    <link href="https://catbro666.github.io/posts/6d5be1a5/"/>
    <id>https://catbro666.github.io/posts/6d5be1a5/</id>
    <published>2022-04-26T14:37:45.000Z</published>
    <updated>2022-04-27T12:27:30.408Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;OpenSSL异步框架是在OpenSSL-1.1.0上引入的一个新特性。它理论上可以应用于任何的异步操作，但当前主要是用于在引擎框架中执行的加密学操作。本文首先介绍其底层原理，接着介绍OpenSSL的异步基础设施，最后着重分析ASYNC_JOB（OpenSSL中的协程）的处理流程（dispatcher和job之间是如何切换的）。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="加密与安全" scheme="https://catbro666.github.io/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
    <category term="编程开发" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    <category term="OpenSSL" scheme="https://catbro666.github.io/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/OpenSSL/"/>
    
    <category term="Unix环境编程" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Unix%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="OpenSSL" scheme="https://catbro666.github.io/tags/OpenSSL/"/>
    
    <category term="协程" scheme="https://catbro666.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="async异步框架" scheme="https://catbro666.github.io/tags/async%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核中隐藏的兵法—以逸待劳</title>
    <link href="https://catbro666.github.io/posts/5d011708/"/>
    <id>https://catbro666.github.io/posts/5d011708/</id>
    <published>2022-04-15T14:21:30.000Z</published>
    <updated>2022-04-16T10:16:22.008Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;在本系列之前的两篇文章&lt;a href=&quot;../68dbb05c/&quot;&gt;无中生有&lt;/a&gt;与&lt;a href=&quot;../7be938f8/&quot;&gt;移花接木&lt;/a&gt;中，我们探究了Linux中的进程创建，它可以说是进程管理中最重要的内容之一（另一个是进程调度）。本文我们将介绍的内容则更多地属于是内存管理范畴。（当然这也是相对而言的，作为Linux内核中最核心的部分，进程管理、内存管理、中断管理相互之间都是紧密联系的。）&lt;/p&gt;&lt;p&gt;也许你已经注意到了，无论是fork还是execve都没有主动去分配内存执行拷贝或读取的动作。fork时只是拷贝了页表并设置为用户只读，而execve时则只是准备了新的LDT局部表以及堆栈中的参数和环境表，而并没有实际读程序到内存中。&lt;/p&gt;&lt;p&gt;这就是本文将讨论的页异常中断：&lt;strong&gt;写保护异常&amp;#x2F;写时复制机制&lt;/strong&gt;和&lt;strong&gt;缺页异常&lt;/strong&gt;。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://catbro666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="内存管理" scheme="https://catbro666.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="写时复制" scheme="https://catbro666.github.io/tags/%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/"/>
    
    <category term="分页机制" scheme="https://catbro666.github.io/tags/%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/"/>
    
    <category term="页异常中断" scheme="https://catbro666.github.io/tags/%E9%A1%B5%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/"/>
    
    <category term="缺页异常" scheme="https://catbro666.github.io/tags/%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8/"/>
    
    <category term="写保护页异常" scheme="https://catbro666.github.io/tags/%E5%86%99%E4%BF%9D%E6%8A%A4%E9%A1%B5%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核中隐藏的兵法—移花接木</title>
    <link href="https://catbro666.github.io/posts/7be938f8/"/>
    <id>https://catbro666.github.io/posts/7be938f8/</id>
    <published>2022-04-13T13:32:29.000Z</published>
    <updated>2022-04-13T15:13:28.562Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;之前在&lt;a href=&quot;https://catbro666.github.io/posts/68dbb05c/&quot;&gt;Linux内核中隐藏的兵法—无中生有&lt;/a&gt;一文中，我们探究了Linux中的进程创建，着重介绍了进程0和fork系统调用。本文我们将继续探究，另一个与进程创建相关的重要系统调用：&lt;strong&gt;execve&lt;/strong&gt;。看看它又是葫芦里卖的什么药。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://catbro666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="系统调用" scheme="https://catbro666.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
    <category term="execve" scheme="https://catbro666.github.io/tags/execve/"/>
    
    <category term="地址空间" scheme="https://catbro666.github.io/tags/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>Nginx的SSL性能测试</title>
    <link href="https://catbro666.github.io/posts/d5d52392/"/>
    <id>https://catbro666.github.io/posts/d5d52392/</id>
    <published>2022-04-05T13:25:03.000Z</published>
    <updated>2022-05-09T15:49:49.849Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;虽说标题写的是SSL性能测试，但其实是不是SSL都无关紧要，只是测试的配置有所不同罢了。相比具体某个指标的测试方法，我们更应该关注的是性能测试的一般原则。具体的测试指标可能随着测试业务、测试环境而千差万别，但是核心的测试方法论是不变的。&lt;/p&gt;&lt;p&gt;因为笔者对SSL的性能测试比较熟悉，所以将以SSL性能测试主要关注的3个指标为例进行分享：每秒新建连接数、最大吞吐量、最大连接数。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="排错与性能" scheme="https://catbro666.github.io/categories/%E6%8E%92%E9%94%99%E4%B8%8E%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="SSL/TLS" scheme="https://catbro666.github.io/tags/SSL-TLS/"/>
    
    <category term="Nginx" scheme="https://catbro666.github.io/tags/Nginx/"/>
    
    <category term="性能调优" scheme="https://catbro666.github.io/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
    <category term="RPS" scheme="https://catbro666.github.io/tags/RPS/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核中隐藏的兵法—无中生有</title>
    <link href="https://catbro666.github.io/posts/68dbb05c/"/>
    <id>https://catbro666.github.io/posts/68dbb05c/</id>
    <published>2022-03-26T04:47:23.000Z</published>
    <updated>2022-04-13T14:58:09.366Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;不管是什么领域，建造往往比销毁困难得多。建造一个大楼可能需要几年的时间，而销毁它也许就是几秒钟的事情。究其根本，因为建造是个熵减的过程，必须有来自系统外的能量输入。而创建中有一类问题显得更为特殊，那就是起源的问题。第一个生命如何诞生？人类又是如何起源的？诸如此类的问题，人类从未停止探究。。。&lt;/p&gt;&lt;p&gt;而今天我们要探究的主题是Linux中的进程创建。大部分的人可能都知道fork，都知道进程就是像细胞分裂一样分出来的。那么你是否清楚下面这些：为了分裂它需要准备什么？所谓分裂到底分了什么，又遗传了什么？遗传物质是如何传递的？第一个进程又是怎么来的？&lt;/p&gt;&lt;p&gt;接下来就让我们一起来探索这些问题吧！&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://catbro666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="进程0" scheme="https://catbro666.github.io/tags/%E8%BF%9B%E7%A8%8B0/"/>
    
    <category term="fork" scheme="https://catbro666.github.io/tags/fork/"/>
    
    <category term="进程创建" scheme="https://catbro666.github.io/tags/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/"/>
    
    <category term="系统调用" scheme="https://catbro666.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>OpenSSL CVE-2022-0778漏洞问题复现与非法证书构造</title>
    <link href="https://catbro666.github.io/posts/83951100/"/>
    <id>https://catbro666.github.io/posts/83951100/</id>
    <published>2022-03-19T14:53:34.000Z</published>
    <updated>2022-05-09T15:06:15.087Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;本文介绍CVE-2022 0778漏洞及其复现方法，并精心构造了具有一个非法椭圆曲线参数的证书可以触发该漏洞。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="加密与安全" scheme="https://catbro666.github.io/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
    <category term="OpenSSL" scheme="https://catbro666.github.io/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/OpenSSL/"/>
    
    
    <category term="OpenSSL" scheme="https://catbro666.github.io/tags/OpenSSL/"/>
    
    <category term="CVE" scheme="https://catbro666.github.io/tags/CVE/"/>
    
    <category term="漏洞复现" scheme="https://catbro666.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核是如何启动的</title>
    <link href="https://catbro666.github.io/posts/615fc0b5/"/>
    <id>https://catbro666.github.io/posts/615fc0b5/</id>
    <published>2022-03-12T11:01:39.000Z</published>
    <updated>2022-03-13T13:31:33.474Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;本文介绍Linux内核的引导启动以及初始化流程，从你按下电源开始到你最终进行终端登录，这期间到底发生了什么？&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://catbro666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="https://catbro666.github.io/tags/Linux/"/>
    
    <category term="内核" scheme="https://catbro666.github.io/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Nginx的共享内存管理--slab算法</title>
    <link href="https://catbro666.github.io/posts/2dc32e47/"/>
    <id>https://catbro666.github.io/posts/2dc32e47/</id>
    <published>2022-03-05T08:50:42.000Z</published>
    <updated>2022-03-10T11:27:29.774Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;初次了解到slab算法，是在学习Linux内核时。内核中采用了伙伴系统（Buddy System）算法对内存页面进行管理。但是对于小对象，还用页面分配器就显得有些浪费了，于是slab就应运而生了，内核的kmalloc()就是使用slab进行管理的。nginx中的共享内存管理使用了相同的思想，当然它没有Linux内核中的slab那么复杂。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="编程开发" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    <category term="Nginx/OpenResty" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Nginx-OpenResty/"/>
    
    
    <category term="Nginx" scheme="https://catbro666.github.io/tags/Nginx/"/>
    
    <category term="slab" scheme="https://catbro666.github.io/tags/slab/"/>
    
    <category term="共享内存" scheme="https://catbro666.github.io/tags/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>C语言中的函数调用约定</title>
    <link href="https://catbro666.github.io/posts/657c24ad/"/>
    <id>https://catbro666.github.io/posts/657c24ad/</id>
    <published>2022-01-23T12:09:28.000Z</published>
    <updated>2022-03-05T10:36:03.300Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;本文主要介绍C语言中的函数调用约定，通过汇编代码结合实时观察栈的变化情况，直观地了解函数调用的过程。本文只讨论x86&amp;#x2F;64架构、Linux&amp;#x2F;GCC环境下的情况，不过其他环境在整体思想上应该是类似的，都需要处理这些问题。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="理解计算机" scheme="https://catbro666.github.io/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="调用约定" scheme="https://catbro666.github.io/tags/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    
    <category term="C/C++" scheme="https://catbro666.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>如何在裸机上直接运行程序—王爽《汇编语言》课程设计2</title>
    <link href="https://catbro666.github.io/posts/8054db72/"/>
    <id>https://catbro666.github.io/posts/8054db72/</id>
    <published>2022-01-17T12:42:17.000Z</published>
    <updated>2022-03-05T10:43:30.687Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;平常我们的程序基本都是运行在操作系统之上，很少有机会直接在裸机上运行程序。现代操作系统需要支持多任务环境的工作方式，这要求CPU在硬件上提供支持。以Intel处理器为例，从80286&amp;#x2F;80386开始，CPU开始支持工作在保护模式，为多任务环境提供保护机制。&lt;/p&gt;&lt;p&gt;操作系统为我们提供了保护和抽象，这方便了开发和使用，但是同时也对学习者了解计算机底层工作原理造成了一定的障碍。本文通过编码实践王爽老师《汇编语言》中的课程设计2，与寄存器、内存、显存、中断、外设等进行了近距离的亲密接触，通过这次实践也算是入门汇编了吧。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="理解计算机" scheme="https://catbro666.github.io/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="8086" scheme="https://catbro666.github.io/tags/8086/"/>
    
    <category term="汇编" scheme="https://catbro666.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
    <category term="DOS" scheme="https://catbro666.github.io/tags/DOS/"/>
    
  </entry>
  
  <entry>
    <title>VIM常用快捷键和插件整理</title>
    <link href="https://catbro666.github.io/posts/d6ca5270/"/>
    <id>https://catbro666.github.io/posts/d6ca5270/</id>
    <published>2021-12-12T10:25:29.000Z</published>
    <updated>2022-03-05T10:44:58.143Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;本文不会介绍基本的VIM使用方法，如果你对VIM的几种模式、基本的编辑、移动和选取等还不了解，推荐你先看一下这篇&lt;a href=&quot;https://coolshell.cn/articles/5426.html&quot;&gt;简明 VIM 练级攻略&lt;/a&gt;，写得还是不错的，基本上最常用的命令都有了。如果你不是vim重度用户的话，知道这些命令已经足够。只能说vim的水太深，根据自身情况在编辑效率和学习成本之间做个平衡吧。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="工具" scheme="https://catbro666.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Vim" scheme="https://catbro666.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>深入理解mmap--内核代码分析及驱动demo示例</title>
    <link href="https://catbro666.github.io/posts/5ec4fb12/"/>
    <id>https://catbro666.github.io/posts/5ec4fb12/</id>
    <published>2021-12-11T13:06:53.000Z</published>
    <updated>2022-03-05T10:36:54.048Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;mmap是一个用户空间很常用的系统调用，无论是分配内存、读写大文件、链接动态库文件，还是多进程间共享内存，都可以看到其身影。本文首先介绍了进程地址空间和mmap，然后分析了内核代码以了解其实现，最后通过一个简单的demo驱动示例，加深对mmap的理解。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://catbro666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="https://catbro666.github.io/tags/Linux/"/>
    
    <category term="内存管理" scheme="https://catbro666.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="mmap" scheme="https://catbro666.github.io/tags/mmap/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试—09支持动态添加和删除断点</title>
    <link href="https://catbro666.github.io/posts/1fdd30ce/"/>
    <id>https://catbro666.github.io/posts/1fdd30ce/</id>
    <published>2021-11-11T16:51:24.000Z</published>
    <updated>2022-03-05T10:39:18.100Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;前面已经支持了几种不同的方式添加断点，但是必须事先在代码中添加断点，在使用上不是那么灵活方便。本文将支持动态增删断点，只需要开一开始引入调试库即可，后续可以在调试过程中动态的添加和删除断点。事不宜迟，我们直接进入正题。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="编程开发" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    <category term="Lua" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Lua/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>从压测碰到的诡异断连问题聊聊Nginx的连接管理</title>
    <link href="https://catbro666.github.io/posts/4198933e/"/>
    <id>https://catbro666.github.io/posts/4198933e/</id>
    <published>2021-11-07T09:52:11.000Z</published>
    <updated>2022-04-16T10:37:36.542Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;本文主要分享一个在压测Nginx反向代理服务过程中碰到的连接异常断开问题，包括问题的定位与复现，最后由这个实际问题引申聊一下Nginx的连接管理。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="编程开发" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    <category term="Nginx/OpenResty" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Nginx-OpenResty/"/>
    
    
    <category term="Nginx" scheme="https://catbro666.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>SSL及GMVPN握手协议详解</title>
    <link href="https://catbro666.github.io/posts/59c71edb/"/>
    <id>https://catbro666.github.io/posts/59c71edb/</id>
    <published>2021-11-01T13:01:32.000Z</published>
    <updated>2022-03-05T10:44:06.163Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;之前写过一篇关于&lt;a href=&quot;../e92ef4b4&quot;&gt;SSL协议的文章&lt;/a&gt;，主要介绍了加密学的基础，并从整体上对SSL协议做了介绍。由于篇幅原因，SSL握手的详细流程没有深入介绍。本文将拆解握手流程，在消息级别对握手进行详细地介绍。还没有加密学基本概念的、或者不清楚SSL协议的基本情况的建议先看一下前面一篇的内容。另外，本文主要是针对TLSv1.2和GMVPN的情况，对于TLSv1.3暂不涉及。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="加密与安全" scheme="https://catbro666.github.io/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="SSL/TLS" scheme="https://catbro666.github.io/tags/SSL-TLS/"/>
    
  </entry>
  
  <entry>
    <title>Linux TC 流量控制介绍</title>
    <link href="https://catbro666.github.io/posts/357ad3ec/"/>
    <id>https://catbro666.github.io/posts/357ad3ec/</id>
    <published>2021-10-17T08:10:15.000Z</published>
    <updated>2022-03-05T10:37:27.191Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;前段时间在做一些测试的时候接触到了Linux tc，因为需要对数据包添加延迟，用到了tc中的netem。添加简单的延迟非常简单，像这样一条命令就搞定了：&lt;code&gt;$ tc qdisc add dev eth0 root netem delay 1s&lt;/code&gt;，你甚至不需要完全理解命令中参数的含义。但是当你想做一些更加特殊的限制的时候，（比如只对某个特定的ip端口添加延迟、或者只对入站的流量添加延迟），事情就变得有些棘手了，简单的百度貌似已经满足不了要求了。你不得不了解TC中的一些基本概念，以及tc[2]命令中相关参数的含义。&lt;/p&gt;&lt;p&gt;本文正是带你了解这些TC中的基本概念，并通过一个实际例子，将这些概念与tc命令联系起来。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://catbro666.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="https://catbro666.github.io/tags/Linux/"/>
    
    <category term="TC" scheme="https://catbro666.github.io/tags/TC/"/>
    
    <category term="流量控制" scheme="https://catbro666.github.io/tags/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试—08支持通过包名称添加断点</title>
    <link href="https://catbro666.github.io/posts/5c25711/"/>
    <id>https://catbro666.github.io/posts/5c25711/</id>
    <published>2021-09-12T10:38:31.000Z</published>
    <updated>2022-03-05T10:39:11.569Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;在前一篇中我们支持了通过函数名称来添加断点，我们同时也提到了在Lua中一个函数的名称的并不是确定的。准确的说，Lua中的函数并没有名称，所谓名称其实是保存这个函数值的变量的名称。&lt;/p&gt;&lt;p&gt;于是通过函数名称添加断点就造成了一定的不确定性，因为函数被调用时并不一定是以这个名字被调用的。另外，多个不同的函数也可能以相同的名字进行调用。&lt;/p&gt;&lt;p&gt;所以为了解决这个问题，本篇我们将继续扩展断点的设置接口，支持通过包名来添加断点。因为包名相对更具确定性，配合行号可以进行精确定位。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="编程开发" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    <category term="Lua" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Lua/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Lua中如何实现类似gdb的断点调试—07支持通过函数名称添加断点</title>
    <link href="https://catbro666.github.io/posts/acdf52b7/"/>
    <id>https://catbro666.github.io/posts/acdf52b7/</id>
    <published>2021-08-26T16:09:50.000Z</published>
    <updated>2022-03-05T10:38:56.644Z</updated>
    
    
    <summary type="html">&lt;div class=&quot;note primary&quot;&gt;
            &lt;p&gt;我们之前已经支持了通过函数来添加断点，并且已经支持了行号的检查和自动修正。但是通过函数来添加断点有一些限制，如果在当前的位置无法访问目标函数，那我们就无法对其添加断点。&lt;/p&gt;&lt;p&gt;于是，本篇我们将扩展断点设置的接口，支持通过函数名称添加断点，以突破这个限制。&lt;/p&gt;</summary>
    
    
    
    <category term="编程开发" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    <category term="Lua" scheme="https://catbro666.github.io/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Lua/"/>
    
    
    <category term="Lua" scheme="https://catbro666.github.io/tags/Lua/"/>
    
    <category term="调试" scheme="https://catbro666.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
</feed>

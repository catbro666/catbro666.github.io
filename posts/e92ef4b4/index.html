<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/images/hiking-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/images/hiking-16.png">
  <link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="JT1HKSsLR6ZiapLatX1c6-7k-OcEM8cAMdR5pgCSptk">
  <meta name="yandex-verification" content="5ab41d9d91227789">
  <meta name="baidu-site-verification" content="code-9Qi2zUhBf4">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"catbro666.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":42,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="SSL协议是现代网络通信中重要的一环，它提供了传输层上的数据安全。为了方便大家的理解，本文将先从加密学的基础知识入手，然后展开对SSL协议原理、流程以及一些重要的特性的详解，最后会扩展介绍一下国密SSL协议的差异、安全性以及TLS 1.3的关键新特性。限于篇幅以及个人知识水平，本文不会涉及过于细节的内容。特别地，本文将不涉及算法的具体原理，也不涉及实际代码的实现。而是试图">
<meta property="og:type" content="article">
<meta property="og:title" content="一篇文章搞懂密码学基础及SSL&#x2F;TLS协议">
<meta property="og:url" content="https://catbro666.github.io/posts/e92ef4b4/index.html">
<meta property="og:site_name" content="CatBro&#39;s Blog">
<meta property="og:description" content="SSL协议是现代网络通信中重要的一环，它提供了传输层上的数据安全。为了方便大家的理解，本文将先从加密学的基础知识入手，然后展开对SSL协议原理、流程以及一些重要的特性的详解，最后会扩展介绍一下国密SSL协议的差异、安全性以及TLS 1.3的关键新特性。限于篇幅以及个人知识水平，本文不会涉及过于细节的内容。特别地，本文将不涉及算法的具体原理，也不涉及实际代码的实现。而是试图">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Caesar3.svg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/simple-substitution-cipher.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Enigma.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/symmetric-cipher-flow.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/RijndaelEncrypt.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Ecb_encryption.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Ecb_decryption.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/ecb-penguin1.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/ecb-penguin2.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/ecb-penguin3.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Cbc_encryption.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/CbC_decryption.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/CTR_encryption_2.svg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/CTR_decryption_2.svg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/GCM-Galois_Counter_Mode_with_IV.svg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Public_key_encryption.svg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Diffie-Hellman_Key_Exchange.svg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Cryptographic_Hash_Function.svg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/MAC-vs-HASH.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/HMAC-use-scene.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Private_key_signing.svg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/DigitalSignature.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Chain-of-trust-with-cert.svg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/CA-signing-of-digital-certificates.svg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS-layered-structure.svg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS-record-structure.svg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/CipherSuite1_2.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/CipherSuite1_3.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS-full-handshake-flow.svg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/SSL-keyexchange-RSA.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/SSL-keyexchange-DH.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS1_2-Key-Calculation.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS-half-handshake-flow.svg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/session_resumption_with_session_id.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/session_resumption_with_session_ticket.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/renegotiation-attack.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/renegotiation-attack-fix1.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/renegotiation-attack-fix2.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Simplified_Heartbleed_explanation.svg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS1_3-Key-Schedule.png">
<meta property="article:published_time" content="2021-08-08T15:32:26.000Z">
<meta property="article:modified_time" content="2021-08-12T12:28:34.315Z">
<meta property="article:author" content="猫猫哥">
<meta property="article:tag" content="SSL&#x2F;TLS">
<meta property="article:tag" content="密码学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Caesar3.svg">

<link rel="canonical" href="https://catbro666.github.io/posts/e92ef4b4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <meta name="360-site-verification" content="e7586a6caf7e44316b4a27dfaf53e858"/>



  <title>一篇文章搞懂密码学基础及SSL/TLS协议 | CatBro's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-6PKG8T836C"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-6PKG8T836C');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?43ceb843b17e732b0a5dd658f624cac5";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="CatBro's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CatBro's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Volar con el viento</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-hot">

    <a href="/hot/" rel="section"><i class="fa fa-thermometer-half fa-fw"></i>热度排行</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404.html" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/catbro666" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener external nofollow noreferrer" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://catbro666.github.io/posts/e92ef4b4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/images/avatar.gif">
      <meta itemprop="name" content="猫猫哥">
      <meta itemprop="description" content="如果说根号二是无理数，那么我就是个无理人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CatBro's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          一篇文章搞懂密码学基础及SSL/TLS协议
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-08 23:32:26" itemprop="dateCreated datePublished" datetime="2021-08-08T23:32:26+08:00">2021-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-12 20:28:34" itemprop="dateModified" datetime="2021-08-12T20:28:34+08:00">2021-08-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%90%86%E8%AE%BA%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">理论向</span></a>
                </span>
            </span>

          
            <span id="/posts/e92ef4b4/" class="post-meta-item leancloud_visitors" data-flag-title="一篇文章搞懂密码学基础及SSL/TLS协议" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论数：</span>
    
    <a title="valine" href="/posts/e92ef4b4/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/e92ef4b4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
  <span class="post-meta-item" title="繁/简：">
    <span class="post-meta-item-icon">
      <i class="fas fa-yin-yang"></i>
    </span>
      <span class="post-meta-item-text">繁/简：</span>
    <a id="translateLink" href="javascript:translatePage();" rel="external nofollow noreferrer">繁體</a>
  </span>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/js/tw_cn.js"></script>
<script type="text/javascript">
var defaultEncoding = 2; //网站编写字体是否繁体，1-繁体，2-简体
var translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0
var cookieDomain = "https://catbro666.github.io/"; //Cookie地址, 一定要设定, 通常为你的网址
var msgToTraditionalChinese = "繁體"; //此处可以更改为你想要显示的文字
var msgToSimplifiedChinese = "简体"; //同上，但两处均不建议更改
var translateButtonId = "translateLink"; //默认互换id
translateInitilization();
</script>
<br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <div class="note primary">
            <p>SSL协议是现代网络通信中重要的一环，它提供了传输层上的数据安全。为了方便大家的理解，本文将先从加密学的基础知识入手，然后展开对SSL协议原理、流程以及一些重要的特性的详解，最后会扩展介绍一下国密SSL协议的差异、安全性以及TLS 1.3的关键新特性。</p><p>限于篇幅以及个人知识水平，本文不会涉及过于细节的内容。特别地，本文将不涉及算法的具体原理，也不涉及实际代码的实现。而是试图以图表等直观的方式来了解基本的原理以及流程。</p>
          </div>

<span id="more"></span>

<h1 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h1><h2 id="古典的密码"><a href="#古典的密码" class="headerlink" title="古典的密码"></a>古典的密码</h2><p>密码学的历史可以追溯到很久以前，早在罗马共和国时期，据说凯撒就使用凯撒密码和他的将军进行通信。</p>
<h3 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h3><p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Caesar3.svg" alt="Caesar Cipher" loading="lazy"></p>
<p>凯撒密码就是一个简单地移位操作。凯撒密钥非常容易被破解，使用<strong>暴力破解</strong>的方式把密钥从0到25都尝试一遍就可以了。</p>
<h3 id="简单替换密码"><a href="#简单替换密码" class="headerlink" title="简单替换密码"></a>简单替换密码</h3><p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/simple-substitution-cipher.png" alt="Simple Substitution Cipher" loading="lazy"></p>
<p>简单替换密码，其明文字母表和密文字母表之间是一种随机的映射关系。这种方式密钥空间为<code>26! ~= 4 * 10^26</code>，这已经无法使用暴力破解方式来找到正确的密钥。但是可以使用<strong>频率分析</strong>来破译。</p>
<h3 id="Enigma密码机"><a href="#Enigma密码机" class="headerlink" title="Enigma密码机"></a>Enigma密码机</h3><p>二战时期德国使用的一系列转子机械加解密机器。尽管此机器的安全性较高，但盟军的密码学家们还是成功地破译了大量由这种机器加密的信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Enigma.jpg" alt="Enigma" loading="lazy"></p>
<p>主要弱点：</p>
<ul>
<li>将通信密码连续输入两次并加密</li>
<li>通信密码是人为选定</li>
<li>必须派发国防军密码本</li>
</ul>
<h2 id="对称密码"><a href="#对称密码" class="headerlink" title="对称密码"></a>对称密码</h2><h3 id="块密码和流密码"><a href="#块密码和流密码" class="headerlink" title="块密码和流密码"></a>块密码和流密码</h3><p>上面几种密码其实都属于对称密码的范畴，对称加密算法可以分为块密码和流密码两种：</p>
<ul>
<li>块密码（block cipher）：每次只能处理特定长度的数据块。一个块的长度就叫块长度（分组长度）</li>
<li>流密码（stream cipher）：对数据流进行连续处理的一类密码算法。一般以1比特、8比特或32比特为单位进行加密和解密。</li>
</ul>
<h3 id="AES-Advanced-Encryption-Standard"><a href="#AES-Advanced-Encryption-Standard" class="headerlink" title="AES (Advanced Encryption Standard)"></a>AES (Advanced Encryption Standard)</h3><p>AES是目前最常用的对称算法之一。对称加密算法，顾名思义，就是<strong>加密和解密使用相同的密钥</strong>。发送方使用密钥K对明文P进行加密得到密文C，然后将密文C发送给接收方，接收方使用相同的密钥K对密文进行解密，得到明文P。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/symmetric-cipher-flow.png" alt="symmetric-cipher-flow" loading="lazy"></p>
<p>AES采用的是Rijndael算法，下图是Rijndael加密中一轮的操作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/RijndaelEncrypt.png" alt="RijndaelEncrypt" loading="lazy"></p>
<p>每一轮都会进行字节替换、行位移、列混合和轮密钥异或，使得输入的位得到充分的<strong>混淆</strong>。一个块的加密会经过很多轮的操作，最终得到密文。</p>
<p>因为这4轮操作都是<strong>可逆</strong>的，解密的时候就是一个相反的过程。</p>
<h2 id="块密码的模式"><a href="#块密码的模式" class="headerlink" title="块密码的模式"></a>块密码的模式</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而块与块之间进行<strong>迭代的方法</strong>就称为分组密码的<strong>模式（mode）</strong>。</p>
<p>常用模式由：ECB、CBC、OFB、CFB、CTR等。这边限于篇幅，仅介绍ECB、CBC、CTR三种。</p>
<h4 id="ECB模式"><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h4><p>ECB是最简单的一种模式，每个块是独立进行加密的。将明文分组加密之后的结果直接成为密文分组。当最后一个明文分组的内容小于分组长度时，需要用一些特定的数据进行填充（padding）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Ecb_encryption.png" alt="Ecb_encryption" loading="lazy"></p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Ecb_decryption.png" alt="Ecb_decryption" loading="lazy"></p>
<p>ECB模式有非常显著的<strong>缺点</strong>：同样的明文块会被加密成相同的密文块；因此，它不能很好的隐藏数据模式。在某些场合，这种方法不能提供严格的数据保密性。</p>
<p>比如下面的企鹅图，用ECB模式加密之后得到中间的图，还是能很明显地看出图片的轮廓，不能很好的保护数据的机密性。而用其他模式加密之后，就得到如第三个图所示的结果，已经看不出明显的特征。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/ecb-penguin1.jpg" alt="原图" loading="lazy"> <img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/ecb-penguin2.jpeg" alt="ECB模式" loading="lazy"><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/ecb-penguin3.jpg" alt="其他模式" loading="lazy"></p>
<h4 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h4><p>CBC模式中，每个明文块先与前一个密文块进行异或，再进行加密。所以每个明文块都依赖于前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量（IV）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Cbc_encryption.png" alt="Cbc_encryption" loading="lazy"></p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/CbC_decryption.png" alt="Cbc_decryption" loading="lazy"></p>
<p>CBC是TLS1.2时代最为常用的工作模式。它没有ECB模式那个相同原文加密称相同密文的问题，但是也因此导致其并行计算能力不如ECB模式。</p>
<h4 id="CTR模式"><a href="#CTR模式" class="headerlink" title="CTR模式"></a>CTR模式</h4><p>计数器模式其实是将块加密转换成了流加密，它对一个逐次累加的计数器进行加密，然后用加密的比特序列与明文进行XOR操作得到密文。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/CTR_encryption_2.svg" alt="CTR_encryption" loading="lazy"></p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/CTR_decryption_2.svg" alt="CTR_decryption" loading="lazy"></p>
<p>计数器的作用跟CBC模式中的IV类似，保证相同的明文会加密成不同的密文。相比CBC等模式，CTR模式还有如下<strong>优点</strong>：它非常适合并行计算、错误密文中的对应比特只会影响明文中的对应比特。</p>
<h3 id="AEAD（Authenticated-Encryption-with-Associated-Data）"><a href="#AEAD（Authenticated-Encryption-with-Associated-Data）" class="headerlink" title="AEAD（Authenticated Encryption with Associated Data）"></a>AEAD（Authenticated Encryption with Associated Data）</h3><p>前面的那些模式都已经被发现存在不同程序的缺点或问题。在TLS1.3时代，只保留了AEAD类型的加密模式。AEAD在加密的同时增加了认证的功能，常用的有GCM、CCM、Ploy1305。</p>
<h4 id="GCM（Galois-Counter-Mode）"><a href="#GCM（Galois-Counter-Mode）" class="headerlink" title="GCM（Galois/Counter Mode）"></a>GCM（Galois/Counter Mode）</h4><p>GCM中的G是指的GMAC（关于MAC我们稍后会讲到），C就是指的我们前面提到的CTR计数器模式。下图右上角的部分就是上面的Counter模式加密，剩余部分则是GMAC。最终的结果包含初始计数器值、加密密文和MAC值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/GCM-Galois_Counter_Mode_with_IV.svg" alt="GCM-Galois_Counter_Mode_with_IV" loading="lazy"></p>
<h2 id="公钥密码（非对称密码）"><a href="#公钥密码（非对称密码）" class="headerlink" title="公钥密码（非对称密码）"></a>公钥密码（非对称密码）</h2><p>在使用对称加密时，一定会碰到<strong>密钥分发（密钥交换）</strong>的问题。使用预先共享密钥具有局限性，需要一种安全的方式将密钥交给对方。于是就引出了公钥密码。</p>
<h3 id="公钥密码算法（RSA、国密SM2）"><a href="#公钥密码算法（RSA、国密SM2）" class="headerlink" title="公钥密码算法（RSA、国密SM2）"></a>公钥密码算法（RSA、国密SM2）</h3><p>最常用的公钥密钥算法要数大名鼎鼎的RSA了，国密中则有SM2算法。公钥密码有两个密钥，其中一个是公开密钥，公开密钥可以散布，另一个是私有密钥，需要自己严密保管。比如Bob要发消息给Alice，Bob用Alice的公钥对消息进行加密，然后发送给Alice，Alice则用自己的私钥进行解密。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Public_key_encryption.svg" alt="Public_key_encryption" loading="lazy"></p>
<h3 id="Diffie-Hellman密钥交换"><a href="#Diffie-Hellman密钥交换" class="headerlink" title="Diffie-Hellman密钥交换"></a>Diffie-Hellman密钥交换</h3><p>另一种常用的公钥密码是DH类算法，可以用下图来形象地解释DH算法的原理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Diffie-Hellman_Key_Exchange.svg" alt="Diffie-Hellman_Key_Exchange" loading="lazy"></p>
<p>首先双方协商一个相同的底色（算法参数），然后各自生成自己私有的颜色（相当于私钥），并通过混合得到对应的公有颜色（相当于公钥）。随后双方交换各自的公有颜色，并与自己的私钥颜色混合，最终协商出一个相同的颜色（即交换的密钥）。窃听者就算得到了双方交换的这些信息，也无法生成相同的密钥，<strong>求解离散对象问题的困难度</strong>保证了DH算法的安全性。</p>
<h3 id="ECDH和ECDHE"><a href="#ECDH和ECDHE" class="headerlink" title="ECDH和ECDHE"></a>ECDH和ECDHE</h3><p><code>ECDH</code>是基于椭圆曲线的DH算法，原理上跟DH基本一样，主要是把有限域上的模幂运算替换成了椭圆曲线上的点乘运算。相比DH算法速度更快，可逆更难。</p>
<p>DH和ECDH都是使用的一个固定密钥，一旦密钥泄漏，以前所有的密文消息就都都破解了。<code>ECDHE</code>则提供了前向安全性，它每次使用一个临时的密钥，基于这个临时密钥进行密钥交换生成会话密钥。就算这个临时密钥泄漏了，也只影响本次SSL会话的消息。</p>
<h2 id="单向散列函数（Hash）"><a href="#单向散列函数（Hash）" class="headerlink" title="单向散列函数（Hash）"></a>单向散列函数（Hash）</h2><p>前面的对称密钥和公钥密码解决了信息传输的<strong>机密性</strong>问题，使我们传输的信息不被窃听。但是还没有解决<strong>完整性</strong>的问题，消息有可能在中途被“<strong>篡改</strong>”。所以就轮到单向散列函数出场了。</p>
<p><strong>单向散列函数</strong>可以根据输入的信息，计算出一个固定长度的散列值（摘要值），这个散列值可以作为消息的指纹用于检查消息的完整性。修改了原始消息的任意1个比特，最终生成的散列值可能就完全不同了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Cryptographic_Hash_Function.svg" alt="Cryptographic_Hash_Function" loading="lazy"></p>
<p>理想的散列函数具有以下几个性质：</p>
<ol>
<li>确定性：同样的消息总是产生同样的散列值</li>
<li>任何给定消息能够快速计算出散列值</li>
<li>单向性：无法通过散列值反算出消息</li>
<li><strong>弱抗碰撞性</strong>：难以找到可以生成给定散列值的消息</li>
<li><strong>强抗碰撞性</strong>：难以找到可以生成两条相同散列值的消息</li>
<li>消息的一个小的改动会导致Hash值的巨大变化</li>
</ol>
<h2 id="消息认证码（MAC）"><a href="#消息认证码（MAC）" class="headerlink" title="消息认证码（MAC）"></a>消息认证码（MAC）</h2><p>单向散列函数虽然保证了消息的<strong>完整性</strong>，但是聪明的攻击者可以将消息连同其散列值一起篡改了，而接收方却无法进行识别。所以还需要对消息进行<strong>认证</strong>，传统的认证方法有手写签名、盖章、手印、身份证、口令（其实是个共享密钥）等。在密码领域则可以通过消息认证码的方法进行认证。消息认证码相比单向散列函数，多了一个共享密钥对消息进行认证。攻击者因为没有这个密钥，所以无法伪造出MAC值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/MAC-vs-HASH.png" alt="MAC-vs-HASH" loading="lazy"></p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/HMAC-use-scene.png" alt="HMAC-use-scene" loading="lazy"></p>
<h3 id="MAC的问题"><a href="#MAC的问题" class="headerlink" title="MAC的问题"></a>MAC的问题</h3><ul>
<li>MAC跟对称密码一样需要一个共享密钥，所以也会有密钥分发的问题。</li>
<li>无法对第三方证明</li>
<li>无法防止否认</li>
</ul>
<h2 id="数字签名（RSA、ECDSA）"><a href="#数字签名（RSA、ECDSA）" class="headerlink" title="数字签名（RSA、ECDSA）"></a>数字签名（RSA、ECDSA）</h2><p>为了解决MAC的问题，又引入了数字签名。</p>
<p>数字签名同样属于公钥密码的范畴。跟之前不同的地方是，它使用私钥进行加密（该操作叫作签名），任何人都可以用公钥进行解密（该操作叫作验签）。因为公钥是公开的，所以解决了第三方证明的问题。又因为私钥只有本人具有，没有私钥的人事实上无法生成这段密文，所以也可以防止否认。所以MAC的三个问题都可以由数字签名解决。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Private_key_signing.svg" alt="Private_key_signing" loading="lazy"></p>
<p>通常配合散列函数使用，同时保证了完整性，也加快了速度。如下图所示，Alice发送消息给Bob。她先把自己的公钥发送给Bob，接着她对消息先计算一个散列值，然后用自己的私钥对这个散列值进行加密得到消息的签名值。然后她将初始的消息和签名一同发送给Bob。Bob收到之后，对消息进行同样的散列函数计算得到散列值，同时用Alice的公钥对签名数据进行解密，得到解密后散列值，然后在比较两个计算得到散列值是否一致，以验证签名的有效性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/DigitalSignature.png" alt="DigitalSignature" loading="lazy"></p>
<h2 id="数字证书、-CA"><a href="#数字证书、-CA" class="headerlink" title="数字证书、 CA"></a>数字证书、 CA</h2><p>到目前为止，我们的公钥密码、数字签名解决了机密性、完整性、可以进行认证以及防止否认等。但其实这一切都是基于一个大前提：就是<strong>公钥是属于真正的发送者</strong>。如果公钥是伪造的、那么这一切就都失效了。前面提到的数字签名只能保证对方拥有这个公钥对应的私钥，但是没法认证公钥所有者本身的身份。</p>
<p>为了解决这个问题，数字证书应运而出。它的解决方式就是让一个<strong>可信的第三方</strong>来对公钥进行签名。这个可信的第三方，我们一般称之为<strong>Certificate authorities（CA）</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Chain-of-trust-with-cert.svg" loading="lazy"></p>
<p>我们来看看实际证书是什么样子的。其中<code>Subject</code>是证书拥有者的信息，<code>Issuer</code>就是其签发者的信息，<code>Subject Public Key Info</code>是实际的公钥信息，这里用的是RSA 2048位的密钥。证书最后就是CA用自己的私钥对这个证书的签名。任何拥有CA的证书（包含公钥）的人都可以对这个证书进行验证，从而验证公钥所有者的身份。<code>Validity</code>是这个证书的有效期。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">$ openssl x509 -<span class="keyword">in</span> ~/sharefile/certs/rsa-user.pem -text -noout</span><br><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number:</span><br><span class="line">            a2:95:90:e8:e0:f6:3a:e4</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">        Issuer: C=CN, ST=SH, L=Shanghai, O=Awesome Software, OU=SSL Group, CN=RSA_CA_Cert/emailAddress=ssl@ca.com</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Nov  5 01:47:05 2018 GMT</span><br><span class="line">            Not After : Nov  2 01:47:05 2028 GMT</span><br><span class="line">        Subject: C=CN, ST=SH, L=Shanghai, O=Awesome Software, OU=SSL Group, CN=RSA_USER/emailAddress=rsa@site.com</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: rsaEncryption</span><br><span class="line">                Public-Key: (2048 bit)</span><br><span class="line">                Modulus:</span><br><span class="line">                    00:f4:a0:b6:57:e7:68:39:98:39:13:11:b9:61:ee:</span><br><span class="line">                    1d:5c:60:c6:53:51:ec:0e:59:53:0e:12:75:1c:5b:</span><br><span class="line">                    b1:b7:e4:dd:4d:c8:c1:b8:eb:07:32:12:a1:<span class="built_in">fc</span>:50:</span><br><span class="line">                    33:d9:63:4a:30:7f:b4:b5:e9:87:d9:71:33:65:ab:</span><br><span class="line">                    56:54:ba:34:92:06:9a:af:ff:84:8e:a3:29:af:46:</span><br><span class="line">                    61:3b:45:39:c5:a8:0a:f9:ae:fb:d4:2b:20:5a:9d:</span><br><span class="line">                    ce:00:fe:c9:87:b2:f4:d2:f8:bf:b7:2e:7a:79:5e:</span><br><span class="line">                    94:54:7d:f9:09:73:4a:ec:c7:22:01:79:4c:62:11:</span><br><span class="line">                    55:a9:d3:3b:f8:ef:3e:1d:56:e3:2f:34:ef:c6:0f:</span><br><span class="line">                    2c:94:40:01:a3:6f:1e:3b:61:bd:79:00:bf:26:f7:</span><br><span class="line">                    d6:c3:a6:22:22:50:f0:6e:aa:03:1e:ea:d9:e6:ad:</span><br><span class="line">                    4d:a9:60:4f:6d:81:80:f4:f9:a9:89:31:ab:f1:a3:</span><br><span class="line">                    9b:1a:a2:57:ed:44:30:39:<span class="built_in">fc</span>:3a:3a:c3:6e:c8:a6:</span><br><span class="line">                    db:2e:14:c1:3b:6b:5b:ca:ab:b7:0d:fb:85:39:08:</span><br><span class="line">                    bf:6b:41:c1:f6:42:b1:3f:9c:45:5c:4c:37:8e:7d:</span><br><span class="line">                    c6:18:f8:9b:87:16:80:7f:25:34:8f:14:a9:02:2e:</span><br><span class="line">                    7c:07:c9:8a:21:77:33:03:6a:9c:86:f1:73:9c:c8:</span><br><span class="line">                    2d:f1</span><br><span class="line">                Exponent: 65537 (0x10001)</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Basic Constraints:</span><br><span class="line">                CA:FALSE</span><br><span class="line">            X509v3 Key Usage:</span><br><span class="line">                Digital Signature, Non Repudiation, Key Encipherment</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">         30:cf:b2:9f:50:ea:d7:0d:e2:87:50:e6:bd:d7:b0:17:12:31:</span><br><span class="line">         b1:9f:59:16:50:60:bc:52:c0:46:7a:43:d0:34:43:48:d0:bd:</span><br><span class="line">         e1:a0:dc:75:a2:60:a0:c9:8f:ed:d4:36:14:18:75:c0:ef:c3:</span><br><span class="line">         92:fa:43:fa:34:5a:12:77:2f:03:00:eb:a6:db:d9:6b:50:ff:</span><br><span class="line">         44:56:22:c6:51:73:73:9a:4b:fd:bb:53:ff:2b:7e:97:55:d3:</span><br><span class="line">         4d:bb:bd:26:69:37:8d:71:30:41:bf:fd:48:40:<span class="built_in">fc</span>:6f:<span class="built_in">cd</span>:e2:</span><br><span class="line">         b7:4a:90:6f:a2:11:85:a7:88:d3:61:d5:03:0a:50:98:cc:0e:</span><br><span class="line">         aa:d5:83:38:b4:d5:f0:06:ff:a5:eb:d4:e6:54:14:e9:65:af:</span><br><span class="line">         36:a5:e4:3e:8b:78:18:0b:d6:7c:cc:f1:a3:da:7a:03:fd:89:</span><br><span class="line">         23:f0:e1:3e:af:7b:b1:7a:53:82:11:4a:5e:1d:84:b6:0b:cc:</span><br><span class="line">         96:b4:3a:8a:43:cf:ff:b3:3a:be:47:e0:40:c0:48:15:b4:f3:</span><br><span class="line">         2d:2b:73:b8:07:d2:21:83:3c:c4:4c:c2:31:17:4e:4c:15:da:</span><br><span class="line">         66:fd:06:9a:b7:ed:b5:9e:71:a3:40:0b:39:12:3c:7b:cb:cb:</span><br><span class="line">         a0:af:d0:c7:fe:59:41:35:04:7f:f3:f3:38:d0:d0:ac:7a:15:</span><br><span class="line">         7e:fa:ee:fd</span><br></pre></td></tr></table></figure>

<p>在实际使用中，通常会使用多级证书链，每一级证书由上一级CA签发，并由上一级CA的证书进行验签。最终的Root CA证书只能由它自己签发的，也即用自己的私钥对自己的公钥进行签名，否则就无限递归了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/CA-signing-of-digital-certificates.svg" alt="CA-signing-of-digital-certificates" loading="lazy"></p>
<p>所以数字证书实际上是一种信任链的传递，将对众多个体的身份认证转移到对少数几个CA的身份认证，可以减少遭到中间人攻击的风险。从公钥密码和证书这些出发就引出了<strong>公钥基础设置（PKI）</strong>：这是为了能够更有效地运用公钥而制定的一系列规范和规格的总称。</p>
<h2 id="混合密码系统"><a href="#混合密码系统" class="headerlink" title="混合密码系统"></a>混合密码系统</h2><p>那么有了公钥密码，是不是就不需要对称密码了呢？公钥密码虽然解决了对称密码的密钥分发问题，但是在计算速度上却远低于对称密码，相差几个数量级。下面是用<code>openssl speed</code>测试RSA1024和AES128的结果。AES128（相同块大小）的速度大概是RSA1024签名的1200倍，是验签的70倍。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ openssl speed rsa1024</span><br><span class="line">                  sign    verify    sign/s verify/s</span><br><span class="line">rsa 1024 bits 0.000103s 0.000006s   9732.8 162578.8</span><br><span class="line"></span><br><span class="line">$ openssl speed -evp aes128</span><br><span class="line"><span class="built_in">type</span>             16 bytes     64 bytes    256 bytes   1024 bytes   8192 bytes  16384 bytes</span><br><span class="line">aes-128-cbc    1075884.36k  1452740.12k  1510392.06k  1530545.83k  1537414.49k  1537114.11k</span><br></pre></td></tr></table></figure>

<p>因为对称密码和非对称密码各有优缺点，所以在实际应用中通常将两者结合起来，使用非对称密码来完成密钥交换，然后生成会话密钥作为对称密码的密钥，使用对称密码对信息进行加解密。</p>
<h2 id="随机数发生器"><a href="#随机数发生器" class="headerlink" title="随机数发生器"></a>随机数发生器</h2><p>截止目前，我们已经解决了很多问题，包括机密性、完整性、认证性、防抵赖，但其实还有一个大问题我们没有解决：即我们的<strong>会话密钥</strong>如何生成？一个安全的算法其所有的安全性应该都是基于其<strong>密钥的安全性</strong>，如果我们的密钥可以被轻易破解或预测，那我们前面构建的一切就都土崩瓦解了。所以随机数发生器就在这里起到了至关重要的作用。</p>
<p>随机数同样在<strong>防重放攻击</strong>中具有重要的作用，所谓重放攻击，就是攻击者将窃听的数据保存下来，在后面再原样发送给接收者，以达到其特定的攻击目的。防重放的常用手段有使用序号、时间戳、随机数等。</p>
<p>这里留个问题给大家思考，因为机密性和完整性的保护，攻击者既不能解密消息，又不能对消息进行篡改，那么重放有什么用呢？</p>
<p>理想的随机数发生器具有以下特性：</p>
<ul>
<li>随机性：不存在统计学偏差，是完全杂乱的数列</li>
<li>不可预测性：不能从过去的数列推测出下一个出现的数</li>
<li>不可重现性：除非将数列本身保存下来，否则不能重现相同的数列</li>
</ul>
<h2 id="密钥派生函数-key-derivation-function"><a href="#密钥派生函数-key-derivation-function" class="headerlink" title="密钥派生函数 key derivation function"></a>密钥派生函数 key derivation function</h2><p>KDF可用于将密钥材料扩展为更长的密钥或获取所需格式的密钥。TLS 1.2中是用的PRF算法，TLS 1.3中则是用的HKDF算法。</p>
<h1 id="SSL-TLS协议详解"><a href="#SSL-TLS协议详解" class="headerlink" title="SSL/TLS协议详解"></a>SSL/TLS协议详解</h1><h2 id="什么是SSL-TLS协议"><a href="#什么是SSL-TLS协议" class="headerlink" title="什么是SSL/TLS协议"></a>什么是SSL/TLS协议</h2><p>好了，有了前面的密码学基础，我们就可以正式进入TLS协议的介绍。前面介绍的基本都是独立的算法或者是几个算法结合起来的组件，而SSL/TLS协议则是基于这些底层的算法原语和组件，最终拼装而成的一个<strong>成品的密码学协议</strong>。</p>
<p>SSL全称是<code>Secure Sockets Layer</code>，安全套接字层，它是由网景公司(Netscape)设计的主要用于Web的安全传输协议，目的是为网络通信提供机密性、认证性及数据完整性保障。如今，SSL已经成为互联网保密通信的工业标准。</p>
<p>SSL最初的几个版本(SSL 1.0、SSL2.0、SSL 3.0)由网景公司设计和维护，从3.1版本开始，SSL协议由因特网工程任务小组(IETF)正式接管，并更名为TLS(Transport Layer Security)，发展至今已有TLS 1.0、TLS1.1、TLS1.2这几个版本。目前主流的还是TLS1.2，不过TLS1.3即将是大势所趋。</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Published</th>
<th>Status</th>
</tr>
</thead>
<tbody><tr>
<td>SSL 1.0</td>
<td>Unpublished</td>
<td>Unpublished</td>
</tr>
<tr>
<td>SSL 2.0</td>
<td>1995</td>
<td>Deprecated in 2011 (RFC <a target="_blank" rel="noopener external nofollow noreferrer" href="https://datatracker.ietf.org/doc/html/rfc6176">6176</a>)</td>
</tr>
<tr>
<td>SSL 3.0</td>
<td>1996</td>
<td>Deprecated in 2015 (RFC <a target="_blank" rel="noopener external nofollow noreferrer" href="https://datatracker.ietf.org/doc/html/rfc7568">7568</a>)</td>
</tr>
<tr>
<td>TLS 1.0</td>
<td>1999</td>
<td>Deprecated in 2020 (RFC <a target="_blank" rel="noopener external nofollow noreferrer" href="https://datatracker.ietf.org/doc/html/rfc8996">8996</a>)[<a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Transport_Layer_Security#cite_note-tls-deprecation-8">8]</a>[<a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Transport_Layer_Security#cite_note-:3-9">9]</a>[<a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Transport_Layer_Security#cite_note-:4-10">10]</a></td>
</tr>
<tr>
<td>TLS 1.1</td>
<td>2006</td>
<td>Deprecated in 2020 (RFC <a target="_blank" rel="noopener external nofollow noreferrer" href="https://datatracker.ietf.org/doc/html/rfc8996">8996</a>)[<a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Transport_Layer_Security#cite_note-tls-deprecation-8">8]</a>[<a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Transport_Layer_Security#cite_note-:3-9">9]</a>[<a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Transport_Layer_Security#cite_note-:4-10">10]</a></td>
</tr>
<tr>
<td>TLS 1.2</td>
<td>2008</td>
<td></td>
</tr>
<tr>
<td>TLS 1.3</td>
<td>2018</td>
<td></td>
</tr>
</tbody></table>
<p>SSL/TLS协议能够提供的安全目标主要包括如下几个：</p>
<div class="note info no-icon">
            <ul><li><p><strong>机密性</strong>：借助加密防止第三方窃听</p></li><li><p><strong>认证性</strong>：借助数字证书认证服务器端和客户端身份，防止身份伪造</p></li><li><p><strong>完整性</strong>：借助消息认证码(MAC)保障数据完整性，防止消息篡改</p></li><li><p><strong>防重放</strong>：防止重放攻击</p></li></ul>
          </div>



<h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><p>相信大家对TCP/IP 5层模型已经非常熟悉了，TLS协议就如其名字所说的（Transport Layer Security），用于保障传输层的安全。它位于传输层之上，应用层之下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS-layered-structure.svg" alt="TLS-layered-structure" loading="lazy"></p>
<p>SSL/TLS协议有一个高度模块化的架构，其内部又分为很多子协议：Handshake协议、Alert协议、ChangeCipherSpec协议、Application协议。它们底层都是基于Record协议，记录层协议负责识别不同的上层消息类型以及消息的分段加密认证等。</p>
<ul>
<li>Handshake协议：包括协商安全参数和算法套件、服务器身份认证(客户端身份认证可选)、密钥交换</li>
<li>Application协议：用于传输应用层数据</li>
<li>ChangeCipherSpec 协议：一条消息表明握手协议已经完成</li>
<li>Alert 协议：对握手协议中一些异常的错误提醒，分为fatal和warning两个级别，fatal类型的错误会直接中断SSL连接，而warning级别的错误一般情况下SSL连接会继续，只是会给出错误警告</li>
</ul>
<p>SSL/TLS协议被设计为一个两阶段协议，分为<strong>握手阶段</strong>和<strong>应用阶段</strong>。</p>
<p><strong>握手阶段</strong>：也称协商阶段，在这一阶段主要目标就是进行我们前面已经提到过的协商安全参数和算法套件、身份认证（基于数字证书）以及密钥交换生成后续加密通信所使用的密钥。</p>
<p><strong>应用阶段</strong>：双方使用握手阶段协商好的密钥进行安全通信。</p>
<h2 id="SSL-record"><a href="#SSL-record" class="headerlink" title="SSL record"></a>SSL record</h2><p>SSL记录层包的格式，跟其下的IP或TCP层类似，所有在SSL会话上交换的数据都按如下格式封装成帧。记录层协议负责识别不同的消息类型，也负责对消息的分段、压缩、消息认证和完整性保护、加密等工作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS-record-structure.svg" alt="TLS-record-structure" loading="lazy"></p>
<p>一个典型的记录层工作流（分组密码算法）如下：</p>
<ul>
<li>记录层接收到应用层的数据</li>
<li>将接收到的数据分块</li>
<li>使用协商的MAC key计算MAC或HMAC，并增加到记录块中</li>
<li>使用协商的Cipher Key将记录数据加密</li>
</ul>
<p>当加密的数据到了接收端，对方则进行相反的操作：解密数据、验证MAC、重组数据并交给应用层。</p>
<p>所有这些工作都由SSL层完成了，对于上层应用是完全透明的。</p>
<p>对于握手阶段的消息，payload是明文，当然就没有MAC和Padding。其他消息的payload都是密文。</p>
<p>对于<strong>流加密算法</strong>，没有后面的padding。对于<strong>块加密算法</strong>的记录，根据使用的算法在payload之前有可选的IV字段。</p>
<p>对于<strong>AEAD算法</strong>，因为认证已经包含在算法里了，所以没有后面的MAC和Padding字段。payload之前有一个外部nonce字段。</p>
<h2 id="算法套件CipherSuites"><a href="#算法套件CipherSuites" class="headerlink" title="算法套件CipherSuites"></a>算法套件CipherSuites</h2><p>在深入握手流程之前，我们先来了解一下算法套件的概念。前面在密码学基础部分我们已经了解到了各种算法，包括认证算法、密钥交换算法、对称密码算法、完整性认证的算法。</p>
<h3 id="TLS-1-2"><a href="#TLS-1-2" class="headerlink" title="TLS 1.2-"></a>TLS 1.2-</h3><p>一个<strong>算法套件</strong>是一个SSL连接中用到的这些算法类型的组合，包含如下几个部分：</p>
<ul>
<li>Key Exchange（Kx）</li>
<li>Authentication（Au）</li>
<li>Encryption（Enc）</li>
<li>Message Authentication Code（Mac）</li>
</ul>
<p>常见的算法套件类型比如<code>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256</code>，<code>TLS_RSA_WITH_AES_256_GCM_SHA384</code>、<code>TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384</code>、<code>ECC_SM2_WITH_SM4_SM3</code>（国密）、<code>ECDHE_SM2_WITH_SM4_SM3</code>（国密）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/CipherSuite1_2.png" alt="CipherSuite1_2" loading="lazy"></p>
<p>以<code>ECDHE-ECDSA-AES128-GCM-SHA256</code>为例，前面的<code>ECDHE</code>表示密钥交换算法，<code>ECDSA</code>表示身份认证算法，<code>AES128-GCM</code>表示对称加密算法，其中<code>128</code>表示块长度，<code>GCM</code>是其模式，<code>SHA256</code>表示哈希算法。对于<code>AEAD</code>因为消息认证和加密已经合并到一起了，最后的<code>SHA256</code>只表示密钥派生函数的算法，而对于传统的数据加密和认证分开的算法套件，它还表示<code>MAC</code>的算法。</p>
<p>可以通过如下命令查看每种算法套件的详细情况：<code>openssl ciphers -V | column -t | less</code>。</p>
<h3 id="TLS-1-3"><a href="#TLS-1-3" class="headerlink" title="TLS 1.3"></a>TLS 1.3</h3><p>对于TLSv1.3，因为已经将密钥交换和身份认证算法从算法套件中独立出去，算法套件只表示加密算法和密钥派生函数。之所以要独立出去，是因为支持的算法越来越多了，导致相乘之后算法套件数量庞大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/CipherSuite1_3.png" alt="CipherSuite1_3" loading="lazy"></p>
<p>可以用如下命令查看当前支持哪些TLS 1.3算法套件：<code>openssl ciphers -V | column -t | grep &#39;TLSv1.3&#39;</code>。</p>
<h2 id="SSL-handshake"><a href="#SSL-handshake" class="headerlink" title="SSL handshake"></a>SSL handshake</h2><p>终于进入核心的握手协议部分了。如前所述，SSL握手主要干以下几件事情：首先得商量双方用什么算法套件，然后根据需要认证对方的身份（基于数字证书），最后基于选择的算法套件进行密钥交换生成后续加密通信所使用的密钥。（本节描述的是TLS 1.2及以前版本的情况）</p>
<p>下图是一个完整SSL握手的建立流程:</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS-full-handshake-flow.svg" alt="TLS-full-handshake-flow" loading="lazy"></p>
<p>首先是TCP的3次握手建立TCP连接，然后客户端发起SSL握手。一次完整的SSL握手包含两次交互，第一次主要是完成算法套件的选择。第二次交互主要是完成身份认证以及密钥交换。这些都协商完成之后，SSL的安全通道就建立完成了。后续的应用数据就会在安全通道上进行加密传输。</p>
<h3 id="密钥交换流程-RSA"><a href="#密钥交换流程-RSA" class="headerlink" title="密钥交换流程-RSA"></a>密钥交换流程-RSA</h3><p>基于RSA的密钥交换流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/SSL-keyexchange-RSA.jpeg" alt="SSL-keyexchange-RSA" loading="lazy"></p>
<p>我们来模拟下协商过程：</p>
<ul>
<li><span class="label info">客户端</span>：Hi，服务端，我这边支持这些算法，这是我本次的随机数。</li>
<li><span class="label success">服务端</span>：好的，我看看，我们就选用这个算法套件吧，这是我本次的随机数，这是我的证书，你用这个证书里的公钥来加密预主密钥。</li>
<li><span class="label info">客户端</span>：稍等我验下证书，嗯，的确是服务端的证书。这是用证书中公钥加密的预主密钥。（使用两个随机数+预主密钥计算主密钥，然后生成会话密钥。。。）好了，我这边OK了。</li>
<li><span class="label success">服务端</span>：收到。（用私钥解密出预主密钥，使用两个随机数+预主密钥计算主密钥，然后生成会话密钥。。。）好了，我这边也OK了。</li>
<li><span class="label info">客户端</span>：这是加密的应用数据。。。</li>
<li><span class="label success">服务端</span>：这是加密的应用数据。。。</li>
</ul>
<p>注：上面的流程是单向认证（服务端没有验证客户端的身份），如果服务端也需要验客户端的身份，会在第一次交互中发送<code>Certificate Request</code>消息，客户端相应的在第二次交互中发送自己的<code>Certificate</code>以及<code>CertificateVerify</code>消息给服务端。</p>
<h3 id="密钥交换流程-DH"><a href="#密钥交换流程-DH" class="headerlink" title="密钥交换流程-DH"></a>密钥交换流程-DH</h3><p>基于DH的密钥交换流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/SSL-keyexchange-DH.jpeg" alt="SSL-keyexchange-DH" loading="lazy"></p>
<p>我们同样来模拟下协商过程：</p>
<ul>
<li><span class="label info">客户端</span>：Hi，服务端，我这边支持这些算法，这是我本次的随机数。</li>
<li><span class="label success">服务端</span>：好的，我看看，我们就选用这个算法套件吧，这是我本次的随机数，给你我的证书。我这边用这个DH参数，这是对应的签名。</li>
<li><span class="label info">客户端</span>：稍等我验下证书和签名，嗯，的确是服务端的证书，签名也没有问题。这是我这边的DH参数。（使用DH参数推导出预主密钥，再使用两个随机数+预主密钥计算主密钥，然后生成会话密钥。。。）好了，我这边OK了。</li>
<li><span class="label success">服务端</span>：收到。（使用DH参数推导预主密钥，再使用两个随机数+预主密钥计算主密钥，然后生成会话密钥。。。）好了，我这边也OK了。</li>
<li><span class="label info">客户端</span>：这是加密的应用数据。。。</li>
<li><span class="label success">服务端</span>：这是加密的应用数据。。。</li>
</ul>
<h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><p>通过第一次ClientHello和ServerHello的交互、以及密钥交换的过程，客户端和服务端双方，都得到了client随机数、server随机数以及预主密钥。接下来就可以通过这些来计算主密钥了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master_secret = PRF(pre_master_secret, &quot;master secret&quot;,</span><br><span class="line">                    ClientHello.random + ServerHello.random)</span><br><span class="line">                    [0..47];</span><br></pre></td></tr></table></figure>

<p>得到主密钥之后，再将其扩展为一个安全字节序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key_block = PRF(SecurityParameters.master_secret,</span><br><span class="line">                     &quot;key expansion&quot;,</span><br><span class="line">                     SecurityParameters.server_random +</span><br><span class="line">                     SecurityParameters.client_random);</span><br></pre></td></tr></table></figure>

<p>然后分别切分为MAC密钥、对称加密的key和IV。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">client_write_MAC_key[SecurityParameters.mac_key_length]</span><br><span class="line">server_write_MAC_key[SecurityParameters.mac_key_length]</span><br><span class="line">client_write_key[SecurityParameters.enc_key_length]</span><br><span class="line">server_write_key[SecurityParameters.enc_key_length]</span><br><span class="line">client_write_IV[SecurityParameters.fixed_iv_length]</span><br><span class="line">server_write_IV[SecurityParameters.fixed_iv_length]</span><br></pre></td></tr></table></figure>

<p>画成图的话大概是下面这个样子。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS1_2-Key-Calculation.png" alt="TLS1_2-Key-Calculation" loading="lazy"></p>
<h2 id="Session重用"><a href="#Session重用" class="headerlink" title="Session重用"></a>Session重用</h2><p>SSL握手额外引入了<strong>两次交互</strong>以及<strong>CPU密集型</strong>的算法运算。每次连接都进行SSL握手时非常耗费性能的，有没有什么办法进行性能优化呢？显然提升硬件性能、软件性能都是有效的方法。其实SSL从协议层面也考虑了这个问题，它提供了“会话重用”的特性。双方在建立前一次SSL连接之后，可以将SSL会话保存下来。下一次想要在建立SSL连接的时候，可以直接恢复之前的SSL会话，从而简化SSL握手流程。Session重用的时候只需要进行一次SSL握手交互，而且不需要再进行身份认证和密钥交换，从而大幅减小了整个流程的延迟和计算开销。</p>
<p>事实上，如果浏览器要对同个站点发起多个连接，它通常就会等第一个SSL握手完成后再发起其他的连接，这样其他的连接就可以复用之前的那个Session。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS-half-handshake-flow.svg" alt="TLS-half-handshake-flow" loading="lazy"></p>
<p>Session重用有两种机制，分别为Session IDs和Session tickets。</p>
<h3 id="Session-ID"><a href="#Session-ID" class="headerlink" title="Session ID"></a>Session ID</h3><p>我们来看下使用Session ID时的Session重用流程。从前面密钥交换的流程图中可以看到，服务端在<code>Server Hello</code>消息中会发送本次会话的<code>Session ID</code>给客户端。完成握手之后，服务端会保存本次的Session。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/session_resumption_with_session_id.jpeg" alt="session_resumption_with_session_id" loading="lazy"></p>
<p>后续客户端可以通过恢复这个Session来建立SSL连接。具体做法就是在<code>ClientHello</code>消息中带上要恢复的Session ID，然后服务端会根据Session ID去查找对应的会话，如果一切都OK的话，就会根据保存的会话恢复出会话密钥等信息。如果服务端不支持会话重用、或者没找到Session ID、或者会话已经过期了，那么就退化到完整的SSL握手。</p>
<h3 id="Session-Ticket"><a href="#Session-Ticket" class="headerlink" title="Session Ticket"></a>Session Ticket</h3><p>Session ID机制它要求服务端保存每个客户端的session cache，这会在服务端造成几个问题：内存的额外开销、要求Session的保存和淘汰策略、然后对有多个服务器的站点，如何高性能地共享session cache提出了挑战。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/session_resumption_with_session_ticket.jpeg" alt="session_resumption_with_session_ticket" loading="lazy"></p>
<p>Session Ticket机制的提出就是为了解决Session ID的问题。Session Ticket不需要服务端保存每个客户端的会话。取而代之，如果客户端宣称它支持session ticket，服务端会发送给客户端一个<code>New Session Ticket</code>消息，其中包含了会话相关的加密数据，加密的密钥只有服务端知道。</p>
<p>客户端会保存这个session ticket，当需要会话恢复的时候，它会在<code>ClientHello</code>消息的<code>SessionTicket</code>扩展中带上这个session ticket。服务端在收到之后解密出其中的session数据从而恢复上次的会话。</p>
<p>所以Session Ticket机制对于服务端来说是一种无状态（stateless）的重用，不需要服务端保存session cache，当然也就没有多服务器同步的问题。</p>
<h2 id="证书的吊销（黑名单）"><a href="#证书的吊销（黑名单）" class="headerlink" title="证书的吊销（黑名单）"></a>证书的吊销（黑名单）</h2><p>我们在介绍证书的时候已经看到了证书有一个有效期，在有效期外是无法验证通过的。但是如果我们想在有效期内就让证书失效该怎么办？比如公司员工离职了、或者私钥泄漏等，总不可能把发出去的证书收回来吧。</p>
<p>所以就引入了证书的吊销，CA可以吊销某张证书，在验证证书有效性的时候进行额外的黑名单验证。黑名单的验证有如下几种机制：</p>
<h3 id="Certificate-Revocation-List-CRL"><a href="#Certificate-Revocation-List-CRL" class="headerlink" title="Certificate Revocation List (CRL)"></a>Certificate Revocation List (CRL)</h3><p>CRL，即证书吊销列表。CA机构维护一个被吊销证书的列表，里面是被吊销证书的信息。验证证书方需要下载这个列表，进行黑名单的验证。</p>
<p>CRL的缺陷也很明显：证书验证方必须下载这个列表，且下载的列表跟实际CA机构的列表之间可能不同步。如果一个证书实际已经被吊销，但是并没有在本地列表中，就可能形成安全隐患。</p>
<h3 id="Online-Certificate-Status-Protocol-OCSP"><a href="#Online-Certificate-Status-Protocol-OCSP" class="headerlink" title="Online Certificate Status Protocol (OCSP)"></a>Online Certificate Status Protocol (OCSP)</h3><p>OCSP，即在线证书状态协议。它通过在线请求的方式来进行黑名单验证，不需要下载整个 list，只需要将该证书的序列号发送给 CA 进行验证。部署 OCSP 对 CA也引入了一定的要求，CA 需要搭建的一个高性能的服务器来提供验证服务。万一服务器挂掉了，那所有的黑名单验证就会当成是通过，有一定的安全隐患。</p>
<h3 id="OCSP-Stapling"><a href="#OCSP-Stapling" class="headerlink" title="OCSP Stapling"></a>OCSP Stapling</h3><p>OCSP Stapling是OCSP标准的一个扩展，主要目标就是提升性能和安全性。证书拥有者自己定期向OCSP服务器发送请求。获取OCSP响应，这个响应是基于时间戳的，而且由CA直接签名。</p>
<p>OCSP Stapling提升整体的性能，一方面证书验证方不需要再直接请求CA的服务器去查询状态，另一方面CA的OCSP服务器的压力也减小了。</p>
<h2 id="Server-Name-Indication（SNI）"><a href="#Server-Name-Indication（SNI）" class="headerlink" title="Server Name Indication（SNI）"></a>Server Name Indication（SNI）</h2><p>当一个站点上部署了多个Server时（相当于一个IP映射了多个域名），不同的Server可能需要使用不同的证书。问题是如何在SSL握手阶段知道是访问那个host（还没到HTTP阶段，无法用请求头里的<code>HOST</code>字段），从而决定使用对应的证书呢？</p>
<p>SNI就是为了解决这个问题，具体做法是在<code>ClientHello</code>扩展中带上SNI，服务端就能从中得知需要访问哪个host，从而选择相应的证书。</p>
<h1 id="GMSSL协议差异"><a href="#GMSSL协议差异" class="headerlink" title="GMSSL协议差异"></a>GMSSL协议差异</h1><p>GMSSL修改自TLS1.1，总体上与TLS协议的差异不大。详见《GMT 0024-2014 SSL VPN技术规范》。</p>
<h2 id="协议号"><a href="#协议号" class="headerlink" title="协议号"></a>协议号</h2><p>TLSv1.0, TSLv1.1, TLSv1.2、TLSv1.3的协议号分别为<code>0x0301</code>、<code>0x0302</code>、<code>0x0303</code>、<code>0x0304</code>。</p>
<p>而国密的版本号是<code>0x0101</code>。</p>
<h2 id="算法套件"><a href="#算法套件" class="headerlink" title="算法套件"></a>算法套件</h2><p>新增了国密的SM1/2/3/4等算法，定义了多个算法套件，其中比较常用的如<code>ECC_SM4_SM3</code>和<code>ECDHE_SM4_SM3</code>。<code>ECDHE_SM4_SM3</code>要求必须双向认证。</p>
<p>其中<code>ECC_SM4_SM3</code>的密钥交换过程类似RSA的密钥交换过程，由客户端用服务端的公钥对预主密钥进行加密后发送给服务端。<code>ECDHE_SM4_SM3</code>的密钥交换过程与普通TLS的ECDHE密钥交换类似，预主密钥由客户端和服务端双方推导得出。<code>ECC_SM4_SM3</code>和<code>ECDHE_SM4_SM3</code>的身份认证是都是通过SM2的签名/验签来完成。</p>
<h2 id="双证书体系"><a href="#双证书体系" class="headerlink" title="双证书体系"></a>双证书体系</h2><h3 id="证书消息"><a href="#证书消息" class="headerlink" title="证书消息"></a>证书消息</h3><p>国密SSL采用双证书体系：一个签名证书、一个加密证书。其中签名证书用于身份认证、加密证书用于密钥交换。发送<code>Certificate</code>消息时需要同时发送两个证书，格式与标准TLS报文格式一样，第一个证书是签名证书、第二个证书是加密证书。</p>
<h3 id="ECC-SM4-SM3密钥交换"><a href="#ECC-SM4-SM3密钥交换" class="headerlink" title="ECC_SM4_SM3密钥交换"></a>ECC_SM4_SM3密钥交换</h3><p>因为采用了双证书体系，在SSL状态机上略微有点不同。<code>ECC_SM4_SM3</code>的密钥交换过程如下：服务端发送<code>Certificate</code>消息之后，还要发送一个<code>ServerKeyExchange</code>消息（这跟RSA密钥交换有所不同），<code>ServerKeyExchange</code>中包含了一个签名值，签名由服务端签名证书对应的私钥（签名私钥）进行计算，签名的内容包括了ClientHello和ServerHello中的随机数以及加密证书。</p>
<p>客户端验证证书和签名之后，使用服务端加密证书加密预主密钥，发送给服务端，服务端则由自己的加密私钥进行解密得到预主密钥。</p>
<h3 id="ECDHE-SM4-SM3密钥交换"><a href="#ECDHE-SM4-SM3密钥交换" class="headerlink" title="ECDHE_SM4_SM3密钥交换"></a>ECDHE_SM4_SM3密钥交换</h3><p><code>ECDHE_SM4_SM3</code>的密钥交换过程如下：服务端发送<code>Certificate</code>消息之后，同样发送一个<code>ServerKeyExchange</code>消息，<code>ServerKeyExchange</code>中包含了一个签名值，签名由服务端签名证书对应的私钥（签名私钥）进行计算。签名的内容跟<code>ECC_SM4_SM3</code>时有所不同，包括了ClientHello和ServerHello中的随机数以及服务端ECDH参数（曲线、公钥）。国密ECDHE的密钥推导计算方式跟TLS也有所不同，TLS只需要对方的临时公钥和自己的临时私钥参与计算，而国密需要对方的临时公钥和固定公钥（即加密证书中的公钥）及自己的临时私钥和固定私钥（即加密私钥）参与计算。所以国密<code>ECDHE</code>必须是双向认证，因为服务端在进行密钥推导的时候也需要用到客户端的加密证书。</p>
<p>客户端验证证书和签名之后，发送自己的证书给服务端，接着根据<code>ServerKeyExchange</code>中ECDH参数信息生成自己的临时密钥，然后同自己的加密密钥、服务端临时公钥和加密公钥一起进行密钥推导得到预主密钥。并将自己的临时密钥参数通过<code>ClientKeyExchange</code>消息发送给服务端，服务端同样使用自己的临时密钥、加密密钥、客户端的临时公钥和加密公钥一起进行密钥推导得到预主密钥。</p>
<p>因为是双向认证，客户端在发送<code>ClientKeyExchange</code>消息之后，还需要发送一个<code>CertificateVerify</code>消息，签名的内容为从ClientHello消息开始到目前为止的所有已经交换的握手消息。</p>
<h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><h2 id="常见攻击"><a href="#常见攻击" class="headerlink" title="常见攻击"></a>常见攻击</h2><p>有些是针对协议设计上的漏洞，有些则是针对实现的bug，经常结合降级攻击手段一起使用。因为篇幅原因，这里仅挑选两个有代表性的重协商攻击和Heartbleed着重介绍一下，对于其余攻击感兴趣的可以参考<a target="_blank" rel="noopener external nofollow noreferrer" href="https://datatracker.ietf.org/doc/html/rfc7457">rfc7457-已知攻击总结</a></p>
<ul>
<li>重协商攻击</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/renegotiation-attack.png" loading="lazy"></p>
<p>中间人在不需要劫持、解密SSL/TLS连接的情况下，成功地将自己伪造的数据插入到用户真正数据之前。中间人如果了解APP协议（如HTTPS）的话，则会精心构造不完整的数据，让服务器的APP程序认为发生粘包，将数据暂缓不处理，继续等待后续的数据上来。例如攻击者先发送了如下的半拉子请求</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/bank/sendmoney.asp?acct=attacker&amp;amount=1000000</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">X-Ignore-This:</span><br></pre></td></tr></table></figure>

<p>后面当客户端发送过来真正的请求</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/ebanking</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>validcookie</span><br></pre></td></tr></table></figure>

<p>APP程序将请求拼接，真正的请求头被屏蔽了，但是却保留了用户的Cookie信息，从而利用用户的Cookie去访问网站内容。服务端会以为前面发送的请求是真正的客户端发送的。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/bank/sendmoney.asp?acct=attacker&amp;amount=1000000</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">X-Ignore-This</span><span class="punctuation">: </span>GET /ebanking HTTP/1.1</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>validcookie</span><br></pre></td></tr></table></figure>



<p>这个漏洞成因在于，客户端认为的首次协商却被服务器认为是重协商，以及首次协商和重协商之间缺少关联性。解决办法就是禁用重协商或者使用<a target="_blank" rel="noopener external nofollow noreferrer" href="https://datatracker.ietf.org/doc/html/rfc5746">安全重协商</a>。安全重协商会增加一个安全重协商标志，以及确认首次协商和重协商的关联性校验，从而确保中间人的攻击行为可以被识别并拒绝，保证重协商安全。</p>
<p>我们来看看安全重协商是如何保证安全的，对于前面的ClientHello2里面不携带安全重协商表示的情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/renegotiation-attack-fix1.png" alt="renegotiation-attack-fix1" loading="lazy"></p>
<p>对于前面的ClientHello2里面携带安全重协商表示的情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/renegotiation-attack-fix2.png" alt="renegotiation-attack-fix2" loading="lazy"></p>
<p>无论哪种情况都能保证中间人无机可乘。而这个安全重协商的标识就是提供了一个新的扩展性<code>renegotiation_info</code>。因为SSLv3/TLS 1.0不支持扩展，所以提供了另一种方法，即在算法套件列表中加上<code>TLS_EMPTY_RENEGOTIATION_INFO_SCSV（0xFF）</code>，这个不是一个真正的算法套件，只是起标识作用。</p>
<p>安全重协商的流程如下：</p>
<pre><code> 1. 在连接建立第一次SSL握手期间，双方通过`renegotiation_info`扩展或`SCSV`套件通知对方自己支持安全重协商
 2. 然后在握手结束之后，client和server都分别记录`Finish`消息之中的`client_verify_data`和`server_verify_data`
 3. 重协商时client在`ClientHello`中包含`client_verify_data`，server在`ServerHello`中包含`client_verify_data`和`server_verify_data`。对于受害者，如果协商中不会携带这些数据则连接无法建立。而Finished消息由于是加密的，攻击者无法得到client_verify_data和server_verify_data的值。
</code></pre>
<ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://heartbleed.com/">Heartbleed</a></li>
</ul>
<p>这是OpenSSL库一个实现上的bug，而不是TLS协议本身的bug。这个bug是由于TLS heartbeat扩展的实现没有进行正确的输入验证（缺少边界检查）导致的。bug的命名也从heartbeat而来。由于没有进行边界检查，导致可以读取的数据超出允许的范围。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Simplified_Heartbleed_explanation.svg" alt="Simplified_Heartbleed_explanation" loading="lazy"></p>
<p>这个bug当前造成了非常广泛的影响，有调查显示在这个漏洞公布后几年，仍有许多网站暴露在此攻击之下。这个bug告诫我们就算协议是安全的，实现仍然可能引入安全问题。安全性就像一个木桶，整体的安全性取决于最短的那块木板。</p>
<ul>
<li>CRIME和BREACH攻击</li>
</ul>
<p>这两个攻击都是基于压缩算法，通过改变请求正文，对比被压缩后的密文长度，可以破解出某些信息。</p>
<p>CRIME通过在受害者的浏览器中运行JavaScript代码并同时监听HTTPS传输数据，能够解密会话Cookie，主要针对TLS压缩。</p>
<p>Javascript代码尝试一位一位的暴力破解Cookie的值。中间人组件能够观察到每次破解请求和响应的密文，寻找不同，一旦发现了一个，他会和执行破解的Javascript通信并继续破解下一位。</p>
<p>BREACH攻击是CRIME攻击的升级版，攻击方法和CRIME相同，不同的是BREACH利用的不是SSL/TLS压缩，而是HTTP压缩。所以要抵御BREACH攻击必须禁用HTTP压缩。</p>
<ul>
<li>BEAST攻击</li>
</ul>
<p>TLS 在 1.1版本之前，下一个记录的IV是直接使用的前一个记录的密文。BEAST攻击就是利用了这一点，攻击者控制受害者发送大量请求，利用可预测性IV猜测关键信息。解决方法就是部署TLS 1.1或者更高级的版本。</p>
<ul>
<li>RC4攻击</li>
</ul>
<p>基于RC4算法的安全性，RC4目前已经不安全，应该禁用。</p>
<ul>
<li>POODLE攻击</li>
</ul>
<p>是SSL 3.0设计上的漏洞，使用了非确定性的CBC-padding，使中间人攻击者更容易通过padding-oracle攻击获取明文数据。</p>
<ul>
<li>降级攻击（版本回退攻击）</li>
</ul>
<p>欺骗服务器使用低版本的不安全的TLS协议，常和其他攻击手段结合使用。删除后向兼容性通常是防止降低攻击的唯一方法。</p>
<h2 id="前向安全性"><a href="#前向安全性" class="headerlink" title="前向安全性"></a>前向安全性</h2><p>如果没有前向安全性，一旦私钥泄漏，不仅将来的会话会受影响，过去的会话也都会受影响。一个耐心的黑客，可以先把以前截获的数据先保存下来，一旦私钥泄露或被破解，就可以破解之前的所有密文。这就是所谓的<strong>今日截获，明日破解</strong>。</p>
<p>TLS的实现之一就是通过使用临时的DH密钥交换来生成会话密钥，<strong>一次一密</strong>保证了即使黑客花大力气破解了这一次的会话密钥，也只是这次通信被攻击，之前的历史消息不会受到影响。这我们已经在第一部分中讲到了。</p>
<p>但即使是使用了临时DH密钥交换，服务端的session管理机制也会影响到前向安全性。前面Session重用的部分我们讲到了session ticket，它的保护完全是依赖于对称加密，所以长时间有效的session ticket密钥会阻止前向安全性的实现。</p>
<p>在实践中，应该优先使用临时DH密钥交换类算法套件，session的有效期不宜设置过长，session ticket的key也应该经常更换。</p>
<h1 id="TLS-1-3新特性"><a href="#TLS-1-3新特性" class="headerlink" title="TLS 1.3新特性"></a>TLS 1.3新特性</h1><p>TLS 1.3相比TLS 1.2改动巨大，它的主要改进目标是<strong>最大兼容</strong>、<strong>强化安全</strong>、<strong>提升性能</strong>。</p>
<p>下面列举了相比TLS 1.3的<strong>主要差异</strong>：</p>
<ul>
<li>对称加密算法只保留了AEAD类算法，将密钥交换和认证算法从算法套件的概念中分离出去了</li>
<li>增加了0-RTT模式</li>
<li>移除了静态RSA和DH密钥协商（现在所有基于公钥的密钥交换都提供了前向安全性）</li>
<li>现在所有的<code>ServerHello</code>后的握手消息都是加密的</li>
<li>密钥派生函数重新设计，KDF换成了标准的<code>HKDF</code></li>
<li>握手状态机大幅重构，砍掉了多余的消息如<code>ChangeCipherSpec</code></li>
<li>使用统一的PSK模型，替代了之前的Session Resumption（包括Session ID和Session Ticket）及早期TLS版本基于PSK（rfc4279）的算法套件</li>
</ul>
<p>这里介绍几个关键的特性</p>
<h2 id="密钥交换模式"><a href="#密钥交换模式" class="headerlink" title="密钥交换模式"></a>密钥交换模式</h2><p>TLS 1.3提出了3种密钥交换模式：</p>
<ul>
<li>(EC)DHE</li>
<li>PSK-only（pre-shared symmetric key）</li>
<li>PSK with (EC)DHE 前两者的结合，具有前向安全性</li>
</ul>
<h2 id="1-RTT握手"><a href="#1-RTT握手" class="headerlink" title="1-RTT握手"></a>1-RTT握手</h2><p>如前所述，TLS 1.2的完整握手有2个RTT，第一个RTT是<code>ClientHello/ServerHello</code>，第二个RTT是<code>ServerKeyExchange/ClientKeyExchange</code>。之所以需要两个RTT是因为TLS 1.2支持多种密钥交换算法及各种不同的参数，这些都依赖第一个RTT去协商出来。TLS 1.3直接大刀阔斧，砍掉了各种自定义的group、curve，砍掉了RSA密钥交换，只剩下为数不多的几个密钥交换算法，实际应用中大部分使用<code>ECDH P-256</code>或<code>X25519</code>。所以干脆让客户端缓存服务器上一次用的是啥密钥交换算法，把<code>KeyExchange</code>直接合入第一个RTT。如果服务器发现客户端发上来的算法不对，那么再告诉它正确的，让客户端重试就好了。（这就引入了<code>HelloRetryRequest</code>消息）。这样基本没有副作用，就可以降到1-RTT了。</p>
<p>TLS 1.3的完整握手流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">       Client                                           Server</span><br><span class="line"></span><br><span class="line">Key  ^ ClientHello</span><br><span class="line">Exch | + key_share*</span><br><span class="line">     | + signature_algorithms*</span><br><span class="line">     | + psk_key_exchange_modes*</span><br><span class="line">     v + pre_shared_key*       --------&gt;</span><br><span class="line">                                                  ServerHello  ^ Key</span><br><span class="line">                                                 + key_share*  | Exch</span><br><span class="line">                                            + pre_shared_key*  v</span><br><span class="line">                                        &#123;EncryptedExtensions&#125;  ^  Server</span><br><span class="line">                                        &#123;CertificateRequest*&#125;  v  Params</span><br><span class="line">                                               &#123;Certificate*&#125;  ^</span><br><span class="line">                                         &#123;CertificateVerify*&#125;  | Auth</span><br><span class="line">                                                   &#123;Finished&#125;  v</span><br><span class="line">                               &lt;--------  [Application Data*]</span><br><span class="line">     ^ &#123;Certificate*&#125;</span><br><span class="line">Auth | &#123;CertificateVerify*&#125;</span><br><span class="line">     v &#123;Finished&#125;              --------&gt;</span><br><span class="line">       [Application Data]      &lt;-------&gt;  [Application Data]</span><br><span class="line"></span><br><span class="line">              +  Indicates noteworthy extensions sent in the</span><br><span class="line">                 previously noted message.</span><br><span class="line"></span><br><span class="line">              *  Indicates optional or situation-dependent</span><br><span class="line">                 messages/extensions that are not always sent.</span><br><span class="line"></span><br><span class="line">              &#123;&#125; Indicates messages protected using keys</span><br><span class="line">                 derived from a [sender]_handshake_traffic_secret.</span><br><span class="line"></span><br><span class="line">              [] Indicates messages protected using keys</span><br><span class="line">                 derived from [sender]_application_traffic_secret_N.</span><br><span class="line"></span><br><span class="line">               Figure 1: Message Flow for Full TLS Handshake</span><br></pre></td></tr></table></figure>

<p>握手过程可以分成三个阶段：</p>
<ul>
<li>密钥交换：建立共享密钥材料，选择加密参数。此阶段后的所有信息都是加密的。</li>
<li>服务端参数：建立其他握手参数，如客户端是否需要认证、应用层协议支持</li>
<li>认证：身份认证，提供密钥确认和握手完整性</li>
</ul>
<h2 id="重用和PSK"><a href="#重用和PSK" class="headerlink" title="重用和PSK"></a>重用和PSK</h2><p>TLS的PSK可以直接在带外建立，也可以通过前一个连接的会话建立。一旦一个握手完成了之后，服务端就会给客户端发送一个PSK id，对应初始握手推导出的密钥。（对应TLS 1.2及之前版本的Session ID和Session Tickets，这两个机制在TLS 1.3中都弃用了）。</p>
<p>PSK可以单独使用，或者跟(EC)DHE密钥交换结合使用以提供前向安全性。</p>
<p>重用和PSK的握手流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">       Client                                               Server</span><br><span class="line"></span><br><span class="line">Initial Handshake:</span><br><span class="line">       ClientHello</span><br><span class="line">       + key_share               --------&gt;</span><br><span class="line">                                                       ServerHello</span><br><span class="line">                                                       + key_share</span><br><span class="line">                                             &#123;EncryptedExtensions&#125;</span><br><span class="line">                                             &#123;CertificateRequest*&#125;</span><br><span class="line">                                                    &#123;Certificate*&#125;</span><br><span class="line">                                              &#123;CertificateVerify*&#125;</span><br><span class="line">                                                        &#123;Finished&#125;</span><br><span class="line">                                 &lt;--------     [Application Data*]</span><br><span class="line">       &#123;Certificate*&#125;</span><br><span class="line">       &#123;CertificateVerify*&#125;</span><br><span class="line">       &#123;Finished&#125;                --------&gt;</span><br><span class="line">                                 &lt;--------      [NewSessionTicket]</span><br><span class="line">       [Application Data]        &lt;-------&gt;      [Application Data]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Subsequent Handshake:</span><br><span class="line">       ClientHello</span><br><span class="line">       + key_share*</span><br><span class="line">       + pre_shared_key          --------&gt;</span><br><span class="line">                                                       ServerHello</span><br><span class="line">                                                  + pre_shared_key</span><br><span class="line">                                                      + key_share*</span><br><span class="line">                                             &#123;EncryptedExtensions&#125;</span><br><span class="line">                                                        &#123;Finished&#125;</span><br><span class="line">                                 &lt;--------     [Application Data*]</span><br><span class="line">       &#123;Finished&#125;                --------&gt;</span><br><span class="line">       [Application Data]        &lt;-------&gt;      [Application Data]</span><br><span class="line"></span><br><span class="line">            Figure 3: Message Flow for Resumption and PSK</span><br></pre></td></tr></table></figure>

<p>这种情况下服务端的身份通过PSK认证，所以服务端不发送<code>Certficate</code>和<code>CertificateVerify</code>消息。当客户端通过PSK提议重用的时候，也应该提供<code>key_share</code>扩展，以便服务端在拒绝重用的时候回退到全握手。</p>
<h2 id="有副作用的0-RTT握手"><a href="#有副作用的0-RTT握手" class="headerlink" title="有副作用的0-RTT握手"></a>有副作用的0-RTT握手</h2><p>当客户端和服务端共享一个PSK的时候（无论是通过外部获得还是通过前面的握手获得），TLS 1.3允许客户端在第一个flight上就发送数据（early data）。客户端使用PSK来认证服务端及加密early data。</p>
<p>0-RTT的握手流程如下，与PSK重用的1-RTT握手相比，增加<code>early_data</code>扩展以及第一个flight上的0-RTT应用数据。当接收到服务端的<code>Finished</code>消息之后，会发送一个<code>EndOfEarlyData</code>消息指示后面加密密钥的更换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Client                                               Server</span><br><span class="line"></span><br><span class="line">ClientHello</span><br><span class="line">+ early_data</span><br><span class="line">+ key_share*</span><br><span class="line">+ psk_key_exchange_modes</span><br><span class="line">+ pre_shared_key</span><br><span class="line">(Application Data*)     --------&gt;</span><br><span class="line">                                                ServerHello</span><br><span class="line">                                           + pre_shared_key</span><br><span class="line">                                               + key_share*</span><br><span class="line">                                      &#123;EncryptedExtensions&#125;</span><br><span class="line">                                              + early_data*</span><br><span class="line">                                                 &#123;Finished&#125;</span><br><span class="line">                        &lt;--------       [Application Data*]</span><br><span class="line">(EndOfEarlyData)</span><br><span class="line">&#123;Finished&#125;              --------&gt;</span><br><span class="line">[Application Data]      &lt;-------&gt;        [Application Data]</span><br><span class="line"></span><br><span class="line">      +  Indicates noteworthy extensions sent in the</span><br><span class="line">         previously noted message.</span><br><span class="line"></span><br><span class="line">      *  Indicates optional or situation-dependent</span><br><span class="line">         messages/extensions that are not always sent.</span><br><span class="line"></span><br><span class="line">      () Indicates messages protected using keys</span><br><span class="line">         derived from a client_early_traffic_secret.</span><br><span class="line"></span><br><span class="line">      &#123;&#125; Indicates messages protected using keys</span><br><span class="line">         derived from a [sender]_handshake_traffic_secret.</span><br><span class="line"></span><br><span class="line">      [] Indicates messages protected using keys</span><br><span class="line">         derived from [sender]_application_traffic_secret_N.</span><br><span class="line"></span><br><span class="line">      Figure 4: Message Flow for a 0-RTT Handshake</span><br></pre></td></tr></table></figure>

<p>0-RTT的数据安全性较弱：</p>
<ul>
<li>0-RTT数据没有前向安全性，因为其加密密钥单纯是从PSK推导出来的</li>
<li>跨连接可以重放0-RTT里的应用数据（常规的TLS 1.3 1-RTT数据通过服务端随机数来防重放）</li>
</ul>
<h2 id="密钥派生过程"><a href="#密钥派生过程" class="headerlink" title="密钥派生过程"></a>密钥派生过程</h2><p>密钥派生过程用到了HKDF-Extract和HKDF-Expand函数，以及如下的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HKDF-Expand-Label(Secret, Label, Context, Length) =</span><br><span class="line">      HKDF-Expand(Secret, HkdfLabel, Length)</span><br></pre></td></tr></table></figure>

<p>其中<code>HkdfLabel</code>表示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">  uint16 length = Length;</span><br><span class="line">  opaque label&lt;7..255&gt; = &quot;tls13 &quot; + Label;</span><br><span class="line">  opaque context&lt;0..255&gt; = Context;</span><br><span class="line">&#125; HkdfLabel;</span><br><span class="line"></span><br><span class="line">Derive-Secret(Secret, Label, Messages) = HKDF-Expand-Label(</span><br><span class="line">  Secret, Label, Transcript-Hash(Messages), Hash.length)</span><br></pre></td></tr></table></figure>



<p>不管是哪种密钥交换模式都给走完下面的整个流程，当没有对应的输入密钥材料（IKM），对应的位置用Hash长度的0值字符串代替。例如没有PSK的话，Early Secret就是<code>HKDF-Extract(0, 0)</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS1_3-Key-Schedule.png" alt="TLS1_3-Key-Schedule" loading="lazy"></p>
<p>其中<code>exporter_secret</code>是导出密钥，用于用户自定义的其他用途。<code>resumption_master_secret</code>用于生成ticket。<code>client_early_traffic_secret</code>用于推导0-RTT的early-data密钥，<code>*_handshake_traffic_secret</code>用于推到握手消息的加密密钥，<code>*_application_traffic_secret_N</code>用于推导应用消息的加密密钥。</p>
<h1 id="常见实现"><a href="#常见实现" class="headerlink" title="常见实现"></a>常见实现</h1><p>OpenSSL：非常流行的开源实现、代码量最大、写得最烂？</p>
<p>LibreSSL：也是OpenSSL的一个fork，OpenBSD项目</p>
<p>BoringSSL：是OpenSSL的一个fork分支，主要用于Google的Chrome/Chromium、Android以及其他应用</p>
<p>JSSE（Java Secure Socket Extension）：Java实现</p>
<p>NSS：最初由网景开发的库，现在主要被浏览器和客户端软件使用，比如Firefox使用的就是NSS库（Mozilla开发）。</p>
<p>go.crypto：Go语言的实现</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://introspelliam.github.io/2018/03/20/crypto/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BBSSL-TLS%E5%AE%9E%E7%8E%B0/">深度解读SSL/TLS实现</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.helong.info/blog/2015/09/07/tls-protocol-analysis-and-crypto-protocol-design/#1-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%88%86%E5%B1%82%E6%8A%BD%E8%B1%A1">TLS协议分析</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.cn/post/6844903624640823310#heading-5">完全吃透</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/">Keyless SSL</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Transport_Layer_Security">wiki-Transport_Layer_Security</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hpbn.co/transport-layer-security-tls/">Transport Layer Security</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.crypto101.io/">Crypto101</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://xiaoxueying.gitbooks.io/graphic-cryptology/content/index.html">graphic-cryptology</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA算法原理</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.pediy.com/kssd/pediy06/pediy6014.htm">ECC加密算法入门</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://datatracker.ietf.org/doc/html/rfc5246">TLS1.2-rfc5246</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://datatracker.ietf.org/doc/html/rfc8446">TLS1.3-rfc8446</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/OCSP_stapling">OCSP_stapling</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="http://drops.xmd5.com/static/drops/tips-4403.html">常见HTTPS攻击方法</a></li>
</ul>

    </div>

    
    
    
      
<div>
    
        <div style="text-align:center;font-size:22px;letter-spacing:10px;user-select:none;color:#bbb;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>



        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>猫猫哥
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://catbro666.github.io/posts/e92ef4b4/" title="一篇文章搞懂密码学基础及SSL&#x2F;TLS协议">https://catbro666.github.io/posts/e92ef4b4/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/SSL-TLS/" rel="tag"><i class="fa fa-tag"></i> SSL/TLS</a>
              <a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" rel="tag"><i class="fa fa-tag"></i> 密码学</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/74970c0e/" rel="prev" title="自己动手实现Lua--实现TAILCALL指令">
      <i class="fa fa-chevron-left"></i> 自己动手实现Lua--实现TAILCALL指令
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/f9a188a7/" rel="next" title="Lua中如何实现类似gdb的断点调试--01最小实现">
      Lua中如何实现类似gdb的断点调试--01最小实现 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">密码学基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%A4%E5%85%B8%E7%9A%84%E5%AF%86%E7%A0%81"><span class="nav-number">1.1.</span> <span class="nav-text">古典的密码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81"><span class="nav-number">1.1.1.</span> <span class="nav-text">凯撒密码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E6%9B%BF%E6%8D%A2%E5%AF%86%E7%A0%81"><span class="nav-number">1.1.2.</span> <span class="nav-text">简单替换密码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Enigma%E5%AF%86%E7%A0%81%E6%9C%BA"><span class="nav-number">1.1.3.</span> <span class="nav-text">Enigma密码机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81"><span class="nav-number">1.2.</span> <span class="nav-text">对称密码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9D%97%E5%AF%86%E7%A0%81%E5%92%8C%E6%B5%81%E5%AF%86%E7%A0%81"><span class="nav-number">1.2.1.</span> <span class="nav-text">块密码和流密码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AES-Advanced-Encryption-Standard"><span class="nav-number">1.2.2.</span> <span class="nav-text">AES (Advanced Encryption Standard)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9D%97%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text">块密码的模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ECB%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">ECB模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CBC%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">CBC模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CTR%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">CTR模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AEAD%EF%BC%88Authenticated-Encryption-with-Associated-Data%EF%BC%89"><span class="nav-number">1.3.2.</span> <span class="nav-text">AEAD（Authenticated Encryption with Associated Data）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GCM%EF%BC%88Galois-Counter-Mode%EF%BC%89"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">GCM（Galois&#x2F;Counter Mode）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%EF%BC%88%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%EF%BC%89"><span class="nav-number">1.4.</span> <span class="nav-text">公钥密码（非对称密码）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%EF%BC%88RSA%E3%80%81%E5%9B%BD%E5%AF%86SM2%EF%BC%89"><span class="nav-number">1.4.1.</span> <span class="nav-text">公钥密码算法（RSA、国密SM2）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Diffie-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2"><span class="nav-number">1.4.2.</span> <span class="nav-text">Diffie-Hellman密钥交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ECDH%E5%92%8CECDHE"><span class="nav-number">1.4.3.</span> <span class="nav-text">ECDH和ECDHE</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%EF%BC%88Hash%EF%BC%89"><span class="nav-number">1.5.</span> <span class="nav-text">单向散列函数（Hash）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81%EF%BC%88MAC%EF%BC%89"><span class="nav-number">1.6.</span> <span class="nav-text">消息认证码（MAC）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MAC%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.6.1.</span> <span class="nav-text">MAC的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%EF%BC%88RSA%E3%80%81ECDSA%EF%BC%89"><span class="nav-number">1.7.</span> <span class="nav-text">数字签名（RSA、ECDSA）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E3%80%81-CA"><span class="nav-number">1.8.</span> <span class="nav-text">数字证书、 CA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.9.</span> <span class="nav-text">混合密码系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%8F%91%E7%94%9F%E5%99%A8"><span class="nav-number">1.10.</span> <span class="nav-text">随机数发生器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%86%E9%92%A5%E6%B4%BE%E7%94%9F%E5%87%BD%E6%95%B0-key-derivation-function"><span class="nav-number">1.11.</span> <span class="nav-text">密钥派生函数 key derivation function</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SSL-TLS%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">SSL&#x2F;TLS协议详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSSL-TLS%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.1.</span> <span class="nav-text">什么是SSL&#x2F;TLS协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82"><span class="nav-number">2.2.</span> <span class="nav-text">协议分层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SSL-record"><span class="nav-number">2.3.</span> <span class="nav-text">SSL record</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%A5%97%E4%BB%B6CipherSuites"><span class="nav-number">2.4.</span> <span class="nav-text">算法套件CipherSuites</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TLS-1-2"><span class="nav-number">2.4.1.</span> <span class="nav-text">TLS 1.2-</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TLS-1-3"><span class="nav-number">2.4.2.</span> <span class="nav-text">TLS 1.3</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SSL-handshake"><span class="nav-number">2.5.</span> <span class="nav-text">SSL handshake</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E6%B5%81%E7%A8%8B-RSA"><span class="nav-number">2.5.1.</span> <span class="nav-text">密钥交换流程-RSA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E6%B5%81%E7%A8%8B-DH"><span class="nav-number">2.5.2.</span> <span class="nav-text">密钥交换流程-DH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90"><span class="nav-number">2.5.3.</span> <span class="nav-text">密钥生成</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Session%E9%87%8D%E7%94%A8"><span class="nav-number">2.6.</span> <span class="nav-text">Session重用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Session-ID"><span class="nav-number">2.6.1.</span> <span class="nav-text">Session ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Session-Ticket"><span class="nav-number">2.6.2.</span> <span class="nav-text">Session Ticket</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%81%E4%B9%A6%E7%9A%84%E5%90%8A%E9%94%80%EF%BC%88%E9%BB%91%E5%90%8D%E5%8D%95%EF%BC%89"><span class="nav-number">2.7.</span> <span class="nav-text">证书的吊销（黑名单）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Certificate-Revocation-List-CRL"><span class="nav-number">2.7.1.</span> <span class="nav-text">Certificate Revocation List (CRL)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Online-Certificate-Status-Protocol-OCSP"><span class="nav-number">2.7.2.</span> <span class="nav-text">Online Certificate Status Protocol (OCSP)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OCSP-Stapling"><span class="nav-number">2.7.3.</span> <span class="nav-text">OCSP Stapling</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Server-Name-Indication%EF%BC%88SNI%EF%BC%89"><span class="nav-number">2.8.</span> <span class="nav-text">Server Name Indication（SNI）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GMSSL%E5%8D%8F%E8%AE%AE%E5%B7%AE%E5%BC%82"><span class="nav-number">3.</span> <span class="nav-text">GMSSL协议差异</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E5%8F%B7"><span class="nav-number">3.1.</span> <span class="nav-text">协议号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%A5%97%E4%BB%B6"><span class="nav-number">3.2.</span> <span class="nav-text">算法套件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E8%AF%81%E4%B9%A6%E4%BD%93%E7%B3%BB"><span class="nav-number">3.3.</span> <span class="nav-text">双证书体系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%81%E4%B9%A6%E6%B6%88%E6%81%AF"><span class="nav-number">3.3.1.</span> <span class="nav-text">证书消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ECC-SM4-SM3%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2"><span class="nav-number">3.3.2.</span> <span class="nav-text">ECC_SM4_SM3密钥交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ECDHE-SM4-SM3%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2"><span class="nav-number">3.3.3.</span> <span class="nav-text">ECDHE_SM4_SM3密钥交换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text">安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB"><span class="nav-number">4.1.</span> <span class="nav-text">常见攻击</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E5%90%91%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">4.2.</span> <span class="nav-text">前向安全性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TLS-1-3%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">5.</span> <span class="nav-text">TLS 1.3新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.1.</span> <span class="nav-text">密钥交换模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-RTT%E6%8F%A1%E6%89%8B"><span class="nav-number">5.2.</span> <span class="nav-text">1-RTT握手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E7%94%A8%E5%92%8CPSK"><span class="nav-number">5.3.</span> <span class="nav-text">重用和PSK</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%840-RTT%E6%8F%A1%E6%89%8B"><span class="nav-number">5.4.</span> <span class="nav-text">有副作用的0-RTT握手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%86%E9%92%A5%E6%B4%BE%E7%94%9F%E8%BF%87%E7%A8%8B"><span class="nav-number">5.5.</span> <span class="nav-text">密钥派生过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.</span> <span class="nav-text">常见实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">7.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">猫猫哥</p>
  <div class="site-description" itemprop="description">如果说根号二是无理数，那么我就是个无理人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/catbro666" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;catbro666" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chzf_zju@163.com" title="E-Mail → mailto:chzf_zju@163.com" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener external nofollow noreferrer" target="_blank"><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>


      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">猫猫哥</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">145k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:12</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"0Syy5qyXX1qTBOGiD0vUzpHb-MdYXbMMI","app_key":"B3MuN4GIHf7ru1ojTSkjjI9a","server_url":null,"security":true,"betterPerformance":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/js/utils.js"></script>

<script src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/js/motion.js"></script>


<script src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/js/schemes/pisces.js"></script>


<script src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : '0Syy5qyXX1qTBOGiD0vUzpHb-MdYXbMMI',
      appKey     : 'B3MuN4GIHf7ru1ojTSkjjI9a',
      placeholder: "欢迎留言讨论，记得在上方【邮箱】处填上邮箱地址，可以收到回复通知哦(^。^)",
      avatar     : 'retro',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>



  <script async src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/js/cursor/fireworks.js"></script>



  <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/js/fold_action.js"></script>


</body>
</html>

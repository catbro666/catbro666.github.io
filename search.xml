<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>C语言中的函数调用约定</title>
    <url>/posts/657c24ad/</url>
    <content><![CDATA[<div class="note primary">
            <p>本文主要介绍C语言中的函数调用约定，通过汇编代码结合实时观察栈的变化情况，直观地了解函数调用的过程。本文只讨论x86/64架构、Linux/GCC环境下的情况，不过其他环境在整体思想上应该是类似的，都需要处理这些问题。</p>
          </div>

<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>什么是调用约定（Calling Convention）？</p>
<p>它主要是为了方便代码的共享以及简化子函数的使用方式。参数和返回值如何进行传递、栈帧如何建立和销毁、调用者和被调者分别负责哪些事情？调用约定对这些都作出了规定，函数的定义者和调用者只要都遵循这个约定，那么就可以无错地进行交互；否则，不一致的状态可能导致程序的致命错误。</p>
<p>x86 C编译器默认通常使用cdecl调用约定，这也是C语言事实上的标准。当然还有一些其他的调用约定，读者可以通过文末的参考资料进行更多的了解。</p>
<h2 id="典型的栈帧结构"><a href="#典型的栈帧结构" class="headerlink" title="典型的栈帧结构"></a>典型的栈帧结构</h2><p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/657c24ad/%E5%85%B8%E5%9E%8B%E7%9A%84%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84.jpeg" alt="典型的栈帧结构" loading="lazy"></p>
<p>上图是一个典型的调用子函数期间的栈帧结构。栈从下面高地址往上生长，每嵌套一层函数调用，就往上生长一个栈帧。其中的返回地址可以看作是每个栈帧的分界线，它上面的部分归被调者管，它下面的部分归调用者管。</p>
<p>ESP和EBP分别指示当前栈顶位置和当前栈帧的基址。通过EBP加适当的偏移可以方便地访问参数以及局部变量，同时也可以快速地进行关帧的操作。</p>
<p>调用约定可以分成两个部分，即规定调用者(caller)的部分和规定被调者(callee)的部分。下面分别进行介绍。</p>
<h2 id="调用者规则"><a href="#调用者规则" class="headerlink" title="调用者规则"></a>调用者规则</h2><p>在发起一个子函数调用时，调用者需要：</p>
<ol>
<li>在调用子函数前，首先需要保存某些寄存器的值。这些寄存器设计为由调用者保存，所以被调函数是允许修改它们的。如果调用者在子函数返回后还依赖这些寄存器的值，就必须在调用子函数前将这些寄存器的值压栈保存，在子函数返回之后再将其出栈恢复。调用者保存的寄存器有EAX、ECX、EDX。</li>
<li>接着，调用者需要把调用子函数的参数压栈，压栈顺序为从右往左，所以第一个参数在栈的最上面（低地址）。</li>
<li>使用<code>call</code>指令调用子函数，这个指令会将返回地址（也即当前函数下一条指令的地址）压栈，然后跳到子函数处开始执行。</li>
</ol>
<p>被调者规则我们稍后再看，现在先假设子函数已经返回，所以正常情况下栈已经恢复到了调用<code>call</code>指令之前的情况。调用者可以从EAX寄存器中获取子函数的返回值。要完全恢复子函数调用前的状态，还需要：</p>
<ol>
<li>将栈上的参数移出</li>
<li>将之前压栈的调用者保存的寄存器的内容出栈恢复（跟入栈时相反的顺序）。调用者可以假设其他寄存器没有被子函数修改。</li>
</ol>
<h2 id="被调者规则"><a href="#被调者规则" class="headerlink" title="被调者规则"></a>被调者规则</h2><p>子函数在开头需要：</p>
<ol>
<li>将EBP的值压栈，然后将ESP的值拷贝到EBP上。可以把这个当作是开帧的操作，首先保存上一个栈帧的基址，然后设置当前栈帧的基址（即子函数刚开始执行时的栈指针的值），参数和局部变量跟EBP有着固定的偏移，所以可以通过EBP访问到。</li>
<li>接下来，分配局部变量的栈空间，这个可以通过减小ESP的值来实现。</li>
<li>然后需要将被调者保存的寄存器的值入栈（如果子函数中用到了它们的话）。被调者保存的寄存器包括EBX、EDI和ESI。</li>
</ol>
<p>执行完这3步操作之后，就开始执行实际的函数体了。当函数体执行结束即将返回的时候，它需要：</p>
<ol>
<li>将返回值放在EAX中</li>
<li>将被调者保存的寄存器的值入栈（跟入栈时相反的顺序）</li>
<li>释放局部变量的栈空间，这个可以通过增大ESP的值来实现，更好的方法是将EBP的值恢复到ESP。</li>
<li>然后恢复上一个栈帧的EBP，将其出栈</li>
<li>最后，执行<code>ret</code>指令返回。该指令会将之前入栈的返回地址出栈，然后跳转到这个返回地址处继续执行。</li>
</ol>
<h2 id="C语言实例"><a href="#C语言实例" class="headerlink" title="C语言实例"></a>C语言实例</h2><p>光说不练假把式，我们通过如下一个简单的例子来实际看一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = <span class="number">0x10</span>;</span><br><span class="line">    <span class="keyword">int</span> fb = <span class="number">0x20</span>;</span><br><span class="line">    fa = a;</span><br><span class="line">    fb = b;</span><br><span class="line">    <span class="keyword">return</span> fa + fb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    ret = foo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将其编译之后，使用objdump进行反汇编：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 内核版本 2.6.8-2-686-smp</span></span><br><span class="line"><span class="comment"># gcc版本 3.3.5</span></span><br><span class="line">$ gcc -g -O0 test.c</span><br><span class="line">$ objdump -Sd a.out &gt; a.s</span><br><span class="line"><span class="comment"># 如果只想编译的话，可以直接</span></span><br><span class="line"><span class="comment"># gcc -S test.c</span></span><br></pre></td></tr></table></figure>

<p>接下来我们将结合汇编代码以及栈的实时情况，来直观地了解下函数的调用过程，即上面foo函数的调用过程。</p>
<h2 id="调用者部分"><a href="#调用者部分" class="headerlink" title="调用者部分"></a>调用者部分</h2><p>首先来看main函数的前面部分</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="number">804837</span>c:   <span class="number">55</span>                      push   %ebp</span><br><span class="line"> <span class="number">804837</span>d:   <span class="number">89</span> e5                   mov    %esp,%ebp</span><br><span class="line"> <span class="number">804837f</span>:   <span class="number">83</span> ec <span class="number">18</span>                sub    $<span class="number">0x18</span>,%esp</span><br><span class="line"> <span class="number">8048382</span>:   <span class="number">83</span> e4 f0                <span class="keyword">and</span>    $<span class="number">0xfffffff0</span>,%esp</span><br><span class="line"> <span class="number">8048385</span>:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line"> <span class="number">804838</span>a:   <span class="number">29</span> c4                   sub    %eax,%esp</span><br></pre></td></tr></table></figure>

<ol>
<li><p>最前面两个指令是main函数的开帧操作</p>
</li>
<li><p>接下来的<code>sub $0x18, %esp</code>分配栈空间，这里分配了较多的空间，包括了局部变量以及调用子函数时参数的空间，而且还有余量。</p>
</li>
<li><p>接下来的<code>and $0xfffffff0,%esp</code>，是将esp 16字节对齐。</p>
</li>
<li><p>接下来的两条指令没有什么实际的影响，不确定是什么目的，估计也是某个编译器行为。</p>
</li>
<li><p><code>movl   $0x0,0xfffffffc(%ebp)</code>将第一个局部变量（即ret）赋值为0。</p>
</li>
</ol>
<p>接下来的就是调用foo函数相关的部分了，此时栈的情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/657c24ad/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A801.png" alt="C语言函数调用01" loading="lazy"></p>
<p>此时的EBP指向main函数栈帧的基址，ESP指向栈顶位置。因为我们的程序非常简单，后面也没有用到调用者保存的寄存器，所以这里省略了保存寄存器的步骤。又因为前面一开始已经分配了参数的栈空间，所以接下来直接对栈中对应位置的形参赋值即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/657c24ad/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A802.png" alt="C语言函数调用02" loading="lazy"></p>
<p>参数的传递是从右往左的顺序，所以先传递第二个参数，ESP+4的位置的值被赋值为2。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/657c24ad/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A803.png" alt="C语言函数调用03" loading="lazy"></p>
<p>接着传递第一个参数，ESP位置的值被赋值为1。参数传递完毕接下来就执行<code>call</code>指令进入子函数foo的范围了。</p>
<p>我们暂且跳过，假设现在foo函数已经返回，来看最后几条指令的操作。现在EAX中存放了返回值。</p>
<ol>
<li><code>mov %eax,0xfffffffc(%ebp)</code>将返回值赋值给局部变量ret</li>
<li>然后main函数返回了，所以要将返回值放到EAX中。（因为我们编译时是用的-O0，所以这一步显得有点多余）</li>
<li>接下来要将参数出栈，这里并没有单独执行这个操作，而是合并到<code>leave</code>指令里了</li>
<li><code>leave</code>指令，相当于<code>mov esp,ebp; pop ebp </code>。直接将关闭当前栈帧，将参数以及局部变量统统清了。从这个例子中我们可以看到，编译器并没有傻瓜式地每次调用函数都执行参数的入栈和出栈操作。事实上，它做了一定的优化，在一开始就分配了充足的栈空间，足够存放局部变量以及后面要调用的子函数的参数，最后在关帧的统一释放栈空间。</li>
<li>如果前面有将调用者保存的寄存器入栈的话，这里要执行相应的出栈操作恢复相应的寄存器的值。在我们这个例子中并没有。</li>
</ol>
<h2 id="被调者部分"><a href="#被调者部分" class="headerlink" title="被调者部分"></a>被调者部分</h2><p>现在我们来看被调者foo函数中的部分，在main函数中执行<code>call</code>指令之后，栈的情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/657c24ad/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A804.png" alt="C语言函数调用04" loading="lazy"></p>
<p>此时，返回地址已经入栈，EBP还是上一个main函数的基址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/657c24ad/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A805.png" alt="C语言函数调用05" loading="lazy"></p>
<p>首先需要创建foo函数的栈帧，将EBP入栈，保存main函数栈帧的基址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/657c24ad/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A806.png" alt="C语言函数调用06" loading="lazy"></p>
<p>紧接着让EBP指向当前ESP的位置，此时EBP变成了foo函数栈帧的基址。后续就可以通过EBP加上一定的偏移来访问形参和局部变量了。<img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/657c24ad/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A807.png" alt="C语言函数调用07" loading="lazy"></p>
<p>接下来一条指令分配局部变量的栈空间，因为有两个int型局部变量，所以这里将esp减了8。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/657c24ad/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A808.png" alt="C语言函数调用08" loading="lazy"></p>
<p>正常情况下，如果foo函数用到了被调者保存的寄存器的话，需要现在这里执行入栈的操作，保存相应寄存器的值。因为我们程序比较简单，所以没有这个过程。</p>
<p>接下来将EBP-4的位置赋值为0x10，对应C代码中的<code>int fa = 0x10;</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/657c24ad/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A809.png" alt="C语言函数调用09" loading="lazy"></p>
<p>同样地，将EBP-8的位置赋值为0x20，对应C代码中的<code>int fb = 0x10;</code></p>
<p>接下来执行将形参a的值赋值给fa，首先将EBP+8位置的形参a赋值到EAX寄存器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/657c24ad/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A810.png" alt="C语言函数调用10" loading="lazy"></p>
<p>然后再将EAX寄存器的值赋值到EBP-4的位置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/657c24ad/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A811.png" alt="C语言函数调用11" loading="lazy"></p>
<p>接下来是形参b的值赋值给fb，执行的操作类似，通过寄存器EAX做了一下中转。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/657c24ad/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A812.png" alt="C语言函数调用12" loading="lazy"></p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/657c24ad/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A813.png" alt="C语言函数调用13" loading="lazy"></p>
<p>接下来执行fa和fb相加的操作，先将EBP-8的值放到EAX中，因为-O0的关系这一步又显得有些多余，然后EBP-4的值加到EAX中，执行完之后EAX就变成了3。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/657c24ad/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A814.png" alt="C语言函数调用14" loading="lazy"></p>
<p>到这里函数体已经执行完毕，但是还有一些善后工作需要做：</p>
<ol>
<li>此时返回值已经在EAX中了。</li>
<li>如果前面有被调者保存的寄存器入栈的话，这里需要执行相应的出栈操作进行恢复。</li>
<li>接下来需要释放局部变量的栈空间，然后恢复上一个栈帧的EBP，将其出栈。这两步合并到了<code>leave</code>指令中。执行完<code>leave</code>之后的栈情况如下。栈顶为返回地址，EBP已经恢复为main函数的基址。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/657c24ad/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A815.png" alt="C语言函数调用15" loading="lazy"></p>
<p>当最后一个<code>ret</code>指令执行之后，返回地址出栈，栈恢复到执行<code>call</code>指令前的情况，程序跳转到返回地址继续执行main函数后续的代码。</p>
<h2 id="x64上的区别"><a href="#x64上的区别" class="headerlink" title="x64上的区别"></a>x64上的区别</h2><p>在x64上，不仅寄存器的位数扩展到了64位，可用的寄存器也更多了。Linux在x64上使用System V AMD64 ABI调用约定，其主要内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%rax     %eax    返回值</span><br><span class="line">%rbx     %ebx    被调用者保存</span><br><span class="line">%rcx     %ecx    第四个参数</span><br><span class="line">%rdx     %edx    第三个参数，<span class="number">128</span>位返回值</span><br><span class="line">%rsi     %esi    第二个参数</span><br><span class="line">%rdi     %edi    第一个参数</span><br><span class="line">%rbp     %ebp    基址指针，被调用者保存</span><br><span class="line">%rsp     %esp    堆栈指针，被调用者保存</span><br><span class="line">%r8      %r8d    第五个参数</span><br><span class="line">%r9      %r9d    第六个参数</span><br><span class="line">%r10     %r10d   调用者保存</span><br><span class="line">%r11     %r11d   调用者保存</span><br><span class="line">%r12     %r12d   被调用者保存</span><br><span class="line">%r13     %r13d   被调用者保存</span><br><span class="line">%r14     %r14d   被调用者保存</span><br><span class="line">%r15     %r15d   被调用者保存</span><br><span class="line">xmm0<span class="number">-7</span>           前<span class="number">8</span>个浮点参数</span><br><span class="line">xmm0<span class="number">-1</span>           浮点返回值</span><br></pre></td></tr></table></figure>

<p>RDI, RSI, RDX, RCX, R8, R9寄存器分别传递前6个整型或指针参数，XMM0-7用于传递前8个浮点参数。如果还有额外的参数，那么还是通过栈进行传递。</p>
<p>不超过64位的返回值通过RAX传递，不超过128位的返回值通过RAX和RDX传递。浮点数返回值使用XMM0和XMM1。</p>
<p>其中RBX、RBP、RSP、R12-R15这几个寄存器是被调用者保存的，其余的都是调用者保存。</p>
<p>另外还有一点值得提一下，对于叶子节点函数，函数的栈指针下方保留了一个128字节的空间（red-zone），编译器可以使用这个区域保存局部变量，这样可以省去开头的一些指令。</p>
<p>我们重新在x64环境下编译前面的示例代码，看看有什么区别</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内核版本 5.4.0-91-generic</span></span><br><span class="line"><span class="comment">// gcc版本 7.5.0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="number">628</span>:   <span class="number">55</span>                      push   %rbp</span><br><span class="line"> <span class="number">629</span>:   <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</span><br><span class="line"> <span class="number">62</span>c:   <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"> <span class="number">630</span>:   c7 <span class="number">45</span> fc <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x0</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">    ret = foo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"> <span class="number">637</span>:   be <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x2</span>,%esi</span><br><span class="line"> <span class="number">63</span>c:   bf <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x1</span>,%edi</span><br><span class="line"> <span class="number">641</span>:   e8 b4 ff ff ff          callq  <span class="number">5f</span>a &lt;foo&gt;</span><br><span class="line"> <span class="number">646</span>:   <span class="number">89</span> <span class="number">45</span> fc                mov    %eax,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"> <span class="number">649</span>:   <span class="number">8b</span> <span class="number">45</span> fc                mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">&#125;</span><br><span class="line"> <span class="number">64</span>c:   c9                      leaveq</span><br><span class="line"> <span class="number">64</span>d:   c3                      retq</span><br><span class="line"> <span class="number">64</span>e:   <span class="number">66</span> <span class="number">90</span>                   xchg   %ax,%ax</span><br></pre></td></tr></table></figure>

<p>可以看到两个参数并没有通过栈传递，而是分别通过edi和esi寄存器传递。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="number">5f</span>a:   <span class="number">55</span>                      push   %rbp</span><br><span class="line"> <span class="number">5f</span>b:   <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</span><br><span class="line"> <span class="number">5f</span>e:   <span class="number">89</span> <span class="number">7</span>d ec                mov    %edi,<span class="number">-0x14</span>(%rbp)</span><br><span class="line"> <span class="number">601</span>:   <span class="number">89</span> <span class="number">75</span> e8                mov    %esi,<span class="number">-0x18</span>(%rbp)</span><br><span class="line">    <span class="keyword">int</span> fa = <span class="number">0x10</span>;</span><br><span class="line"> <span class="number">604</span>:   c7 <span class="number">45</span> f8 <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x10</span>,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">    <span class="keyword">int</span> fb = <span class="number">0x20</span>;</span><br><span class="line"> <span class="number">60b</span>:   c7 <span class="number">45</span> fc <span class="number">20</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x20</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">    fa = a;</span><br><span class="line"> <span class="number">612</span>:   <span class="number">8b</span> <span class="number">45</span> ec                mov    <span class="number">-0x14</span>(%rbp),%eax</span><br><span class="line"> <span class="number">615</span>:   <span class="number">89</span> <span class="number">45</span> f8                mov    %eax,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">    fb = b;</span><br><span class="line"> <span class="number">618</span>:   <span class="number">8b</span> <span class="number">45</span> e8                mov    <span class="number">-0x18</span>(%rbp),%eax</span><br><span class="line"> <span class="number">61b</span>:   <span class="number">89</span> <span class="number">45</span> fc                mov    %eax,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">    <span class="keyword">return</span> fa + fb;</span><br><span class="line"> <span class="number">61</span>e:   <span class="number">8b</span> <span class="number">55</span> f8                mov    <span class="number">-0x8</span>(%rbp),%edx</span><br><span class="line"> <span class="number">621</span>:   <span class="number">8b</span> <span class="number">45</span> fc                mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line"> <span class="number">624</span>:   <span class="number">01</span> d0                   add    %edx,%eax</span><br><span class="line">&#125;</span><br><span class="line"> <span class="number">626</span>:   <span class="number">5</span>d                      pop    %rbp</span><br><span class="line"> <span class="number">627</span>:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>再来看看foo函数的情况，注意到它里面并没有为局部变量分配栈空间，而是直接通过rbp进行赋值了。这是因为foo函数就是我们前面提到的叶子节点函数，它没有再调用其他函数，所以可以直接使用red-zone的空间。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.cs.virginia.edu/~evans/cs216/guides/x86.html">x86汇编指南</a></li>
<li><a href="https://en.wikipedia.org/wiki/Calling_convention">Calling_convention</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions">X86_calling_conventions</a></li>
<li><a href="https://zh.wikipedia.org/wiki/X86%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A">x86调用约定</a></li>
<li><a href="https://www.jianshu.com/p/1782e14a0766">gcc内联汇编基础</a></li>
</ul>
]]></content>
      <categories>
        <category>理解计算机</category>
      </categories>
      <tags>
        <tag>调用约定</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT Tag 插件的使用</title>
    <url>/posts/29bfe8c9/</url>
    <content><![CDATA[<p><code>Tag Plugin</code> 是一种使 Hexo 支持特殊样式内容的方法。例如，我们无法在标准 Markdown 中显示具有自定义尺寸的图像。然后我们可以使用标签插件来解决它。 Hexo 有很多可以帮助用户的标签。 Hexo 还具有主题接口，使主题能够创建自己的标签。</p>
<span id="more"></span>

<h2 id="文本居中引用-Centered-Quote"><a href="#文本居中引用-Centered-Quote" class="headerlink" title="文本居中引用 - Centered Quote"></a>文本居中引用 - Centered Quote</h2><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% cq %&#125;因为我渺小的心灵里，容不下一个谜，一点悬而未决的东西&#123;% endcq %&#125;</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>因为我渺小的心灵里，容不下一个谜，一点悬而未决的东西</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>



<h2 id="提示块-Note"><a href="#提示块-Note" class="headerlink" title="提示块 - Note"></a>提示块 - Note</h2><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<div class="note default">
            <p>default 提示块标签</p>
          </div>

<div class="note primary">
            <p>primary 提示块标签</p>
          </div>

<div class="note success">
            <p>success 提示块标签</p>
          </div>

<div class="note info">
            <p>info 提示块标签</p>
          </div>

<div class="note warning">
            <p>warning 提示块标签</p>
          </div>

<div class="note danger">
            <p>danger 提示块标签</p>
          </div>



<p>可在主题配置文件中修改风格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Note tag (bs-callout)</span><br><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: flat</span><br><span class="line">  icons: true</span><br><span class="line">  # 圆角</span><br><span class="line">  border_radius: 3</span><br><span class="line">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span><br><span class="line">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span><br><span class="line">  light_bg_offset: 0</span><br></pre></td></tr></table></figure>



<h2 id="标签-Label"><a href="#标签-Label" class="headerlink" title="标签 - Label"></a>标签 - Label</h2><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% label default@默认 %&#125; &#123;% label primary@主要 %&#125; &#123;% label info@信息 %&#125; &#123;% label warning@警告 %&#125; &#123;% label danger@危险 %&#125; </span><br><span class="line">&#123;% label success@成功%&#125;</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<span class="label default">默认</span> <span class="label primary">主要</span> <span class="label info">信息</span> <span class="label warning">警告</span> <span class="label danger">危险</span> 
<span class="label success">成功</span>

<h2 id="选项卡-Tabs"><a href="#选项卡-Tabs" class="headerlink" title="选项卡 - Tabs"></a>选项卡 - Tabs</h2><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% tabs tab, 2 %&#125; 名字为tab，默认显示第1个选项卡，如果是-1则隐藏</span><br><span class="line">&lt;!-- tab 魏国--&gt;</span><br><span class="line">**曹操**</span><br><span class="line"></span><br><span class="line">司马懿 郭嘉 荀彧 荀攸 程昱 杨修 </span><br><span class="line"></span><br><span class="line">典韦 许褚 夏侯渊 夏侯惇 曹仁 于禁 张辽 徐晃</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab 蜀国--&gt;</span><br><span class="line">**刘备**</span><br><span class="line"></span><br><span class="line">诸葛亮 庞统 徐庶 姜维 法正 马良</span><br><span class="line"></span><br><span class="line">关羽 张飞 赵云 马超 黄忠 魏延 关兴 张苞</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab 吴国 --&gt;</span><br><span class="line">**孙权**</span><br><span class="line"></span><br><span class="line">周瑜 张昭 鲁肃 诸葛瑾 陆逊</span><br><span class="line"></span><br><span class="line">甘宁 太史慈 吕蒙 韩当 黄盖 程普  </span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab"><a href="#tab-1">魏国</a></li><li class="tab active"><a href="#tab-2">蜀国</a></li><li class="tab"><a href="#tab-3">吴国</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-1"><p><strong>曹操</strong></p>
<p>司马懿 郭嘉 荀彧 荀攸 程昱 杨修 </p>
<p>典韦 许褚 夏侯渊 夏侯惇 曹仁 于禁 张辽 徐晃</p></div><div class="tab-pane active" id="tab-2"><p><strong>刘备</strong></p>
<p>诸葛亮 庞统 徐庶 姜维 法正 马良</p>
<p>关羽 张飞 赵云 马超 黄忠 魏延 关兴 张苞</p></div><div class="tab-pane" id="tab-3"><p><strong>孙权</strong></p>
<p>周瑜 张昭 鲁肃 诸葛瑾 陆逊</p>
<p>甘宁 太史慈 吕蒙 韩当 黄盖 程普  </p></div></div></div>



<p>可在主题配置文件中修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Tabs tag</span><br><span class="line">tabs:</span><br><span class="line">  transition:</span><br><span class="line">    tabs: true</span><br><span class="line">    labels: true</span><br><span class="line">  border_radius: 3</span><br></pre></td></tr></table></figure>

<h2 id="按钮-Button"><a href="#按钮-Button" class="headerlink" title="按钮 - Button"></a>按钮 - Button</h2><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% button url, text, icon [class], [title] %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>url</code>: 本地或外部url</li>
<li><code>text</code>: 显示的文本，文本和图标至少指定一个</li>
<li><code>icon</code>: 显示的图标， FontAwesome 图标名称（开头没有’fa-‘）</li>
<li><code>[class]</code>: FontAwesome 类，可以取如下值<code>fa-fw | fa-lg | fa-2x | fa-3x | fa-4x | fa-5X</code></li>
<li><code>title</code>: 鼠标悬停时的提示信息</li>
</ul>
<p>注意：最好添加 <code>&lt;div&gt;</code> 标签，测试时没加 div，下面显示不完全，加上非常美观。</p>
<p>一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&#123;% button https://catbro666.github.io/ ,首页,home fa-fw,这是我的博客首页%&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<div><a class="btn" href="https://catbro666.github.io/ " title="这是我的博客首页">
            <i class="fa fa-home fa-fw"></i>首页
          </a></div>

<p>多个按钮的时候可以套两层div。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;text-center&quot;&gt;&lt;div&gt;&#123;% button https://catbro666.github.io/ ,首页,home fa-fw,这是我的博客首页%&#125;&#123;% button https://catbro666.github.io/archives ,归档, archive fa-lg&#125;&lt;/div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<div class="text-center"><div><a class="btn" href="https://catbro666.github.io/ " title="这是我的博客首页">
            <i class="fa fa-home fa-fw"></i>首页
          </a><a class="btn" href="https://catbro666.github.io/archives ">
            <i class="fa fa-archive fa-lg}</div></div>"></i>归档
          </a>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux TC 流量控制介绍</title>
    <url>/posts/357ad3ec/</url>
    <content><![CDATA[<div class="note primary">
            <p>前段时间在做一些测试的时候接触到了Linux tc，因为需要对数据包添加延迟，用到了tc中的netem。添加简单的延迟非常简单，像这样一条命令就搞定了：<code>$ tc qdisc add dev eth0 root netem delay 1s</code>，你甚至不需要完全理解命令中参数的含义。但是当你想做一些更加特殊的限制的时候，（比如只对某个特定的ip端口添加延迟、或者只对入站的流量添加延迟），事情就变得有些棘手了，简单的百度貌似已经满足不了要求了。你不得不了解TC中的一些基本概念，以及tc[2]命令中相关参数的含义。</p><p>本文正是带你了解这些TC中的基本概念，并通过一个实际例子，将这些概念与tc命令联系起来。</p>
          </div>

<span id="more"></span>



<h2 id="示例命令"><a href="#示例命令" class="headerlink" title="示例命令"></a>示例命令</h2><p>考虑到这是一个科普向的介绍，这里只举了一个最简单的例子，但是基本上包含了重要的概念。本文的期望是，让读者在阅读后可以完全理解下面的例子，并且知道如何根据自身的需求编写自己的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tc qdisc add dev eth0 root handle 1: prio bands 4</span><br><span class="line">sudo tc qdisc add dev eth0 parent 1:4 handle 40: netem loss 10% delay 40ms</span><br><span class="line">sudo tc filter add dev eth0 protocol ip parent 1:0 prio 4 u32 match ip dst 192.168.190.7 match ip dport 36000 0xffff flowid 1:4</span><br></pre></td></tr></table></figure>



<h2 id="TC基本概念"><a href="#TC基本概念" class="headerlink" title="TC基本概念"></a>TC基本概念</h2><h3 id="QDISCS"><a href="#QDISCS" class="headerlink" title="QDISCS"></a>QDISCS</h3><p>全称是queueing discipline，我们姑且称其为排队规则吧。它是协议栈和网络接口之间的一个缓冲层。你可以在qdisc上对数据包做一些你想做的操作，比如分类、整形、调度等。</p>
<p>qdisc分为无类（classless）qdisc和有类（classful）qdisc。无类qdisc不再内部细分类，有类qdisc可进一步包含多个分类，每个class上可以进一步包含子qdisc，子qdisc也可以是有类qdisc，这样就形成了树状的分层结构。</p>
<h3 id="CLASSES"><a href="#CLASSES" class="headerlink" title="CLASSES"></a>CLASSES</h3><p>有类qdisc可以有多个子类（class），有些qdisc预定义了子类（如prio），有些则需要用户添加类。一个类上又可以附加其他类。最末端没有子类的类称为叶子类，它上面附加了一个qdisc。当创建一个class的时候，默认会附加一个fifo qdisc，它只是一个简单的队列，不对数据包进行任何的操作。当在这个类上增加子类的时候，这个默认的qdisc被移除。你可以将这个默认的fifo qdisc替换成其他任意你想用的qdisc。</p>
<h3 id="FILTERS"><a href="#FILTERS" class="headerlink" title="FILTERS"></a>FILTERS</h3><p>过滤器，用于有类qdisc中，决定将包入队到哪个类中。每当一个包到达有子类的类时，就需要进行分类。其中一种分类的方法就是使用过滤器（另外两个是ToS和skb-&gt;priority）。所有附加到类上的过滤器会被依次调用，直到其中一个返回裁决。一个filter包含了一些条件，当一个包到达该节点时，会根据包的特征判断是否匹配。</p>
<p>以上3个是TC中最基本的3个概念，任何复杂的流量控制都是通过这个三元组递归实现的。</p>
<h2 id="层级结构"><a href="#层级结构" class="headerlink" title="层级结构"></a>层级结构</h2><p>每个接口有一个egress ‘root qdisc’，默认是pfifo_fast。每个qdisc和class都分配一个句柄handle，句柄用于在后续的配置语句中进行引用。除了egress qdisc，一个接口也可以有一个ingress qdisc，负责管制入站的流量。但是ingress qdisc相比classful qdisc其可能性是非常有限。（所以才有所谓的控发不控收，对入站流量进行控制通常需要借助ifb[6]或者imq）。</p>
<p>这些qdisc的handles有两个部分组成，一个major数和一个minor数：<code>&lt;major&gt;:&lt;minor&gt;</code>。习惯上将root qdisc命名为<code>1:</code>，等价于<code>1:0</code>。一个qdisc的minor数总是0。</p>
<p>子类需要跟它们的parent有相同的major数。major数在一个egress或ingress内必须是唯一的，minor数在一个qdisc和它的class中必须是唯一的。</p>
<p>一个典型的层级结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">          1:   root qdisc</span><br><span class="line">           |</span><br><span class="line">          1:1    child class</span><br><span class="line">        /  |  \</span><br><span class="line">       /   |   \</span><br><span class="line">      /    |    \</span><br><span class="line">      /    |    \</span><br><span class="line">   1:10  1:11  1:12   child classes</span><br><span class="line">    |      |     | </span><br><span class="line">    |     11:    |    leaf class</span><br><span class="line">    |            | </span><br><span class="line">    10:         12:   qdisc</span><br><span class="line">   /   \       /   \</span><br><span class="line">10:1  10:2   12:1  12:2   leaf classes</span><br></pre></td></tr></table></figure>



<p>内核只跟root qdisc进行通信，每当包需要入队或者出队的时候，都需要从root节点开始，最终到达叶子节点，从而决定入队到哪里，或者从哪里出队。</p>
<p>比如当一个包入队时，它可能会经过如下路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1: -&gt; 1:1 -&gt; 1:12 -&gt; 12: -&gt; 12:2</span><br></pre></td></tr></table></figure>

<p>当然也可能直接走如下路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1: -&gt; 12:2</span><br></pre></td></tr></table></figure>

<p>这种情况，就是root qdisc上的过滤器决定把包直接送到<code>12:2</code>。</p>
<span class="label warning">注意：</span>入队和出队时虽然节点的拓扑图是一样的，但是每个节点表示的含义却有所不同[4]。入队时是根据过滤器和包的特征决定走哪条路径，而出队时则取决于qdisc本身的调度算法，比如FIFO、优先级队列、SFQ的顺序调度等。



<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>前面已经提到了过滤器用于将包分类到子类，那么具体是如何对包进行分类的呢？tc支持很多类型的分类器，它们根据数据包相关的不同信息来作出决策。其中最常用的就是<strong>u32分类器</strong>，它根据数据包中的字段做出决策（例如源IP地址等）。还有比如<strong>fw分类器</strong>，根据防火墙如何标记数据包来做出决策，你可以使用iptables标记目标数据包，然后通过fw分类器进行过滤。另外还有诸如<strong>route分类器</strong>、<strong>cgroup分类器</strong>、<strong>bpf分类器</strong>等，篇幅原因不再赘述。下面仅介绍最常见的u32分类器。</p>
<h3 id="公共参数"><a href="#公共参数" class="headerlink" title="公共参数"></a>公共参数</h3><p>分类器一般接收以下几个公共的参数：</p>
<ul>
<li><p>protocol</p>
<p>分类器接受的协议，通常你只接受IP流量。必须。</p>
</li>
<li><p>parent</p>
<p>分类器附加到哪个handle上。这个handle必须是一个已经存在的类。必须。</p>
</li>
<li><p>prio|perf</p>
<p>分类器的优先级。<strong>数字越小</strong>的越先进行匹配尝试。</p>
</li>
<li><p>handle</p>
<p>这个handle对于不同的过滤器表示不同的含义。</p>
</li>
</ul>
<h3 id="u32分类器-3"><a href="#u32分类器-3" class="headerlink" title="u32分类器[3]"></a>u32分类器[3]</h3><p>u32过滤器最简单的格式是设置一组选择器对包进行匹配，匹配的包分到特定的子类中，或者执行一个action。u32分类器提供了多种不同的选择器，可以大致分成特殊选择器和通用选择器两类。</p>
<h3 id="特殊选择器"><a href="#特殊选择器" class="headerlink" title="特殊选择器"></a>特殊选择器</h3><p>常用的有ip选择器和tcp选择器。特殊选择器简化了一些常用字段的设置，可以匹配包头中的各种字段，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tc filter add dev eth0 protocol ip parent 1:0 prio 10 u32 \</span><br><span class="line">	match ip src 192.168.8.0/24 flowid 1:4</span><br></pre></td></tr></table></figure>

<p>上例匹配ip源地址在192.168.8.0/24子网的包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tc filter add dev eth0 protocol ip parent 1:0 prio 10 u32 \</span><br><span class="line">        match ip protocol 0x6 0xff \</span><br><span class="line">        match tcp dport 53 0xffff \</span><br><span class="line">        flowid 1:2</span><br></pre></td></tr></table></figure>

<p>上例匹配TCP协议（0x6）、且目的端口为53的包。</p>
<h3 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h3><p>特殊选择器总是可以改写成对应的通用选择器，通用选择器可以匹配 IP（或上层）头中的几乎任何位，不过相比特殊选择器较难编写和阅读。其语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match [ u32 | u16 | u8 ] PATTERN MASK at [OFFSET | nexthdr+OFFSET]</span><br></pre></td></tr></table></figure>

<p>其中u32|u16|u8指定pattern的长度，分别为4个字节、2个字节、1个字节。PATTERN表示匹配的包的pattern，MASK告诉过滤器匹配哪些位，at表示从包的指定偏移处开始匹配。</p>
<p>来看一个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tc filter add dev eth0 protocol ip parent 1:0 pref 10 u32 \</span><br><span class="line">	match u32 00100000 00ff0000 at 0 flowid 1:10</span><br></pre></td></tr></table></figure>

<p>选择器会匹配IP头第二个字节为0x10的包，<code>at 0</code>表示从头开始匹配，mask为<code>00ff0000</code>所以只匹配第二个字节，pattern为<code>00100000</code>即第二个字节为0x10。</p>
<p>再来看另一个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tc filter add dev eth0 protocol ip parent 1:0 pref 10 u32 \</span><br><span class="line">	match u32 00000016 0000ffff at nexthdr+0 flowid 1:10</span><br></pre></td></tr></table></figure>

<p><code>nexthdr</code>选项表示封装在IP包里的下一个头，即上层协议的头。<code>at nexthdr+0</code>表示从下一个头第一个字节开始匹配。因为mask为<code>0000ffff</code>，所以匹配发生在头的第三和第四个字节。在TCP和UDP协议中这两个字节是包的目的端口。数字是由大段格式给出的，所以pattern <code>00000016</code>转换成十进制是22。即该选择器会匹配目的端口为22的包。</p>
<h2 id="示例解析"><a href="#示例解析" class="headerlink" title="示例解析"></a>示例解析</h2><p>好了，现在我们可以回过头来看最初的那个示例了，看看这些命令到底是什么意思。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tc qdisc add dev eth0 root handle 1: prio bands 4</span><br><span class="line">sudo tc qdisc add dev eth0 parent 1:4 handle 40: netem loss 10% delay 40ms</span><br><span class="line">sudo tc filter add dev eth0 protocol ip parent 1:0 prio 4 u32 match ip dst 192.168.190.7 match ip dport 36000 0xffff flowid 1:4</span><br></pre></td></tr></table></figure>

<p>我们一行行来看，第一行在设备eth0上添加了一个root qdisc，句柄为1:，qdisc类型为prio，bands数为4。</p>
<p>prio是一个有类的qdisc。它的作用跟默认的qdisc pfifo_fast类似。pfifo_fast有三个所谓的band，不同band的流量具有不同的优先级。每个band内，则应用FIFO规则。</p>
<p>prio qdisc，默认会创建3个子类，包含纯FIFO qdisc，默认根据ToS位进行分类。你可以使用过滤器来对流量进行分类，你也可以在子类上附加其他qdisc替换默认的FIFO。</p>
<p>接下来看第二个命令，<code>parent 1:4</code>表示在子类1:4上，<code>handle 40:</code>表示句柄为40:，<code>netem</code>表示添加一个netem qdisc，<code>loss 10% delay 40ms</code>则是netem的参数，表示丢包10%、延迟40ms。netem[5]是一个用于提供网络仿真功能的无类qdisc，可以模拟延迟、丢包、包重复、包失序等各种情况。</p>
<p>第三个命令则是添加了一个过滤器，<code>parent 1:0</code>表示在根节点上添加该过滤器，<code>prio 4</code>是过滤器的优先级，如果有很多过滤器会根据优先级的值按顺序进行尝试。<code>u32</code>表示使用u32分类器。<code>match ip dst 192.168.190.7</code>表示匹配ip地址为192.168.190.7的包，<code>match ip dport 36000 0xffff</code>表示匹配目的端口为36000的包，多个选择器之间是“与”的关系，<code>flowid 1:4</code>表示将匹配的包分类到<code>1:4</code>子类中。</p>
<p>所以最终的效果是，发往192.168.190.7且目的端口为36000的包，会分类到1:4子类，添加40ms的延迟，且有10%的丢包率。其他包则还是默认的行为，即根据ToS字段分类到1:1、1:2或1:3子类中，然后根据优先级依次发送。</p>
<p>画出该例子的分层结构图，大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">          1:     root qdisc (prio)</span><br><span class="line">         / | \ \</span><br><span class="line">       /   |  \  \</span><br><span class="line">       /   |   \   \</span><br><span class="line">     1:1  1:2  1:3  1:4      classes</span><br><span class="line">      |    |    |    |</span><br><span class="line">                     40:     qdiscs</span><br><span class="line">   pfifo pfifo pfifo netem</span><br><span class="line">band  0    1    2    3</span><br></pre></td></tr></table></figure>



<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本文只介绍了tc的基本概念和简单用法。prio qdisc只对包做了一个分类，并没有进行整形。实际上，你也可以使用更复杂的带整形的qdisc，比如CBQ、HTB等，也可以增加更多的层级。你还可以在叶子节点上添加SFQ qdisc以实现会话级的带宽公平性。相信理解了TC的这些基本概念，再根据自身需求使用其他qdisc也不是什么难事了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><p><a href="https://lartc.org/howto/">lartc</a></p>
</li>
<li><p><a href="https://man7.org/linux/man-pages/man8/tc.8.html">tc(8)</a></p>
</li>
<li><p><a href="https://man7.org/linux/man-pages/man8/tc-u32.8.html">tc-u32(8)</a></p>
</li>
<li><p><a href="https://blog.csdn.net/dog250/article/details/40681809">数据包的分类和调度</a></p>
</li>
<li><p><a href="https://wiki.linuxfoundation.org/networking/netem">netem</a></p>
</li>
<li><p><a href="https://wiki.linuxfoundation.org/networking/ifb">ifb</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>TC</tag>
        <tag>流量控制</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua中如何实现类似gdb的断点调试--01最小实现</title>
    <url>/posts/f9a188a7/</url>
    <content><![CDATA[<div class="note primary">
            <p>说到Lua代码调试，最常用的方法应该就是加一堆print进行打印。print大法虽好，但其缺点也是显而易见的。比如效率低下，需要修改原有函数内部代码，在每个需要的地方添加print语句，运行一次只能获取一次信息，下次换个地方又得重新添加print语句。而且有时候，事先并不知道该去哪打印、或者打印什么内容，需要通过运行中获取的信息才能确定。</p><p>当print大法无法满足我们的需求时，就需要类似断点调试这样更高级的调试功能。本文将从零开始编写一个Lua调试器，实现类似gdb的断点调试功能。</p><p>本文代码已开源至<a href="https://github.com/catbro666/lua-debugger">Github</a>，欢迎watch/star😘。</p>
          </div>

<span id="more"></span>



<h2 id="定义模块及接口"><a href="#定义模块及接口" class="headerlink" title="定义模块及接口"></a>定义模块及接口</h2><p>首先，我们来定义模块及接口，创建一个名为<code>luadebug.lua</code>的模块，该模块是基于标准库中的debug库。为了实现最基本的断点调试功能，我们的模块提供了两个接口<code>setbreakpoint</code>和<code>removebreakpoint</code>，分别用于设置断点和删除断点。断点信息通过一个函数和一个行号指定，返回断点的id。后续可以通过这个id来删除相应断点。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env lua</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">debug</span> = <span class="built_in">require</span> <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 省略...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setbreakpoint</span><span class="params">(func, line)</span></span></span><br><span class="line">    <span class="comment">-- 省略...</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">removebreakpoint</span><span class="params">(id)</span></span></span><br><span class="line">    <span class="comment">-- 省略...</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    setbreakpoint = setbreakpoint,</span><br><span class="line">    removebreakpoint = removebreakpoint,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="维护状态的数据结构"><a href="#维护状态的数据结构" class="headerlink" title="维护状态的数据结构"></a>维护状态的数据结构</h2><p>接着，来定义维护状态的数据结构，表<code>status</code>维护了所有断点相关信息，其中的<code>bpnum</code>元素表示当前总共有多少断点，<code>bpid</code>表示当前的断点id，这个值是不断递增的，<code>bptable</code>则是保存所有断点信息的表。表<code>bptable</code>的键是断点的id，值也是一个表，保存了断点的所在的函数和行号。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 省略...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 记录断点状态</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">status</span> = &#123;&#125;</span><br><span class="line"><span class="built_in">status</span>.bpnum = <span class="number">0</span>        <span class="comment">-- 当前总断点数</span></span><br><span class="line"><span class="built_in">status</span>.bpid = <span class="number">0</span>         <span class="comment">-- 当前断点id</span></span><br><span class="line"><span class="built_in">status</span>.bptable = &#123;&#125;     <span class="comment">-- 保存断点信息的表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 省略...</span></span><br></pre></td></tr></table></figure>



<h2 id="设置断点接口"><a href="#设置断点接口" class="headerlink" title="设置断点接口"></a>设置断点接口</h2><p>接下来来定义我们的<code>setbreakpoint</code>接口。设置断点时，首先检查参数有效性，再更新断点id和断点数，然后将参数中传入的函数<code>func</code>和行号<code>line</code>保存到表<code>bptable</code>中下一个断点id的位置。如果只有一个断点（从无到有），那么还需要调用<code>debug.sethook</code>设置钩子。这是实现断点调试的核心函数之一，它使得我们有机会停在断点处。因为是最小实现，简单起见这里只设置了<code>line</code>事件。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置断点</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setbreakpoint</span><span class="params">(func, line)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(func) ~= <span class="string">&quot;function&quot;</span> <span class="keyword">or</span> <span class="built_in">type</span>(line) ~= <span class="string">&quot;number&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>                      <span class="comment">--&gt; nil表示无效断点</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">status</span>.bpid = <span class="built_in">status</span>.bpid + <span class="number">1</span></span><br><span class="line">    <span class="built_in">status</span>.bpnum = <span class="built_in">status</span>.bpnum + <span class="number">1</span></span><br><span class="line">    <span class="built_in">status</span>.bptable[<span class="built_in">status</span>.bpid] = &#123;func = func, line = line&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">status</span>.bpnum == <span class="number">1</span> <span class="keyword">then</span>           <span class="comment">-- 第一个断点</span></span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">sethook</span>(linehook, <span class="string">&quot;l&quot;</span>)    <span class="comment">-- 设置钩子</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">status</span>.bpid                  <span class="comment">--&gt; 返回断点id</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>在钩子函数中，通过<code>debug.getinfo</code>获取到闭包信息，注意这里的层次为2，因为<code>debug.getinfo()</code>函数本身的层次是0，钩子函数层次是1，断点所在的函数层次即为2。然后遍历断点表，与获取的闭包信息进行比较，如果函数和行号都匹配，说明命中断点。我们打印一行提示信息，然后调用<code>debug.debug()</code>进入交互调试模式，<code>debug.debug</code>是实现断点调试的另一个核心函数，它使得我们可以在断点处输入任意代码执行。交互调试模式一直持续，直到用户输入<code>cont</code>为止。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 钩子函数</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">linehook</span> <span class="params">(event, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> info = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>, <span class="string">&quot;nfS&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">status</span>.bptable) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> v.func == info.func <span class="keyword">and</span> v.line == line <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> prompt = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;(%s)%s %s:%d\n&quot;</span>,</span><br><span class="line">                info.namewhat, info.name, info.short_src, line)</span><br><span class="line">            <span class="built_in">io</span>.<span class="built_in">write</span>(prompt)</span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">debug</span>()</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="删除断点接口"><a href="#删除断点接口" class="headerlink" title="删除断点接口"></a>删除断点接口</h2><p>删除断点比较简单，首先检查id参数是否有效，如果无效直接返回，如果有效则将断点表中相应id位置的值置为nil即可，然后更新断点数，如果已经没有断点了，则清除钩子。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除断点</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">removebreakpoint</span><span class="params">(id)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">status</span>.bptable[id] == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">status</span>.bptable[id] = <span class="literal">nil</span></span><br><span class="line">    <span class="built_in">status</span>.bpnum = <span class="built_in">status</span>.bpnum - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">status</span>.bpnum == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">sethook</span>()                 <span class="comment">-- 清除钩子</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>至此我们的模块就编写好了，下面对这个模块进行测试。</p>
<h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><p>我们编写一个如下的测试脚本<code>test.lua</code>，定义了两个函数foo和bar，然后分别在两个函数中设置了一个断点（注意：注释和空行不是有效的断点行），然后多次调用函数并先后删除断点：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line"></span><br><span class="line">g = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> u = <span class="number">2</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">3</span></span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line">    u = u + <span class="number">1</span></span><br><span class="line">    g = g + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span> <span class="params">(n)</span></span></span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(foo, <span class="number">11</span>)      <span class="comment">-- 设置断点1</span></span><br><span class="line"><span class="keyword">local</span> id2 = setbp(bar, <span class="number">16</span>)      <span class="comment">-- 设置断点2</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">10</span>)</span><br><span class="line">bar(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">rmbp(id1)                       <span class="comment">-- 删除断点1</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">20</span>)</span><br><span class="line">bar(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">rmbp(id2)                       <span class="comment">-- 删除断点2</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">30</span>)</span><br><span class="line">bar(<span class="number">30</span>)</span><br></pre></td></tr></table></figure>



<h2 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h2><p>然后我们运行测试脚本，可以看到程序停在了foo函数的断点1处。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua test.lua</span><br><span class="line">(<span class="built_in">local</span>)foo test.lua:11</span><br><span class="line">lua_debug&gt; </span><br></pre></td></tr></table></figure>

<p>我们可以在这里打印调用栈信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua test.lua</span><br><span class="line">(<span class="built_in">local</span>)foo test.lua:11</span><br><span class="line">lua_debug&gt; <span class="built_in">print</span>(debug.traceback())</span><br><span class="line">stack traceback:</span><br><span class="line">	(debug <span class="built_in">command</span>):1: <span class="keyword">in</span> main chunk</span><br><span class="line">	[C]: <span class="keyword">in</span> <span class="keyword">function</span> <span class="string">&#x27;debug.debug&#x27;</span></span><br><span class="line">	./luadebug.lua:20: <span class="keyword">in</span> hook <span class="string">&#x27;?&#x27;</span></span><br><span class="line">	test.lua:11: <span class="keyword">in</span> <span class="built_in">local</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">	test.lua:22: <span class="keyword">in</span> main chunk</span><br><span class="line">	[C]: <span class="keyword">in</span> ?</span><br><span class="line">lua_debug&gt; </span><br></pre></td></tr></table></figure>

<p>可以看到foo函数在第4层（第1层是执行我们调试命令的main chunk，第2层是<code>debug.debug</code>函数，第3层是hook函数）。我们打印foo函数中第一个局部变量（即固定参数n）的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; <span class="built_in">print</span>(debug.getlocal(4, 1))</span><br><span class="line">n	10</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>然后打印第二个局部变量（即a）的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; <span class="built_in">print</span>(debug.getlocal(4, 2))</span><br><span class="line">a	4</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>然后我们输入<code>cont</code>继续代码的执行，碰到了bar函数的断点2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">(<span class="built_in">local</span>)bar test.lua:16</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>我们打印bar函数的参数n的值，可以看到也是10</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; <span class="built_in">print</span>(debug.getlocal(4, 1))</span><br><span class="line">n	10</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>然后我们输入<code>cont</code>继续执行代码，因为断点1已经被移除，所以再次停在了bar函数的断点2处</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">(<span class="built_in">local</span>)bar test.lua:16</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>我们再来打印下参数n的值，此时参数n的值是20</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; <span class="built_in">print</span>(debug.getlocal(4, 1))</span><br><span class="line">n	20</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>我们再次输入<code>cont</code>，因为断点2也被移除了，所以第三次调用<code>foo</code>函数和<code>bar</code>函数就没有再碰到断点，程序运行结束</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>这样一个最简单的Lua断点调试器就完成了。虽然还比较简陋，但是已经能够应付一些简单的调试了。🎉</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua中如何实现类似gdb的断点调试--02通用变量打印</title>
    <url>/posts/f6e9079c/</url>
    <content><![CDATA[<div class="note primary">
            <p>在前一篇<a href="../f9a188a7/">01最小实现</a>中，我们实现了Lua断点调试的的一个最小实现。我们编写了一个模块，提供了两个基本的接口：设置断点和删除断点。</p><p>虽然我们已经支持在断点进行变量的打印，但是需要自己指定层数以及变量索引，使用起来不是很方便。要进行upvalue打印的话，操作会更加麻烦。为了提升调试的方便性，我们决定封装一个通用的变量打印函数，可以通过变量名查找到对应变量的值进行打印。支持局部变量、upvalue以及全局的<code>_ENV</code>中的变量。</p><span id="more"></span><p>本文代码已开源至<a href="https://github.com/catbro666/lua-debugger">Github</a>，欢迎watch/star😘。</p>
          </div>

<h2 id="局部变量中查找"><a href="#局部变量中查找" class="headerlink" title="局部变量中查找"></a>局部变量中查找</h2><p>因为函数比较长，我们分几部分进行说明，该函数有三个参数：<code>name</code>为要查找的变量的名字，<code>level</code>指示在哪个层级的函数中查找，<code>isenv</code>是个标记我们稍后再提。层级的默认值为1， <span class="label warning">注意</span>将层级加上1，是为了将层次修正为包含<code>_getvavalue</code>函数自己。</p>
<p>然后遍历局部变量表，比较变量名字是不是等于<code>name</code>，如果匹配的话记录其值，并且标记一下我们已经找到。<span class="label warning">注意</span>我们找到之后并没有立马跳出循环，因为可能具有多个同名的局部变量，我们应该获取索引最大的那个。</p>
<p>循环结束之后，如果已经在局部变量中找到了<code>name</code>，就返回<code>&quot;local&quot;</code>和变量的值。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">_getvarvalue</span> <span class="params">(name, level, isenv)</span></span></span><br><span class="line">    <span class="keyword">local</span> value</span><br><span class="line">    <span class="keyword">local</span> found = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 加1将层次纠正为包括_getvarvalue自己</span></span><br><span class="line">    level = (level <span class="keyword">or</span> <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">    <span class="comment">-- 尝试局部变量</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> n, v = <span class="built_in">debug</span>.<span class="built_in">getlocal</span>(level, i)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> n == name <span class="keyword">then</span></span><br><span class="line">            value = v</span><br><span class="line">            found = <span class="literal">true</span></span><br><span class="line">            <span class="comment">-- 这里不跳出，获取具有最大索引的那个局部变量</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> found <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">&quot;local&quot;</span>, value <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="上值中查找"><a href="#上值中查找" class="headerlink" title="上值中查找"></a>上值中查找</h2><p>如果在局部变量中没有找到，我们再尝试到upvalue中进行查找。首先通过<code>getbug.getinfo</code>获取到第level层的函数，然后遍历其上值，如果找到匹配的变量就返回<code>&quot;upvalue&quot;</code>和变量值。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">_getvarvalue</span> <span class="params">(name, level, isenv)</span></span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 尝试非局部变量</span></span><br><span class="line">    <span class="keyword">local</span> func = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(level, <span class="string">&quot;f&quot;</span>).func</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> n, v = <span class="built_in">debug</span>.<span class="built_in">getupvalue</span>(func, i)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> n == name <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">&quot;upvalue&quot;</span>, v <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="ENV表中查找"><a href="#ENV表中查找" class="headerlink" title="_ENV表中查找"></a>_ENV表中查找</h2><p>如果在普通的上值中还是没有找到，我们就去<code>_ENV</code>表中查找。<code>isenv</code>标志表示当前<code>name</code>是否就是<code>&quot;_ENV&quot;</code>，是用来防止无限循环调用的，第一次调用的时候肯定不是。然后将<code>&quot;_ENV&quot;</code>作为<code>name</code>递归调用<code>_getvarvalue</code>。因为多了一次函数调用，第二次调用的时候level又会自动加1。接下来还是先后在局部变量和上值中查找，找到了就返回类型和变量值。没有找到的话，返回<code>&quot;noenv&quot;</code>。</p>
<p>然后返回到外层的<code>_getvarvalue</code>，判断第二个返回值是否为真，如果是说明找到了<code>_ENV</code>表，就从<code>_ENV</code>表中获取名为name的值，否则直接返回<code>&quot;noenv&quot;</code>。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">_getvarvalue</span> <span class="params">(name, level, isenv)</span></span></span><br><span class="line">	<span class="comment">-- 省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> isenv <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">&quot;noenv&quot;</span> <span class="keyword">end</span>	<span class="comment">-- 避免无限循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 没找到，从环境中获取</span></span><br><span class="line">    <span class="keyword">local</span> _, env = _getvarvalue(<span class="string">&quot;_ENV&quot;</span>, level, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> env <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;global&quot;</span>, env[name]</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;noenv&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="包装函数"><a href="#包装函数" class="headerlink" title="包装函数"></a>包装函数</h2><p><code>_getvarvalue</code>函数已经定义好了，我们再定义一个包装函数<code>printvarvalue</code>。如果第二个返回值为真，表示找到了变量，就打印变量类型及结果，否则提示未找到。</p>
<span class="label warning">注意到</span>我们这里将`level`层次数加了4，目的是跟`_getvarvalue`函数中类似，也是为了修正层次数以包含`printvarvalue`函数自身以及其上层的`debug mainchunk`、`debug.debug`以及钩子函数。这样当`level`参数为1时就表示断点所在的函数。同样地，如果level不指定默认为1，即断点所在函数。2表示断点所在函数上一层，以此类推。当然如果你有特殊需求，你也可以指定层次为0，查看hook函数的情况。

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 包装 _getvarvalue, 打印结果</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">printvarvalue</span> <span class="params">(name, level)</span></span></span><br><span class="line">    <span class="comment">-- level默认值1</span></span><br><span class="line">    <span class="comment">-- 加4，将层次纠正为包含 printvarvalue, debug mainchunk, debug.debug和hook</span></span><br><span class="line">    level = (level <span class="keyword">or</span> <span class="number">1</span>) + <span class="number">4</span></span><br><span class="line">    <span class="keyword">local</span> where, value = _getvarvalue(name, level)</span><br><span class="line">    <span class="keyword">if</span> value <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(where, value)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(name, <span class="string">&quot;not found&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>最后将<code>printvarvalue</code>函数作为模块的函数输出。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    setbreakpoint = setbreakpoint,</span><br><span class="line">    removebreakpoint = removebreakpoint,</span><br><span class="line">    printvarvalue = printvarvalue,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><p>OK，调试库我们已经改好了，接下来将我们之前的测试脚本<code>test.lua</code>稍做修改。在开头添加如下一行：</p>
<p><code>pv = luadebug.printvarvalue</code></p>
<p>为了方便在断点内部调用，我们将其写到全局变量里了。然后调整下断点的行号，换一下断点删除的顺序，其他内容保持不变。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> luadebug = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = luadebug.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = luadebug.removebreakpoint</span><br><span class="line">pv = luadebug.printvarvalue		<span class="comment">-- 增加这一行</span></span><br><span class="line"></span><br><span class="line">g = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> u = <span class="number">2</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">3</span></span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line">    u = u + <span class="number">1</span></span><br><span class="line">    g = g + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span> <span class="params">(n)</span></span></span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(foo, <span class="number">12</span>)		<span class="comment">-- 行号调整</span></span><br><span class="line"><span class="keyword">local</span> id2 = setbp(bar, <span class="number">17</span>)		<span class="comment">-- 行号调整</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">10</span>)</span><br><span class="line">bar(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">rmbp(id2)						<span class="comment">-- 先删除断点2</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">20</span>)</span><br><span class="line">bar(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">rmbp(id1)						<span class="comment">-- 再删除断点1</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">30</span>)</span><br><span class="line">bar(<span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<h2 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h2><p>接下来，让我们来测试一把。可以看到无论是局部变量、upvalue、还是全局<code>_ENV</code>表中的变量，都可以很方便地获取值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua test.lua</span><br><span class="line">(<span class="built_in">local</span>)foo test.lua:12</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="built_in">local</span>	4</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;u&quot;</span>)</span><br><span class="line">upvalue	2</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">global	1</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">x	not found</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>第二次停到foo函数断点处，<code>u</code>和<code>g</code>都已经加1。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">(<span class="built_in">local</span>)bar test.lua:17</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">(<span class="built_in">local</span>)foo test.lua:12</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="built_in">local</span>	4</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;u&quot;</span>)</span><br><span class="line">upvalue	3</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">global	2</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>我们尝试显式指定层数，结果一样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; pv(<span class="string">&quot;a&quot;</span>, 1)</span><br><span class="line"><span class="built_in">local</span>	4</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;u&quot;</span>, 1)</span><br><span class="line">upvalue	3</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;g&quot;</span>, 1)</span><br><span class="line">global	2</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>我们再尝试打印上一层的变量（即main chunk），结果都符合预期。变量a是foo里的局部变量应该找不到，变量u在main chunk中是局部变量，全局变量g则没啥区别。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; pv(<span class="string">&quot;a&quot;</span>, 2)</span><br><span class="line">a	not found</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;u&quot;</span>, 2)</span><br><span class="line"><span class="built_in">local</span>	3</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;g&quot;</span>, 2)</span><br><span class="line">global	2</span><br></pre></td></tr></table></figure>

<p>OK，大功告成！</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua中如何实现类似gdb的断点调试--03通用变量修改及调用栈回溯</title>
    <url>/posts/a05a2f5f/</url>
    <content><![CDATA[<div class="note primary">
            <p>在前面两篇<a href="../f9a188a7/">01最小实现</a>及<a href="../f6e9079c">02通用变量打印</a>中，我们已经实现了设置断点、删除断点及通用变量打印接口。</p><p>本篇将继续新增两个辅助的调试接口：调用栈回溯打印接口、通用变量设置接口。前者打印调用栈的回溯信息，后者可以方便地修改变量的值，支持局部变量、upvalue以及全局的<code>_ENV</code>中的变量。</p><span id="more"></span><p>本文代码已开源至<a href="https://github.com/catbro666/lua-debugger">Github</a>，欢迎watch/star😘。</p>
          </div>

<h2 id="调用栈打印函数"><a href="#调用栈打印函数" class="headerlink" title="调用栈打印函数"></a>调用栈打印函数</h2><p>我们首先来实现调用栈回溯打印接口<code>printtraceback()</code>，这个接口比较简单，只是简单地包装了一下<code>debug.traceback()</code>，对层级进行了一个修正，就不多介绍了。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 打印调用栈的一个回溯</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">printtraceback</span><span class="params">(level)</span></span></span><br><span class="line">    <span class="comment">-- 层次的默认值为1</span></span><br><span class="line">    <span class="comment">-- 加上4是为了修正层次数以包含printtraceback, debug mainchunk, debug.debug, hook</span></span><br><span class="line">    level = (level <span class="keyword">or</span> <span class="number">1</span>) + <span class="number">4</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">debug</span>.<span class="built_in">traceback</span>(<span class="literal">nil</span>, level))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="通用变量值修改函数"><a href="#通用变量值修改函数" class="headerlink" title="通用变量值修改函数"></a>通用变量值修改函数</h2><p>接着来实现通用的变量值修改函数<code>_setvarvalue()</code>，这个函数的结构跟<code>_getvarvalue()</code>类似，依次在局部变量、上值和<code>_ENV</code>表中查找，只不过找到之后会修改相应的值。函数有三个参数，<code>name</code>为要修改的变量的名字，<code>value</code>是修改的目标值，<code>level</code>指示在哪个层级的函数中查找，我们同样分成几部分来看。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">_setvarvalue</span> <span class="params">(name, value, level)</span></span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="局部变量中查找"><a href="#局部变量中查找" class="headerlink" title="局部变量中查找"></a>局部变量中查找</h2><p>同样地，先处理层级，层级的默认值为1， 将层级加上1是为了将层次修正为包含<code>_setvavalue</code>函数自己。</p>
<p>然后遍历局部变量表，查找是否有名字为<code>name</code>的变量，如果找到的话记录其索引。<span class="label warning">注意</span>我们找到之后并没有立马跳出循环，因为可能具有多个同名的局部变量，我们应该获取索引最大的那个。</p>
<p>循环结束之后，如果已经在局部变量中找到了<code>name</code>，就修改该变量的值为<code>value</code>，然后返回<code>&quot;local&quot;</code>，指示修改的是局部变量。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">_setvarvalue</span> <span class="params">(name, value, level)</span></span></span><br><span class="line">    <span class="keyword">local</span> index</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 加1是为了将层次修正了包含_setvarvalue自身</span></span><br><span class="line">    level = (level <span class="keyword">or</span> <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">    <span class="comment">-- 在局部变量中查找</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> n, v = <span class="built_in">debug</span>.<span class="built_in">getlocal</span>(level, i)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> n == name <span class="keyword">then</span></span><br><span class="line">            index = i</span><br><span class="line">            <span class="comment">-- 只更新索引值，并不退出循环</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> index <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">setlocal</span>(level, index, value)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;local&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="上值中查找"><a href="#上值中查找" class="headerlink" title="上值中查找"></a>上值中查找</h2><p>如果在局部变量中没有找到，我们再尝试到upvalue中进行查找。首先通过<code>getbug.getinfo</code>获取到第level层的函数，然后遍历其上值，如果找到匹配的变量就修改其值为<code>value</code>，然后返回<code>&quot;upvalue&quot;</code>以指示修改的是上值。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">_setvarvalue</span> <span class="params">(name, value, level)</span></span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">local</span> func = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(level, <span class="string">&quot;f&quot;</span>).func</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> n, v = <span class="built_in">debug</span>.<span class="built_in">getupvalue</span>(func, i)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> n == name <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">setupvalue</span>(func, i, value)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;upvalue&quot;</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="ENV表中查找"><a href="#ENV表中查找" class="headerlink" title="_ENV表中查找"></a>_ENV表中查找</h2><p>如果在普通的上值中还是没有找到，我们就去<code>_ENV</code>表中查找。首先调用<code>_getvarvalue</code>获取到<code>_ENV</code>表，注意这里的<code>isenv</code>标志为<code>true</code>。如果如果找到了<code>_ENV</code>表且表中存在名为<code>name</code>的变量，就修改其值为<code>value</code>，然后返回<code>&quot;global&quot;</code>以指示是修改的<code>_ENV</code>表中的值。如果没有<code>_ENV</code>表或表中不存在要找的变量，就返回<code>nil</code>。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">_setvarvalue</span> <span class="params">(name, value, level)</span></span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">local</span> _, env = _getvarvalue(<span class="string">&quot;_ENV&quot;</span>, level, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> env <span class="keyword">and</span> env[name] <span class="keyword">then</span></span><br><span class="line">        env[name] = value</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;global&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="包装函数"><a href="#包装函数" class="headerlink" title="包装函数"></a>包装函数</h2><p>接下来我们同样再定义一个包装函数，对层次数<code>level</code>进行修正以包含<code>setvarvalue</code>函数自身以及其上层的<code>debug mainchunk</code>、<code>debug.debug</code>以及钩子函数。</p>
<p>然后对返回值进行检查，如果返回值为真，说明修改变量值成功，就打印变量类型，否则提示未找到。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setvarvalue</span> <span class="params">(name, value, level)</span></span></span><br><span class="line">    <span class="comment">-- level 默认值为1</span></span><br><span class="line">    <span class="comment">-- 加4是为了将层次纠正为包含 settvarvalue, debug mainchunk, debug.debug和hook</span></span><br><span class="line">    level = (level <span class="keyword">or</span> <span class="number">1</span>) + <span class="number">4</span></span><br><span class="line">    <span class="keyword">local</span> where = _setvarvalue(name, value, level)</span><br><span class="line">    <span class="keyword">if</span> where <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(where, name)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(name, <span class="string">&quot;not found&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>接口定义好了，让我们把这两个接口也添加到返回到表中。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line">    printtraceback = printtraceback,</span><br><span class="line">    setvarvalue = setvarvalue,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><p>接下来编写一个测试脚本<code>test.lua</code>以对我们新添加的接口进行测试。脚本很简单，就不多做解释了。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line">pv = ldb.printvarvalue</span><br><span class="line">sv = ldb.setvarvalue</span><br><span class="line">ptb = ldb.printtraceback</span><br><span class="line"></span><br><span class="line">g = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> u = <span class="number">2</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">3</span></span><br><span class="line">    u = u</span><br><span class="line">    g = g</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(foo, <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">foo(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">rmbp(id1)</span><br></pre></td></tr></table></figure>



<h2 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h2><p>我们运行测试脚本，首先调用堆栈打印函数，默认是打印从断点所在函数开始的堆栈。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua test.lua</span><br><span class="line">(<span class="built_in">local</span>)foo test.lua:14</span><br><span class="line">lua_debug&gt; ptb()</span><br><span class="line">stack traceback:</span><br><span class="line">	test.lua:14: <span class="keyword">in</span> <span class="built_in">local</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">	test.lua:21: <span class="keyword">in</span> main chunk</span><br><span class="line">	[C]: <span class="keyword">in</span> ?</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>我们显式指定层数试一下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; ptb(2)</span><br><span class="line">stack traceback:</span><br><span class="line">	test.lua:21: <span class="keyword">in</span> main chunk</span><br><span class="line">	[C]: <span class="keyword">in</span> ?</span><br><span class="line">lua_debug&gt; ptb(0)</span><br><span class="line">stack traceback:</span><br><span class="line">	./luadebug.lua:20: <span class="keyword">in</span> hook <span class="string">&#x27;?&#x27;</span></span><br><span class="line">	test.lua:14: <span class="keyword">in</span> <span class="built_in">local</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">	test.lua:21: <span class="keyword">in</span> main chunk</span><br><span class="line">	[C]: <span class="keyword">in</span> ?</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>没有问题，层数为2的时候少打印了一层，为0的时候则多打了一层。</p>
<p>我们再来测试下变量值修改函数，先看来变量原来的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; pv(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="built_in">local</span>	3</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;u&quot;</span>)</span><br><span class="line">upvalue	2</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">global	1</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>然后修改变量的值，我们把这三个变量值都改成了6</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; sv(<span class="string">&quot;a&quot;</span>, 6)</span><br><span class="line"><span class="built_in">local</span>	a</span><br><span class="line">lua_debug&gt; sv(<span class="string">&quot;u&quot;</span>, 6)</span><br><span class="line">upvalue	u</span><br><span class="line">lua_debug&gt; sv(<span class="string">&quot;g&quot;</span>, 6)</span><br><span class="line">global	g</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>然后再打印下值检查下结果，可以看到都修改成功了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; pv(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="built_in">local</span>	6</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;u&quot;</span>)</span><br><span class="line">upvalue	6</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">global	6</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>我们再试试显式指定层级为2，将变量值再改为8</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; sv(<span class="string">&quot;a&quot;</span>, 8, 2)</span><br><span class="line">a	not found</span><br><span class="line">lua_debug&gt; sv(<span class="string">&quot;u&quot;</span>, 8, 2)</span><br><span class="line"><span class="built_in">local</span>	u</span><br><span class="line">lua_debug&gt; sv(<span class="string">&quot;g&quot;</span>, 8, 2)</span><br><span class="line">global	g</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="built_in">local</span>	6</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;u&quot;</span>)</span><br><span class="line">upvalue	8</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">global	8</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>变量a因为是函数foo的局部变量，所以外层看不到。变量u在main chunk中是属于局部变量，而变量g则还是全局变量。修改之后变量a的结果没有变，其他两个都改成了8。</p>
<p>Well done！</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua中如何实现类似gdb的断点调试--04优化钩子事件处理</title>
    <url>/posts/c1ecd715/</url>
    <content><![CDATA[<div class="note primary">
            <p>在第一篇的<a href="../f9a188a7/">01最小实现</a>中，我们实现了一个断点调试的最小实现，在设置钩子函数时只加了line事件，显然这会对性能有很大的影响。而后来两篇<a href="../f6e9079c">02通用变量打印</a>和<a href="../a05a2f5f">03通用变量修改及调用栈回溯</a>则是提供了一些辅助的调试接口，并没有对钩子函数进行修改。</p><p>我们本篇将在钩子中引入call和return事件的处理，尝试对性能进行优化。</p><span id="more"></span><p>源码已经上传<a href="https://github.com/catbro666/lua-debugger">Github</a>，欢迎watch/star😘。</p>
          </div>



<h2 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h2><p>当前的实现因为只加了line事件，执行每一行代码都会执行钩子函数去查看是否有断点，这是没有必要的。我们可以在call事件时检查当前函数是否有断点，只有当有断点的时候才加入line事件。那我们什么时候去掉line事件呢？是不是遇到return事件就去掉呢？</p>
<h3 id="考虑如下场景"><a href="#考虑如下场景" class="headerlink" title="考虑如下场景"></a>考虑如下场景</h3><p>考虑如下场景：假设f1调用f2，f2又调用f3。f1中有断点，f2没有断点，f3有断点。如果遇到return就去掉line事件，那么从f2返回到f1之后，就无法再停到f1后面的断点上了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b             b</span><br><span class="line">f1 --&gt; f2 --&gt; f3</span><br><span class="line">   &lt;--    &lt;--</span><br></pre></td></tr></table></figure>

<h3 id="正确的做法"><a href="#正确的做法" class="headerlink" title="正确的做法"></a>正确的做法</h3><p>所以正确的做法应该是：call事件时，根据被调函数是否有断点，决定是否加line事件；return事件时，则根据主调函数是否有断点，决定是否加line事件。那么return时如何获取到主调函数的信息呢？我们就需要在call的时候保存函数的相关信息，组成一个链表。call的时候在尾部增加一个节点，return的时候则去掉一个节点。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>首先，在status数据结构中增加3个成员，<code>stackinfos</code>相当于我们前面提到的链表（只不过这里以数组的形式实现），维护了调用栈中每个函数的信息，记录其中是否有断点，<code>stackdepth</code>记录了链表的长度，或者说栈的深度。<code>funcinfos</code>用于缓存一些函数调试信息，不用每次都调用<code>debug.getinfo</code>去获取。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">status</span>.stackinfos = &#123;&#125;  <span class="comment">-- table for saving stack infos</span></span><br><span class="line"><span class="built_in">status</span>.stackdepth = <span class="number">0</span>   <span class="comment">-- the depth of stack</span></span><br><span class="line"><span class="built_in">status</span>.funcinfos = &#123;&#125;   <span class="comment">-- table for caching func infos</span></span><br></pre></td></tr></table></figure>



<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>我们本篇最主要的改动是钩子函数，除了line事件，我们还增加了call（或tail call）事件和return（或tail return）事件的处理。为了代码的简洁，用局部变量s来表示<code>status</code>。接下来我们分别来看这三个部分。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span> <span class="params">(event, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail call&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">elseif</span> event == <span class="string">&quot;return&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail return&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">elseif</span> event == <span class="string">&quot;line&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="call事件"><a href="#call事件" class="headerlink" title="call事件"></a>call事件</h2><p>如果是call事件（或tail call事件），那么先获取当前函数，查看是否在断点表中有断点。</p>
<p>如果有则在<code>s.stackinfos</code>表尾部插入一个元素，其中<code>hasbreak</code>字段为<code>true</code>指示该函数有断点。注意，这里我们对<code>tail call</code>进行了一个优化，直接覆盖上一层的节点，在递归尾调用时可以防止空间无限膨胀。（Lua5.1上因为没有tail call就无能为力了：）。然后重新设置钩子函数的事件，将call、return和line事件全加上了。</p>
<p>如果当前函数没有断点，同样在<code>s.stackinfos</code>表尾部插入一个节点，不过其中<code>hasbreak</code>字段为<code>false</code>指示该层没有断点。在设置的钩子事件中，则只保留了<code>cr</code>，将line事件移除了。这样就只有断点所在的函数内才会触发line事件，可以大幅提升性能。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span> <span class="params">(event, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail call&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> func = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>, <span class="string">&quot;f&quot;</span>).func</span><br><span class="line">        <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">pairs</span>(s.bptable) <span class="keyword">do</span></span><br><span class="line">            <span class="comment">-- 当前函数中有断点</span></span><br><span class="line">            <span class="keyword">if</span> v.func == func <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">then</span></span><br><span class="line">                    s.stackdepth = s.stackdepth + <span class="number">1</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                s.stackinfos[s.stackdepth] =</span><br><span class="line">                    &#123;func = func, hasbreak = <span class="literal">true</span>&#125;</span><br><span class="line">                <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;crl&quot;</span>)  <span class="comment">-- 添加&quot;line&quot;事件</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">-- 当前函数中没有断点</span></span><br><span class="line">        <span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">then</span></span><br><span class="line">            s.stackdepth = s.stackdepth + <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        s.stackinfos[s.stackdepth] = &#123;func = func, hasbreak = <span class="literal">false</span>&#125;</span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;cr&quot;</span>)   <span class="comment">-- 移除&quot;line&quot;事件</span></span><br><span class="line">    <span class="keyword">elseif</span> event == <span class="string">&quot;return&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail return&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="return事件"><a href="#return事件" class="headerlink" title="return事件"></a>return事件</h2><p>接下来，我们来看return事件的处理。它首先删除<code>s.stackinfos</code>表尾部的节点，然后检查前一个节点的函数是否有断点，如果有则恢复line事件，否则移除line事件。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span> <span class="params">(event, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail call&quot;</span> <span class="keyword">then</span></span><br><span class="line">    	<span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">elseif</span> event == <span class="string">&quot;return&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail return&quot;</span> <span class="keyword">then</span></span><br><span class="line">        s.stackinfos[s.stackdepth] = <span class="literal">nil</span></span><br><span class="line">        s.stackdepth = s.stackdepth - <span class="number">1</span></span><br><span class="line">        <span class="comment">-- 如果上一层的函数有断点</span></span><br><span class="line">        <span class="keyword">if</span> s.stackdepth &gt; <span class="number">0</span> <span class="keyword">and</span> s.stackinfos[s.stackdepth].hasbreak <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;crl&quot;</span>)  <span class="comment">-- 恢复&quot;line&quot;事件</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;cr&quot;</span>)   <span class="comment">-- 移除&quot;line&quot;事件</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> event == <span class="string">&quot;line&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="line事件"><a href="#line事件" class="headerlink" title="line事件"></a>line事件</h2><p>最后一部分是line事件的处理，跟之前没有太大的变化。它遍历断点表，如果匹配到断点则打印提示信息，然后进入用户交互模式。不过这里也做了一个小优化，将<code>debug.getinfo</code>获取的函数信息缓存到了<code>status.funcinfos</code>中，下一次就可以直接从缓存中获取到该函数的信息。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span> <span class="params">(event, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail call&quot;</span> <span class="keyword">then</span></span><br><span class="line">    	<span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">elseif</span> event == <span class="string">&quot;line&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">pairs</span>(s.bptable) <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> v.func == s.stackinfos[s.stackdepth].func</span><br><span class="line">                <span class="keyword">and</span> v.line == line <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> s.funcinfos[v.func] <span class="keyword">then</span></span><br><span class="line">                    s.funcinfos[v.func] = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>, <span class="string">&quot;nS&quot;</span>)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">local</span> info = s.funcinfos[v.func]</span><br><span class="line">                <span class="keyword">local</span> prompt = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s (%s)%s %s:%d\n&quot;</span>,</span><br><span class="line">                    info.what, info.namewhat, info.name, info.short_src, line)</span><br><span class="line">                <span class="built_in">io</span>.<span class="built_in">write</span>(prompt)</span><br><span class="line">                <span class="built_in">debug</span>.<span class="built_in">debug</span>()</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="初始事件设置"><a href="#初始事件设置" class="headerlink" title="初始事件设置"></a>初始事件设置</h2><p>hook函数已经修改好了，我们再调整一下<code>setbreakpoint</code>函数中第一次设置钩子时的行为。初始只设置call事件。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setbreakpoint</span><span class="params">(func, line)</span></span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">if</span> s.bpnum == <span class="number">1</span> <span class="keyword">then</span>                <span class="comment">-- 只有一个断点</span></span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;c&quot;</span>)        <span class="comment">-- 设置call事件</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> s.bpid</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>我们假设代码执行的总行数为<code>L</code>，断点数<code>N=n*b</code>，其中<code>n</code>为有断点的函数个数，<code>b</code>为平均每个函数的断点数，断点所在函数平均行数为<code>l</code>，断点所在函数平均调用次数为<code>c</code>，总的函数调用次数<code>C</code>。</p>
<p>那么优化前复杂度为<code>O(L*N)</code>，优化后的复杂度为<code>O(C*N+c*l*N)</code></p>
<p>一般情况下<code>(C+c*I) &lt;&lt; L</code>，因为右边<code>L</code>代码执行总行数可以分成有断点的函数执行总行数+没有断点的函数执行总行数，而左边的<code>c*I</code>就是有断点的函数执行总行数，<code>C</code>为函数调用总次数。正常情况下函数调用总次数肯定是远远小于没有断点的函数执行的总行数的，有断点的函数执行总行数也是远远小于没有断点的函数执行总行数的。</p>
<h2 id="测试断点是否正常"><a href="#测试断点是否正常" class="headerlink" title="测试断点是否正常"></a>测试断点是否正常</h2><p>我们编写如下测试脚本，来测试下之前提到的那种场景：f1调用f2，f2又调用f3，f1中加了两个断点，在调用f2前后各有一个，f2没有断点，f3有断点。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line">pv = ldb.printvarvalue</span><br><span class="line">sv = ldb.setvarvalue</span><br><span class="line">ptb = ldb.printtraceback</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">f3</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line">    f3()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line">    f2()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- f3中加断点</span></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(f3, <span class="number">9</span>)</span><br><span class="line"><span class="comment">-- f2不加断点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- f1中在调用f2前后各加一个断点</span></span><br><span class="line"><span class="keyword">local</span> id2 = setbp(f1, <span class="number">16</span>)</span><br><span class="line"><span class="keyword">local</span> id3 = setbp(f1, <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line">f1()</span><br><span class="line"></span><br><span class="line">rmbp(id1)</span><br><span class="line">rmbp(id2)</span><br><span class="line">rmbp(id3)</span><br></pre></td></tr></table></figure>

<p>然后来运行测试脚本验证一下。首先停在了f1函数第16行（调用f2之前），然后<code>cont</code>继续执行，停在了函数f3的断点处，再次<code>cont</code>继续，函数停在了f1函数第17行（调用f2之后）。可见断点能正常工作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua test.lua</span><br><span class="line">Lua (<span class="built_in">local</span>)f1 test.lua:16</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (upvalue)f3 test.lua:9</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)f1 test.lua:17</span><br><span class="line">lua_debug&gt; cont</span><br></pre></td></tr></table></figure>



<h2 id="测试tail-call优化"><a href="#测试tail-call优化" class="headerlink" title="测试tail call优化"></a>测试tail call优化</h2><p>我们再来测试下tail call的优化，编写如下测试脚本。我们定义了一个尾调用递归的函数foo，然后再其他函数上随便加了一个断点（为了设置hook）。然后我们foo函数一直递归调用。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line">pv = ldb.printvarvalue</span><br><span class="line">sv = ldb.setvarvalue</span><br><span class="line">ptb = ldb.printtraceback</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> foo(n<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- add a break in bar</span></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(bar, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">foo(<span class="number">100000000000</span>)</span><br><span class="line"></span><br><span class="line">rmbp(id1)</span><br></pre></td></tr></table></figure>

<h3 id="Lua5-1测试"><a href="#Lua5-1测试" class="headerlink" title="Lua5.1测试"></a>Lua5.1测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua5.1 test2.lua</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用Lua5.1运行上面的测试脚本，内存占用一直在飙升，我只测试了一小会，就已经飙到8G了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/c1ecd715/lua5.1-call.jpg" alt="lua5.1-call" loading="lazy"></p>
<h3 id="Lua5-3测试"><a href="#Lua5-3测试" class="headerlink" title="Lua5.3测试"></a>Lua5.3测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua5.3 test2.lua</span><br></pre></td></tr></table></figure>

<p>用Lua5.3运行上面的测试脚本，因为有尾调用的优化，内存占用一直保持在720KB。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/c1ecd715/lua5.3-tail-call.jpg" alt="lua5.3-tail-call" loading="lazy"></p>
<p>细心的同学可能已经发现了，我们的hook函数中call事件和line都需要对整个断点表进行遍历，这其中其实是存在着一些冗余的。因为篇幅原因，我们放到下回分解。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua中如何实现类似gdb的断点调试--05优化断点信息数据结构</title>
    <url>/posts/2e777dd3/</url>
    <content><![CDATA[<div class="note primary">
            <p>在上一篇<a href="../c1ecd715/">04优化钩子事件处理</a>中，我们在钩子函数中引入了call和return事件的处理，对性能进行了优化。</p><p>细心的同学可能已经发现了，我们的hook函数中call事件和line都需要对整个断点表进行遍历，这其中其实是存在着一些冗余的。因为call事件只关心函数是否有断点，而line事件则只关心本函数内有哪些断点。所以我们可以想办法优化一下断点信息的数据结构，进一步提升性能。</p><span id="more"></span><p>源码已经上传<a href="https://github.com/catbro666/lua-debugger">Github</a>，欢迎watch/star😘。</p>
          </div>



<h2 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h2><p>原来的断点表<code>status.bptable</code>是以断点id为键的数组，我们需要通过断点id来快速删除断点，所以<code>status.bptable</code>表还是保留。</p>
<p>但是在钩子函数中，我们并不关心断点的id，相反我们关心断点属于哪个函数。只有当程序执行到有断点的函数时，我们才需要处理line事件。所以，很自然地可以想到，我们应该新增一个以函数为键的断点表。我们把这个新表定义如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">status</span>.funcbpt = &#123;&#125;     <span class="comment">-- 以函数为键的断点表</span></span><br></pre></td></tr></table></figure>

<p>那么新表的值应该是什么呢？因为一个函数中可能有多个断点，而在line事件中我们又需要比较当前行是否是断点行，所以我们把新表<code>status.funcbpt</code>的值也设计成一个表，该表的键是断点行号，值为断点id。因为断点行号并不连续，所以<code>status.funcbpt[func]</code>表不是一个序列，为了快速获取断点个数，我们在表中额外加了一个特殊的<code>num</code>字段保存该函数中的断点个数。</p>
<p>这样我们就可以在call事件中快速地判断当前函数是否有断点，在line事件中快速地判断当前行是否是断点行。</p>
<p>另外，之所以将断点id作为<code>status.funcbpt[func]</code>表的值，则是为了保留从<code>status.funcbpt</code>访问<code>status.bptable</code>中对应断点的能力（<code>status.bptable</code>表中元素因为包含了<code>func</code>和<code>line</code>字段，所以也可以访问到<code>status.funcbpt</code>对应断点）。</p>
<p>这么说可能不直观，我们来看个例子。</p>
<p>假设我们的<code>bptable</code>表中func函数添加了两个断点如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">bptable[<span class="number">1</span>] = &#123;func = func, line = <span class="number">10</span>&#125;</span><br><span class="line">bptable[<span class="number">2</span>] = &#123;func = func, line = <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>

<p>对应的在<code>funcbpt</code>表中的操作如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">funcbpt[func] = &#123;&#125;          <span class="comment">-- 构造表</span></span><br><span class="line">funcbpt[func][<span class="number">10</span>] = <span class="number">1</span>	    <span class="comment">-- 函数func，行号10，断点id为1</span></span><br><span class="line">funcbpt[func].num = <span class="number">1</span>       <span class="comment">-- 该函数第一个断点</span></span><br><span class="line">funcbpt[func][<span class="number">20</span>] = <span class="number">2</span>       <span class="comment">-- 函数func，行号20，断点id为2</span></span><br><span class="line">funcbpt[func].num = funcbpt[func].num + <span class="number">1</span>	<span class="comment">-- 断点个数+1</span></span><br></pre></td></tr></table></figure>



<p>OK，理清楚了<code>status.funcbpt</code>的数据结构设计，实现起来就简单了。</p>
<h2 id="添加断点"><a href="#添加断点" class="headerlink" title="添加断点"></a>添加断点</h2><p>我们先从设置断点函数入手修改代码。新增的代码已经用中括号括起来了，有两个部分。其中前面的部分先根据函数和行号检查是否已经设置过同一个断点了，如果是的话，直接返回之前设置的断点id。</p>
<p>后面的部分，在断点保存到<code>s.bptable</code>表之后，也要保存到我们新增的表<code>s.funcbpt</code>表中，行号line作为键，新断点id作为值。如果设置的是该函数的第一个断点，需要先进行表的初始化构造，所以操作稍有不同。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setbreakpoint</span><span class="params">(func, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(func) ~= <span class="string">&quot;function&quot;</span> <span class="keyword">or</span> <span class="built_in">type</span>(line) ~= <span class="string">&quot;number&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="string">[[ 新增代码开始 ]]</span></span><br><span class="line">    <span class="comment">-- 已经设置了相同的断点</span></span><br><span class="line">    <span class="keyword">if</span> s.funcbpt[func] <span class="keyword">and</span> s.funcbpt[func][line] <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> s.funcbpt[func][line]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="string">[[ 新增代码结束 ]]</span></span><br><span class="line">    s.bpid = s.bpid + <span class="number">1</span></span><br><span class="line">    s.bpnum = s.bpnum + <span class="number">1</span></span><br><span class="line">    s.bptable[s.bpid] = &#123;func = func, line = line&#125;</span><br><span class="line">    <span class="string">[[ 新增代码开始 ]]</span></span><br><span class="line">    <span class="keyword">if</span> s.funcbpt[func] <span class="keyword">then</span>             <span class="comment">-- 该函数已经有断点了</span></span><br><span class="line">        s.funcbpt[func].num = s.funcbpt[func].num + <span class="number">1</span></span><br><span class="line">        s.funcbpt[func][line] = s.bpid</span><br><span class="line">    <span class="keyword">else</span>                                <span class="comment">-- 该函数第一个断点</span></span><br><span class="line">        s.funcbpt[func] = &#123;&#125;</span><br><span class="line">        s.funcbpt[func].num = <span class="number">1</span></span><br><span class="line">        s.funcbpt[func][line] = s.bpid</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">     <span class="string">[[ 新增代码结束 ]]</span></span><br><span class="line">    <span class="keyword">if</span> s.bpnum == <span class="number">1</span> <span class="keyword">then</span>                <span class="comment">-- 全局第一个断点</span></span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;c&quot;</span>)        <span class="comment">-- 设置钩子&quot;call&quot;事件</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> s.bpid                       <span class="comment">--&gt; 返回断点id</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h2><p>相应地，在删除断点的时候，我们也需要把<code>s.funcbpt</code>表中对应的断点删除。首先根据断点id，从<code>s.bptable</code>表中获取到断点的函数和行号，从而找到<code>s.funcbpt</code>表中对应的断点。现将断点个数减1，然后将对应断点删除（防止后续line事件找到该断点）。如果该函数已经没有断点了，那么将<code>s.funcbpt[func]</code>表本身也删除（防止后续call事件以为该函数还有断点）。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">removebreakpoint</span><span class="params">(id)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> s.bptable[id] == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="string">[[ 新增代码开始 ]]</span></span><br><span class="line">    <span class="keyword">local</span> func = s.bptable[id].func</span><br><span class="line">    <span class="keyword">local</span> line = s.bptable[id].line</span><br><span class="line">    s.funcbpt[func].num = s.funcbpt[func].num - <span class="number">1</span></span><br><span class="line">    s.funcbpt[func][line] = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> s.funcbpt[func].num == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        s.funcbpt[func] = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="string">[[ 新增代码结束 ]]</span></span><br><span class="line">    s.bptable[id] = <span class="literal">nil</span></span><br><span class="line">    s.bpnum = s.bpnum - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> s.bpnum == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">sethook</span>()                 <span class="comment">-- 移除钩子</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>然后来修改钩子函数的处理，钩子的函数的修改主要有两处，分别是call事件和line事件。我们先来看call事件的修改：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> local function hook (event, line)</span><br><span class="line">     local s = status</span><br><span class="line">     if event == &quot;call&quot; or event == &quot;tail call&quot; then</span><br><span class="line">         local func = debug.getinfo(2, &quot;f&quot;).func</span><br><span class="line"><span class="deletion">-        for _, v in pairs(s.bptable) do</span></span><br><span class="line"><span class="deletion">-            -- found breakpoint in current function</span></span><br><span class="line"><span class="deletion">-            if v.func == func then</span></span><br><span class="line"><span class="deletion">-                if event == &quot;call&quot; then</span></span><br><span class="line"><span class="deletion">-                    s.stackdepth = s.stackdepth + 1</span></span><br><span class="line"><span class="deletion">-                end</span></span><br><span class="line"><span class="deletion">-                s.stackinfos[s.stackdepth] =</span></span><br><span class="line"><span class="deletion">-                    &#123;func = func, hasbreak = true&#125;</span></span><br><span class="line"><span class="deletion">-                debug.sethook(hook, &quot;crl&quot;)     -- 添加&quot;line&quot;事件</span></span><br><span class="line"><span class="deletion">-                return</span></span><br><span class="line"><span class="deletion">-            end</span></span><br><span class="line"><span class="deletion">-        end</span></span><br><span class="line"><span class="deletion">-        -- 没有断点</span></span><br><span class="line"><span class="deletion">-        if event == &quot;call&quot; then</span></span><br><span class="line"><span class="addition">+        if event == &quot;call&quot; then     -- 对于尾调用,直接覆盖</span></span><br><span class="line">             s.stackdepth = s.stackdepth + 1</span><br><span class="line">         end</span><br><span class="line"><span class="deletion">-        s.stackinfos[s.stackdepth] = &#123;func = func, hasbreak = false&#125;</span></span><br><span class="line"><span class="deletion">-        debug.sethook(hook, &quot;cr&quot;)   -- 去掉&quot;line&quot;事件</span></span><br><span class="line"><span class="addition">+        -- found breakpoint in current function</span></span><br><span class="line"><span class="addition">+        if s.funcbpt[func] then</span></span><br><span class="line"><span class="addition">+            s.stackinfos[s.stackdepth] = &#123;func = func, hasbreak = true&#125;</span></span><br><span class="line"><span class="addition">+            debug.sethook(hook, &quot;crl&quot;) -- 添加&quot;line&quot;事件</span></span><br><span class="line"><span class="addition">+        else        -- no breakpoints found</span></span><br><span class="line"><span class="addition">+            s.stackinfos[s.stackdepth] = &#123;func = func, hasbreak = false&#125;</span></span><br><span class="line"><span class="addition">+            debug.sethook(hook, &quot;cr&quot;)   -- 去掉&quot;line&quot;事件</span></span><br><span class="line"><span class="addition">+        end</span></span><br><span class="line">     elseif event == &quot;return&quot; or event == &quot;tail return&quot; then</span><br></pre></td></tr></table></figure>

<p>主要的改动就是从原本的遍历<code>s.bptable</code>表来查找是否有断点，改成了直接通过检查<code>s.funcbpt[func]</code>是否不为<code>nil</code>来判断是否有断点。这里直接从遍历一个表，优化成了一个查表操作。</p>
<p>第二处是line事件的修改，下面是修改前的代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">   <span class="comment">-- 省略</span></span><br><span class="line">   <span class="keyword">elseif</span> event == <span class="string">&quot;line&quot;</span> <span class="keyword">then</span></span><br><span class="line">       <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">pairs</span>(s.bptable) <span class="keyword">do</span></span><br><span class="line">           <span class="keyword">if</span> v.func == s.stackinfos[s.stackdepth].func</span><br><span class="line">               <span class="keyword">and</span> v.line == line <span class="keyword">then</span></span><br><span class="line">               <span class="keyword">if</span> <span class="keyword">not</span> s.funcinfos[v.func] <span class="keyword">then</span></span><br><span class="line">                   s.funcinfos[v.func] = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>, <span class="string">&quot;nS&quot;</span>)</span><br><span class="line">               <span class="keyword">end</span></span><br><span class="line">               <span class="keyword">local</span> info = s.funcinfos[v.func]</span><br><span class="line">               <span class="keyword">local</span> prompt = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s (%s)%s %s:%d\n&quot;</span>,</span><br><span class="line">                   info.what, info.namewhat, info.name, info.short_src, line)</span><br><span class="line">               <span class="built_in">io</span>.<span class="built_in">write</span>(prompt)</span><br><span class="line">               <span class="built_in">debug</span>.<span class="built_in">debug</span>()</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 省略</span></span><br></pre></td></tr></table></figure>

<p>下面是修改后的代码，除了增加了一些局部变量简化代码之外，也是将原本的遍历<code>s.bptable</code>表来判断当前行是否是断点行，改成了直接通过检查<code>s.funcbpt[curfunc][line]</code>是否不为<code>nil</code>来判断当前行是否是断点行。这里也将遍历一个表的动作，优化成了一个查表操作。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">elseif</span> event == <span class="string">&quot;line&quot;</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">local</span> curfunc = s.stackinfos[s.stackdepth].func</span><br><span class="line">    <span class="keyword">local</span> funcbp = s.funcbpt[curfunc]</span><br><span class="line">    <span class="built_in">assert</span>(funcbp)</span><br><span class="line">    <span class="keyword">if</span> funcbp[line] <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s.funcinfos[curfunc] <span class="keyword">then</span></span><br><span class="line">            s.funcinfos[curfunc] = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>, <span class="string">&quot;nS&quot;</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">local</span> info = s.funcinfos[curfunc]</span><br><span class="line">        <span class="keyword">local</span> prompt = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s (%s)%s %s:%d\n&quot;</span>,</span><br><span class="line">            info.what, info.namewhat, info.name, info.short_src, line)</span><br><span class="line">        <span class="built_in">io</span>.<span class="built_in">write</span>(prompt)</span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">debug</span>()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>我们仍然假设代码执行的总行数为<code>L</code>，断点数<code>N=n*b</code>，其中<code>n</code>为有断点的函数个数，<code>b</code>为平均每个函数的断点数，断点所在函数平均行数为<code>l</code>，断点所在函数平均调用次数为<code>c</code>，总的函数调用次数<code>C</code>。</p>
<p>完全没优化前复杂度为<code>O(L*N)</code>，上一篇的事件处理优化后的复杂度为<code>O(C*N+c*l*N)</code>，而本篇的数据结构优化之后复杂度进一步缩小为<code>O(C+c*l)</code>。</p>
<h2 id="测试多函数多断点"><a href="#测试多函数多断点" class="headerlink" title="测试多函数多断点"></a>测试多函数多断点</h2><p>先来测试一下修改之后断点功能是否正常，编写一个测试脚本如下。我们对foo函数和bar函数分别添加了两个断点，其中foo函数第一个断点添加了两次用于测试重复添加的情况。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line">pv = ldb.printvarvalue</span><br><span class="line">sv = ldb.setvarvalue</span><br><span class="line">ptb = ldb.printtraceback</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span> <span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> b = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(foo, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">assert</span>(id1 == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">local</span> id1 = setbp(foo, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">assert</span>(id1 == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">local</span> id2 = setbp(foo, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id3 = setbp(bar, <span class="number">13</span>)</span><br><span class="line"><span class="keyword">local</span> id4 = setbp(bar, <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line">rmbp(id1)</span><br><span class="line">rmbp(id2)</span><br><span class="line">rmbp(id3)</span><br><span class="line">rmbp(id4)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>

<p>运行脚本，4个断点情况都能正常跑到。删除断点后再调用foo和bar函数，不再碰到断点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua test.lua</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:9</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:10</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)bar test.lua:13</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)bar test.lua:14</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">$</span><br></pre></td></tr></table></figure>



<h2 id="性能比对"><a href="#性能比对" class="headerlink" title="性能比对"></a>性能比对</h2><p>我们再来做个简单的测试，看看我们优化的效果。编写如下测试脚本，foo函数模拟较长的程序，然后在另一个函数上加个断点（为了设置hook）。我们分别使用优化前的<code>luadebug.lua</code>和优化后的<code>luadebug.lua</code>进行测试。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">10000000</span> <span class="keyword">do</span></span><br><span class="line">        a = a + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span> <span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(bar, <span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<h3 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h3><p>使用优化前的实现，运行这个脚本用了40s</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ time lua test2.lua</span><br><span class="line">lua test2.lua  39.54s user 0.16s system 99% cpu 39.957 total</span><br></pre></td></tr></table></figure>

<h3 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h3><p>使用优化后的实现，则只花了0.109s，相差了接近400倍，可见我们的优化效果还是很明显的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ time lua test2.lua</span><br><span class="line">lua test2.lua  0.10s user 0.00s system 97% cpu 0.109 total</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>编程开发</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua中如何实现类似gdb的断点调试—06断点行号检查与自动修正</title>
    <url>/posts/fa52978d/</url>
    <content><![CDATA[<div class="note primary">
            <p>前面两篇我们对性能做了一个优化，接下来继续来丰富调试器的特性。</p><p>我们前面提到过，函数内并不是所有行都是有效行，空行和注释行就不是有效行。我们之前在添加断点的时候，并没有对行号进行检查，任何行号都能成功添加断点。所以如果添加的断点行号是无效的，那么永远也不会断到那里。但是钩子里并不知道它是无效的，call事件仍然会以为函数有断点从而启动line事件，造成CPU的浪费。</p><p>所以本篇，我们将对断点的行号进行检查，对于不在函数范围内的行号直接添加断点失败；在函数范围内的行号则自动修正为下一个有效的行号；另外支持不指定行号，默认为函数的第一个有效行。</p><span id="more"></span><p>源码已经上传<a href="https://github.com/catbro666/lua-debugger">Github</a>，欢迎watch/star😘。</p>
          </div>



<h2 id="添加断点"><a href="#添加断点" class="headerlink" title="添加断点"></a>添加断点</h2><p>因为是断点行号相关的检查，所以修改主要集中在添加断点的函数中。首先因为支持了不指定行号，所以修改了参数检查的地方允许为空。其次，因为要检查行号是否有效，我们就需要先获取到函数的信息。考虑到在钩子函数中也需要获取函数信息，我们就把相关的操作封装成了一个单独的函数<code>getfuncinfo()</code>。获取到函数信息之后，就可以验证行号是否有效了，同样我们将这个验证行号的操作也封装成了一个单独的函数<code>verifyfuncline</code>。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setbreakpoint</span><span class="params">(func, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(func) ~= <span class="string">&quot;function&quot;</span> <span class="keyword">or</span> ( line <span class="keyword">and</span> <span class="built_in">type</span>(line) ~= <span class="string">&quot;number&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;invalid parameter\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- get func info</span></span><br><span class="line">    <span class="keyword">local</span> info = getfuncinfo(func)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> info <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;unable to get func info\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- verify the line</span></span><br><span class="line">    line = verifyfuncline(info, line)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;invalid line\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="获取函数信息"><a href="#获取函数信息" class="headerlink" title="获取函数信息"></a>获取函数信息</h2><p><code>getfuncinfo</code>函数的代码如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">getfuncinfo</span> <span class="params">(func, level)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">local</span> info = s.funcinfos[func]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> info <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> level <span class="keyword">then</span></span><br><span class="line">            s.funcinfos[func] = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(level + <span class="number">1</span>, <span class="string">&quot;nSL&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s.funcinfos[func] = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(func, <span class="string">&quot;SL&quot;</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        info = s.funcinfos[func]</span><br><span class="line">        info.sortedlines = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k, _ <span class="keyword">in</span> <span class="built_in">pairs</span>(info.activelines) <span class="keyword">do</span></span><br><span class="line">           <span class="built_in">table</span>.<span class="built_in">insert</span>(info.sortedlines, k)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">sort</span>(info.sortedlines)</span><br><span class="line">    <span class="keyword">elseif</span> level <span class="keyword">then</span>	<span class="comment">-- name和namewhat需要实时获取</span></span><br><span class="line">         <span class="keyword">local</span> nameinfo = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(level + <span class="number">1</span>, <span class="string">&quot;n&quot;</span>)</span><br><span class="line">         info.name = nameinfo.name</span><br><span class="line">         info.namewhat = nameinfo.namewhat</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> info</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>该函数有两个参数，第一个参数就是函数，第二个可选的参数level用于指定在调用栈中的层数，第二个参数只有在钩子函数中时才会指定，返回值就是函数信息。如果在调用<code>debug.getinfo</code>的时候传递函数作为参数，那么是获取不到函数的名字信息的，<code>name</code>和<code>namewhat</code>字段都为空。因为函数可能是任意名字，Lua需要通过查找调用该函数的代码，知道它是怎么被调用的，从而确定函数的名字。所以只有当指定调用栈的层数时才能获取到名字信息。</p>
<p>我们接着看代码的主体部分：</p>
<p>首先尝试去<code>s.funcinfos</code>表中查找是否有缓存的函数信息。如果没有那就只能调用<code>debug.getinfo</code>去获取了，这里分为两种情况，如果指定了<code>level</code>参数，那么就以层数（这里+1同样是为了修正层数，我们在前面多次提到过）作为参数调用，此时第二个参数设置为了<code>&quot;nSL&quot;</code>，比之前多了<code>&quot;L&quot;</code>用于获取有效行号；如果没有指定<code>level</code>参数，则以函数作为参数调用。获取到函数信息之后，为了方便我们后面的行号检查，我们对有效的行号进行了排序，<code>info.sortedlines</code>数组就是排序后的有效行号，然后就返回函数信息<code>info</code>了。</p>
<p>如果缓存中已经有函数信息了，如果本次调用又指定了<code>level</code>参数，那么我们就更新下name信息。调用<code>debug.getinfo</code>获取到信息之后设置到原有的<code>info</code>表中。完成之后同样是返回函数信息<code>info</code>。</p>
<h2 id="检查及修正函数行号"><a href="#检查及修正函数行号" class="headerlink" title="检查及修正函数行号"></a>检查及修正函数行号</h2><p><code>verifyfuncline</code>函数的代码如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">verifyfuncline</span> <span class="params">(info, line)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> info.sortedlines[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> line &lt; info.linedefined <span class="keyword">or</span> line &gt; info.lastlinedefined <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(info.sortedlines) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> v &gt;= line <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>)   <span class="comment">-- impossible to reach here</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>该函数有两个参数，其中第二个行号是可选的。如果没有指定行号，那么直接返回函数的第一个有效行号。如果指定了行号，但是范围超出了函数定义的范围，那么返回<code>nil</code>。如果行号落在函数范围内，那么就遍历已经排好序的有效行号数组，返回碰到的第一个大于等于指定行号的值。</p>
<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>接下来看下钩子函数的修改，因为我们已经封装了<code>getfuncinfo</code>函数，所以钩子函数中也改成用它来获取函数信息。不过这里在调用的时候指定了<code>level</code>从而可以获取到函数名字信息。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span> <span class="params">(event, line)</span></span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">elseif</span> event == <span class="string">&quot;line&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> curfunc = s.stackinfos[s.stackdepth].func</span><br><span class="line">        <span class="keyword">local</span> funcbp = s.funcbpt[curfunc]</span><br><span class="line">        <span class="built_in">assert</span>(funcbp)</span><br><span class="line">        <span class="keyword">if</span> funcbp[line] <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> info = getfuncinfo(curfunc, <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">local</span> prompt = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s (%s)%s %s:%d\n&quot;</span>,</span><br><span class="line">                info.what, info.namewhat, info.name, info.short_src, line)</span><br><span class="line">            <span class="built_in">io</span>.<span class="built_in">write</span>(prompt)</span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">debug</span>()</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>OK，代码修改完了，我们进行测试。</p>
<h2 id="测试有效行排序"><a href="#测试有效行排序" class="headerlink" title="测试有效行排序"></a>测试有效行排序</h2><p>首先测试一下，有效行号排序那块的逻辑。我们编写了一个如下的测试脚本：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">debug</span> = <span class="built_in">require</span> <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">sortlines</span><span class="params">(func)</span></span></span><br><span class="line">    <span class="keyword">local</span> info = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(func, <span class="string">&quot;nSL&quot;</span>)</span><br><span class="line">    info.sortedlines = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(info.activelines) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(k, v)</span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(info.sortedlines, k)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">sort</span>(info.sortedlines)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(info.sortedlines) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(k, v)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">sortlines(foo)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line">sortlines(bar)</span><br></pre></td></tr></table></figure>

<p>我们定义了两个函数foo和bar，其中foo函数的范围为第3行到第9行，有4个有效行4、6、8、9。而bar函数则为特殊的单行函数。</p>
<p>运行脚本，输出如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua sortlines.lua</span><br><span class="line">foo</span><br><span class="line">4	<span class="literal">true</span></span><br><span class="line">9	<span class="literal">true</span></span><br><span class="line">6	<span class="literal">true</span></span><br><span class="line">8	<span class="literal">true</span></span><br><span class="line">1	4</span><br><span class="line">2	6</span><br><span class="line">3	8</span><br><span class="line">4	9</span><br><span class="line">bar</span><br><span class="line">11	<span class="literal">true</span></span><br><span class="line">1	11</span><br></pre></td></tr></table></figure>

<p>foo函数4个有效行没排之前是4、9、6、8，排序之后变成4、6、8、9。bar函数唯一的有效行就是它开始定义的那行。</p>
<h2 id="测试行号检查和自动修正"><a href="#测试行号检查和自动修正" class="headerlink" title="测试行号检查和自动修正"></a>测试行号检查和自动修正</h2><p>编写测试脚本如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(foo)</span><br><span class="line"><span class="built_in">assert</span>(id1 == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">local</span> id2 = setbp(foo, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">assert</span>(id2 == id1)</span><br><span class="line"><span class="keyword">local</span> id3 = setbp(foo, <span class="number">6</span>)</span><br><span class="line"><span class="built_in">assert</span>(id3 == id1)</span><br><span class="line"><span class="keyword">local</span> id4 = setbp(foo, <span class="number">7</span>)</span><br><span class="line"><span class="built_in">assert</span>(id4 == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">local</span> id5 = setbp(foo, <span class="number">8</span>)</span><br><span class="line"><span class="built_in">assert</span>(id5 == id4)</span><br><span class="line"><span class="keyword">local</span> id6 = setbp(foo, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">assert</span>(id6 == <span class="number">3</span>)</span><br><span class="line"><span class="keyword">local</span> id7 = setbp(foo, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">assert</span>(<span class="keyword">not</span> id7)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">rmbp(id1)</span><br><span class="line">rmbp(id4)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">rmbp(id6)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>我们在foo函数上添加了好几个断点，第一个断点行号省略，第二个断点加在了第5行，也就是函数开始定义的行，第三个断点加在了第6行，这是函数第一个有效行。预期前三次添加断点应该都返回同一个断点id，断在第6行。接下来添加的两个断点，第7行不是有效行，第8行是有效行，预期返回同一个断点id，断在第8行。然后在第9行添加了一个断点，因为不是有效行，预期断在第10行。最后一个在第100行设置了一个断点，因为超出了函数的范围，预期设置断点失败返回<code>nil</code>。</p>
<p>设置好断点，先调用一次foo函数，然后删除两个断点，在调用一次foo函数，最后将剩余那个断点删除，再调用一次foo函数。</p>
<p>我们了运行下测试脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua test.lua</span><br><span class="line">invalid line</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:6</span><br><span class="line">lua_debug&gt; </span><br></pre></td></tr></table></figure>

<p>断点的设置都符合预期，最后一个因为行号超出了范围，打了一行错误日志<code>invalid line</code>，程序停在了第6行处。然后我们输入两个<code>cont</code>，程序停在了最后一个断点处。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:6</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:8</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:10</span><br><span class="line">lua_debug&gt; </span><br></pre></td></tr></table></figure>

<p>我们再次输入<code>cont</code>，foo函数运行结束，此时因为前两个断点已经被删除，第二次调用foo函数应该直接停在断点3处，也就是第10行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:6</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:8</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:10</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:10</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>我们再次输入<code>cont</code>，因为最后一个断点也被删除了，所以最后一个执行foo函数没有再碰到断点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua test.lua</span><br><span class="line">invalid line</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:6</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:8</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:10</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:10</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">$</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程开发</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua中如何实现类似gdb的断点调试—07支持通过函数名称添加断点</title>
    <url>/posts/acdf52b7/</url>
    <content><![CDATA[<div class="note primary">
            <p>我们之前已经支持了通过函数来添加断点，并且已经支持了行号的检查和自动修正。但是通过函数来添加断点有一些限制，如果在当前的位置无法访问目标函数，那我们就无法对其添加断点。</p><p>于是，本篇我们将扩展断点设置的接口，支持通过函数名称添加断点，以突破这个限制。</p><span id="more"></span><p>源码已经上传<a href="https://github.com/catbro666/lua-debugger">Github</a>，欢迎watch/star😘。</p>
          </div>



<h2 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h2><p>由于Lua是动态类型语言，变量可以是任何值。而函数在Lua语言中又是第一类值，与其他值一样使用，可以被存放在变量中、作为参数或返回值传递。所以一个函数的名字是不确定的，它可能是任意名字，取决于函数调用时候的变量的名称。</p>
<p>通过下面这个简单的例子，就可以看出来</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">setbp(foo, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> bar = foo</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>

<p>我们在foo函数中添加了一个断点，将foo函数赋值给局部变量bar，然后分别用foo和bar调用函数。运行这个脚本结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua namenotstable.lua</span><br><span class="line">Lua (<span class="built_in">local</span>)foo namenotstable.lua:6</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)bar namenotstable.lua:6</span><br><span class="line">lua_debug&gt; cont</span><br></pre></td></tr></table></figure>

<p>调用<code>foo()</code>和<code>bar()</code>都会碰到断点，函数名称分别为<code>foo</code>和<code>bar</code>。</p>
<p>所以通过函数名称添加的断点并不是确定的，函数名称和函数之间并不是一一映射的关系，而可能是m对n的关系。就算已经匹配到了一个与断点设置的函数名称一致的函数，我们也不能简单地将函数名称断点转换成相应的函数断点，而是仍然需要维护函数名称断点。</p>
<p>因此，我们需要增加一个维护函数名称断点的数据结构—-新的断点表<code>status.namebpt</code>。类似之前在<a href="../2e777dd3/">05优化断点信息数据结构</a>中添加的<code>status.funcbpt</code>表，只是表的键由之前的函数变成了函数名称。<code>status.namebpt</code>表的值同样是一个表，该表的键是断点行号，值为断点id。同样地，为了快速获取断点个数，我们在表中额外加了一个特殊的<code>num</code>字段保存该函数名称中的断点个数。</p>
<p>通过下面的例子来直观地看一下，假设我们的<code>bptable</code>表中添加了两个断点如下（<code>name</code>字段用来保存函数名称）：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">bptable[<span class="number">1</span>] = &#123;name = <span class="string">&quot;foo&quot;</span>, line = <span class="number">10</span>&#125;</span><br><span class="line">bptable[<span class="number">2</span>] = &#123;name = <span class="string">&quot;foo&quot;</span>, line = <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>

<p>对应的在<code>namebpt</code>表中的操作如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">namebpt[<span class="string">&quot;foo&quot;</span>] = &#123;&#125;          <span class="comment">-- 构造表</span></span><br><span class="line">namebpt[<span class="string">&quot;foo&quot;</span>][<span class="number">10</span>] = <span class="number">1</span>	     <span class="comment">-- 函数名foo，行号10，断点id为1</span></span><br><span class="line">namebpt[<span class="string">&quot;foo&quot;</span>].num = <span class="number">1</span>       <span class="comment">-- 该函数第一个断点</span></span><br><span class="line">namebpt[<span class="string">&quot;foo&quot;</span>][<span class="number">20</span>] = <span class="number">2</span>       <span class="comment">-- 函数名foo，行号20，断点id为2</span></span><br><span class="line">namebpt[<span class="string">&quot;foo&quot;</span>].num = namebpt[<span class="string">&quot;foo&quot;</span>].num + <span class="number">1</span>	<span class="comment">-- 断点个数+1</span></span><br></pre></td></tr></table></figure>

<p>OK，分析完了，接下来开始修改相应的代码实现。</p>
<h2 id="添加断点"><a href="#添加断点" class="headerlink" title="添加断点"></a>添加断点</h2><p>按照惯例，我们先修改设置断点函数。因为支持了通过函数名称设置断点，第一个参数需要支持string类型。为了简洁及代码重用，我们将之前通过函数设置断点的操作封装成了<code>setfuncbp</code>函数，另外将通过函数名称设置断点的操作封装成了<code>setnamebp</code>函数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setbreakpoint</span><span class="params">(where, line)</span></span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">type</span>(where) ~= <span class="string">&quot;function&quot;</span> <span class="keyword">and</span> <span class="built_in">type</span>(where) ~= <span class="string">&quot;string&quot;</span>)</span><br><span class="line">        <span class="keyword">or</span> ( line <span class="keyword">and</span> <span class="built_in">type</span>(line) ~= <span class="string">&quot;number&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;invalid parameter\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(where) == <span class="string">&quot;function&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> setfuncbp(where, line)</span><br><span class="line">    <span class="keyword">else</span>            <span class="comment">-- &quot;string&quot;</span></span><br><span class="line">        <span class="keyword">return</span> setnamebp(where, line)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>接下来，来看下<code>setnamebp</code>函数的实现：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setnamebp</span><span class="params">(name, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">local</span> namebp = s.namebpt[name]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line <span class="keyword">then</span>                    <span class="comment">-- 如果没有指定行号</span></span><br><span class="line">        line = <span class="number">0</span>                        <span class="comment">-- 用一个特殊值0来表示第一个有效行</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 是否已经添加了相同的断点</span></span><br><span class="line">    <span class="keyword">if</span> namebp <span class="keyword">and</span> namebp[line] <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> namebp[line]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    s.bpid = s.bpid + <span class="number">1</span></span><br><span class="line">    s.bpnum = s.bpnum + <span class="number">1</span></span><br><span class="line">    s.bptable[s.bpid] = &#123;name = name, line = line&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> namebp <span class="keyword">then</span>                  <span class="comment">-- 该函数名称的第一个断点</span></span><br><span class="line">        s.namebpt[name] = &#123;&#125;</span><br><span class="line">        namebp = s.namebpt[name]</span><br><span class="line">        namebp.num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    namebp.num = namebp.num + <span class="number">1</span></span><br><span class="line">    namebp[line] = s.bpid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s.bpnum == <span class="number">1</span> <span class="keyword">then</span>                <span class="comment">-- 第一个全局断点</span></span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;c&quot;</span>)        <span class="comment">-- 设置钩子函数的&quot;call&quot;事件</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> s.bpid                       <span class="comment">--&gt; 返回断点id</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>因为我们支持不指定行号，但我们并不确定函数的第一个有效行是什么。为了方便地记录断点，又不至于与实际的断点行冲突，我们用了一个特殊值0来表示这种情况。</p>
<p>后续的逻辑与<code>setfuncbp</code>函数基本一致，如果已经添加了相同的断点，则返回之前的断点id。然后分别在<code>bptable</code>表和<code>namebp</code>表中添加断点。这里不再赘述。</p>
<h2 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h2><p>删除断点函数的改动不大。主要是要区分删除的是哪类断点，这个可以通过<code>s.bptable</code>表中<code>id</code>所对应的断点信息来判断。如果有func则说明是通过函数添加的断点，否则则是通过函数名称添加的断点。根据情况删除<code>s.funcbpt</code>或者<code>s.namebpt</code>表中的断点，最后删除<code>s.bptable</code>表中的断点。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">removebreakpoint</span><span class="params">(id)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> s.bptable[id] == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> func = s.bptable[id].func</span><br><span class="line">    <span class="keyword">local</span> name = s.bptable[id].name</span><br><span class="line">    <span class="keyword">local</span> line = s.bptable[id].line</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> dstbp = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">then</span></span><br><span class="line">        dstbp = s.funcbpt[func]</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dstbp = s.namebpt[name]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> dstbp <span class="keyword">and</span> dstbp[line] <span class="keyword">then</span></span><br><span class="line">        dstbp.num = dstbp.num - <span class="number">1</span></span><br><span class="line">        dstbp[line] = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> dstbp.num == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            dstbp = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    s.bptable[id] = <span class="literal">nil</span></span><br><span class="line">    s.bpnum = s.bpnum - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> s.bpnum == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">sethook</span>()                 <span class="comment">-- 移除钩子</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="获取函数信息"><a href="#获取函数信息" class="headerlink" title="获取函数信息"></a>获取函数信息</h2><p>正如前面提到过的，因为函数名称信息是不确定的，所以我们修改了<code>getfuncinfo</code>函数实现，不再缓存函数名称信息，而只缓存确定的函数信息。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">getfuncinfo</span> <span class="params">(func)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">local</span> info = s.funcinfos[func]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> info <span class="keyword">then</span></span><br><span class="line">        info = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(func, <span class="string">&quot;SL&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (info.activelines) <span class="keyword">then</span></span><br><span class="line">            info.sortedlines = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> k, _ <span class="keyword">in</span> <span class="built_in">pairs</span>(info.activelines) <span class="keyword">do</span></span><br><span class="line">               <span class="built_in">table</span>.<span class="built_in">insert</span>(info.sortedlines, k)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="built_in">table</span>.<span class="built_in">sort</span>(info.sortedlines)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        s.funcinfos[func] = info</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> info</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>钩子函数的改动主要是在call事件。函数名称每次都根据调用栈实时获取。首先在函数断点表<code>s.funcbpt</code>中查找当前函数是否有断点，如果没有则再去函数名称断点表<code>s.namebpt</code>中查找。需要检查断点行号是否在当前函数的定义范围之内，只有当行号在范围之内才认为匹配。如果没有指定行号的话（默认为第一个有效行），则总是认为匹配。另外，在调用栈信息表中，分别将确定的函数信息<code>funcinfo</code>和调用栈相关信息<code>stackinfo</code>分别保存，以供return事件和line事件时使用。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span> <span class="params">(event, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail call&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> stackinfo = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>, <span class="string">&quot;nf&quot;</span>)</span><br><span class="line">        <span class="keyword">local</span> func = stackinfo.func</span><br><span class="line">        <span class="keyword">local</span> name = stackinfo.name</span><br><span class="line">        <span class="keyword">local</span> funcinfo = getfuncinfo(func)</span><br><span class="line">        <span class="keyword">local</span> hasbreak = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> s.funcbpt[func] <span class="keyword">then</span></span><br><span class="line">            hasbreak = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasbreak <span class="keyword">and</span> s.namebpt[name] <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> <span class="built_in">min</span> = funcinfo.linedefined</span><br><span class="line">            <span class="keyword">local</span> <span class="built_in">max</span> = funcinfo.lastlinedefined</span><br><span class="line">            <span class="keyword">for</span> k, _ <span class="keyword">in</span> <span class="built_in">pairs</span>(s.namebpt[name]) <span class="keyword">do</span></span><br><span class="line">                <span class="keyword">if</span> k ~= <span class="string">&quot;num&quot;</span> <span class="keyword">and</span> ((k &gt;= <span class="built_in">min</span> <span class="keyword">and</span> k &lt;= <span class="built_in">max</span>) <span class="keyword">or</span> k == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                    hasbreak = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">then</span>     <span class="comment">-- for tail call, just overwrite</span></span><br><span class="line">            s.stackdepth = s.stackdepth + <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        s.stackinfos[s.stackdepth] =</span><br><span class="line">            &#123;stackinfo = stackinfo, funcinfo = funcinfo, hasbreak = hasbreak&#125;</span><br><span class="line">        <span class="comment">-- found breakpoint in current function</span></span><br><span class="line">        <span class="keyword">if</span> hasbreak <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;crl&quot;</span>)	<span class="comment">-- add &quot;line&quot; event</span></span><br><span class="line">        <span class="keyword">else</span>        <span class="comment">-- no breakpoints found</span></span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;cr&quot;</span>)   <span class="comment">-- remove &quot;line&quot; event temporarily</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> event == <span class="string">&quot;return&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail return&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>line事件也需要做相应的修改</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span> <span class="params">(event, line)</span></span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">elseif</span> event == <span class="string">&quot;line&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> sinfo = s.stackinfos[s.stackdepth].stackinfo</span><br><span class="line">        <span class="keyword">local</span> finfo = s.stackinfos[s.stackdepth].funcinfo</span><br><span class="line">        <span class="keyword">local</span> func = sinfo.func</span><br><span class="line">        <span class="keyword">local</span> name = sinfo.name</span><br><span class="line">        <span class="keyword">local</span> funcbp = s.funcbpt[func]</span><br><span class="line">        <span class="keyword">local</span> namebp = s.namebpt[name]</span><br><span class="line">        <span class="keyword">if</span> (funcbp <span class="keyword">and</span> funcbp[line]) <span class="keyword">or</span> (namebp <span class="keyword">and</span> namebp[line])</span><br><span class="line">            <span class="keyword">or</span> (namebp <span class="keyword">and</span> namebp[<span class="number">0</span>] <span class="keyword">and</span> line == finfo.sortedlines[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> prompt = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s (%s)%s %s:%d\n&quot;</span>,</span><br><span class="line">                finfo.what, sinfo.namewhat, name, finfo.short_src, line)</span><br><span class="line">            <span class="built_in">io</span>.<span class="built_in">write</span>(prompt)</span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">debug</span>()</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在判断当前行是否有断点时，除了查看<code>funcbpt</code>表，还需要查看<code>namebpt</code>表，对于函数名称断点没有指定行号的情况，判断当前行是不是第一个有效行。打印提示信息时，则从<code>stackinfos</code>表中保存的信息中获取。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>代码修改好了，我们来测试下通过函数名称添加断点的功能。编写如下测试脚本：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">pee</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(foo)</span><br><span class="line"><span class="keyword">local</span> id2 = setbp(foo, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id3 = setbp(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> id4 = setbp(<span class="string">&quot;bar&quot;</span>, <span class="number">11</span>)</span><br><span class="line"><span class="keyword">local</span> id5 = setbp(<span class="string">&quot;bar&quot;</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id6 = setbp(pee)</span><br><span class="line"><span class="keyword">local</span> id7 = setbp(<span class="string">&quot;pee&quot;</span>, <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">bar()</span><br><span class="line">pee()</span><br><span class="line"></span><br><span class="line">rmbp(id1)</span><br><span class="line">rmbp(id3)</span><br><span class="line">rmbp(id6)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">bar()</span><br><span class="line">pee()</span><br><span class="line"></span><br><span class="line">rmbp(id2)</span><br><span class="line">rmbp(id4)</span><br><span class="line">rmbp(id7)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">bar()</span><br><span class="line">pee()</span><br></pre></td></tr></table></figure>

<p>我们添加了三个函数，其中foo函数以函数作为参数添加断点，bar函数以函数名称作为参数添加断点，pee函数分别用函数和函数名添加了一个断点。添加完断点，先分别调用一次，预期每个函数都会碰到两个断点。接着三个函数各删除一个断点，再各调用一次，预期每个函数都会碰到一个断点。最后三个函数再各删除一个断点，再各调用一次，预期不碰到断点。</p>
<p>运行测试脚本，结果符合预期。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua test.lua</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:6</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:7</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)bar test.lua:10</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)bar test.lua:11</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)pee test.lua:14</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)pee test.lua:15		<span class="comment"># 第一次调用，每个函数碰到两个断点</span></span><br><span class="line">lua_debug&gt; cont					</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:7</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)bar test.lua:11</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)pee test.lua:15		<span class="comment"># 第二次调用，每个函数碰到一个断点</span></span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">$								<span class="comment"># 第三次调用，不再碰到断点</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程开发</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL及GMVPN握手协议详解</title>
    <url>/posts/59c71edb/</url>
    <content><![CDATA[<div class="note primary">
            <p>之前写过一篇关于<a href="../e92ef4b4">SSL协议的文章</a>，主要介绍了加密学的基础，并从整体上对SSL协议做了介绍。由于篇幅原因，SSL握手的详细流程没有深入介绍。本文将拆解握手流程，在消息级别对握手进行详细地介绍。还没有加密学基本概念的、或者不清楚SSL协议的基本情况的建议先看一下前面一篇的内容。另外，本文主要是针对TLSv1.2和GMVPN的情况，对于TLSv1.3暂不涉及。</p>
          </div>

<span id="more"></span>



<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>本文将分如下几个部分展开，其中密钥交换和身份认证部分会着重进行讲解。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/59c71edb/SSL%E6%8F%A1%E6%89%8B%E9%80%BB%E8%BE%91%E5%9B%BE-%E6%A1%86%E6%9E%B6.png" alt="SSL握手逻辑图-框架" loading="lazy"></p>
<p>我们都知道SSL协议最主要的作用就是用来协商通信双方的安全参数，然后基于协商的安全参数进行安全通信。所以首当其冲地，第一个要解决的问题就是如何进行密钥交换。考虑到对称密码和非对称密码的性能差异显著，在实际使用中往往使用对称密码对数据进行加密，而使用非对称密码来完成重要的密钥交换和身份认证。</p>
<h3 id="基本握手流程"><a href="#基本握手流程" class="headerlink" title="基本握手流程"></a>基本握手流程</h3><p>下图是一个我们通常看到的SSL握手流程图，SSL协议分为两个阶段：握手阶段和应用阶段。握手阶段主要负责协商安全参数，应用阶段则基于前面协商的安全参数进行数据通信。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/59c71edb/SSL%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%96%B0-%E5%9F%BA%E6%9C%AC.png" alt="SSL协议流程图新-基本" loading="lazy"></p>
<p>这里先不对每个消息进行详细的介绍，后面的内容中会陆续涉及到。其中带*号的表示可选消息或者根据前面消息的情况而定。ChangeCipherSpec作为单独的一类消息只是表明握手协议已经完成，后续使用协商的加密参数进行通信。Finished消息就是第一个加密的消息，用于验证握手已经顺利完成。这里稍微提一下ServerHelloDone这个消息，这个消息并没有什么实际的内容，它存在的主要原因就是因为前面的消息CertificateRequest是可选的，所以需要明确地告诉客户端服务端这边的消息发完了，否则客户端无从知道是否该等待CertificateRequest消息。</p>
<h2 id="如何进行密钥交换"><a href="#如何进行密钥交换" class="headerlink" title="如何进行密钥交换"></a>如何进行密钥交换</h2><p>密钥交换的方法可以分成两大类：一类是基于加密、一类是基于DH。前者有RSA算法、GM的ECC算法；后者则有ECDHE、GM的ECDHE。</p>
<p>虽然前面一篇已经讲过了，这里还是稍微带一下这两者的基本原理，以方便在后面实际的握手流程中进行对照。</p>
<h3 id="密钥交换原理"><a href="#密钥交换原理" class="headerlink" title="密钥交换原理"></a>密钥交换原理</h3><p>公钥加密的基本原理如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Public_key_encryption.svg" alt="Public_key_encryption" loading="lazy"></p>
<p>公钥密码有两个密钥，其中一个是公开密钥，公开密钥可以随意传播，另一个是私有密钥，需要自己严密保管。比如Bob要发消息给Alice，Bob用Alice的公钥对消息进行加密，然后发送给Alice，Alice则用自己的私钥进行解密。</p>
<p>DH类算法的原理可以用下图来形象地解释：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Diffie-Hellman_Key_Exchange.svg" alt="Diffie-Hellman_Key_Exchange" loading="lazy"></p>
<p>首先双方协商一个相同的底色（算法参数），然后各自生成自己私有的颜色（相当于私钥），并通过混合得到对应的公有颜色（相当于公钥）。随后双方交换各自的公有颜色，并与自己的私钥颜色混合，最终协商出一个相同的颜色（即交换的密钥）。窃听者就算得到了双方交换的这些信息，也无法生成相同的密钥，<strong>求解离散对象问题的困难度</strong>保证了DH算法的安全性。</p>
<h3 id="TLS-RSA密钥交换"><a href="#TLS-RSA密钥交换" class="headerlink" title="TLS RSA密钥交换"></a>TLS RSA密钥交换</h3><p>这种情况的典型算法套件是AES256-SHA。（相关的消息都已经标成蓝色了，连到消息块上的实线箭头表示该消息中带了相应的内容。）</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/59c71edb/SSL%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%96%B0-RSA%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2.png" alt="SSL协议流程图新-RSA密钥交换" loading="lazy"></p>
<p>这种情况比较简单，首先客户端生成一个随机数在ClientHello消息中带过去，服务端同样也生成一个随机数在ServerHello消息中带过去。然后服务端在Certificate消息中将它的证书发送给客户端，证书中包含了它的公钥。客户端收到之后就用服务端的公钥加密一个随机生成的预主密钥，通过ClientKeyExchange消息发送给服务端，服务端则用自己的私钥进行解密得到预主密钥。这里就是应用了前面提到的公钥加密的原理。</p>
<p>通过密钥交换之后，双方都得到了预主密钥，再加上前面交换的两个随机数，这3个材料一起进行密钥派生得到主密钥。主密钥再结合两个随机数派生出最终的会话密钥。</p>
<p>这里先抛出几个问题供大家思考。为什么不直接用预主密钥，而是要跟两个随机数派生出主密钥？为什么不直接用主密钥，而是再跟两个随机数派生出会话密钥？我暂时不做解答，留到后面分解。</p>
<h3 id="TLS-ECDHE密钥交换"><a href="#TLS-ECDHE密钥交换" class="headerlink" title="TLS ECDHE密钥交换"></a>TLS ECDHE密钥交换</h3><p>这个情况的典型算法套件如ECDHE-RSA-AES256-GCM-SHA384、ECDHE-ECDSA-AES256-GCM-SHA384。这里的EC表示椭圆曲线，DH表示基于DH算法，最后一个E则表示使用临时密钥进行密钥交换，而不是证书相关的非临时密钥。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/59c71edb/SSL%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%96%B0-ECDHE%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2.png" alt="SSL协议流程图新-ECDHE密钥交换" loading="lazy"></p>
<p>我们来比较下跟前一种情况的区别，首先ClientHello和ServerHello消息是一样的，都带了一个随机数。区别在于服务端是通过ServerKeyExchange消息发送了一个临时DH参数给对方（也就是前面将DH原理时的公有颜色），类似地客户端也通过ClientKeyExchange消息把它的临时DH参数发送给服务端。这样双方就交换了彼此的临时DH公钥，然后他们各自利用自己的临时私钥和对方的临时公钥计算出预主密钥。与前一种情况的最大区别就在于此，前者是客户端加密预主密钥发送给服务端，后者是双方交换临时DH公钥，然后各自计算出预主密钥。</p>
<p>得到预主密钥后，后续的流程就一样了。结合两个随机数派生出主密钥，然后再派生出会话密钥。</p>
<h3 id="GM-ECC密钥交换"><a href="#GM-ECC密钥交换" class="headerlink" title="GM ECC密钥交换"></a>GM ECC密钥交换</h3><p>接下来我们看GM ECC密钥交换的情况，这种情况的典型算法套件为ECC-SM4-SM3。GMVPN协议一个最大的区别就是它引入了双证书体系，每一方都有两个证书（对应地就有两个私钥），一个加密证书负责进行密钥交换，一个签名证书负责进行身份认证。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/59c71edb/SSL%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%96%B0-%E5%9B%BD%E5%AF%86ECC%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2.png" alt="SSL协议流程图新-国密ECC密钥交换" loading="lazy"></p>
<p>跟TLS RSA密钥交换的主要区别是，这种情况的证书消息中包含了双证书，客户端在加密预主密钥时是用服务端加密证书中的公钥。相应地，服务端在解密时则用自己的加密私钥。后续的密钥派生流程都是一样的，这里就不再赘述了。</p>
<p>至于GM为什么要引入双证书，是因为这样你的加密私钥就在CA那里有留档，必要时它就可以解密你的消息。Big brother is watching you!</p>
<h3 id="GM-ECDHE密钥交换"><a href="#GM-ECDHE密钥交换" class="headerlink" title="GM ECDHE密钥交换"></a>GM ECDHE密钥交换</h3><p>这种情况的典型算法套件为ECDHE-SM4-SM3。同样是双证书，ServerKeyExchange消息中带了服务端的临时DH参数，客户端也将双证书以及它的临时DH参数发送给服务端。注意到在计算预主密钥时，有4个材料参与了运算，对方加密证书中的公钥以及临时公钥，自己的加密私钥以及临时私钥，由这4个材料一起计算出预主密钥。作为对比，普通TLS的ECDHE只有自己的临时私钥和对方的临时公钥参与计算。</p>
<p>GM ECDHE最大的区别就在于此，所以GM ECDHE的算法套件必须是双向认证的，因为在密钥交换时也需要客户端的加密证书参与。从这里也可以看出GM协议在设计上的不严谨，哪有算法套件只允许双向认证的。而且GM ECDHE因为也有临时密钥参与计算预主密钥，所以就算CA有加密私钥也是无法解密的，这又与双证书的最初目的相悖。。。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/59c71edb/SSL%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%96%B0-%E5%9B%BD%E5%AF%86ECDHE%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2-5776669.png" alt="SSL协议流程图新-国密ECDHE密钥交换" loading="lazy"></p>
<h3 id="TLS1-2-密钥派生流程"><a href="#TLS1-2-密钥派生流程" class="headerlink" title="TLS1.2 密钥派生流程"></a>TLS1.2 密钥派生流程</h3><p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/59c71edb/TLS1.2_KeyCalculation.png" alt="TLS1.2_KeyCalculation" loading="lazy"></p>
<p>密钥派生的流程前面其实已经画出来了，基于加密或者DH双方交换得到预主密钥，预主密钥结合两个随机数派生得到主密钥，TLS1.2中派生是通过PRF进行的，其中secret就是预主密钥，label是一个特定的字符串，seed是前面的两个随机数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">master_secret = PRF(pre_master_secret, &quot;master secret&quot;,</span><br><span class="line">                   ClientHello.random + ServerHello.random)</span><br><span class="line">                   [0..47];</span><br></pre></td></tr></table></figure>

<p>得到主密钥之后在结合两个随机数派生出会话密钥，同样使用PRF，不过此时secret是主密钥，label字符串不同，seed还是两个随机数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key_block = PRF(SecurityParameters.master_secret,</span><br><span class="line">                     &quot;key expansion&quot;,</span><br><span class="line">                     SecurityParameters.server_random +</span><br><span class="line">                     SecurityParameters.client_random);</span><br></pre></td></tr></table></figure>

<p>得到会话密钥之后，再按照需要切分成MAC key和对称加密的key。图中把IV画成了虚线，因为TLS1.2中一般不需要这个。因为自从TLS1.1改成显式IV之后（为了防止CBC明文选择攻击），iv都是在记录中显式带过去的，只有当使用AEAD算法，需要隐式nonce时还需需要这个。</p>
<p>至于前面抛出的两个问题，为什么不直接用预主密钥？一方面是为了统一长度，因为基于加密的密钥交换预主密钥时48字节，而基于DH的密钥交换预主密钥长度取决于具体的算法。更重要的一点，双方的随机数加入计算，可以防重放攻击，还可以增加随机数的熵源，增加安全性。</p>
<p>那么为什么不直接用主密钥，还要再次派生出会话密钥呢？这个主要是生命周期的考虑，两者有不同生命周期，主密钥的生命周期较长，会话密钥则较短，只在当前会话有效。后面在讲session重用时就可以看出其区别。</p>
<h2 id="如何进行身份认证"><a href="#如何进行身份认证" class="headerlink" title="如何进行身份认证"></a>如何进行身份认证</h2><p>前面讨论了如何进行密钥交换，但是密钥交换只管协商出密钥，并不考虑对方是谁？你如何确认对方的身份，防止被中间人攻击呢？所以就引入了身份认证。</p>
<p>身份认证需要解决两个问题：</p>
<ul>
<li>确认对方拥有公钥对应的私钥</li>
<li>确认对方的身份</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/59c71edb/SSL%E6%8F%A1%E6%89%8B%E9%80%BB%E8%BE%91%E5%9B%BE-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81.png" alt="SSL握手逻辑图-身份认证" loading="lazy"></p>
<p>第一个问题，使用单纯的数字签名就可以解决。通过验证对方的数字签名，可以确认对方拥有相应的私钥。</p>
<p>而第二个问题，则需要引入数字证书和PKI了。数字证书，说白了就是将一个公钥跟身份信息进行绑定，然后由第三方可信机构（CA）给你做个证明（通过CA签名）。那么CA本身的身份又由谁来证明呢，再通过更上级的CA进行证明。最终的根CA只能通过其他手段进行认证，否则就无限循环了。</p>
<h3 id="数字签名原理"><a href="#数字签名原理" class="headerlink" title="数字签名原理"></a>数字签名原理</h3><p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Private_key_signing.svg" alt="Private_key_signing" loading="lazy"></p>
<p>数字签名的基本原理也很简单，与前面的公钥加密相对，这里是使用私钥对数据进行签名，对方则用公钥对签名数据进行验签。</p>
<h3 id="TLS-RSA密钥交换时的RSA认证"><a href="#TLS-RSA密钥交换时的RSA认证" class="headerlink" title="TLS RSA密钥交换时的RSA认证"></a>TLS RSA密钥交换时的RSA认证</h3><p>典型算法套件仍然是AES256-SHA。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/59c71edb/SSL%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%96%B0-RSA%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2RSA%E8%AE%A4%E8%AF%81.png" alt="SSL协议流程图新-RSA密钥交换RSA认证" loading="lazy"></p>
<p>服务端的认证只涉及Certificate消息，服务端把证书和CA证书链发送给客户端，客户端只需要对证书和证书链进行验证。最终的Root CA需要是本机信任的，否则就存在安全风险，可能受到中间人攻击。</p>
<p>如果需要双向认证，即服务端也需要认证客户端，还涉及图中橙色的3个消息。服务端会发送CertificateRequest消息，告诉客户端支持的证书类型、签名哈希算法、以及CA的DN项。客户端根据这些信息选择适合的客户端证书，然后在Certificate消息中将证书和CA证书链发送给服务端，另外还需要用自己的私钥做一个签名，以证明自己拥有证书对应的私钥。这里签名的内容是前面所有的握手消息（从ClientHello开始到当前消息之前的所有消息）。然后服务端对客户端的证书链以及签名进行验证。</p>
<h3 id="TLS-ECDHE密钥交换时的认证"><a href="#TLS-ECDHE密钥交换时的认证" class="headerlink" title="TLS ECDHE密钥交换时的认证"></a>TLS ECDHE密钥交换时的认证</h3><p>典型算法套件如ECDHE-RSA-AES256-GCM-SHA384、ECDHE-ECDSA-AES256-GCM-SHA384。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/59c71edb/SSL%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%96%B0-ECDHE%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%9A%84%E8%AE%A4%E8%AF%81.png" alt="SSL协议流程图新-ECDHE密钥交换的认证" loading="lazy"></p>
<p>跟前一种情况下比，服务端多了一个签名。因为这种情况密钥交换是通过临时DH参数完成的，并没有服务端证书对应的私钥参与，所以需要用证书对应的私钥额外做一个签名，以证明自己确实拥有证书对应私钥。这里签名的内容是两个hello随机数以及服务端的临时DH参数，其实就是参与计算预主密钥的三个材料。</p>
<p>客户端除了验证证书链之外，还需要对这个签名进行验证。</p>
<p>客户端认证的部分跟前一种情况完全一样，不再进行赘述。</p>
<h3 id="GM-ECC密钥交换时的认证"><a href="#GM-ECC密钥交换时的认证" class="headerlink" title="GM ECC密钥交换时的认证"></a>GM ECC密钥交换时的认证</h3><p>典型算法套件还是ECC-SM4-SM3。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/59c71edb/SSL%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%96%B0-%E5%9B%BD%E5%AF%86ECC%E8%AE%A4%E8%AF%81.png" alt="SSL协议流程图新-国密ECC认证" loading="lazy"></p>
<p>前面TLS RSA的情况，服务端不需要做一个额外的签名。因为密钥交换和身份认证都是通过同一个证书来进行的，服务端能够完成密钥交换（解密出预主密钥）就已经说明了它有对应的私钥。</p>
<p>而GM ECC则则不然，因为双证书的关系，密钥交换和身份认证是通过不同证书进行的。所以服务端仍然需要做一个签名证明其私钥持有性。签名是通过签名私钥来进行的，签名的内容有所改变，是两个hello随机数和服务端的加密证书。客户端除了验证证书链，还需要用服务端的签名证书对签名进行验证。</p>
<p>客户端认证的流程还是类似，只不过发送的也是双证书，然后在签名时也是用的签名私钥。服务端除了验证证书链，还需要用客户端的签名证书对签名进行验证。</p>
<h3 id="GM-ECDHE密钥交换时的认证"><a href="#GM-ECDHE密钥交换时的认证" class="headerlink" title="GM ECDHE密钥交换时的认证"></a>GM ECDHE密钥交换时的认证</h3><p>典型算法套件还是ECDHE-SM4-SM3。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/59c71edb/SSL%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%96%B0-%E5%9B%BD%E5%AF%86ECDHE%E8%AE%A4%E8%AF%81.png" alt="SSL协议流程图新-国密ECDHE认证" loading="lazy"></p>
<p>跟前一种情况相比，主要是服务端的签名内容有一点区别，是两个hello随机数+服务端的临时DH参数。我们注意到前面几种情况，服务端签名的内容都是参与计算预主密钥的材料。从这个逻辑上来说，这边在协议设计上也有些问题，因为服务端的加密证书实际上也参与了密钥交换，按照协议设计一致性也应该包含到签名内容中。</p>
<p>其他部分跟前一种情况完全一样，不再进行赘述。</p>
<h2 id="如何协商协议算法"><a href="#如何协商协议算法" class="headerlink" title="如何协商协议算法"></a>如何协商协议算法</h2><p>前面讨论了几种不同的情况，可以看到不同的协议版本、不同的算法套件，它们在握手的处理流程上是不一样的，那么双方如何对此达成一致呢？</p>
<p>于是就需要引入一次Hello交互了。这也是为什么完整的SSL握手需要两次交互的主要原因。通过这次Hello交互对使用的协议版本和算法套件达成一致。另外得益于SSL协议引入的扩展机制，不仅仅是协议版本算法套件，双方还可以协商除此之外的很多东西，甚至是用户自定义的扩展项。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/59c71edb/SSL%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%96%B0-%E5%8D%8F%E5%95%86%E5%8D%8F%E8%AE%AE%E7%AE%97%E6%B3%95.png" alt="SSL协议流程图新-协商协议算法" loading="lazy"></p>
<p>不过最基本的还是协议版本、算法套件之类的。客户端发送它支持的版本、算法套件列表、如果是椭圆曲线还会指定支持的曲线列表、签名算法等，服务端基于客户端的信息，选择最终使用的协议版本、算法套件、EC点格式等。</p>
<h2 id="如何提升性能"><a href="#如何提升性能" class="headerlink" title="如何提升性能"></a>如何提升性能</h2><p>完整的SSL握手需要两个RTT，而且还需要耗时的非对称运算。协议在设计上也考虑了如何提升性能的问题。在握手流程优化方面，主要就是通过会话重用来简化握手流程。（对于TLSv1.3则有PSK、1-RTT和0-RTT，不过本文将不涉及TLS1.3，）这里主要介绍下会话重用的情况。</p>
<h3 id="会话重用基本流程"><a href="#会话重用基本流程" class="headerlink" title="会话重用基本流程"></a>会话重用基本流程</h3><p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/59c71edb/SSL%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%96%B0-%E4%BC%9A%E8%AF%9D%E9%87%8D%E7%94%A8%E5%9F%BA%E6%9C%AC.png" alt="SSL协议流程图新-会话重用基本" loading="lazy"></p>
<p>会话重用的基本流程如上所示。首先是一个完整的握手，然后客户端如果想重用前面的会话，在ClientHello进行相应的指示告诉服务端，服务端如果同意在ServerHello中进行答复，然后就直接进行简化的握手，不需要再进行密钥交换和身份认证。不但省了一次交互，也省去了费时的非对称运算。</p>
<h3 id="Session-ID"><a href="#Session-ID" class="headerlink" title="Session ID"></a>Session ID</h3><p>会话重用有两种方式，首先来看下Session ID的流程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/59c71edb/SSL%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%96%B0-%E4%BC%9A%E8%AF%9D%E9%87%8D%E7%94%A8SessionID.png" alt="SSL协议流程图新-会话重用SessionID" loading="lazy"></p>
<p>前一次握手中，服务端在ServerHello消息中将Session ID告诉客户端，握手正常完成之后，服务端会将对应的Session保存，其中就包含了主密钥。</p>
<p>后续客户端想要重用之前那个Session，可以在ClientHello中带上之前的Session ID，服务端收到之后会根据Session ID进行查找，如果找到了且未过期，那么进行会话重用，服务端将Session ID再原样发送给客户端，进入简化的握手流程；否则，服务端还是随机生成新的Session ID发送给客户端，回退到完整的握手流程。</p>
<p>会话重用时，使用之前Session的主密钥来推导会话密钥。这里就可以看出其生命周期的不同了，会话重用时主密钥是用的同一个，但是会话密钥每次都是重新生成的。而且注意到，这时也是有两个随机数参与密钥派生的，同样也是出于防重放的考虑。</p>
<h3 id="Session-Ticket"><a href="#Session-Ticket" class="headerlink" title="Session Ticket"></a>Session Ticket</h3><p>前一种情况服务端需要保存 session cache，会消耗内存资源，如果是集群的话还会带来cache同步的问题。而session ticket的出现正是为了解决这些问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/59c71edb/SSL%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%96%B0-%E4%BC%9A%E8%AF%9D%E9%87%8D%E7%94%A8SessionTicket.png" alt="SSL协议流程图新-会话重用SessionTicket" loading="lazy"></p>
<p>我们来看下它的流程，首先客户端在ClientHello的扩展中带上session_ticket扩展表示它想使用session_ticket功能，服务端如果同意则在ServerHello中回复session_ticket扩展项。服务端不用保存session，而是加密之后通过NewSessionTicket消息发送给客户端。这里session ticket key实际上是个对称密钥，它只有服务端自己知道。</p>
<p>后续客户端想要重用该Session，在ClientHello扩展中把之前那个session_ticket塞进去，服务端成功解密且验证通过之后就进行会话重用，否则回退到完整的握手。然后还是同样地根据主密钥重新派生出会话密钥。</p>
<p>这样服务端没有了保存session的负担，但是天下没有免费的午餐，session ticket对前向安全性会带来一定的损害。因为session ticket只是单纯使用session ticket key进行加密的，如果session ticket key泄漏了，那么之前基于会话重用的握手就都可以被破解了。</p>
<p>所以在实际使用时，session ticket key应该经常更换，减小前向安全性方面的风险。</p>
<h2 id="如何保证安全性"><a href="#如何保证安全性" class="headerlink" title="如何保证安全性"></a>如何保证安全性</h2><p>简单回顾来握手中是如何保证安全性的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/59c71edb/SSL%E6%8F%A1%E6%89%8B%E9%80%BB%E8%BE%91%E5%9B%BE-%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E6%80%A7.png" alt="SSL握手逻辑图-保证安全性" loading="lazy"></p>
<p>首先通过两个hello随机数来实现防重放。防止中间人攻击是通过对服务端的认证了完成的。防篡改是通过最后的Finished来完成的，Finished消息中包含了一个verify_data，它也是由PRF计算得到的，其中的seed是前面所有握手消息（ClientHello开始，到当前Finished消息前）的摘要值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verify_data: </span><br><span class="line">PRF(master_secret, finished_label, </span><br><span class="line">    Hash(handshake_messages))</span><br><span class="line">            [0..verify_data_length-1];</span><br></pre></td></tr></table></figure>

<p>前向安全性也是需要特别注意的点，事实上TLS1.3中砍掉了所有没有前向安全性的算法套件，只留下了DHE或ECDHE的算法套件。另外前面也提到了session ticket也会对前向安全性有一定的损害。</p>
<p>最后，要特别强调下随机数的重要性。一个好的加密算法，其安全性完全是基于密钥的安全性，如果随机数本身质量不过关，比如可以被预测，那么前面所有的一切都是白忙活。随机数可以说是所有这些的基石。</p>
<p>最后的最后，安全领域其实也适用木桶理论，一个通信的安全性取决于其最薄弱的环节。无论是协议设计、代码实现还是在用户使用上，任何一处纰漏都可能导致巨大的安全问题。</p>
]]></content>
      <categories>
        <category>加密与安全</category>
      </categories>
      <tags>
        <tag>SSL/TLS</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX环境高级编程APUE练习3.2-不用fcntl实现dup2的功能</title>
    <url>/posts/2485f370/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>编写与<code>dup2</code>功能相同的函数，要求不调用<code>fcntl</code>函数，并且要有正确的出错处理。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>不能用<code>fcntl</code>，能够返回一个文件描述符的只有<code>open</code>和<code>dup</code>。而<code>open</code>会创建一个新的文件表项，返回的fd指向新的文件表项，与<code>dup2</code>的表现不符。<code>dup</code>基本能满足要求，但是返回的是最小的可用fd，需要进一步操作满足要求。另外需要自己添加错误处理，以及处理oldfd与newfd相等的情况等。具体地，</p>
<span id="more"></span>

<ol>
<li>当dup返回出错时，直接返回出错</li>
<li>当dup返回值等于newfd时，直接返回</li>
<li>当dup返回值小于newfd时，记录返回值，循环调用dup直到返回值等于newfd。关闭前面记录的所有fd，返回newfd</li>
<li>当dup返回值大于newfd时，关闭返回值的fd。如果oldfd等于newfd，直接返回newfd;如果不相等，关掉newfd，然后再dup（因为不是原子的，返回值需要再判断）</li>
</ol>
<h2 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h2><ol>
<li>oldfd的出错处理可以直接交给dup</li>
<li>newfd的出错处理，需要判断是否超出文件描述符范围(<code>RLIMIT_NOFILE</code> in getrlimit)</li>
<li>对于dup返回EMFILE的情况，newfd如果没超过进程可打开的最大文件数，则不影响</li>
<li>另外还有一个判断顺序问题，是先判断参数是否合法还是oldfd==newfd, 这个可以根据dup2函数实测来确定</li>
</ol>
<h2 id="4-测试用例"><a href="#4-测试用例" class="headerlink" title="4 测试用例"></a>4 测试用例</h2><h3 id="进程打开的文件数没满的情况下"><a href="#进程打开的文件数没满的情况下" class="headerlink" title="进程打开的文件数没满的情况下"></a>进程打开的文件数没满的情况下</h3><ol>
<li>都超出范围，相同（MAX+1，MAX+1）</li>
<li>未打开描述符，相同 (100, 100)</li>
<li>newfd超出范围 (1, MAX+1)</li>
<li>newfd正好没超出 (1, MAX)</li>
<li>oldfd和newfd相同 (2, 2)</li>
</ol>
<h3 id="进程打开的文件数满的情况下"><a href="#进程打开的文件数满的情况下" class="headerlink" title="进程打开的文件数满的情况下"></a>进程打开的文件数满的情况下</h3><ol>
<li>newfd正好超出范围 (1, MAX+1)</li>
<li>newfd正好没超出 (1, MAX)</li>
<li>oldfd和newfd相同 (2, 2)</li>
</ol>
<h2 id="5-开始撸码实测"><a href="#5-开始撸码实测" class="headerlink" title="5 开始撸码实测"></a>5 开始撸码实测</h2><h3 id="5-1-先验证dup2的判断顺序问题"><a href="#5-1-先验证dup2的判断顺序问题" class="headerlink" title="5.1 先验证dup2的判断顺序问题"></a>5.1 先验证dup2的判断顺序问题</h3><ul>
<li>测试源码</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">old_rlim</span>=</span>&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    getrlimit(RLIMIT_NOFILE, &amp;old_rlim);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NOFILE limits: soft=%lld; hard=%lld\n&quot;</span>,</span><br><span class="line">                   (<span class="keyword">long</span> <span class="keyword">long</span>) old_rlim.rlim_cur, (<span class="keyword">long</span> <span class="keyword">long</span>) old_rlim.rlim_max);</span><br><span class="line"></span><br><span class="line">    r = dup2(<span class="number">10000</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2(10000, 10000) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2(10000, 10000) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2(100, 100) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2(100, 100) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2(1, 10000) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2(1, 10000) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2(1, 100) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2(1, 100) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>MAC OSX下运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ./a.out</span><br><span class="line">NOFILE limits: soft=7168; hard=9223372036854775807</span><br><span class="line">dup2(10000, 10000) fail: : Bad file descriptor</span><br><span class="line">dup2(100, 100) fail: : Bad file descriptor</span><br><span class="line">dup2(1, 10000) fail: : Bad file descriptor</span><br><span class="line">dup2(1, 100) success return 100</span><br></pre></td></tr></table></figure>

<p>可见是参数出错判断是先于oldfd == newfd判断的</p>
<h3 id="5-2-测试进程打开的最大文件数到上限时，dup2是否能成功"><a href="#5-2-测试进程打开的最大文件数到上限时，dup2是否能成功" class="headerlink" title="5.2 测试进程打开的最大文件数到上限时，dup2是否能成功"></a>5.2 测试进程打开的最大文件数到上限时，dup2是否能成功</h3><ul>
<li>测试源码</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> max_fd = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">old_rlim</span>=</span>&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    getrlimit(RLIMIT_NOFILE, &amp;old_rlim);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NOFILE limits: soft=%lld; hard=%lld\n&quot;</span>,</span><br><span class="line">                   (<span class="keyword">long</span> <span class="keyword">long</span>) old_rlim.rlim_cur, (<span class="keyword">long</span> <span class="keyword">long</span>) old_rlim.rlim_max);</span><br><span class="line">    <span class="keyword">while</span>((r = dup(<span class="number">0</span>))!= <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        max_fd = r;</span><br><span class="line">    &#125;</span><br><span class="line">    perror(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max fd is %d\n&quot;</span>, max_fd);</span><br><span class="line"></span><br><span class="line">    r = dup2(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2(1, 10000) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2(1, 10000) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2(1, 100) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2(1, 100) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>MAC OSX下运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ./a.out</span><br><span class="line">NOFILE limits: soft=7168; hard=9223372036854775807</span><br><span class="line">Too many open files</span><br><span class="line">max fd is 7167</span><br><span class="line">dup2(1, 7168) fail: : Bad file descriptor</span><br><span class="line">dup2(1, 7167) success return 7167</span><br></pre></td></tr></table></figure>

<p>可见在进程打开文件数达到上限时，dup2替换已经打开的文件是可以的</p>
<h3 id="5-3-实现dup2的功能"><a href="#5-3-实现dup2的功能" class="headerlink" title="5.3 实现dup2的功能"></a>5.3 实现dup2的功能</h3><ul>
<li>源码</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*dup实现dup2的功能*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2_</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">7168</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">old_rlim</span>=</span>&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    getrlimit(RLIMIT_NOFILE, &amp;old_rlim);</span><br><span class="line">    <span class="keyword">if</span> (newfd &lt; <span class="number">0</span> || newfd &gt; old_rlim.rlim_cur - <span class="number">1</span>) &#123;</span><br><span class="line">        errno = EBADF;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        ret = dup(oldfd);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno != EMFILE) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno == EMFILE) &#123;</span><br><span class="line">            <span class="keyword">if</span>(oldfd == newfd) &#123;</span><br><span class="line">                <span class="keyword">return</span> newfd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;close(newfd)\n&quot;</span>);</span><br><span class="line">            close(newfd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(oldfd == newfd) &#123;</span><br><span class="line">                close(ret);</span><br><span class="line">                <span class="keyword">return</span> newfd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ret == newfd) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ret &lt; newfd) &#123;</span><br><span class="line">                <span class="built_in">stack</span>[count++] = ret;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                close(ret);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;close(newfd)\n&quot;</span>);</span><br><span class="line">                close(newfd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(count) &#123;</span><br><span class="line">        close(<span class="built_in">stack</span>[--count]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r, max_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">old_rlim</span>=</span>&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    getrlimit(RLIMIT_NOFILE, &amp;old_rlim);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NOFILE limits: soft=%lld; hard=%lld\n&quot;</span>,</span><br><span class="line">                   (<span class="keyword">long</span> <span class="keyword">long</span>) old_rlim.rlim_cur, (<span class="keyword">long</span> <span class="keyword">long</span>) old_rlim.rlim_max);</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">7168</span>, <span class="number">7168</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(7168, 7168) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(7168, 7168) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(100, 100) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(100, 100) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">1</span>, <span class="number">7168</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(1, 7168) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(1, 7168) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">1</span>, <span class="number">7167</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(1, 7167) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(1, 7167) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(2, 2) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(2, 2) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((r = dup(<span class="number">0</span>))!= <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        max_fd = r;</span><br><span class="line">    &#125;</span><br><span class="line">    perror(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max fd is %d\n&quot;</span>, max_fd);</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">1</span>, <span class="number">7168</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(1, 7168) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(1, 7168) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">1</span>, <span class="number">7167</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(1, 7167) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(1, 7167) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(2, 2) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(2, 2) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>MAC OSX下的运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NOFILE limits: soft=7168; hard=9223372036854775807</span><br><span class="line">dup2_(7168, 7168) fail: : Bad file descriptor</span><br><span class="line">dup2_(100, 100) fail: : Bad file descriptor</span><br><span class="line">dup2_(1, 7168) fail: : Bad file descriptor</span><br><span class="line">dup2_(1, 7167) success return 7167</span><br><span class="line">dup2_(2, 2) success return 2</span><br><span class="line">Too many open files</span><br><span class="line">max fd is 7167</span><br><span class="line">dup2_(1, 7168) fail: : Bad file descriptor</span><br><span class="line">close(newfd)</span><br><span class="line">dup2_(1, 7167) success return 7167</span><br><span class="line">close(newfd)</span><br><span class="line">dup2_(1, 100) success return 100</span><br><span class="line">dup2_(2, 2) success return 2</span><br></pre></td></tr></table></figure>

<p>结果都符合预期</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Unix环境编程</category>
      </categories>
      <tags>
        <tag>Unix</tag>
        <tag>dup2</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX环境高级编程APUE练习4.6-实现类似cp(1)的程序，保留文件中的空洞</title>
    <url>/posts/aa99fc97/</url>
    <content><![CDATA[<h2 id="1-题面"><a href="#1-题面" class="headerlink" title="1 题面"></a>1 题面</h2><p>编写类似<code>cp(1)</code>的程序，它复制包含空洞的文件，但是不将字节0写到输出文件中去。</p>
<h2 id="2-基本思路"><a href="#2-基本思路" class="headerlink" title="2 基本思路"></a>2 基本思路</h2><ul>
<li>首先要搞清楚空洞的性质以判断一个文件是否有空洞，以及空洞的位置</li>
<li>知道了空洞的位置之后，读到源文件中的空洞部分时，在目标文件中<code>lseek</code>相应的长度</li>
</ul>
<span id="more"></span>

<h2 id="3-创建空洞文件，同时探索空洞性质"><a href="#3-创建空洞文件，同时探索空洞性质" class="headerlink" title="3 创建空洞文件，同时探索空洞性质"></a>3 创建空洞文件，同时探索空洞性质</h2><p>交替<code>lseek</code>和<code>write</code>，逐渐增大间隔长度。比较文件的大小和实际占用的block数目</p>
<ul>
<li>测试源码</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> holesize[]=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>, <span class="number">4096</span>, <span class="number">8192</span>, <span class="number">16384</span>, <span class="number">32</span>*<span class="number">1024</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> filesize = <span class="number">64</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, fd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">32</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">32</span>*<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">1</span>, <span class="number">32</span>*<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">for</span> (; i&lt; <span class="keyword">sizeof</span>(holesize)/ <span class="keyword">sizeof</span>(<span class="keyword">int</span>); ++i) &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(filename, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(filename, <span class="string">&quot;%s%d&quot;</span>, <span class="string">&quot;holesize&quot;</span>, holesize[i]);</span><br><span class="line">        fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;open file fail\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; filesize) &#123;</span><br><span class="line">            ret = lseek(fd, holesize[i], SEEK_CUR);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;lseek fail\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> remain = holesize[i];</span><br><span class="line">            <span class="keyword">while</span>(remain) &#123;</span><br><span class="line">                ret = write(fd, buf, remain);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;write fail\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                remain -= ret;</span><br><span class="line">            &#125;</span><br><span class="line">            count += holesize[i] * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>MAC OSX 10.1.4.6测试结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ll -s</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize1</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize1024</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize128</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize16</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize16384</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize2</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize2048</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize256</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize32</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize32768</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize4</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize4096</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize512</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize64</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize8</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize8192</span><br></pre></td></tr></table></figure>

<p>Mac OSX上创建不了空洞文件，因为默认的文件系统是HFS +，不支持稀疏文件</p>
<ul>
<li>Ubuntu18 4.15.0-60-generic测试结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ll -s</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize1</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize1024</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize128</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize16</span><br><span class="line">32 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize16384</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize2</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize2048</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize256</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize32</span><br><span class="line">32 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize32768</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize4</span><br><span class="line">32 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize4096</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize512</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize64</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize8</span><br><span class="line">32 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize8192</span><br></pre></td></tr></table></figure>

<p>4KB以上才实际创建空洞。<br>因为在linux的文件系统中，磁盘分配的最小物理单元为簇。(即使文件大小不足以占用满一簇，该簇空余的磁盘存储仍旧是该文件的)</p>
<p>所以可以根据这个性质，判断文件是否是空洞文件。有空洞的文件，用文件大小计算的block数至少比实际占用的block数大1个簇的block数</p>
<h2 id="如何可移植地获取簇的大小"><a href="#如何可移植地获取簇的大小" class="headerlink" title="如何可移植地获取簇的大小"></a>如何可移植地获取簇的大小</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pagesize = sysconf(_SC_PAGESIZE);</span><br></pre></td></tr></table></figure>

<h2 id="初步实现功能"><a href="#初步实现功能" class="headerlink" title="初步实现功能"></a>初步实现功能</h2><ul>
<li>源码</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_cp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1 = <span class="number">-1</span>, fd2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> rev = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *start_pos = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">long</span> pagesize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> blocks, blksize, size;</span><br><span class="line">    <span class="keyword">int</span> read_num, write_num, remain_num, current_pos = <span class="number">0</span>, last_zero = <span class="number">-1</span>, last_nonzero = <span class="number">-1</span>, have_holes = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    fd1 = open(from, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fd1)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open file1 faild&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fstat(fd1, &amp;st) !=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat: &quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SC_PAGESIZE</span></span><br><span class="line">        pagesize = sysconf(_SC_PAGESIZE);</span><br><span class="line">        <span class="keyword">if</span> (pagesize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EINVAL) &#123;</span><br><span class="line">                    <span class="built_in">fputs</span>(<span class="string">&quot; (not supported)\n&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">                    pagesize = st.st_blksize;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    perror(<span class="string">&quot;sysconf error&quot;</span>);</span><br><span class="line">                    <span class="keyword">goto</span> err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">&quot; (no limit)\n&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">                pagesize = st.st_blksize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pagesize: %ld\n&quot;</span>, pagesize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        pagesize = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        blocks = st.st_blocks;</span><br><span class="line">        blksize = st.st_blksize;</span><br><span class="line">        size = st.st_size;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st.st_blocks: %lld\n&quot;</span>, blocks);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st.st_blksize: %lld\n&quot;</span>, blksize);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st.st_size: %lld\n&quot;</span>, size);</span><br><span class="line">        <span class="comment">/*块大小512，在不同平台上可能不兼容*/</span></span><br><span class="line">        <span class="keyword">if</span>(S_ISREG(st.st_mode) &amp;&amp; (size / pagesize + (size%pagesize?<span class="number">1</span>:<span class="number">0</span>)) * pagesize &gt; <span class="number">512</span> * blocks) &#123;</span><br><span class="line">            have_holes = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s is a sparse-block file!\n&quot;</span>, from);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            have_holes = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s is not a sparse-block file!\n&quot;</span>, from);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fd2 = open(to, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">-1</span> == fd2) &#123;</span><br><span class="line">        perror (<span class="string">&quot;open file2 faild&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer = <span class="built_in">malloc</span>(pagesize);</span><br><span class="line">    <span class="keyword">if</span>(buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror (<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, pagesize);</span><br><span class="line">    <span class="keyword">while</span>((read_num = read(fd1, buffer, pagesize)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 源文件有空洞 */</span></span><br><span class="line">        <span class="keyword">if</span>(have_holes)&#123;</span><br><span class="line">            last_zero = <span class="number">-1</span>;</span><br><span class="line">            last_nonzero = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(current_pos = <span class="number">0</span>; current_pos &lt; read_num; current_pos++)&#123;</span><br><span class="line">                <span class="comment">/* 逐字节判断，效率较低*/</span></span><br><span class="line">                <span class="keyword">if</span>(buffer[current_pos] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(last_nonzero &gt; last_zero)&#123;</span><br><span class="line">                        remain_num = last_nonzero - last_zero;</span><br><span class="line">                        start_pos = buffer + last_zero + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">while</span>(remain_num)&#123;</span><br><span class="line">                            write_num = write(fd2, start_pos, remain_num);</span><br><span class="line">                            <span class="keyword">if</span> ( <span class="number">-1</span> == write_num)&#123;</span><br><span class="line">                                perror( <span class="string">&quot;write file2 error&quot;</span>);</span><br><span class="line">                                <span class="keyword">goto</span> err;</span><br><span class="line">                            &#125;</span><br><span class="line">                            remain_num -= write_num;</span><br><span class="line">                            start_pos += write_num;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    last_zero = current_pos;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(last_zero &gt; last_nonzero)&#123;</span><br><span class="line">                        remain_num = last_zero - last_nonzero;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="number">-1</span> == lseek(fd2, remain_num, SEEK_CUR))&#123;</span><br><span class="line">                            perror(<span class="string">&quot;lseek file2 fail&quot;</span>);</span><br><span class="line">                            <span class="keyword">goto</span> err;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    last_nonzero = current_pos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 处理最后剩余数据*/</span></span><br><span class="line">            remain_num = (last_nonzero &gt; last_zero)?(last_nonzero - last_zero):(last_zero - last_nonzero);</span><br><span class="line">            start_pos = buffer + current_pos - remain_num;</span><br><span class="line">            <span class="keyword">if</span>(last_nonzero &gt; last_zero)&#123;</span><br><span class="line">                <span class="keyword">while</span>(remain_num)&#123;</span><br><span class="line">                    write_num = write(fd2, start_pos, remain_num);</span><br><span class="line">                    <span class="keyword">if</span> ( <span class="number">-1</span> == write_num)&#123;</span><br><span class="line">                        perror( <span class="string">&quot;write file2 error&quot;</span>);</span><br><span class="line">                        <span class="keyword">goto</span> err;</span><br><span class="line">                    &#125;</span><br><span class="line">                        remain_num -= write_num;</span><br><span class="line">                        start_pos += write_num;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">-1</span> == lseek(fd2, remain_num, SEEK_CUR))&#123;</span><br><span class="line">                    perror(<span class="string">&quot;lseek file2 fail&quot;</span>);</span><br><span class="line">                    <span class="keyword">goto</span> err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 源文件无空洞 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            remain_num = read_num;</span><br><span class="line">            start_pos = buffer;</span><br><span class="line">            <span class="keyword">while</span>(remain_num)&#123;</span><br><span class="line">                write_num = write(fd2, start_pos, remain_num);</span><br><span class="line">                <span class="keyword">if</span> ( <span class="number">-1</span> == write_num)&#123;</span><br><span class="line">                    perror( <span class="string">&quot;write file2 error&quot;</span>);</span><br><span class="line">                    <span class="keyword">goto</span> err;</span><br><span class="line">                &#125;</span><br><span class="line">                remain_num -= write_num;</span><br><span class="line">                start_pos += write_num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == read_num) &#123;</span><br><span class="line">        perror(<span class="string">&quot;read file1 error&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    rev = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span>(buffer) <span class="built_in">free</span>(buffer);</span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s file1 file2\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    my_cp(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>测试结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ./my_cp holesize2048 holesize2048.cp</span><br><span class="line">pagesize: 4096</span><br><span class="line">st.st_blocks: 128</span><br><span class="line">st.st_blksize: 4096</span><br><span class="line">st.st_size: 65536</span><br><span class="line">holesize2048 is not a sparse-block file!</span><br><span class="line">chen@ubuntu18:~/study/apue.3e/exercises/4</span><br><span class="line">^_^$ ./my_cp holesize4096 holesize4096.cp</span><br><span class="line">pagesize: 4096</span><br><span class="line">st.st_blocks: 72</span><br><span class="line">st.st_blksize: 4096</span><br><span class="line">st.st_size: 65536</span><br><span class="line">holesize4096 is a sparse-block file!</span><br><span class="line"></span><br><span class="line">^_^$ ll -s</span><br><span class="line">total 1708</span><br><span class="line">64 -rw-r--r-- 1 chen chen  65536 1月   6 17:27 holesize2048</span><br><span class="line">64 -rw-r--r-- 1 chen chen  65536 1月   6 17:27 holesize2048.cp</span><br><span class="line">36 -rw-r--r-- 1 chen chen  65536 1月   6 17:27 holesize4096</span><br><span class="line">32 -rw-r--r-- 1 chen chen  65536 1月   6 17:27 holesize4096.cp</span><br></pre></td></tr></table></figure>

<p>空洞文件可以正常拷贝</p>
<h2 id="尝试优化程序"><a href="#尝试优化程序" class="headerlink" title="尝试优化程序"></a>尝试优化程序</h2><p>上面的程序仅在判断文件是否含有空洞时利用的空洞的最小限制。而在实际读写时并没有利用该性质。</p>
<p>这样较短的0字节也会当成是空洞，导致系统调用次数的增加，性能的降低</p>
<p>要优化性能，必须进一步探究空洞的性质。在什么样的情况下才创建空洞(不实际占用磁盘空间的块)？</p>
<ul>
<li>测试程序源码</li>
</ul>
<p>此程序创建了3个文件：</p>
<pre><code>- 文件1先`write`了1K的非零数据，然后`lseek` 7K-1字节。循环2次。
- 文件2先`write`了1K的非零数据，然后`lseek` 7K字节。循环2次
- 文件3先`write`了1K的非零数据，然后`lseek` 7K+1字节。循环2次
</code></pre>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> holesize[]=&#123;<span class="number">4096</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> filesize = <span class="number">64</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, fd1 = <span class="number">0</span>, fd2 = <span class="number">0</span>, fd3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> filename1[<span class="number">32</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> filename2[<span class="number">32</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> filename3[<span class="number">32</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">32</span>*<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">1</span>, <span class="number">32</span>*<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">for</span> (; i&lt; <span class="keyword">sizeof</span>(holesize)/ <span class="keyword">sizeof</span>(<span class="keyword">int</span>); ++i) &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(filename1, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">        <span class="built_in">memset</span>(filename2, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">        <span class="built_in">memset</span>(filename3, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(filename1, <span class="string">&quot;%s%d-1&quot;</span>, <span class="string">&quot;holesize&quot;</span>, holesize[i]);</span><br><span class="line">        <span class="built_in">sprintf</span>(filename2, <span class="string">&quot;%s%d-2&quot;</span>, <span class="string">&quot;holesize&quot;</span>, holesize[i]);</span><br><span class="line">        <span class="built_in">sprintf</span>(filename3, <span class="string">&quot;%s%d-3&quot;</span>, <span class="string">&quot;holesize&quot;</span>, holesize[i]);</span><br><span class="line">        fd1 = open(filename1, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">        fd2 = open(filename2, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">        fd3 = open(filename3, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">        <span class="keyword">if</span>(fd1 &lt; <span class="number">0</span> || fd2 &lt; <span class="number">0</span> || fd3 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;open file fail\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> remain = holesize[i] * <span class="number">1</span> / <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">while</span>(remain) &#123;</span><br><span class="line">                ret = write(fd1, buf, remain);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;write fail\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                remain -= ret;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = lseek(fd1, holesize[i] * <span class="number">7</span> / <span class="number">4</span> - <span class="number">1</span>, SEEK_CUR);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;lseek fail\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> remain = holesize[i] * <span class="number">1</span> / <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">while</span>(remain) &#123;</span><br><span class="line">                ret = write(fd2, buf, remain);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;write fail\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                remain -= ret;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = lseek(fd2, holesize[i] * <span class="number">7</span> / <span class="number">4</span>, SEEK_CUR);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;lseek fail\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> remain = holesize[i] * <span class="number">1</span> / <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">while</span>(remain) &#123;</span><br><span class="line">                ret = write(fd3, buf, remain);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;write fail\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                remain -= ret;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = lseek(fd3, holesize[i] * <span class="number">7</span> / <span class="number">4</span> + <span class="number">1</span>, SEEK_CUR);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;lseek fail\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd1);</span><br><span class="line">        close(fd2);</span><br><span class="line">        close(fd3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>测试结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ll -s</span><br><span class="line">12 -rw-r--r-- 1 chen chen  9215 1月   6 15:07 holesize4096-1</span><br><span class="line"> 8 -rw-r--r-- 1 chen chen  9216 1月   6 15:07 holesize4096-2</span><br><span class="line"> 8 -rw-r--r-- 1 chen chen  9217 1月   6 15:07 holesize4096-3</span><br></pre></td></tr></table></figure>

<p>可见空洞必须从一页的起始位置开始计算,并且等于或超过pagesize，才不占用实际磁盘空间</p>
<h2 id="优化后程序"><a href="#优化后程序" class="headerlink" title="优化后程序"></a>优化后程序</h2><ul>
<li>源码</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read_ex</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbyte)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> read_remain = nbyte;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *read_start = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf;</span><br><span class="line">    <span class="keyword">ssize_t</span> read_num = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> total_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(read_remain) &#123;</span><br><span class="line">        read_num = read(fd, read_start, read_remain);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == read_num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == read_num)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            read_remain -= read_num;</span><br><span class="line">            read_start += read_num;</span><br><span class="line">            total_num += read_num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write_ex</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbyte)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> write_remain = nbyte;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *write_start = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf;</span><br><span class="line">    <span class="keyword">ssize_t</span> write_num = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> total_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(write_remain) &#123;</span><br><span class="line">        write_num = write(fd, write_start, write_remain);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == write_num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            write_remain -= write_num;</span><br><span class="line">            write_start += write_num;</span><br><span class="line">            total_num += write_num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total_num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_cp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1 = <span class="number">-1</span>, fd2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> rev = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer = <span class="literal">NULL</span>, *buffer_zero = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">long</span> pagesize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> blocks, blksize, size;</span><br><span class="line">    <span class="keyword">int</span> read_num, write_num, write_remain, have_holes = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    fd1 = open(from, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fd1)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open file1 faild&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fstat(fd1, &amp;st) !=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat: &quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SC_PAGESIZE</span></span><br><span class="line">        pagesize = sysconf(_SC_PAGESIZE);</span><br><span class="line">        <span class="keyword">if</span> (pagesize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EINVAL) &#123;</span><br><span class="line">                    <span class="built_in">fputs</span>(<span class="string">&quot; (not supported)\n&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">                    pagesize = st.st_blksize;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    perror(<span class="string">&quot;sysconf error&quot;</span>);</span><br><span class="line">                    <span class="keyword">goto</span> err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">&quot; (no limit)\n&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">                pagesize = st.st_blksize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pagesize: %ld\n&quot;</span>, pagesize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        pagesize = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        blocks = st.st_blocks;</span><br><span class="line">        blksize = st.st_blksize;</span><br><span class="line">        size = st.st_size;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st.st_blocks: %lld\n&quot;</span>, blocks);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st.st_blksize: %lld\n&quot;</span>, blksize);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st.st_size: %lld\n&quot;</span>, size);</span><br><span class="line">        <span class="comment">/*块大小512，在不同平台上可能不兼容*/</span></span><br><span class="line">        <span class="keyword">if</span>(S_ISREG(st.st_mode) &amp;&amp; (size / pagesize + (size%pagesize?<span class="number">1</span>:<span class="number">0</span>)) * pagesize &gt; <span class="number">512</span> * blocks) &#123;</span><br><span class="line">            have_holes = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s is a sparse-block file!\n&quot;</span>, from);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            have_holes = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s is not a sparse-block file!\n&quot;</span>, from);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer = <span class="built_in">malloc</span>(pagesize);</span><br><span class="line">    buffer_zero = <span class="built_in">malloc</span>(pagesize);</span><br><span class="line">    <span class="keyword">if</span>(buffer == <span class="literal">NULL</span> || buffer_zero == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror (<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, pagesize);</span><br><span class="line">    <span class="built_in">memset</span>(buffer_zero, <span class="string">&#x27;\0&#x27;</span>, pagesize);</span><br><span class="line"></span><br><span class="line">    fd2 = open(to, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fd2) &#123;</span><br><span class="line">        perror (<span class="string">&quot;open file2 faild&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((read_num = read_ex(fd1, buffer, pagesize)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 读取到空洞 */</span></span><br><span class="line">        <span class="keyword">if</span>(have_holes &amp;&amp; !<span class="built_in">memcmp</span>(buffer_zero, buffer, read_num))&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">-1</span> == lseek(fd2, read_num, SEEK_CUR))&#123;</span><br><span class="line">                perror(<span class="string">&quot;lseek file2 fail&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 非空洞 */</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            write_num = write_ex(fd2, buffer, read_num);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">-1</span> == write_num)&#123;</span><br><span class="line">                perror( <span class="string">&quot;write file2 error&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == read_num)&#123;</span><br><span class="line">        perror(<span class="string">&quot;read file1 error&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    rev = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span>(buffer) <span class="built_in">free</span>(buffer);</span><br><span class="line">    <span class="keyword">if</span>(buffer_zero) <span class="built_in">free</span>(buffer_zero);</span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s file1 file2\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    my_cp(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>对比测试</li>
</ul>
<p>构造一个文件，除了开头一个空洞，其余数据为0x00,0x01的100000次重复</p>
<p>用优化前的程序拷贝该文件10000次，大约2000s</p>
<p>用优化后的程序拷贝该文件10000次，大约30s</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Unix环境编程</category>
      </categories>
      <tags>
        <tag>Unix</tag>
        <tag>cp</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现Lua--实现TAILCALL指令</title>
    <url>/posts/74970c0e/</url>
    <content><![CDATA[<div class="note primary">
            <p>最近在看《自己动手实现Lua—虚拟机、编译器和标准库》。这是本挺不错的书，通过学习此书能够对Lua语言有比较深刻的理解，此外还可以对如何自己实现一门脚本语言有直观的认识。对于想学习Lua的同学，安利一下这本书。</p><p>废话不多说，书中留了一个作业，让读者自己实现<code>TAILCALL</code>指令，实现尾调用的优化。本文就算是交作业吧。</p>
          </div>

<span id="more"></span>

<h1 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h1><p>尾调用，被调函数可以重用主调函数的调用帧，可以有效缓解调用栈溢出。</p>
<p>不过尾调用的条件非常苛刻，必须是直接返回函数调用。下面的是一个尾调用的例子，<code>TAILCALL</code>指令后面肯定紧跟着<code>RETURN</code>指令，并且<code>RETURN</code>指令的操作数A跟<code>TAILCALL</code>相同，<code>RETURN</code>指令的操作数B肯定是0。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ luac -l -</span><br><span class="line"><span class="built_in">return</span> f(a)</span><br><span class="line">^D</span><br><span class="line">main &lt;stdin:0,0&gt; (5 instructions at 0x7fa2b9d00070)</span><br><span class="line">0+ params, 2 slots, 1 upvalue, 0 locals, 2 constants, 0 <span class="built_in">functions</span></span><br><span class="line">	1	[1]	GETTABUP 	0 0 -1	; _ENV <span class="string">&quot;f&quot;</span></span><br><span class="line">	2	[1]	GETTABUP 	1 0 -2	; _ENV <span class="string">&quot;a&quot;</span></span><br><span class="line">	3	[1]	TAILCALL 	0 2 0</span><br><span class="line">	4	[1]	RETURN   	0 0</span><br><span class="line">	5	[1]	RETURN   	0 1</span><br></pre></td></tr></table></figure>



<p>下面几个例子，都不是尾调用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ luac -l -</span><br><span class="line"><span class="built_in">return</span> (f(a))</span><br><span class="line">^D</span><br><span class="line">main &lt;stdin:0,0&gt; (5 instructions at 0x7fb5a34035e0)</span><br><span class="line">0+ params, 2 slots, 1 upvalue, 0 locals, 2 constants, 0 <span class="built_in">functions</span></span><br><span class="line">	1	[1]	GETTABUP 	0 0 -1	; _ENV <span class="string">&quot;f&quot;</span></span><br><span class="line">	2	[1]	GETTABUP 	1 0 -2	; _ENV <span class="string">&quot;a&quot;</span></span><br><span class="line">	3	[1]	CALL     	0 2 2</span><br><span class="line">	4	[1]	RETURN   	0 2</span><br><span class="line">	5	[1]	RETURN   	0 1</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ luac -l -</span><br><span class="line"><span class="built_in">return</span> f(a)+1</span><br><span class="line">^D</span><br><span class="line">main &lt;stdin:0,0&gt; (6 instructions at 0x7f98c3d00070)</span><br><span class="line">0+ params, 2 slots, 1 upvalue, 0 locals, 3 constants, 0 <span class="built_in">functions</span></span><br><span class="line">	1	[1]	GETTABUP 	0 0 -1	; _ENV <span class="string">&quot;f&quot;</span></span><br><span class="line">	2	[1]	GETTABUP 	1 0 -2	; _ENV <span class="string">&quot;a&quot;</span></span><br><span class="line">	3	[1]	CALL     	0 2 2</span><br><span class="line">	4	[1]	ADD      	0 0 -3	; - 1</span><br><span class="line">	5	[1]	RETURN   	0 2</span><br><span class="line">	6	[1]	RETURN   	0 1</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ luac -l -</span><br><span class="line"><span class="built_in">return</span> &#123;f(a)&#125;</span><br><span class="line">^D</span><br><span class="line">main &lt;stdin:0,0&gt; (7 instructions at 0x7fb1b95006f0)</span><br><span class="line">0+ params, 3 slots, 1 upvalue, 0 locals, 2 constants, 0 <span class="built_in">functions</span></span><br><span class="line">	1	[1]	NEWTABLE 	0 0 0</span><br><span class="line">	2	[1]	GETTABUP 	1 0 -1	; _ENV <span class="string">&quot;f&quot;</span></span><br><span class="line">	3	[1]	GETTABUP 	2 0 -2	; _ENV <span class="string">&quot;a&quot;</span></span><br><span class="line">	4	[1]	CALL     	1 2 0</span><br><span class="line">	5	[1]	SETLIST  	0 0 1	; 1</span><br><span class="line">	6	[1]	RETURN   	0 2</span><br><span class="line">	7	[1]	RETURN   	0 1</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ luac -l -</span><br><span class="line"><span class="built_in">return</span> 1, f(a)</span><br><span class="line">^D</span><br><span class="line">main &lt;stdin:0,0&gt; (6 instructions at 0x7f8f9c500070)</span><br><span class="line">0+ params, 3 slots, 1 upvalue, 0 locals, 3 constants, 0 <span class="built_in">functions</span></span><br><span class="line">	1	[1]	LOADK    	0 -1	; 1</span><br><span class="line">	2	[1]	GETTABUP 	1 0 -2	; _ENV <span class="string">&quot;f&quot;</span></span><br><span class="line">	3	[1]	GETTABUP 	2 0 -3	; _ENV <span class="string">&quot;a&quot;</span></span><br><span class="line">	4	[1]	CALL     	1 2 0</span><br><span class="line">	5	[1]	RETURN   	0 0</span><br><span class="line">	6	[1]	RETURN   	0 1</span><br></pre></td></tr></table></figure>



<h1 id="CALL指令"><a href="#CALL指令" class="headerlink" title="CALL指令"></a>CALL指令</h1><p>我们先来看看普通的<code>CALL</code>指令的操作流程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1))</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">call</span><span class="params">(i Instruction, vm LuaVM)</span></span> &#123;</span><br><span class="line">    a, b, c := i.ABC()</span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// println(&quot;:::&quot;+ vm.StackToString())</span></span><br><span class="line">    nArgs := _pushFuncAndArgs(a, b, vm)</span><br><span class="line">    vm.Call(nArgs, c<span class="number">-1</span>)</span><br><span class="line">    _popResults(a, c, vm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先将位于寄存器中的函数和参数推入栈顶，然后调用<code>Call()</code>方法执行函数，最后将栈上的返回值出栈并放入指定寄存器中。</p>
<p><code>_pushFuncAndArgs()</code>和<code>_popResults()</code>分别要处理操作数B和操作数C为0的特殊情况。操作数B为0的情况，部分参数已经在栈上了（由前面的<code>CALL</code>指令或<code>VARARG</code>指令留在栈上）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">pushFuncAndArgs</span><span class="params">(a, b <span class="keyword">int</span>, vm LuaVM)</span> <span class="params">(nArgs <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b &gt;= <span class="number">1</span> &#123;</span><br><span class="line">        vm.CheckStack(b)</span><br><span class="line">        <span class="keyword">for</span> i := a; i &lt; a+b; i++ &#123;</span><br><span class="line">            vm.PushValue(i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _fixStack(a, vm)</span><br><span class="line">        <span class="keyword">return</span> vm.GetTop() - vm.RegisterCount() - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而操作数C为0的情况，则不需要将返回值从栈上弹出。直接将返回值留在栈上，供后面的指令使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">popResults</span><span class="params">(a, c <span class="keyword">int</span>, vm LuaVM)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// no results</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> c &gt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := a + c - <span class="number">2</span>; i &gt;= a; i-- &#123;</span><br><span class="line">            vm.Replace(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// leave results on stack</span></span><br><span class="line">        vm.CheckStack(<span class="number">1</span>)</span><br><span class="line">        vm.PushInteger(<span class="keyword">int64</span>(a))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们来看下<code>Call()</code>方法做了什么。它首先根据索引找到要调用的函数的值，检查它是否是闭包类型，如果不是直接报错。然后通过<code>callLuaClosure()</code>调用该函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [-(nargs+1), +nresults, e]</span></span><br><span class="line"><span class="comment">// http://www.lua.org/manual/5.3/manual.html#lua_call</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *luaState)</span> <span class="title">Call</span><span class="params">(nArgs, nResults <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    val := self.stack.get(-(nArgs + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">if</span> c, ok := val.(*closure); ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;call %s&lt;%d,%d&gt;\n&quot;</span>, c.proto.Source,</span><br><span class="line">            c.proto.LineDefined, c.proto.LastLineDefined)</span><br><span class="line">        self.callLuaClosure(nArgs, nResults, c)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;not function!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>callLuaClosure()</code>稍微有点复杂，来看下代码。首先从闭包的函数原型中获取到各种信息，如寄存器个数、固定参数个数、是否是vararg。接着创建一个新的调用帧，并将闭包与调用帧关联。然后将函数和参数值全部从主调帧栈顶弹出，并将固定参数压入被调帧栈顶，如果是vararg且参数个数大于固定参数个数，还要将vararg参数记录下来。</p>
<p>到这新帧就准备就绪了，将新帧推入调用栈顶，然后调用<code>runLuaClosure()</code>开始执行被调函数的指令。执行结束之后，被调帧的任务结束，将其弹出调用栈顶。</p>
<p>此时，返回值还留在被调帧的栈顶，需要移到主调帧栈顶。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *luaState)</span> <span class="title">callLuaClosure</span><span class="params">(nArgs, nResults <span class="keyword">int</span>, c *closure)</span></span> &#123;</span><br><span class="line">    nRegs := <span class="keyword">int</span>(c.proto.MaxStackSize)</span><br><span class="line">    nParams := <span class="keyword">int</span>(c.proto.NumParams)</span><br><span class="line">    isVararg := c.proto.IsVararg == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// create new lua stack</span></span><br><span class="line">    newStack := newLuaStack(nRegs + <span class="number">20</span>)</span><br><span class="line">    newStack.closure = c</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass args, pop func</span></span><br><span class="line">    funcAndArgs := self.stack.popN(nArgs + <span class="number">1</span>)</span><br><span class="line">    newStack.pushN(funcAndArgs[<span class="number">1</span>:], nParams)</span><br><span class="line">    newStack.top = nRegs</span><br><span class="line">    <span class="keyword">if</span> nArgs &gt; nParams &amp;&amp; isVararg &#123;</span><br><span class="line">        newStack.varargs = funcAndArgs[nParams+<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run closure</span></span><br><span class="line">    self.pushLuaStack(newStack)</span><br><span class="line">    self.runLuaClosure()</span><br><span class="line">    self.popLuaStack()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return results, nResults == c - 1</span></span><br><span class="line">    <span class="keyword">if</span> nResults != <span class="number">0</span> &#123;</span><br><span class="line">        results := newStack.popN(newStack.top - nRegs)</span><br><span class="line">        self.stack.check(<span class="built_in">len</span>(results))</span><br><span class="line">        self.stack.pushN(results, nResults)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现TAILCALL指令"><a href="#实现TAILCALL指令" class="headerlink" title="实现TAILCALL指令"></a>实现TAILCALL指令</h1><p>知道了<code>CALL</code>指令的流程，我们就可以着手实现<code>TAILCALL</code>指令了。其操作数A和操作数B的含义跟<code>CALL</code>指令完全一致，操作数C没用，相当于固定为0。所以<code>_pushFuncAndArgs()</code>和<code>_popResults()</code>函数可以重用，主要是修改中间的调用流程。我们首先给LuaVM新增一个接口<code>TailCall()</code>。</p>
<p>在<code>api/lua_vm.go</code>文件中添加如下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LuaVM <span class="keyword">interface</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    TailCall(nArgs <span class="keyword">int</span>)	<span class="comment">// add this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>因为<code>TAILCALL</code>指令后面紧跟着<code>RETURN</code>指令，且<code>RETURN</code>指令的操作数B为0，操作数A跟<code>TAILCALL</code>指令一样。所以<code>_popResults()</code>之后，我们啥都不用干，直接把返回值保留在栈上即可。</p>
<p>在<code>vm/inst_call.go</code>文件中修改<code>tailCall()</code>如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// return R(A)(R(A+1), ... ,R(A+B-1))</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tailCall</span><span class="params">(i Instruction, vm LuaVM)</span></span> &#123;</span><br><span class="line">    a, b, _ := i.ABC()</span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    nArgs := _pushFuncAndArgs(a, b, vm)</span><br><span class="line">    vm.TailCall(nArgs)</span><br><span class="line">    _popResults(a, <span class="number">0</span>, vm)</span><br><span class="line">    <span class="comment">// no need to _return() as ‘b’ of the following ‘RETURN’ is 0, </span></span><br><span class="line">    <span class="comment">// ‘a’ of ‘RETURN’ is same ‘as’ a of ‘TAILCALL’</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>state/api_call.go</code>文件中添加<code>TailCall()</code>代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [-(nargs+1), +nresults, e]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *luaState)</span> <span class="title">TailCall</span><span class="params">(nArgs <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    val := self.stack.get(-(nArgs + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">if</span> c, ok := val.(*closure); ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;tailcall %s&lt;%d,%d&gt;\n&quot;</span>, c.proto.Source,</span><br><span class="line">            c.proto.LineDefined, c.proto.LastLineDefined)</span><br><span class="line">        self.tailCallLuaClosure(nArgs, c)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;not function!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>tailCallLuaClosure()</code>中实现主要逻辑。在<code>state/api_call.go</code>文件中添加<code>tailCallLuaClosure()</code>代码如下。</p>
<p>首先同样是从闭包中获取函数原型的信息。因为当前帧在<code>TAILCALL</code>之后肯定跟着<code>RETURN</code>，所以保存参数之后可以直接清理掉当前帧的栈，然后直接给被调函数重用。将被调函数的信息设置到当前帧，先检查栈空间是否够，然后将当前帧关联到新的闭包，然后将固定参数推入栈顶，修改栈顶指针指向最后一个寄存器。如果是vararg且参数个数大于固定参数个数，还要将vararg参数记录下来。</p>
<p>一切就绪之后，就可以调用<code>runLuaClosure()</code>开始执行闭包的指令了。执行完毕后返回值保留在栈顶。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *luaState)</span> <span class="title">tailCallLuaClosure</span><span class="params">(nArgs <span class="keyword">int</span>, c *closure)</span></span> &#123;</span><br><span class="line">    nRegs := <span class="keyword">int</span>(c.proto.MaxStackSize)</span><br><span class="line">    nParams := <span class="keyword">int</span>(c.proto.NumParams)</span><br><span class="line">    isVararg := c.proto.IsVararg == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// store args</span></span><br><span class="line">    args := self.stack.popN(nArgs)</span><br><span class="line">    <span class="comment">// clean the stack</span></span><br><span class="line">    self.SetTop(<span class="number">0</span>)    </span><br><span class="line">    <span class="comment">// check if stack space is enough</span></span><br><span class="line">    self.stack.check(nRegs + <span class="number">20</span>)</span><br><span class="line">    <span class="comment">// substitue the closure to new one</span></span><br><span class="line">    self.stack.closure = c</span><br><span class="line">    <span class="comment">// push fixed args</span></span><br><span class="line">    self.stack.pushN(args[<span class="number">1</span>:], nParams)</span><br><span class="line">    self.stack.top = nRegs</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// store varargs</span></span><br><span class="line">    <span class="keyword">if</span> nArgs &gt; nParams &amp;&amp; isVararg &#123;</span><br><span class="line">        self.stack.varargs = args[nParams+<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run closure</span></span><br><span class="line">    self.runLuaClosure()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><p>我们重新编译Go代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$LUAGO</span>/go</span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="variable">$PWD</span>/ch08</span><br><span class="line"><span class="built_in">export</span> GOBIN=<span class="variable">$PWD</span>/ch08/bin</span><br><span class="line">go install luago</span><br></pre></td></tr></table></figure>

<p>然后来编写Lua脚本，我们编写了一个求和的函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(n, s, fun)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    s = s + n</span><br><span class="line">    <span class="keyword">return</span> fun(n<span class="number">-1</span>, s, fun)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">assert</span><span class="params">(v)</span></span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> v <span class="keyword">then</span> fail() <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v1 = sum(<span class="number">0</span>, <span class="number">0</span>, sum)</span><br><span class="line"><span class="built_in">assert</span>(v1 == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v2 = sum(<span class="number">1</span>, <span class="number">0</span>, sum)</span><br><span class="line"><span class="built_in">assert</span>(v2 == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v3 = sum(<span class="number">3</span>, <span class="number">0</span>, sum)</span><br><span class="line"><span class="built_in">assert</span>(v3 == <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v4 = sum(<span class="number">10</span>, <span class="number">0</span>, sum)</span><br><span class="line"><span class="built_in">assert</span>(v4 == <span class="number">55</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v5 = sum(<span class="number">10000</span>, <span class="number">0</span>, sum)</span><br><span class="line"><span class="built_in">assert</span>(v5 == <span class="number">50005000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v6 = sum(<span class="number">1000000</span>, <span class="number">0</span>, sum)</span><br><span class="line"><span class="built_in">assert</span>(v6 == <span class="number">500000500000</span>)</span><br></pre></td></tr></table></figure>

<p>先来看看<code>sum()</code>函数会被编译成什么指令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ luac -l -</span><br><span class="line"><span class="built_in">local</span> <span class="keyword">function</span> sum(n, s, fun)</span><br><span class="line">    <span class="keyword">if</span> n == 0 <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> s</span><br><span class="line">    end</span><br><span class="line">    s = s + n</span><br><span class="line">    <span class="built_in">return</span> fun(n-1, s, fun)</span><br><span class="line">end</span><br><span class="line">^D</span><br><span class="line">main &lt;stdin:0,0&gt; (2 instructions at 0x7fe071d00070)</span><br><span class="line">0+ params, 2 slots, 1 upvalue, 1 <span class="built_in">local</span>, 0 constants, 1 <span class="keyword">function</span></span><br><span class="line">	1	[7]	CLOSURE  	0 0	; 0x7fe071e00110</span><br><span class="line">	2	[7]	RETURN   	0 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> &lt;stdin:1,7&gt; (11 instructions at 0x7fe071e00110)</span><br><span class="line">3 params, 7 slots, 0 upvalues, 3 locals, 2 constants, 0 <span class="built_in">functions</span></span><br><span class="line">	1	[2]	EQ       	0 0 -1	; - 0</span><br><span class="line">	2	[2]	JMP      	0 1	; to 4</span><br><span class="line">	3	[3]	RETURN   	1 2</span><br><span class="line">	4	[5]	ADD      	1 1 0</span><br><span class="line">	5	[6]	MOVE     	3 2</span><br><span class="line">	6	[6]	SUB      	4 0 -2	; - 1</span><br><span class="line">	7	[6]	MOVE     	5 1</span><br><span class="line">	8	[6]	MOVE     	6 2</span><br><span class="line">	9	[6]	TAILCALL 	3 4 0</span><br><span class="line">	10	[6]	RETURN   	3 0</span><br><span class="line">	11	[7]	RETURN   	0 1</span><br></pre></td></tr></table></figure>

<p>可以看到的确是被编译成了<code>TAILCALL</code>，后面紧跟<code>RETURN</code>指令，且<code>RETURN</code>指令的操作数A与<code>TAILCALL</code>相同，操作数B为0。</p>
<p>我们编译Lua脚本，然后用我们的虚拟机进行执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">luac ../lua/ch08/tailcall.lua</span><br><span class="line">./ch08/bin/luago  luac.out</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;0,0&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;9,11&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;9,11&gt;</span><br><span class="line">panic: GETTABUP</span><br></pre></td></tr></table></figure>

<p>哦哦，执行失败了，残念！</p>
<p>于是加日志进行问题排查，把指令执行时的栈打出来</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开</div></div><div class="fold">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">call @../lua/ch08/tailcall.lua&lt;0,0&gt;</span><br><span class="line">CLOSURE  	0 0	[nil][nil][nil][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">CLOSURE  	1 1	[<span class="keyword">function</span>][nil][nil][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	2 0	[<span class="keyword">function</span>][<span class="keyword">function</span>][nil][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">LOADK    	3 -1	[<span class="keyword">function</span>][<span class="keyword">function</span>][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">LOADK    	4 -1	[<span class="keyword">function</span>][<span class="keyword">function</span>][<span class="keyword">function</span>][0][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	5 0	[<span class="keyword">function</span>][<span class="keyword">function</span>][<span class="keyword">function</span>][0][0][nil][nil]</span><br><span class="line"></span><br><span class="line">CALL     	2 4 2	[<span class="keyword">function</span>][<span class="keyword">function</span>][<span class="keyword">function</span>][0][0][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">EQ       	0 0 -1	[0][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">RETURN   	1 2	[0][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">RETURN   	after 	[0][0][<span class="keyword">function</span>][nil][nil][nil][nil][0]</span><br><span class="line"></span><br><span class="line">CALL     	after 	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][0][0][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	3 1	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][0][0][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">EQ       	1 2 -1	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][<span class="keyword">function</span>][0][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">JMP      	0 1	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][<span class="keyword">function</span>][0][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">LOADBOOL 	4 1 0	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][<span class="keyword">function</span>][0][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">CALL     	3 2 1	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][<span class="keyword">function</span>][<span class="literal">true</span>][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;9,11&gt;</span><br><span class="line">TEST     	0 1	[<span class="literal">true</span>][nil]</span><br><span class="line"></span><br><span class="line">JMP      	0 2	[<span class="literal">true</span>][nil]</span><br><span class="line"></span><br><span class="line">RETURN   	0 1	[<span class="literal">true</span>][nil]</span><br><span class="line"></span><br><span class="line">RETURN   	after 	[<span class="literal">true</span>][nil]</span><br><span class="line"></span><br><span class="line">CALL     	after 	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][<span class="keyword">function</span>][<span class="literal">true</span>][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	3 0	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][<span class="keyword">function</span>][<span class="literal">true</span>][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">LOADK    	4 -2	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][<span class="keyword">function</span>][<span class="literal">true</span>][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">LOADK    	5 -1	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][<span class="keyword">function</span>][1][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	6 0	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][<span class="keyword">function</span>][1][0][nil]</span><br><span class="line"></span><br><span class="line">CALL     	3 4 2	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][<span class="keyword">function</span>][1][0][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">EQ       	0 0 -1	[1][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">JMP      	0 1	[1][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">ADD      	1 1 0	[1][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	3 2	[1][1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">SUB      	4 0 -2	[1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	5 1	[1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][0][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	6 2	[1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][0][1][nil]</span><br><span class="line"></span><br><span class="line">TAILCALL 	3 4 0	[1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][0][1][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">RETURN   	3 0	[1][<span class="keyword">function</span>][nil][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">RETURN   	after 	[1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">TAILCALL 	after 	[1][<span class="keyword">function</span>][nil][nil][nil][nil][4]</span><br><span class="line"></span><br><span class="line">RETURN   	0 1	[1][<span class="keyword">function</span>][nil][nil][nil][nil][4]</span><br><span class="line"></span><br><span class="line">RETURN   	after 	[1][<span class="keyword">function</span>][nil][nil][nil][nil][4]</span><br><span class="line"></span><br><span class="line">CALL     	after 	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][nil][1][0][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">MOVE     	4 1	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][nil][1][0][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">EQ       	1 3 -2	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][nil][<span class="keyword">function</span>][0][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">LOADBOOL 	5 0 1	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][nil][<span class="keyword">function</span>][0][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">CALL     	4 2 1	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][nil][<span class="keyword">function</span>][<span class="literal">false</span>][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;9,11&gt;</span><br><span class="line">TEST     	0 1	[<span class="literal">false</span>][nil]</span><br><span class="line"></span><br><span class="line">GETTABUP 	1 0 -1	[<span class="literal">false</span>][nil]</span><br><span class="line"></span><br><span class="line">panic: GETTABUP</span><br></pre></td></tr></table></figure>

</div></div>

<p>我们发现在<code>TAILCALL</code>开始执行之后立马调用了<code>RETURN</code>，问题就是出在这里，我们虽然替换了当前帧的闭包为被调函数的闭包，但是忘了更新pc。于是修改<code>tailCallLuaClosure()</code>初始化pc为0。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *luaState)</span> <span class="title">tailCallLuaClosure</span><span class="params">(nArgs <span class="keyword">int</span>, c *closure)</span></span> &#123;</span><br><span class="line">    <span class="comment">// substitue the closure to new one</span></span><br><span class="line">    self.stack.closure = c</span><br><span class="line">    self.stack.pc = <span class="number">0</span> <span class="comment">// add this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新编译之后测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go install luago</span><br><span class="line">$ ./ch08/bin/luago  luac.out</span><br><span class="line">...	<span class="comment"># 省略前面的日志</span></span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">EQ       	0 0 -1	[1][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">JMP      	0 1	[1][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">ADD      	1 1 0	[1][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	3 2	[1][1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">SUB      	4 0 -2	[1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	5 1	[1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][0][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	6 2	[1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][0][1][nil]</span><br><span class="line"></span><br><span class="line">TAILCALL 	3 4 0	[1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][0][1][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">EQ       	0 0 -1	[1][<span class="keyword">function</span>][nil][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">JMP      	0 1	[1][<span class="keyword">function</span>][nil][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">ADD      	1 1 0	[1][<span class="keyword">function</span>][nil][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">panic: arithmetic error!</span><br></pre></td></tr></table></figure>

<p>哦哦，又执行失败了🤷‍♂️！查看打印的栈信息，<code>TAILCALL</code>指令执行之前栈的情况是正常的，三个参数都已经推入栈顶<code>[0][1][function]</code>，但是执行<code>EQ</code>指令前栈中却少了一个参数，只有<code>[1][function]</code>。于是检查代码，原来是数组索引搞错了，Go的起始索引是0，跟Lua搞混了🤷‍♂️。。。</p>
<p>修改<code>tailCallLuaClosure()</code>如下之后</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *luaState)</span> <span class="title">tailCallLuaClosure</span><span class="params">(nArgs <span class="keyword">int</span>, c *closure)</span></span> &#123;</span><br><span class="line">    nRegs := <span class="keyword">int</span>(c.proto.MaxStackSize)</span><br><span class="line">    nParams := <span class="keyword">int</span>(c.proto.NumParams)</span><br><span class="line">    isVararg := c.proto.IsVararg == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// store args</span></span><br><span class="line">    args := self.stack.popN(nArgs)</span><br><span class="line">    <span class="comment">// clean the stack</span></span><br><span class="line">    self.SetTop(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// check if stack space is enough</span></span><br><span class="line">    self.stack.check(nRegs + <span class="number">20</span>)</span><br><span class="line">    <span class="comment">// substitue the closure to new one</span></span><br><span class="line">    self.stack.closure = c</span><br><span class="line">    self.stack.pc = <span class="number">0</span></span><br><span class="line">    <span class="comment">// push fixed args</span></span><br><span class="line">    self.stack.pushN(args, nParams)</span><br><span class="line">    self.stack.top = nRegs</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store varargs</span></span><br><span class="line">    <span class="keyword">if</span> nArgs &gt; nParams &amp;&amp; isVararg &#123;</span><br><span class="line">        self.stack.varargs = args[nParams:]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run closure</span></span><br><span class="line">    self.runLuaClosure()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新编译，然后继续执行，程序进入了死循环。。。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开</div></div><div class="fold">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go install luago</span><br><span class="line">$ ./ch08/bin/luago  luac.out</span><br><span class="line">...	<span class="comment"># 程序停不下来了。。。</span></span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">EQ          0 0 -1  [1][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">JMP         0 1 [1][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">ADD         1 1 0   [1][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE        3 2 [1][1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">SUB         4 0 -2  [1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE        5 1 [1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][0][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE        6 2 [1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][0][1][nil]</span><br><span class="line"></span><br><span class="line">TAILCALL    3 4 0   [1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][0][1][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">EQ          0 0 -1  [0][1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">RETURN      1 2 [0][1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">RETURN      after   [0][1][<span class="keyword">function</span>][nil][nil][nil][nil][1]</span><br><span class="line"></span><br><span class="line">TAILCALL    after   [0][1][<span class="keyword">function</span>][nil][nil][nil][nil][1][4]</span><br><span class="line"></span><br><span class="line">ADD         1 1 0   [0][1][<span class="keyword">function</span>][nil][nil][nil][nil][1][4]</span><br><span class="line"></span><br><span class="line">MOVE        3 2 [0][1][<span class="keyword">function</span>][nil][nil][nil][nil][1][4]</span><br><span class="line"></span><br><span class="line">SUB         4 0 -2  [0][1][<span class="keyword">function</span>][<span class="keyword">function</span>][nil][nil][nil][1][4]</span><br><span class="line"></span><br><span class="line">MOVE        5 1 [0][1][<span class="keyword">function</span>][<span class="keyword">function</span>][-1][nil][nil][1][4]</span><br><span class="line"></span><br><span class="line">MOVE        6 2 [0][1][<span class="keyword">function</span>][<span class="keyword">function</span>][-1][1][nil][1][4]</span><br><span class="line"></span><br><span class="line">TAILCALL    3 4 0   [0][1][<span class="keyword">function</span>][<span class="keyword">function</span>][-1][1][<span class="keyword">function</span>][1][4]</span><br><span class="line">EQ          0 0 -1  [-1][1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">JMP         0 1 [-1][1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">ADD         1 1 0   [-1][1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE        3 2 [-1][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">SUB         4 0 -2  [-1][0][<span class="keyword">function</span>][<span class="keyword">function</span>][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE        5 1 [-1][0][<span class="keyword">function</span>][<span class="keyword">function</span>][-2][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE        6 2 [-1][0][<span class="keyword">function</span>][<span class="keyword">function</span>][-2][0][nil]</span><br><span class="line"></span><br><span class="line">TAILCALL    3 4 0   [-1][0][<span class="keyword">function</span>][<span class="keyword">function</span>][-2][0][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">EQ          0 0 -1  [-2][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">JMP         0 1 [-2][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">ADD         1 1 0   [-2][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE        3 2 [-2][-2][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">SUB         4 0 -2  [-2][-2][<span class="keyword">function</span>][<span class="keyword">function</span>][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE        5 1 [-2][-2][<span class="keyword">function</span>][<span class="keyword">function</span>][-3][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE        6 2 [-2][-2][<span class="keyword">function</span>][<span class="keyword">function</span>][-3][-2][nil]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

</div></div>

<p>观察到在<code>TAILCALL</code>结束之后，又继续执行<code>RETURN</code>指令后面的<code>ADD</code>指令了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TAILCALL    3 4 0   [1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][0][1][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">EQ          0 0 -1  [0][1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">RETURN      1 2 [0][1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">RETURN      after   [0][1][<span class="keyword">function</span>][nil][nil][nil][nil][1]</span><br><span class="line"></span><br><span class="line">TAILCALL    after   [0][1][<span class="keyword">function</span>][nil][nil][nil][nil][1][4]</span><br><span class="line"></span><br><span class="line">ADD         1 1 0   [0][1][<span class="keyword">function</span>][nil][nil][nil][nil][1][4]</span><br></pre></td></tr></table></figure>

<p>正常在执行第3条指令<code>RETURN</code>之后就应该返回上层了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> &lt;../lua/ch08/tailcall.lua:1,7&gt; (11 instructions at 0x7fd783c03070)</span><br><span class="line">3 params, 7 slots, 0 upvalues, 3 locals, 2 constants, 0 <span class="built_in">functions</span></span><br><span class="line">	1	[2]	EQ       	0 0 -1	; - 0</span><br><span class="line">	2	[2]	JMP      	0 1	; to 4</span><br><span class="line">	3	[3]	RETURN   	1 2</span><br><span class="line">	4	[5]	ADD      	1 1 0</span><br><span class="line">	5	[6]	MOVE     	3 2</span><br><span class="line">	6	[6]	SUB      	4 0 -2	; - 1</span><br><span class="line">	7	[6]	MOVE     	5 1</span><br><span class="line">	8	[6]	MOVE     	6 2</span><br><span class="line">	9	[6]	TAILCALL 	3 4 0</span><br><span class="line">	10	[6]	RETURN   	3 0</span><br><span class="line">	11	[7]	RETURN   	0 1</span><br></pre></td></tr></table></figure>



<p>猛然想到，之前把<code>RETURN</code>语句给略过了，虽然在返回值的处理上是没有问题，但是外层帧依赖<code>RETURN</code>指令来结束</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *luaState)</span> <span class="title">runLuaClosure</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> inst.Opcode() == vm.OP_RETURN &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们修改<code>runLuaClosure()</code>，使<code>TAILCALL</code>指令执行之后也结束。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *luaState)</span> <span class="title">runLuaClosure</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">if</span> inst.Opcode() == vm.OP_RETURN || inst.Opcode() == vm.OP_TAILCALL &#123;</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个地方需要修改，因为我们省略了<code>RETURN</code>指令，所以<code>tailCall()</code>里的<code>_popResults()</code>也就不需要了，否则栈上会多出一个值。<code>_popResults()</code>会推一个整数值（即a）到栈顶指示返回值起始的寄存器位置，相应的在<code>RETURN</code>指令的时候会把这个整数值弹出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// return R(A)(R(A+1), ... ,R(A+B-1))</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tailCall</span><span class="params">(i Instruction, vm LuaVM)</span></span> &#123;</span><br><span class="line">    a, b, _ := i.ABC()</span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// todo: optimize tail call!</span></span><br><span class="line">    nArgs := _pushFuncAndArgs(a, b, vm)</span><br><span class="line">    vm.TailCall(nArgs)</span><br><span class="line">    <span class="comment">// _popResults(a, 0, vm)</span></span><br><span class="line">    <span class="comment">// no need to _return() as ‘b’ of the following ‘RETURN’ is 0, </span></span><br><span class="line">    <span class="comment">// ‘a’ of ‘RETURN’ is same ‘as’ a of ‘TAILCALL’</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>重新编译执行，这回终于大功告成了！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go install luago</span><br><span class="line">$ ./ch08/bin/luago  luac.out</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;0,0&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;9,11&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;9,11&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;9,11&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;9,11&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;9,11&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;9,11&gt;</span><br></pre></td></tr></table></figure>



<p>我们再来试试可变参数的情况，修改Lua脚本如下</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(n, s, fun, ...)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> args = &#123;...&#125;</span><br><span class="line">    <span class="keyword">if</span> args[n] <span class="keyword">then</span></span><br><span class="line">        s = s + args[n]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> fun(n<span class="number">-1</span>, s, fun, ...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">assert</span><span class="params">(v)</span></span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> v <span class="keyword">then</span> fail() <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v1 = sum(<span class="number">0</span>, <span class="number">0</span>, sum)</span><br><span class="line"><span class="built_in">assert</span>(v1 == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v2 = sum(<span class="number">1</span>, <span class="number">0</span>, sum, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">assert</span>(v2 == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v3 = sum(<span class="number">3</span>, <span class="number">0</span>, sum, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">assert</span>(v3 == <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v4 = sum(<span class="number">3</span>, <span class="number">0</span>, sum, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">assert</span>(v4 == <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v3 = sum(<span class="number">3</span>, <span class="number">0</span>, sum, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">assert</span>(v3 == <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>编译Lua脚本，执行测试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ luac ../lua/ch08/tailcall2.lua</span><br><span class="line">$ ./ch08/bin/luago  luac.out</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;0,0&gt;</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;1,10&gt;</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;12,14&gt;</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;1,10&gt;</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;12,14&gt;</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;1,10&gt;</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;12,14&gt;</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;1,10&gt;</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;12,14&gt;</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;1,10&gt;</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;12,14&gt;</span><br></pre></td></tr></table></figure>

<p>也没有问题✌️</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>TAILCALL</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua中如何实现类似gdb的断点调试—09支持动态添加和删除断点</title>
    <url>/posts/1fdd30ce/</url>
    <content><![CDATA[<div class="note primary">
            <p>前面已经支持了几种不同的方式添加断点，但是必须事先在代码中添加断点，在使用上不是那么灵活方便。本文将支持动态增删断点，只需要开一开始引入调试库即可，后续可以在调试过程中动态的添加和删除断点。事不宜迟，我们直接进入正题。</p>
          </div>

<span id="more"></span>

<p>源码已经上传<a href="https://github.com/catbro666/lua-debugger">Github</a>，欢迎watch/star😘。</p>
<h2 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h2><h3 id="入口断点"><a href="#入口断点" class="headerlink" title="入口断点"></a>入口断点</h3><p>尽管我们目标是支持动态添加断点，但还是需要一个入口，提供用户添加初始的断点。仍然像之前一样，在用户代码中显式添加的确可以，但显然不是我们想要效果。理想的效果就是用户开始调试程序，就自动停在入口处，等待用户输入交互信息，就像gdb那样。</p>
<p>因为引入调试库这个动作是肯定要做的，所以最方便的方式就是在引入这个库的时候就直接停到入口断点。我们可以在调试库中实现一个init方法，在require这个调试库之后调用init进入调试入口，类似下面这样</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;luadebug&quot;</span>).init()</span><br></pre></td></tr></table></figure>

<p>用户代码中只需要添加这样一行，无需其他任何改动，后续就可以交互模式中动态添加断点了。</p>
<h3 id="支持动态添加断点"><a href="#支持动态添加断点" class="headerlink" title="支持动态添加断点"></a>支持动态添加断点</h3><p>要在交互模式中动态添加断点，我们的接口函数如添加断点函数、删除断点函数就需要在交互模式的作用域中可见，所以需要将公共接口函数放到<code>_G</code>或<code>_ENV</code>中。但是放到这样的全局表中，可能出现名字冲突的情况，需要支持通过参数自定义接口函数的名称。</p>
<p>支持了动态断点之后，原本在call事件中判断函数是否有断点并记录在status.stackinfos中，然后在return事件中查询该值的机制就失效了。因为随时可以动态增删断点，所以在call和return事件都需要实时进行判断，然后根据结果决定是否添加或删除line事件。</p>
<p>另外为了方便添加断点，扩展断点添加函数以支持用”.”表示当前函数或当前包。</p>
<h3 id="支持动态删除断点"><a href="#支持动态删除断点" class="headerlink" title="支持动态删除断点"></a>支持动态删除断点</h3><p>要支持动态删除断点，需要添加一个断点打印函数以查看当前的断点情况。</p>
<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>首先来看钩子函数，因为需要支持动态增删断点，所以call和return事件需要相应修改。先看call事件改动，updatehookevent函数把之前根据函数信息判断是否有断点，并调整line事件的逻辑给封装起来了，因为现在在return事件中也需要进行这些操作。而status.stackinfos中则不再缓存hasbreak，因为支持动态添加断点后，需要实时判断了。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span> <span class="params">(event, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail call&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- level 2: hook, target func</span></span><br><span class="line">        <span class="keyword">local</span> sinfo = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>, <span class="string">&quot;nf&quot;</span>)</span><br><span class="line">        <span class="keyword">local</span> finfo = updatehookevent(sinfo)</span><br><span class="line">        <span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">then</span>     <span class="comment">-- for tail call, just overwrite</span></span><br><span class="line">            s.stackdepth = s.stackdepth + <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        s.stackinfos[s.stackdepth] =</span><br><span class="line">            &#123;stackinfo = sinfo, funcinfo = finfo&#125;</span><br><span class="line">        <span class="comment">-- 省略...</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>然后来看return事件的改动。s.stackinfos中把当前函数出栈，这还是跟之前一样。然后如果已经删除了所有断点，那么将钩子函数移除，并清空s.stackinfos缓存。如果栈中还有函数，则调用updatehookevent函数，这里的参数是即将返回的函数的信息。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span> <span class="params">(event, line)</span></span></span><br><span class="line">    <span class="comment">-- 省略...</span></span><br><span class="line">        <span class="keyword">elseif</span> event == <span class="string">&quot;return&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail return&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> s.stackdepth &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            s.stackinfos[s.stackdepth] = <span class="literal">nil</span></span><br><span class="line">            s.stackdepth = s.stackdepth - <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> s.bpnum == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">sethook</span>()</span><br><span class="line">            s.stackinfos = &#123;&#125;</span><br><span class="line">            s.stackdepth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> s.stackdepth &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            updatehookevent(s.stackinfos[s.stackdepth].stackinfo)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 省略...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>我们来看下updatehookevent的实现：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updatehookevent</span><span class="params">(stackinfo)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">local</span> func = stackinfo.func</span><br><span class="line">    <span class="keyword">local</span> name = stackinfo.name</span><br><span class="line">    <span class="keyword">local</span> funcinfo = getfuncinfo(func)</span><br><span class="line">    <span class="keyword">local</span> hasbreak = <span class="literal">false</span></span><br><span class="line">    <span class="comment">-- check unsolved srcbp</span></span><br><span class="line">    solvesrcbp(funcinfo, func)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> funcinfo.what ~= <span class="string">&quot;C&quot;</span> <span class="keyword">then</span></span><br><span class="line">        setsrcfunc(funcinfo, func)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s.funcbpt[func] <span class="keyword">then</span></span><br><span class="line">        hasbreak = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hasbreak <span class="keyword">and</span> s.namebpt[name] <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> <span class="built_in">min</span> = funcinfo.linedefined</span><br><span class="line">        <span class="keyword">local</span> <span class="built_in">max</span> = funcinfo.lastlinedefined</span><br><span class="line">        <span class="keyword">for</span> k, _ <span class="keyword">in</span> <span class="built_in">pairs</span>(s.namebpt[name]) <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">type</span>(k) == <span class="string">&quot;number&quot;</span> <span class="keyword">and</span> ((k &gt;= <span class="built_in">min</span> <span class="keyword">and</span> k &lt;= <span class="built_in">max</span>) <span class="keyword">or</span> k == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                hasbreak = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- found breakpoint in current function</span></span><br><span class="line">    <span class="keyword">if</span> hasbreak <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;crl&quot;</span>)  <span class="comment">-- add &quot;line&quot; event</span></span><br><span class="line">    <span class="keyword">else</span>        <span class="comment">-- no breakpoints found</span></span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;cr&quot;</span>)   <span class="comment">-- remove &quot;line&quot; event</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> funcinfo</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>大部分都是之前的call事件中干的事情，首先检查srcbpt中是否有当前包中未解析的断点，然后判断当前函数时候有断点，有断点打开line事件，没有断点移除line事件。</p>
<p>##初始化函数</p>
<p>我们分成三个部分来看初始化函数，首先第一部分是将函数注册到全局表<code>_G</code>。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">(name_table)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">_G</span>.luadebug_inited <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">_G</span>.luadebug_inited = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> name_table <span class="keyword">and</span> <span class="built_in">type</span>(name_table) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">if</span> hasdupname(name_table) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="built_in">_G</span>[name_table[<span class="number">1</span>]] = setbreakpoint</span><br><span class="line">            <span class="built_in">_G</span>[name_table[<span class="number">2</span>]] = removebreakpoint</span><br><span class="line">            <span class="built_in">_G</span>[name_table[<span class="number">3</span>]] = printvarvalue</span><br><span class="line">            <span class="built_in">_G</span>[name_table[<span class="number">4</span>]] = setvarvalue</span><br><span class="line">            <span class="built_in">_G</span>[name_table[<span class="number">5</span>]] = printtraceback</span><br><span class="line">            <span class="built_in">_G</span>[name_table[<span class="number">6</span>]] = printbreakinfo</span><br><span class="line">            <span class="built_in">_G</span>[name_table[<span class="number">7</span>]] = help</span><br><span class="line">            hascustomnames = <span class="literal">true</span></span><br><span class="line">            customnames = name_table</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> hasdupname(longnames) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> hasdupname(shortnames) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="built_in">_G</span>.setbreakpoint = setbreakpoint</span><br><span class="line">            <span class="built_in">_G</span>.removebreakpoint = removebreakpoint</span><br><span class="line">            <span class="built_in">_G</span>.printvarvalue = printvarvalue</span><br><span class="line">            <span class="built_in">_G</span>.setvarvalue = setvarvalue</span><br><span class="line">            <span class="built_in">_G</span>.printtraceback = printtraceback</span><br><span class="line">            <span class="built_in">_G</span>.printbreakinfo = printbreakinfo</span><br><span class="line">            <span class="built_in">_G</span>.help = help</span><br><span class="line">            <span class="comment">-- short names</span></span><br><span class="line">            <span class="built_in">_G</span>.b = setbreakpoint</span><br><span class="line">            <span class="built_in">_G</span>.d = removebreakpoint</span><br><span class="line">            <span class="built_in">_G</span>.p = printvarvalue</span><br><span class="line">            <span class="built_in">_G</span>.bt = printtraceback</span><br><span class="line">            <span class="built_in">_G</span>.s = setvarvalue</span><br><span class="line">            <span class="built_in">_G</span>.i = printbreakinfo</span><br><span class="line">            <span class="built_in">_G</span>.h = help</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 省略...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>可选参数<code>name_table</code>用于指定自定义的函数名称。我们添加了一个标记<code>luadebug_inited</code>表示是否已经初始化了全局表。如果还没有则进行注册，如果提供了自定义的函数名，则注册自定义的，否则注册默认的函数名。注册前使用hasdupname函数检查<code>_G</code>表中是否已经有了同名的成员，如果有则终止注册，函数返回。</p>
<p>接着看函数第二部分，这部分在输出一些提示信息后debug.debug进入交互模式，这就是我们第一个入口断点，可以在这里添加一些初始的断点。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">(name_table)</span></span></span><br><span class="line">    <span class="comment">-- 省略...</span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;luadebug %s start ...\n&quot;</span>, version))</span><br><span class="line">    <span class="keyword">if</span> hascustomnames <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;input &#x27;&quot;</span> .. customnames[<span class="number">7</span>] .. <span class="string">&quot;()&#x27; for help info or &#x27;&quot;</span></span><br><span class="line">            .. customnames[<span class="number">7</span>] .. <span class="string">&quot;(1)&#x27; for verbose info\n&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;input &#x27;help()&#x27; for help info or &#x27;help(1)&#x27; for verbose info\n&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> sinfo = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>, <span class="string">&quot;nfl&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> func = sinfo.func</span><br><span class="line">    <span class="keyword">local</span> name = sinfo.name</span><br><span class="line">    <span class="keyword">local</span> finfo = getfuncinfo(func)</span><br><span class="line">    <span class="keyword">local</span> prompt = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s (%s)%s %s:%d\n&quot;</span>,</span><br><span class="line">        finfo.what, sinfo.namewhat, name, finfo.short_src, sinfo.currentline)</span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(prompt)</span><br><span class="line">    <span class="built_in">debug</span>.<span class="built_in">debug</span>()</span><br><span class="line">    <span class="comment">-- 省略...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>接下来看函数的第三部分，这部分可能不太好理解。我们的status.stackinfos是用于缓存调用栈的函数信息的，call事件时入栈，return事件时出栈，我们依赖这个缓存的函数信息来决定是否添加line事件。但是在sethook函数启动钩子之前已经在调用栈中的函数，我们是没有缓存的函数信息的，也就造成即使我们在这些函数上添加了断点，也没有办法真正断到那里。</p>
<p>解决办法有两个：一个是不使用缓存，每次都debug.getinfo实时获取调用栈中的函数信息。这样虽然简单，但是性能有一定损失。第二个办法就是我们在第一次调用sethook函数前，把缺失的调用栈函数信息手动补上去。</p>
<p>原先我们是在添加第一个断点时，debug.sethook启动钩子函数，因为我们有多个断点添加函数，且存在潜嵌套调用的情况，所以如果在断点设置函数中处理代码上会有重复，而且debug.getinfo在层数上时不确定的，所以我们决定在init函数中干这个事情。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">(name_table)</span></span></span><br><span class="line">    <span class="comment">-- 省略...</span></span><br><span class="line">    <span class="keyword">if</span> s.bpnum &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> s.stackdepth == <span class="number">0</span> <span class="keyword">then</span>       <span class="comment">-- set hook</span></span><br><span class="line">            <span class="keyword">local</span> max_depth = <span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> ( <span class="literal">true</span> ) <span class="keyword">do</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(max_depth, <span class="string">&quot;f&quot;</span>) <span class="keyword">then</span></span><br><span class="line">                    max_depth = max_depth - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                max_depth = max_depth + <span class="number">1</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">-- init stackinfos</span></span><br><span class="line">            <span class="keyword">for</span> i=max_depth, <span class="number">1</span>, <span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">                s.stackdepth = s.stackdepth + <span class="number">1</span></span><br><span class="line">                <span class="keyword">local</span> sinfo = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(i, <span class="string">&quot;nf&quot;</span>)</span><br><span class="line">                <span class="keyword">local</span> func = sinfo.func</span><br><span class="line">                <span class="keyword">local</span> finfo = getfuncinfo(func)</span><br><span class="line">                s.stackinfos[s.stackdepth] =</span><br><span class="line">                    &#123;stackinfo = sinfo, funcinfo = finfo&#125;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">-- add sethook</span></span><br><span class="line">            s.stackdepth = s.stackdepth + <span class="number">1</span></span><br><span class="line">            s.stackinfos[s.stackdepth] =</span><br><span class="line">                &#123;stackinfo = &#123;name = <span class="string">&quot;sethook&quot;</span>, func = <span class="built_in">debug</span>.<span class="built_in">sethook</span>&#125;,</span><br><span class="line">                 funcinfo = getfuncinfo(<span class="built_in">debug</span>.<span class="built_in">sethook</span>)&#125;</span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;cr&quot;</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">	<span class="comment">-- 省略...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>首先检查是否添加了断点，如果没有断点不需要添加钩子函数。然后检查当前s.stackdepth是否为0，这是考虑到init函数可能被多次调用的情况，只有第一次才需要手动补调用栈信息。接下来的while循环是为了探测调用栈的深度，之所以不使用固定值，是考虑到调用init函数的也不一定就是最外层。然后从栈的最深处开始一层一层添加，最后再补上sethook函数本身。补充完status.stackinfos信息后就可以调用debug.sethook设置钩子函数了。</p>
<p>既然我们在init函数中sethook了，那么之前设置断点函数中的sethook就都可以去掉了。</p>
<h2 id="断点打印函数"><a href="#断点打印函数" class="headerlink" title="断点打印函数"></a>断点打印函数</h2><p>断点打印函数非常简单，只是遍历status.bptable表，打印断点信息，对应通过函数名字添加的断点打印名字及行数，其余断点打印包名及行数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">printbreakinfo</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,s.bpid <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> bp = s.bptable[i]</span><br><span class="line">        <span class="keyword">local</span> prompt</span><br><span class="line">        <span class="keyword">if</span> bp <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">if</span> bp.name <span class="keyword">then</span></span><br><span class="line">                prompt = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;id: %d, name: %s, line: %d\n&quot;</span>,</span><br><span class="line">                    i, bp.name, bp.line)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prompt = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;id: %d, src: %s, line: %d\n&quot;</span>,</span><br><span class="line">                    i, bp.src, bp.line)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="built_in">io</span>.<span class="built_in">write</span>(prompt)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>help帮助函数，以及扩展断点添加函数支持用”.”表示当前函数或当前包，我就不专门讲了。另外，既然我们的接口函数已经支持在交互模式中动态调用了，那么也就不需要再导出了，模块只需要导出init函数即可。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    init = init,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我们编写一个如下的Lua测试脚本</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;luadebug&quot;</span>).init()</span><br><span class="line"><span class="keyword">local</span> lib = <span class="built_in">require</span> <span class="string">&quot;testlib&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> g = <span class="number">1</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">faa</span> <span class="params">()</span></span></span><br><span class="line">    g = <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">faa()</span><br><span class="line">lib.foo()</span><br><span class="line">lib.bar()</span><br><span class="line">faa()</span><br></pre></td></tr></table></figure>

<p>测试包还是跟之前一样</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    foo = foo,</span><br><span class="line">    bar = bar,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="入口脚本中断点测试"><a href="#入口脚本中断点测试" class="headerlink" title="入口脚本中断点测试"></a>入口脚本中断点测试</h3><p>首先测试仅在入口脚本中添加断点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua dynamictest.lua</span><br><span class="line">luadebug 0.0.1 start ...</span><br><span class="line">input <span class="string">&#x27;help()&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span> info or <span class="string">&#x27;help(1)&#x27;</span> <span class="keyword">for</span> verbose info</span><br><span class="line">main ()nil dynamictest.lua:1</span><br><span class="line">lua_debug&gt; </span><br></pre></td></tr></table></figure>

<p>我们添加两个断点，一个是当前包的第7行，及faa函数的最后一行，一个是当前函数即mainchunk的第9行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; b(<span class="string">&quot;.:7&quot;</span>)</span><br><span class="line">lua_debug&gt; b(<span class="string">&quot;.@9&quot;</span>)</span><br><span class="line">lua_debug&gt; i()</span><br><span class="line">id: 1, src: dynamictest.lua, line: 7, refname: nil</span><br><span class="line">id: 2, src: dynamictest.lua, line: 9, refname: main</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>我们继续执行，首先停在了mainchunk的第9行，此时g的值为1，继续执行，又停在了faa的第7行，此时g已经改为2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">main ()nil dynamictest.lua:9</span><br><span class="line">lua_debug&gt; p(<span class="string">&quot;g&quot;</span>)</span><br><span class="line"><span class="built_in">local</span>	1</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)faa dynamictest.lua:7</span><br><span class="line">lua_debug&gt; p(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">upvalue	2</span><br><span class="line">lua_debug&gt; i()</span><br><span class="line">id: 1, src: dynamictest.lua, line: 7, refname: faa</span><br><span class="line">id: 2, src: dynamictest.lua, line: 9, refname: main</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>此时我们删除两个断点，再次继续执行，程序不再停到faa上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; d(1)</span><br><span class="line">lua_debug&gt; d(2)</span><br><span class="line">lua_debug&gt; i()</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>

<h3 id="其他包中断点测试"><a href="#其他包中断点测试" class="headerlink" title="其他包中断点测试"></a>其他包中断点测试</h3><p>接着测试下在testlib包中添加断点，首先启动调试，添加两个断点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua dynamictest.lua</span><br><span class="line">luadebug 0.0.1 start ...</span><br><span class="line">input <span class="string">&#x27;help()&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span> info or <span class="string">&#x27;help(1)&#x27;</span> <span class="keyword">for</span> verbose info</span><br><span class="line">main ()nil dynamictest.lua:1</span><br><span class="line">lua_debug&gt; b(<span class="string">&quot;testlib:-9&quot;</span>)</span><br><span class="line">lua_debug&gt; b(<span class="string">&quot;foo@&quot;</span>)</span><br><span class="line">lua_debug&gt; i()</span><br><span class="line">id: 1, src: /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua, line: -9, refname: nil</span><br><span class="line">id: 2, name: foo, line: 0</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>继续执行，程序首先停在了testlib的mainchunk第9行，我们在这里添加faa的断点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">main ()nil /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:9</span><br><span class="line">lua_debug&gt; i()</span><br><span class="line">id: 1, src: /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua, line: 9, refname: main</span><br><span class="line">id: 2, name: foo, line: 0</span><br><span class="line">lua_debug&gt; b(<span class="string">&quot;faa@&quot;</span>)</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>继续执行，程序先停在faa函数，然后停在foo函数，最后听到faa函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (local)faa dynamictest.lua:6</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (field)foo /usr/local/share/lua/5.3/testlib.lua:2</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (local)faa dynamictest.lua:6</span><br><span class="line">lua_debug&gt; cont</span><br></pre></td></tr></table></figure>

<h3 id="多次初始化测试"><a href="#多次初始化测试" class="headerlink" title="多次初始化测试"></a>多次初始化测试</h3><p>我们在testlib包开头添加一行<code>require(&quot;luadebug&quot;).init()</code>。首先一样停在了dynamictest.lua中的入口断点处，我们添加两个断点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua dynamictest.lua</span><br><span class="line">luadebug 0.0.1 start ...</span><br><span class="line">input <span class="string">&#x27;help()&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span> info or <span class="string">&#x27;help(1)&#x27;</span> <span class="keyword">for</span> verbose info</span><br><span class="line">main ()nil dynamictest.lua:1</span><br><span class="line">lua_debug&gt; b(<span class="string">&quot;faa@&quot;</span>)</span><br><span class="line">lua_debug&gt; b(<span class="string">&quot;foo@&quot;</span>)</span><br><span class="line">lua_debug&gt; i()</span><br><span class="line">id: 1, name: faa, line: 0</span><br><span class="line">id: 2, name: foo, line: 0</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>然后继续执行，发现程序停到了testlib的入口断点处，断点情况正常</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">luadebug 0.0.1 start ...</span><br><span class="line">input <span class="string">&#x27;help()&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span> info or <span class="string">&#x27;help(1)&#x27;</span> <span class="keyword">for</span> verbose info</span><br><span class="line">main ()nil /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:1</span><br><span class="line">lua_debug&gt; bt()</span><br><span class="line">stack traceback:</span><br><span class="line">	/usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:1: <span class="keyword">in</span> main chunk</span><br><span class="line">	[C]: <span class="keyword">in</span> <span class="keyword">function</span> <span class="string">&#x27;require&#x27;</span></span><br><span class="line">	dynamictest.lua:2: <span class="keyword">in</span> main chunk</span><br><span class="line">	[C]: <span class="keyword">in</span> ?</span><br><span class="line">lua_debug&gt; i()</span><br><span class="line">id: 1, name: faa, line: 0</span><br><span class="line">id: 2, name: foo, line: 0</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>我们继续执行，停在了faa函数处，我们删除断点1，然后继续执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)faa dynamictest.lua:6</span><br><span class="line">lua_debug&gt; d(1)</span><br><span class="line">lua_debug&gt; i()</span><br><span class="line">id: 2, name: foo, line: 0</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>程序停在了foo函数处，再继续因为faa函数处的断点1已经删除，所以程序直接结束。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (field)foo /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:3</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h3 id="仅在testlib包中初始化"><a href="#仅在testlib包中初始化" class="headerlink" title="仅在testlib包中初始化"></a>仅在testlib包中初始化</h3><p>我们删除dynamictest.lua中的第一行，继续测试，程序直接停在了testlib包的入口断点，我们同样添加两个断点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua dynamictest.lua</span><br><span class="line">luadebug 0.0.1 start ...</span><br><span class="line">input <span class="string">&#x27;help()&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span> info or <span class="string">&#x27;help(1)&#x27;</span> <span class="keyword">for</span> verbose info</span><br><span class="line">main ()nil /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:1</span><br><span class="line">lua_debug&gt; b(<span class="string">&quot;faa@&quot;</span>)</span><br><span class="line">lua_debug&gt; b(<span class="string">&quot;foo@&quot;</span>)</span><br><span class="line">lua_debug&gt; i()</span><br><span class="line">id: 1, name: faa, line: 0</span><br><span class="line">id: 2, name: foo, line: 0</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>继续执行，程序停在了faa函数处，我们删除断点1，然后继续执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)faa dynamictest.lua:5</span><br><span class="line">lua_debug&gt; d(1)</span><br><span class="line">lua_debug&gt; i()</span><br><span class="line">id: 2, name: foo, line: 0</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>程序停在了foo函数处，再继续因为断点1已经删除，所以不再停在faa函数处，程序直接结束。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (field)foo /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:3</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h3 id="自定义函数名称及重名测试"><a href="#自定义函数名称及重名测试" class="headerlink" title="自定义函数名称及重名测试"></a>自定义函数名称及重名测试</h3><p>我们在dynamictest.lua最前面添加一行：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">d = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>测试输出如下，提示错误之后没有进入交互模式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua dynamictest.lua</span><br><span class="line">table `_G` already has element called <span class="string">&quot;d&quot;</span> please specify custom names as the following example:</span><br><span class="line">require(<span class="string">&quot;luadebug&quot;</span>).init(&#123;<span class="string">&quot;bb&quot;</span>, <span class="string">&quot;dd&quot;</span>, <span class="string">&quot;pp&quot;</span>, <span class="string">&quot;ss&quot;</span>, <span class="string">&quot;tt&quot;</span>, <span class="string">&quot;ii&quot;</span>, <span class="string">&quot;hh&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>我们再将第二行改为如下</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;luadebug&quot;</span>).init(&#123;<span class="string">&quot;bb&quot;</span>, <span class="string">&quot;dd&quot;</span>, <span class="string">&quot;pp&quot;</span>, <span class="string">&quot;ss&quot;</span>, <span class="string">&quot;tt&quot;</span>, <span class="string">&quot;ii&quot;</span>, <span class="string">&quot;hh&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>然后重新测试，可以看到函数名已经顺利修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua dynamictest.lua</span><br><span class="line">luadebug 0.0.1 start ...</span><br><span class="line">input <span class="string">&#x27;hh()&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span> info or <span class="string">&#x27;hh(1)&#x27;</span> <span class="keyword">for</span> verbose info</span><br><span class="line">main ()nil dynamictest.lua:2</span><br><span class="line">lua_debug&gt; bb(<span class="string">&quot;faa@&quot;</span>)</span><br><span class="line">lua_debug&gt; bb(<span class="string">&quot;foo@&quot;</span>)</span><br><span class="line">lua_debug&gt; ii()</span><br><span class="line">id: 1, name: faa, line: 0</span><br><span class="line">id: 2, name: foo, line: 0</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>继续执行，一切正常。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">luadebug 0.0.1 start ...</span><br><span class="line">input <span class="string">&#x27;hh()&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span> info or <span class="string">&#x27;hh(1)&#x27;</span> <span class="keyword">for</span> verbose info</span><br><span class="line">main ()nil /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:1</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)faa dynamictest.lua:7</span><br><span class="line">lua_debug&gt; dd(1)</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (field)foo /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:3</span><br><span class="line">lua_debug&gt; tt()</span><br><span class="line">stack traceback:</span><br><span class="line">	/usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:3: <span class="keyword">in</span> <span class="keyword">function</span> <span class="string">&#x27;testlib.foo&#x27;</span></span><br><span class="line">	dynamictest.lua:11: <span class="keyword">in</span> main chunk</span><br><span class="line">	[C]: <span class="keyword">in</span> ?</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程开发</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua中如何实现类似gdb的断点调试—08支持通过包名称添加断点</title>
    <url>/posts/5c25711/</url>
    <content><![CDATA[<div class="note primary">
            <p>在前一篇中我们支持了通过函数名称来添加断点，我们同时也提到了在Lua中一个函数的名称的并不是确定的。准确的说，Lua中的函数并没有名称，所谓名称其实是保存这个函数值的变量的名称。</p><p>于是通过函数名称添加断点就造成了一定的不确定性，因为函数被调用时并不一定是以这个名字被调用的。另外，多个不同的函数也可能以相同的名字进行调用。</p><p>所以为了解决这个问题，本篇我们将继续扩展断点的设置接口，支持通过包名来添加断点。因为包名相对更具确定性，配合行号可以进行精确定位。</p>
          </div>

<span id="more"></span>

<p>源码已经上传<a href="https://github.com/catbro666/lua-debugger">Github</a>，欢迎watch/star😘。</p>
<h2 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h2><h3 id="为何选用包名的方式"><a href="#为何选用包名的方式" class="headerlink" title="为何选用包名的方式"></a>为何选用包名的方式</h3><p>其实一开始的想法并不是通过包名来添加断点，而是通过源文件名。但是源文件名同样存在重复的可能，我们只能考虑使用类似后缀匹配这种模糊的方式进行查找。这样的话，每个call事件中都需要对通过源文件名设置的断点表进行遍历。</p>
<p>使用绝对路径虽然可以解决重复的问题，但是使用上不方便，在添加断点的时候也不一定知道源文件的具体位置，况且<code>short_src</code>也不一定是绝对路径。</p>
<p>所以出于性能及易用性的考虑，采用了通过包名来设置断点的方式，这样就可以利用Lua本身的包名搜索机制，使用搜索包路径的方法<code>package.searchpackage()</code>将包名转成路径。而这个路径就是<code>debug.getinfo</code>获取到的调试信息中的<code>short_src</code>。</p>
<p>下面是一个例子：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">package</span>.searchpath( <span class="string">&quot;foo.bar.baz&quot;</span>, <span class="built_in">package</span>.<span class="built_in">path</span> )</span><br><span class="line"><span class="comment">--&gt; (e.g.) &quot;/usr/share/lua/5.3/foo/bar/baz.lua&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="断点的保存解析和查找"><a href="#断点的保存解析和查找" class="headerlink" title="断点的保存解析和查找"></a>断点的保存解析和查找</h3><p>跟上一篇中通过函数名称添加的断点不同的是，通过包名添加的断点都是确定的，所以最终都可以将其转换为函数的断点。但是只有当执行过该函数之后，我们才能获取到该函数的相关信息，进行断点的转换，所以在此之前我们需要将它们临时存放在一个表中，跟之前的<code>status.funcbpt</code>、<code>status.namebpt</code>类似，我们把这个表定义为<code>status.srcbpt</code>。</p>
<p>当执行到该函数之后，我们就可以将<code>status.srcbpt</code>中对应的断点转移到<code>status.funcbpt</code>表中，后续就可以通过普通函数断点的方式进行处理了。</p>
<p>为了提升性能，我们可以将之前执行过的函数的信息保存下来，后续再（通过包名方式）在相同的函数中添加断点时，就可以快速地确定其所在函数，直接在添加断点的时候就转换为普通函数断点了，而不需要推迟到后面进行查找比对转换了。之前我们已经有了一个保存函数信息的表<code>status.funcinfos</code>，但是那个表是以函数作为键，而这里我们需要通过源文件路径进行查找，所以需要新的数据结构。</p>
<h3 id="解决断点歧义"><a href="#解决断点歧义" class="headerlink" title="解决断点歧义"></a>解决断点歧义</h3><p>通过包名添加断点存在着一种歧义的情况：当断点落在函数定义的范围之内时，它是表示对mainchunk中的函数声明添加断点，还是表示在该子函数执行时添加断点。（本质上是因为mainchunk的有效行和子函数有效行存在重叠）</p>
<p>所以为了优雅地解决这个歧义问题，我们使用行号的正负表示是在mainchunk中还是在子函数中添加断点。如果行号是正数，表示子函数，跟前几篇中的情况保持一致；如果行号是负数，则表示在mainchunk中添加断点。</p>
<p>好了，解决了最关键的几个问题，我们就可以开始着手写代码了</p>
<h2 id="添加断点"><a href="#添加断点" class="headerlink" title="添加断点"></a>添加断点</h2><p>同样依照惯例，我们先修改设置断点函数。它的改动较大，因为函数名称和包名称都是通过字符串参数指定，所以需要一个区分手段，我们这里采用了一个跟在名称后面的特殊字符来进行区分。如果后面跟的是<code>@</code>，表示是函数名称，如果后面跟的是<code>:</code>，表示是包名。</p>
<p>先来看通过包名添加断点的情况，首先查找标记符号<code>:</code>，如果找到则前面部分表示包名，后面部分表示行号。切分之后，检查包名是否为空，再检查行号是否合法。如果没有指定行号，那么默认设置为-1，也就是mainchunk的第一行。接下来调用<code>package.searchpath()</code>将包名转化为路径，如果找到了指定的包，再通过<code>setsrcbp()</code>函数来设置断点。<code>setsrcbp()</code>我们稍后介绍。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setbreakpoint</span><span class="params">(where, line)</span></span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(where) == <span class="string">&quot;function&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> setfuncbp(where, line)</span><br><span class="line">    <span class="keyword">else</span>            <span class="comment">-- &quot;string&quot;</span></span><br><span class="line">        <span class="keyword">local</span> i = <span class="built_in">string</span>.<span class="built_in">find</span>(where, <span class="string">&quot;:&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">then</span>   <span class="comment">-- package name</span></span><br><span class="line">            <span class="keyword">local</span> packname = <span class="built_in">string</span>.<span class="built_in">sub</span>(where, <span class="number">1</span>, i<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">local</span> line = <span class="built_in">string</span>.<span class="built_in">sub</span>(where, i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> packname == <span class="string">&quot;&quot;</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;no package name specified!\n&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> line ~= <span class="string">&quot;&quot;</span> <span class="keyword">then</span></span><br><span class="line">                line = <span class="built_in">tonumber</span>(line)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> line <span class="keyword">then</span></span><br><span class="line">                    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;no valid line number specified!\n&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                line = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">local</span> <span class="built_in">path</span>, err = <span class="built_in">package</span>.searchpath(packname, <span class="built_in">package</span>.<span class="built_in">path</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">path</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">io</span>.<span class="built_in">write</span>(err)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">return</span> setsrcbp(<span class="built_in">path</span>, line)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>通过函数名称添加断点的情况也是类似，不过省了路径转换的步骤。首先查找标记符号<code>@</code>，然后切分函数名和行号，检查函数名是否为空，检查行号是否合法，都ok之后再交给<code>setnamebp()</code>进行后面的工作。<code>setnamebp()</code>函数我们在上一篇已经介绍过了。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setbreakpoint</span><span class="params">(where, line)</span></span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">local</span> i = <span class="built_in">string</span>.<span class="built_in">find</span>(where, <span class="string">&quot;@&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">then</span>   <span class="comment">-- function name</span></span><br><span class="line">                <span class="keyword">local</span> funcname = <span class="built_in">string</span>.<span class="built_in">sub</span>(where, <span class="number">1</span>, i<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">local</span> line = <span class="built_in">string</span>.<span class="built_in">sub</span>(where, i+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> funcname == <span class="string">&quot;&quot;</span> <span class="keyword">then</span></span><br><span class="line">                    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;no function name specified!\n&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">if</span> line ~= <span class="string">&quot;&quot;</span> <span class="keyword">then</span></span><br><span class="line">                    line = <span class="built_in">tonumber</span>(line)</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> line <span class="keyword">then</span></span><br><span class="line">                        <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;no valid line number specified!\n&quot;</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    line = <span class="literal">nil</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">return</span> setnamebp(funcname, line)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>下面我们来看<code>setsrcbp()</code>函数的实现，这个函数跟<code>setnamebp()</code>大体上类似，开头部分稍有不同。首先会通过<code>lookforfunc()</code>查看断点是否位于已知函数中，如果是的话返回该函数，然后直接调用<code>setfuncbp()</code>函数作为函数断点处理。<code>lookforfunc()</code>我们稍晚一点再介绍。后面的流程跟<code>setnamebp()</code>并无二致就不再赘述。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setsrcbp</span><span class="params">(src, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 检查断点是否位于已知函数中</span></span><br><span class="line">    <span class="keyword">local</span> func = lookforfunc(src, line)</span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> setfuncbp(func, line)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> srcbp = s.srcbpt[src]</span><br><span class="line">    <span class="comment">-- 检查相同的断点是否已经设置</span></span><br><span class="line">    <span class="keyword">if</span> srcbp <span class="keyword">and</span> srcbp[line] <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> srcbp[line]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>钩子函数的改动都是在call事件中。首先，在获取到当前函数及其信息之后，调用<code>solvesrcbp()</code>处理<code>status.srcbpt</code>表中还未转换的断点，如果发现有位于当前函数中的断点，那么就进行相应的断点转换。接下来，如果当前函数不是C函数，就调用<code>setsrcfunc()</code>函数保存函数信息。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span> <span class="params">(event, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail call&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> stackinfo = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>, <span class="string">&quot;nf&quot;</span>)</span><br><span class="line">        <span class="keyword">local</span> func = stackinfo.func</span><br><span class="line">        <span class="keyword">local</span> name = stackinfo.name</span><br><span class="line">        <span class="keyword">local</span> funcinfo = getfuncinfo(func)</span><br><span class="line">        <span class="keyword">local</span> hasbreak = <span class="literal">false</span></span><br><span class="line">        <span class="comment">-- 处理通过包名添加的还未转换的断点</span></span><br><span class="line">        solvesrcbp(funcinfo, func)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> funcinfo.what ~= <span class="string">&quot;C&quot;</span> <span class="keyword">then</span></span><br><span class="line">            setsrcfunc(funcinfo, func)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> s.funcbpt[func] <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> id = s.funcbpt[func]</span><br><span class="line">            <span class="keyword">if</span> s.bptable[id] <span class="keyword">and</span> <span class="keyword">not</span> s.bptable[id].src <span class="keyword">then</span></span><br><span class="line">                s.bptable[id].src = funcinfo.short_src</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            hasbreak = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="断点转换"><a href="#断点转换" class="headerlink" title="断点转换"></a>断点转换</h2><p>接下来看下<code>solvesrcbp()</code>函数的实现，如果当前源文件中存在未转换的断点，那么遍历这些断点，调用<code>verifyfuncline()</code>判断断点是否在当前函数中，如果是的话就调用<code>modsrcbp()</code>函数进行实际的转换操作。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">solvesrcbp</span> <span class="params">(info, func)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">local</span> srcbp = s.srcbpt[info.short_src]</span><br><span class="line">    <span class="keyword">if</span> srcbp <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(srcbp) <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> k ~= <span class="string">&quot;num&quot;</span> <span class="keyword">then</span></span><br><span class="line">                line = verifyfuncline(info, k)</span><br><span class="line">                <span class="keyword">if</span> line <span class="keyword">then</span></span><br><span class="line">                    modsrcbp(info.short_src, func, k, line)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p><code>modsrcbp()</code>函数的实现如下，它有4个参数第一个<code>src</code>是源文件路径、第二个<code>func</code>是函数、第三个<code>oline</code>是设置断点时的行号、第四个<code>nline</code>是<code>verifyfuncline()</code>进行修正后的行号。</p>
<p>该函数首先以<code>src</code>和<code>oline</code>为索引将断点从<code>status.srcbpt</code>表中移除，然后设置到<code>status.funcbpt</code>表中。如果同一个断点已经设置过了，那么将新添加的断点删除，然后返回旧的断点id。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">modsrcbp</span><span class="params">(src, func, oline, nline)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">local</span> srcbp = s.srcbpt[src]</span><br><span class="line">    <span class="keyword">local</span> id = srcbp[oline]</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 从srcbpt中移除</span></span><br><span class="line">    srcbp.num = srcbp.num - <span class="number">1</span></span><br><span class="line">    srcbp[oline] = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> srcbp.num == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        srcbp = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 设置funcbpt</span></span><br><span class="line">    <span class="keyword">local</span> funcbp = s.funcbpt[func]</span><br><span class="line">    <span class="comment">-- 检查是否已经设置了相同的断点</span></span><br><span class="line">    <span class="keyword">if</span> funcbp <span class="keyword">and</span> funcbp[nline] <span class="keyword">then</span></span><br><span class="line">        s.bptable[id] = <span class="literal">nil</span>      <span class="comment">-- 如果已经设置了，删除新加的断点</span></span><br><span class="line">        s.bpnum = s.bpnum - <span class="number">1</span></span><br><span class="line">        <span class="built_in">assert</span>(s.bpnum &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> funcbp[nline]     <span class="comment">-- 返回旧的断点id</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>如果还未添加过这个断点，那么就在<code>status.funcbpt</code>中添加该断点，然后将断点所在的函数和修正后的行号更新到<code>s.bptable</code>表中。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">modsrcbp</span><span class="params">(src, func, oline, nline)</span></span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> funcbp <span class="keyword">then</span>            <span class="comment">-- 该函数的第一个断点</span></span><br><span class="line">        s.funcbpt[func] = &#123;&#125;</span><br><span class="line">        funcbp = s.funcbpt[func]</span><br><span class="line">        funcbp.num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    funcbp.num = funcbp.num + <span class="number">1</span></span><br><span class="line">    funcbp[nline] = id</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 更新bptable中字段</span></span><br><span class="line">    s.bptable[id].func = func</span><br><span class="line">    s.bptable[id].line = nline</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="行号扩展"><a href="#行号扩展" class="headerlink" title="行号扩展"></a>行号扩展</h2><p>因为我们对行号进行了扩展了，使用负数来表示mainchunk中的断点，所以<code>verifyfuncline()</code>也需要进行相应的扩展。对于行号是负数的情况，如果不是mainchunk函数，直接返回nil，否则对行号取反还原为正常的行号。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">verifyfuncline</span> <span class="params">(info, line)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> info.sortedlines[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> line &lt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> info.what ~= <span class="string">&quot;main&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        line = -line</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> line &lt; info.linedefined <span class="keyword">or</span> line &gt; info.lastlinedefined <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(info.sortedlines) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> v &gt;= line <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>)   <span class="comment">-- impossible to reach here</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>这里还有一个问题，通过<code>debug.getinfo()</code>函数获取到的函数信息中，对于mainchunk的情况，<code>linedefined</code>和<code>lastlinedefined</code>字段的值都是0，于是我们的<code>getfuncinfo()</code>函数也要进行相应的调整：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">getfuncinfo</span> <span class="params">(func)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">local</span> info = s.funcinfos[func]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> info <span class="keyword">then</span></span><br><span class="line">        info = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(func, <span class="string">&quot;SL&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (info.activelines) <span class="keyword">then</span></span><br><span class="line">            info.sortedlines = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> k, _ <span class="keyword">in</span> <span class="built_in">pairs</span>(info.activelines) <span class="keyword">do</span></span><br><span class="line">               <span class="built_in">table</span>.<span class="built_in">insert</span>(info.sortedlines, k)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="built_in">table</span>.<span class="built_in">sort</span>(info.sortedlines)</span><br><span class="line">            <span class="comment">-- mainchunk需要特殊处理以使`verifyfuncline`能够正常工作</span></span><br><span class="line">            <span class="keyword">if</span> info.what == <span class="string">&quot;main&quot;</span> <span class="keyword">then</span></span><br><span class="line">                info.linedefined = <span class="number">1</span></span><br><span class="line">                info.lastlinedefined = info.sortedlines[#info.sortedlines]</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        s.funcinfos[func] = info</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> info</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>对于mainchunk函数进行特殊处理，将<code>linedefined</code>设置为1，将<code>lastlinedefined</code>设置为最后一个有效行的行号。</p>
<h2 id="缓存及查找源文件的函数"><a href="#缓存及查找源文件的函数" class="headerlink" title="缓存及查找源文件的函数"></a>缓存及查找源文件的函数</h2><p>我们在钩子函数中调用<code>setsrcfunc()</code>保存函数信息，将函数与源文件关联。在<code>setsrcbp()</code>中调用<code>lookforfunc()</code>通过源文件和行号查找对应的函数。先来看<code>setsrcfunc()</code>函数实现：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setsrcfunc</span> <span class="params">(info, func)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">local</span> srcfunc = s.srcfuncmap[info.short_src]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> srcfunc <span class="keyword">then</span></span><br><span class="line">        srcfunc = &#123;&#125;</span><br><span class="line">        s.srcfuncmap[info.short_src] = srcfunc</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> srcfunc[func] <span class="keyword">then</span></span><br><span class="line">        srcfunc[func] = info</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>其中<code>status.srcfuncmap</code>就是我们新增的数据结构，它是一个以源文件路径为键的表，其值也是一个表，保存位于该源文件中的函数信息，以函数为键，以函数信息为值。</p>
<p>再来看<code>lookforfunc()</code>函数的实现：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">lookforfunc</span> <span class="params">(src, line)</span></span></span><br><span class="line">    <span class="built_in">assert</span>(line)</span><br><span class="line">    <span class="keyword">local</span> srcfunc = <span class="built_in">status</span>.srcfuncmap[src]</span><br><span class="line">    <span class="keyword">if</span> srcfunc <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">for</span> func, info <span class="keyword">in</span> <span class="built_in">pairs</span>(srcfunc) <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> info.what == <span class="string">&quot;main&quot;</span> <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">if</span> line &lt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">return</span> func</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">elseif</span> line &gt;= info.linedefined</span><br><span class="line">                <span class="keyword">and</span> line &lt;= info.lastlinedefined <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">return</span> func</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p><code>lookforfunc()</code>函数中首先判断该源文件是否有缓存的函数信息，如果有则进行遍历。如果行号是负数，则只要找到mainchunk就可以返回了。否则，需要判断断点的行号是否在函数定义的范围内。找到了，就返回断点所在函数；没有找到返回<code>nil</code>。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>首先，编写一个用于测试的包<code>testlib.lua</code>，实现了两个简单的函数foo和bar。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    foo = foo,</span><br><span class="line">    bar = bar,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="测试通过函数名和包名添加断点"><a href="#测试通过函数名和包名添加断点" class="headerlink" title="测试通过函数名和包名添加断点"></a>测试通过函数名和包名添加断点</h3><p>我们通过函数名添加了两个断点，其中一个省略行号，默认为函数第一个有效行。又通过包名添加了两个有效断点id3和id4，id5虽然能添加成功，但是并不落在有效函数范围内。id6和id7都是参数错误的情况，添加断点失败。</p>
<p>设置完断点，先分别调用foo和bar函数一次，预期都在foo函数第2行第3行会碰到断点，然后在bar函数的第6行第7行碰到断点。接着分别删除foo和bar函数中的1个断点，再分别调用foo和bar函数一次，预期在foo函数的第3行和bar函数的第7行碰到断点。最后删除foo和bar函数中的另一个断点，再分别调用foo和bar函数一次，预期不再碰到断点。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> lib = <span class="built_in">require</span> <span class="string">&quot;testlib&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(<span class="string">&quot;foo@&quot;</span>)           <span class="comment">-- foo 2</span></span><br><span class="line"><span class="keyword">local</span> id2 = setbp(<span class="string">&quot;foo@3&quot;</span>)          <span class="comment">-- foo 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id3 = setbp(<span class="string">&quot;testlib:5&quot;</span>)      <span class="comment">-- bar 6</span></span><br><span class="line"><span class="keyword">local</span> id4 = setbp(<span class="string">&quot;testlib:7&quot;</span>)      <span class="comment">-- bar 7</span></span><br><span class="line"><span class="keyword">local</span> id5 = setbp(<span class="string">&quot;testlib:100&quot;</span>)    <span class="comment">-- invalid line</span></span><br><span class="line"><span class="keyword">local</span> id6 = setbp(<span class="string">&quot;:5&quot;</span>)</span><br><span class="line"><span class="built_in">assert</span>(<span class="keyword">not</span> id6)</span><br><span class="line"><span class="keyword">local</span> id7 = setbp(<span class="string">&quot;testlib:aa&quot;</span>)</span><br><span class="line"><span class="built_in">assert</span>(<span class="keyword">not</span> id7)</span><br><span class="line"></span><br><span class="line">lib.foo(<span class="number">1</span>)              <span class="comment">-- break twice</span></span><br><span class="line">lib.bar(<span class="number">1</span>)              <span class="comment">-- break twice</span></span><br><span class="line"></span><br><span class="line">rmbp(id1)</span><br><span class="line">rmbp(id3)</span><br><span class="line"></span><br><span class="line">lib.foo(<span class="number">2</span>)              <span class="comment">-- break once</span></span><br><span class="line">lib.bar(<span class="number">2</span>)              <span class="comment">-- break once</span></span><br><span class="line"></span><br><span class="line">rmbp(id2)</span><br><span class="line">rmbp(id4)</span><br><span class="line"></span><br><span class="line">lib.foo(<span class="number">3</span>)              <span class="comment">-- not break</span></span><br><span class="line">lib.bar(<span class="number">3</span>)              <span class="comment">-- not break</span></span><br></pre></td></tr></table></figure>

<p>运行测试脚本，分别在foo函数和bar函数中碰到两个断点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua setbpbysrc.lua</span><br><span class="line">no package name specified!</span><br><span class="line">no valid line number specified!</span><br><span class="line">Lua (field)foo /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:2</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (field)foo /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:3</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (field)bar /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:6</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (field)bar /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:7</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>继续执行，分别在foo函数和bar函数中碰到一个断点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (field)foo /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:3</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (field)bar /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:7</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>继续执行，没有再碰到断点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">$</span><br></pre></td></tr></table></figure>



<h3 id="测试行号扩展"><a href="#测试行号扩展" class="headerlink" title="测试行号扩展"></a>测试行号扩展</h3><p>编写如下测试脚本，在mainchunk中添加了4个断点，其中不指定行号时默认是mainchunk的第一个有效行。当require该包时，预期在mainchunk的第3行、第7行、第9行和第13行分别碰到断点。</p>
<p>接着在子函数foo中添加两个断点，调用foo函数，预期在foo函数第2行和第3行碰到断点。然后其中一个断点，再调用foo函数，预期在foo函数第3行碰到断点。最后删除剩余一个断点，再调用foo函数，预期不再碰到断点。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(<span class="string">&quot;testlib:&quot;</span>)       <span class="comment">-- main 3</span></span><br><span class="line"><span class="keyword">local</span> id2 = setbp(<span class="string">&quot;testlib:-5&quot;</span>)     <span class="comment">-- main 7</span></span><br><span class="line"><span class="keyword">local</span> id3 = setbp(<span class="string">&quot;testlib:-9&quot;</span>)     <span class="comment">-- main 9</span></span><br><span class="line"><span class="keyword">local</span> id4 = setbp(<span class="string">&quot;testlib:-13&quot;</span>)    <span class="comment">-- main 13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> lib = <span class="built_in">require</span> <span class="string">&quot;testlib&quot;</span>       <span class="comment">-- break 4 times</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id5 = setbp(<span class="string">&quot;testlib:2&quot;</span>)      <span class="comment">-- foo 2</span></span><br><span class="line"><span class="keyword">local</span> id6 = setbp(<span class="string">&quot;testlib:3&quot;</span>)      <span class="comment">-- foo 3</span></span><br><span class="line"></span><br><span class="line">lib.foo()   <span class="comment">-- break 2 times</span></span><br><span class="line"></span><br><span class="line">rmbp(id5)</span><br><span class="line"></span><br><span class="line">lib.foo()   <span class="comment">-- break 1 time</span></span><br><span class="line"></span><br><span class="line">rmbp(id6)</span><br><span class="line"></span><br><span class="line">lib.foo()   <span class="comment">-- not break</span></span><br></pre></td></tr></table></figure>



<p>运行测试脚本，首先碰到了mainchunk中的4个断点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua mainchunk.lua</span><br><span class="line">main ()nil /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:3</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">main ()nil /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:7</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">main ()nil /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:9</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">main ()nil /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:13</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>继续执行，碰到foo函数中两个断点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (field)foo /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:2</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (field)foo /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:3</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>再继续执行，碰到foo函数中一个断点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (field)foo /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:3</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>再cont就结束了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">$</span><br></pre></td></tr></table></figure>



<h3 id="测试断点重复及缓存源文件的函数"><a href="#测试断点重复及缓存源文件的函数" class="headerlink" title="测试断点重复及缓存源文件的函数"></a>测试断点重复及缓存源文件的函数</h3><p>编写如下测试脚本，首先我们通过函数添加一个断点，然后再通过包名添加一个断点。虽然这两个实际是同一个断点，但是刚开始的时候因为还没有缓存信息，所以第二个断点也会添加成功。接着调用 foo函数，预期在foo函数第2行碰到断点。在钩子函数call事件中会处理未转换的断点2，因为已经存在同样的断点了，所以会将断点2删除。</p>
<p>接下来我们删除断点1之后，就没有断点了，再次调用foo函数，预期不会碰到断点。</p>
<p>然后我们再通过包名添加一个断点，这里因为已经有了对应的函数信息，所以预期会直接转换成对应的函数断点。当我们再对函数添加同样的断点的时候预期返回之前的断点号。</p>
<p>调用foo函数，预期在foo函数第3行碰到断点。删除断点3，预期不再碰到断点。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> lib = <span class="built_in">require</span> <span class="string">&quot;testlib&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(lib.foo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id2 = setbp(<span class="string">&quot;testlib:1&quot;</span>)  <span class="comment">-- foo 2</span></span><br><span class="line"></span><br><span class="line">lib.foo()   <span class="comment">-- break once</span></span><br><span class="line"></span><br><span class="line">rmbp(id1)</span><br><span class="line"></span><br><span class="line">lib.foo()   <span class="comment">-- not break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;not break&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id3 = setbp(<span class="string">&quot;testlib:3&quot;</span>)  <span class="comment">-- foo 3</span></span><br><span class="line"><span class="built_in">assert</span>(id3 == <span class="number">3</span>)</span><br><span class="line"><span class="keyword">local</span> id4 = setbp(lib.foo, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">assert</span>(id3 == id4)</span><br><span class="line"></span><br><span class="line">lib.foo()   <span class="comment">-- break once</span></span><br><span class="line"></span><br><span class="line">rmbp(id3)</span><br><span class="line"></span><br><span class="line">lib.foo()   <span class="comment">-- not break</span></span><br></pre></td></tr></table></figure>



<p>运行测试脚本，结果符合预期。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua srcfuncmap.lua</span><br><span class="line">Lua (field)foo /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:2</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">not <span class="built_in">break</span></span><br><span class="line">Lua (field)foo /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:3</span><br><span class="line">lua_debug&gt; cont</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>编程开发</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenResty Lua钩子调用完整流程</title>
    <url>/posts/30b81f82/</url>
    <content><![CDATA[<div class="note primary">
            <p>前面一篇文章介绍了<a href="../150430f0/">Openresty Lua协程调度机制</a>，主要关心的是核心调度函数<code>run_thread()</code>内部发生的事情，而对于外部的事情我们并没有涉及。本篇作为其姊妹篇，准备补上剩余的部分。本篇将通过一个例子，完整介绍OpenResty中Lua钩子的调用流程，包括初始化阶段的工作、新连接进来时如何进入钩子、I/O等待时如何出去、事件触发时如何恢复、钩子正常执行结束时的操作、钩子内出错的情况。本文同样是基于<code>stream-lua</code>模块的代码。</p>
          </div>

<span id="more"></span>

<h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p>我们以<code>ssl_certificate_by_lua*</code>钩子为例来进行介绍，一来是因为它还涉及SSL握手，流程上更长一点。二来是因为在其上下文中是<code>YIELDABLE</code>的，支持的<code>ngx</code>接口比较完整。</p>
<p>我们将以下面两个配置为例来展开介绍。例子非常简单，第一个是正常的结束情况在<code>ssl_certificate_by_lua_block</code>里面调用了<code>ngx.sleep()</code>。第二个是出错中止的情况，多了一个<code>ngx.exit(ngx.ERROR)</code>。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="section">ssl_certificate_by_lua_block</span> &#123;</span><br><span class="line">        ngx.sleep(0.1)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> test.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> test.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="section">ssl_certificate_by_lua_block</span> &#123;</span><br><span class="line">        ngx.sleep(0.1)</span><br><span class="line">        ngx.exit(ngx.ERROR)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> test.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> test.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，分别来看一下初始化阶段和连接阶段的整体流程。后面章节会结合实际代码，来详细介绍每种情况下是如何处理的。</p>
<h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/30b81f82/openresty-lua-hook-flow-init-phase.svg" alt="openresty-lua-hook-flow-init-phase" loading="lazy"></p>
<p>初始化阶段的流程比较简单：配置解析阶段会读取配置文件中的代码块进行解析保存，然后创建Lua代码的key，这个key是用于后面将代码cache到注册表的。配置合并阶段，主要是合并配置项，然后设置<code>cert_cb</code>回调。配置后处理阶段，主要工作是初始化Lua VM，包括创建注册表项、创建全局表项<code>ngx</code>、替换coroutine接口。</p>
<h2 id="连接阶段"><a href="#连接阶段" class="headerlink" title="连接阶段"></a>连接阶段</h2><p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/30b81f82/openresty-lua-hook-flow-connect-phase.svg" alt="openresty-lua-hook-flow-connect-phase" loading="lazy"></p>
<p>连接阶段因为涉及新连接进入钩子、I/O等待时出去、事件触发时恢复、钩子正常执行结束（YIELD之后）、钩子内出错（YIELD之后）等各种情况，相对比较复杂。图中用不同颜色分别表示这几种不同的情况，每种颜色又用数字标识了其流程顺序。读者可以结合这个图，阅读后续每个阶段的代码，应该能够帮助您更好地理解。</p>
<p>另外提一下，本文没有涉及Lua代码执行过程没有碰到YIELD就直接完成或者出错的情况。因为这种情况比较简单，整个流程都是一个同步的过程。执行完成或者出错之后，<code>lua_resume()</code>返回，后续的流程就跟图中I/O等待（棕色）的情况是一样的。</p>
<h1 id="初始化阶段-1"><a href="#初始化阶段-1" class="headerlink" title="初始化阶段"></a>初始化阶段</h1><h2 id="配置项解析"><a href="#配置项解析" class="headerlink" title="配置项解析"></a>配置项解析</h2><p>解析到<code>ssl_certificate_by_lua_block</code>时会调用<code>ngx_stream_lua_ssl_cert_by_lua_block()</code>进行解析，里面会进行配置文件的词法分析，将代码块中的代码都合并到一个buffer之后，插入到参数数组的后面。然后调用<code>ngx_stream_lua_ssl_cert_by_lua()</code>。（如果是<code>by_lua_file</code>的情况会直接调用<code>ngx_stream_lua_ssl_cert_by_lua()</code>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_stream_lua_ssl_cert_by_lua_block</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> *conf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>        *rv;</span><br><span class="line">    <span class="keyword">ngx_conf_t</span>   save;</span><br><span class="line"></span><br><span class="line">    save = *cf;</span><br><span class="line">    cf-&gt;handler = ngx_stream_lua_ssl_cert_by_lua;</span><br><span class="line">    cf-&gt;handler_conf = conf;</span><br><span class="line"></span><br><span class="line">    rv = ngx_stream_lua_conf_lua_block_parse(cf, cmd);</span><br><span class="line"></span><br><span class="line">    *cf = save;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ngx_stream_lua_ssl_cert_by_lua()</code>主要工作是设置<code>lscf-&gt;srv.ssl_cert_src</code>以及创建Lua代码的key。如果是<code>by_lua_file</code>的情况，key以字符串<code>nhlf_</code>开头，后边是对文件路径计算的摘要十六进制值；而<code>by_lua_block</code>的情况，key以字符串<code>&quot;ssl_certificate_by_lua&quot;</code>开头，后边是对整个Lua代码块计算的摘要十六进制值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lscf-&gt;srv.ssl_cert_src = value[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">p = ngx_palloc(cf-&gt;pool,</span><br><span class="line">               <span class="keyword">sizeof</span>(<span class="string">&quot;ssl_certificate_by_lua&quot;</span>) +</span><br><span class="line">               NGX_STREAM_LUA_INLINE_KEY_LEN);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> NGX_CONF_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lscf-&gt;srv.ssl_cert_src_key = p;</span><br><span class="line"></span><br><span class="line">p = ngx_copy(p, <span class="string">&quot;ssl_certificate_by_lua&quot;</span>,</span><br><span class="line">             <span class="keyword">sizeof</span>(<span class="string">&quot;ssl_certificate_by_lua&quot;</span>) - <span class="number">1</span>);</span><br><span class="line">p = ngx_copy(p, NGX_STREAM_LUA_INLINE_TAG, NGX_STREAM_LUA_INLINE_TAG_LEN);</span><br><span class="line">p = ngx_stream_lua_digest_hex(p, value[<span class="number">1</span>].data, value[<span class="number">1</span>].len);</span><br><span class="line">*p = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="配置项合并"><a href="#配置项合并" class="headerlink" title="配置项合并"></a>配置项合并</h2><p>在配置合并阶段，由<code>ngx_stream_lua_merge_srv_conf()</code>把<code>cert_cb</code>回调函数<code>ngx_stream_lua_ssl_cert_handler()</code>设置到server的<code>SSL_CTX</code>上。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        <span class="comment">/* 先进行配置合并 */</span></span><br><span class="line">        <span class="keyword">if</span> (conf-&gt;srv.ssl_cert_src.len == <span class="number">0</span>) &#123;</span><br><span class="line">            conf-&gt;srv.ssl_cert_src = prev-&gt;srv.ssl_cert_src;</span><br><span class="line">            conf-&gt;srv.ssl_cert_src_key = prev-&gt;srv.ssl_cert_src_key;</span><br><span class="line">            conf-&gt;srv.ssl_cert_handler = prev-&gt;srv.ssl_cert_handler;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 如果设置了该配置 */</span></span><br><span class="line">        <span class="keyword">if</span> (conf-&gt;srv.ssl_cert_src.len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sscf-&gt;ssl.ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ngx_log_error(NGX_LOG_EMERG, cf-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                              <span class="string">&quot;no ssl configured for the server&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> NGX_CONF_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> OPENSSL_VERSION_NUMBER &gt;= 0x1000205fL</span></span><br><span class="line">            <span class="comment">/* 设置cert_cb回调 */</span></span><br><span class="line">            SSL_CTX_set_cert_cb(sscf-&gt;ssl.ctx, ngx_stream_lua_ssl_cert_handler, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置后处理-postconfiguration"><a href="#配置后处理-postconfiguration" class="headerlink" title="配置后处理 postconfiguration"></a>配置后处理 postconfiguration</h2><p>在postconfig阶段，会调用<code>ngx_stream_lua_init()</code>，它里面最关键的任务就是初始化Lua VM。（其实还会调用<code>init_by*</code>钩子，不过不在我们今天的讨论范围内。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rc = ngx_stream_lua_init_vm(&amp;lmcf-&gt;lua, <span class="literal">NULL</span>, cf-&gt;cycle, cf-&gt;pool,</span><br><span class="line">                            lmcf, cf-&gt;<span class="built_in">log</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>我们来看下<code>ngx_stream_lua_init_vm()</code>里面的实现，它先会创建Lua VM实例，然后注册其cleanup handler，如果有第三方模块的<code>preload_hooks</code>会注册之，然后会加载<code>resty.core</code>模块，最后会注入代码对全局变量的写操作加一个警告日志。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/* create new Lua VM instance */</span></span><br><span class="line">    L = ngx_stream_lua_new_state(parent_vm, cycle, lmcf, <span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* register cleanup handler for Lua VM */</span></span><br><span class="line">    cln-&gt;handler = ngx_stream_lua_cleanup_vm;</span><br><span class="line"></span><br><span class="line">    state = ngx_alloc(<span class="keyword">sizeof</span>(<span class="keyword">ngx_stream_lua_vm_state_t</span>), <span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    state-&gt;vm = L;</span><br><span class="line">    state-&gt;count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    cln-&gt;data = state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lmcf-&gt;vm_cleanup == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* this assignment will happen only once,</span></span><br><span class="line"><span class="comment">         * and also only for the main Lua VM */</span></span><br><span class="line">        lmcf-&gt;vm_cleanup = cln;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OPENRESTY_LUAJIT</span></span><br><span class="line">    <span class="comment">/* load FFI library first since cdata needs it */</span></span><br><span class="line">    luaopen_ffi(L);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lmcf-&gt;preload_hooks) &#123;</span><br><span class="line">        <span class="comment">/* 注册第三方preload_hooks */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *new_vm = L;</span><br><span class="line"></span><br><span class="line">    lua_getglobal(L, <span class="string">&quot;require&quot;</span>);</span><br><span class="line">    lua_pushstring(L, <span class="string">&quot;resty.core&quot;</span>);</span><br><span class="line"></span><br><span class="line">    rc = lua_pcall(L, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_DECLINED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OPENRESTY_LUAJIT</span></span><br><span class="line">    ngx_stream_lua_inject_global_write_guard(L, <span class="built_in">log</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NGX_OK;</span><br></pre></td></tr></table></figure>

<p>关键函数是创建Lua VM实例的<code>ngx_stream_lua_new_state()</code>，我们来一睹其芳容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建vm state*/</span></span><br><span class="line">L = luaL_newstate();</span><br><span class="line"><span class="comment">/* 打开标准库 */</span></span><br><span class="line">luaL_openlibs(L);</span><br><span class="line"><span class="comment">/* 获取package表 */</span></span><br><span class="line">lua_getglobal(L, <span class="string">&quot;package&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置package.path和package.cpath */</span></span><br><span class="line"></span><br><span class="line">lua_pop(L, <span class="number">1</span>); <span class="comment">/* remove the &quot;package&quot; table */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化registry */</span></span><br><span class="line">ngx_stream_lua_init_registry(L, <span class="built_in">log</span>);</span><br><span class="line"><span class="comment">/* 初始化globals */</span></span><br><span class="line">ngx_stream_lua_init_globals(L, cycle, lmcf, <span class="built_in">log</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> L;</span><br></pre></td></tr></table></figure>

<p>重点是最后的两个函数，它们分别初始化<code>registry</code>和<code>globals</code>。这个两个函数都不算太长，让我们来完整看下它们做了些什么。</p>
<p><code>ngx_stream_lua_init_registry()</code>创建了几个注册表项，分别用于存放协程、Lua的请求ctx、socket连接池、Lua预编译正则表达式对象cache及Lua代码cache。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ngx_stream_lua_init_registry(lua_State *L, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_log_debug0(NGX_LOG_DEBUG_STREAM, <span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="string">&quot;lua initializing lua registry&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &#123;&#123;&#123; register a table to anchor lua coroutines reliably:</span></span><br><span class="line"><span class="comment">     * &#123;([int]ref) = [cort]&#125; */</span></span><br><span class="line">    lua_pushlightuserdata(L, ngx_stream_lua_lightudata_mask(</span><br><span class="line">                          coroutines_key));</span><br><span class="line">    lua_createtable(L, <span class="number">0</span>, <span class="number">32</span> <span class="comment">/* nrec */</span>);</span><br><span class="line">    lua_rawset(L, LUA_REGISTRYINDEX);</span><br><span class="line">    <span class="comment">/* &#125;&#125;&#125; */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create the registry entry for the Lua request ctx data table */</span></span><br><span class="line">    lua_pushliteral(L, ngx_stream_lua_ctx_tables_key);</span><br><span class="line">    lua_createtable(L, <span class="number">0</span>, <span class="number">32</span> <span class="comment">/* nrec */</span>);</span><br><span class="line">    lua_rawset(L, LUA_REGISTRYINDEX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create the registry entry for the Lua socket connection pool table */</span></span><br><span class="line">    lua_pushlightuserdata(L, ngx_stream_lua_lightudata_mask(</span><br><span class="line">                          socket_pool_key));</span><br><span class="line">    lua_createtable(L, <span class="number">0</span>, <span class="number">8</span> <span class="comment">/* nrec */</span>);</span><br><span class="line">    lua_rawset(L, LUA_REGISTRYINDEX);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_PCRE)</span></span><br><span class="line">    <span class="comment">/* create the registry entry for the Lua precompiled regex object cache */</span></span><br><span class="line">    lua_pushlightuserdata(L, ngx_stream_lua_lightudata_mask(</span><br><span class="line">                          regex_cache_key));</span><br><span class="line">    lua_createtable(L, <span class="number">0</span>, <span class="number">16</span> <span class="comment">/* nrec */</span>);</span><br><span class="line">    lua_rawset(L, LUA_REGISTRYINDEX);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &#123;&#123;&#123; register table to cache user code:</span></span><br><span class="line"><span class="comment">     * &#123; [(string)cache_key] = &lt;code closure&gt; &#125; */</span></span><br><span class="line">    lua_pushlightuserdata(L, ngx_stream_lua_lightudata_mask(</span><br><span class="line">                          code_cache_key));</span><br><span class="line">    lua_createtable(L, <span class="number">0</span>, <span class="number">8</span> <span class="comment">/* nrec */</span>);</span><br><span class="line">    lua_rawset(L, LUA_REGISTRYINDEX);</span><br><span class="line">    <span class="comment">/* &#125;&#125;&#125; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ngx_stream_lua_init_globals()</code>则是创建了<code>ngx</code>表，接着把相关Lua Ngx API全部注册到全局表上了，其中就包括我们前面例子中的<code>ngx.sleep()</code>和<code>ngx.exit()</code>。然后把<code>ngx</code>表分别设为全局表项，同时也设到<code>package.loaded.ngx</code>了。注意，原生的<code>coroutine</code>接口也在这里被替换了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_stream_lua_inject_ngx_api</span><span class="params">(lua_State *L, <span class="keyword">ngx_stream_lua_main_conf_t</span> *lmcf,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lua_createtable(L, <span class="number">0</span> <span class="comment">/* narr */</span>, <span class="number">113</span> <span class="comment">/* nrec */</span>);    <span class="comment">/* ngx.* */</span></span><br><span class="line"></span><br><span class="line">    lua_pushcfunction(L, ngx_stream_lua_get_raw_phase_context);</span><br><span class="line">    lua_setfield(L, <span class="number">-2</span>, <span class="string">&quot;_phase_ctx&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ngx_stream_lua_inject_core_consts(L);</span><br><span class="line"></span><br><span class="line">    ngx_stream_lua_inject_log_api(L);</span><br><span class="line">    ngx_stream_lua_inject_output_api(L);</span><br><span class="line">    ngx_stream_lua_inject_string_api(L);</span><br><span class="line">    ngx_stream_lua_inject_control_api(<span class="built_in">log</span>, L);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ngx_stream_lua_inject_sleep_api(L);</span><br><span class="line">    ngx_stream_lua_inject_phase_api(L);</span><br><span class="line"></span><br><span class="line">    ngx_stream_lua_inject_req_api(<span class="built_in">log</span>, L);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ngx_stream_lua_inject_shdict_api(lmcf, L);</span><br><span class="line">    ngx_stream_lua_inject_socket_tcp_api(<span class="built_in">log</span>, L);</span><br><span class="line">    ngx_stream_lua_inject_socket_udp_api(<span class="built_in">log</span>, L);</span><br><span class="line">    ngx_stream_lua_inject_uthread_api(<span class="built_in">log</span>, L);</span><br><span class="line">    ngx_stream_lua_inject_timer_api(L);</span><br><span class="line">    ngx_stream_lua_inject_config_api(L);</span><br><span class="line"></span><br><span class="line">    lua_getglobal(L, <span class="string">&quot;package&quot;</span>); <span class="comment">/* ngx package */</span></span><br><span class="line">    lua_getfield(L, <span class="number">-1</span>, <span class="string">&quot;loaded&quot;</span>); <span class="comment">/* ngx package loaded */</span></span><br><span class="line">    lua_pushvalue(L, <span class="number">-3</span>); <span class="comment">/* ngx package loaded ngx */</span></span><br><span class="line">    lua_setfield(L, <span class="number">-2</span>, <span class="string">&quot;ngx&quot;</span>); <span class="comment">/* ngx package loaded */</span></span><br><span class="line">    lua_pop(L, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    lua_setglobal(L, <span class="string">&quot;ngx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ngx_stream_lua_inject_coroutine_api(<span class="built_in">log</span>, L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>初始化阶段的主要工作就是这些，简单小结一下，配置项解析阶段完成了Lua代码key的创建，配置项合并阶段完成了Lua钩子回调的设置，postconfig阶段完成了Lua虚拟机的初始化，其中包括registry和globals的初始化。当master进程fork出worker子进程之后，每个worker都将有一个自己的Lua VM实例。</p>
<h1 id="进入Lua钩子"><a href="#进入Lua钩子" class="headerlink" title="进入Lua钩子"></a>进入Lua钩子</h1><p>接下来，我们来看连接发起阶段。当监听的socket接收到连接请求之后，会调用<code>accept</code>建立连接，因为是stream子系统调用到<code>ngx_stream_init_connection</code>，又因为是ssl server会先走到<code>ngx_stream_ssl_handler</code>，里面调用<code>ngx_ssl_create_connection</code>创建连接(<code>SSL_new(ssl-&gt;ctx)</code>)，最终会调用<code>SSL_do_handshake</code>进入SSL状态机。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for ( ;; ) &#123;</span><br><span class="line">    ngx_process_events_and_timers(cycle)</span><br><span class="line">    +-- ngx_epoll_process_events()</span><br><span class="line">        |-- epoll_wait()</span><br><span class="line">        +-- ngx_event_accept()</span><br><span class="line">            |-- accept4()</span><br><span class="line">            |-- ngx_get_connection()</span><br><span class="line">            +-- ngx_stream_init_connection()</span><br><span class="line">                +-- ngx_stream_session_handler()</span><br><span class="line">                    |-- s = ngx_pcalloc(c-&gt;pool, sizeof(ngx_stream_session_t))</span><br><span class="line">                    +-- ngx_stream_core_run_phases()</span><br><span class="line">                        +-- ngx_stream_core_generic_phase()</span><br><span class="line">                            +-- ngx_stream_ssl_handler()</span><br><span class="line">                                +-- ngx_stream_ssl_init_connection()</span><br><span class="line">                                    |-- ngx_ssl_create_connection()</span><br><span class="line">                                    |   +-- SSL_new(ssl-&gt;ctx)</span><br><span class="line">                                    +-- ngx_ssl_handshake()</span><br><span class="line">                                        |-- SSL_do_handshake()</span><br><span class="line">                                        |-- sslerr = SSL_get_error();</span><br><span class="line">                       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SSL状态机的部分不是我们今天的重点，这里暂且略过。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ossl_statem_accept()</span><br><span class="line">+-- state_machine()</span><br><span class="line">    +-- read_state_machine()</span><br><span class="line">        +-- ossl_statem_server_post_process_message()</span><br></pre></td></tr></table></figure>

<p>状态机最终会调用到<code>tls_post_process_client_hello()</code>里的<code>cert_cb</code>。这个回调我们已经在配置初始化阶段设置了，在创建SSL连接的时候又会拷贝到<code>SSL</code>结构体里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tls_post_process_client_hello()</span><br><span class="line">+-- s-&gt;cert-&gt;cert_cb(); /* 即ngx_stream_lua_ssl_cert_handler */</span><br><span class="line">    |   /* 即ngx_stream_lua_ssl_cert_handler_inline */</span><br><span class="line">    +-- lscf-&gt;srv.ssl_cert_handler(r, lscf, L); </span><br><span class="line">        |-- ngx_stream_lua_cache_loadbuffer()</span><br><span class="line">        +-- ngx_stream_lua_ssl_cert_by_chunk()</span><br><span class="line">            |-- ngx_stream_lua_create_ctx()</span><br><span class="line">            |-- lua_xmove(L, co, 1);    /* 将代码闭包从L移到co上 */</span><br><span class="line">            |-- ngx_stream_lua_new_thread()</span><br><span class="line">            +-- ngx_stream_lua_run_thread() </span><br><span class="line">                |-- lua_resume()</span><br></pre></td></tr></table></figure>

<p>在<code>ngx_stream_lua_ssl_cert_handler</code>中会做一些初始化工作，如创建fake连接、fake会话、fake请求(因为还在SSL握手阶段，还没有真实的前端请求)，设置默认的返回码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fc = ngx_stream_lua_create_fake_connection(<span class="literal">NULL</span>);</span><br><span class="line">fs = ngx_stream_lua_create_fake_session(fc);</span><br><span class="line">r = ngx_stream_lua_create_fake_request(fs);</span><br><span class="line">cctx-&gt;exit_code = <span class="number">1</span>;  <span class="comment">/* successful by default */</span></span><br><span class="line">cctx-&gt;connection = c;</span><br><span class="line">cctx-&gt;request = r;</span><br><span class="line">cctx-&gt;entered_cert_handler = <span class="number">1</span>;</span><br><span class="line">cctx-&gt;done = <span class="number">0</span>;</span><br><span class="line">SSL_set_ex_data(c-&gt;ssl-&gt;connection, ngx_stream_lua_ssl_ctx_index, </span><br><span class="line">                cctx)</span><br></pre></td></tr></table></figure>



<p>然后因为是用配置指令是<code>xxx_by_lua_block</code>所以调用<code>ngx_stream_lua_ssl_cert_handler_inline</code>，它里面会加载Lua代码。如果是第一次加载会把代码块加载为一个Lua函数闭包工厂，然后保存闭包工厂到虚拟机的注册表上并生成一个闭包到栈顶；后续会直接从虚拟机注册表上查找并生成闭包到栈顶。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ngx_int_t</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_stream_lua_ssl_cert_handler_inline</span><span class="params">(<span class="keyword">ngx_stream_lua_request_t</span> *r,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">ngx_stream_lua_srv_conf_t</span> *lscf, lua_State *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        rc = ngx_stream_lua_cache_loadbuffer(r-&gt;connection-&gt;<span class="built_in">log</span>, L,</span><br><span class="line">                                         lscf-&gt;srv.ssl_cert_src.data,</span><br><span class="line">                                         lscf-&gt;srv.ssl_cert_src.len,</span><br><span class="line">                                         lscf-&gt;srv.ssl_cert_src_key,</span><br><span class="line">                                         <span class="string">&quot;=ssl_certificate_by_lua&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ngx_stream_lua_ssl_cert_by_chunk(L, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是进入<code>by_chunk()</code>准备执行Lua代码了，这里首先创建模块<code>ctx</code>，接着在虚拟机上创建一个入口线程，并把代码闭包从虚拟机栈上移到新线程的栈上，还在fake请求上挂了一个cleanup。然后就是调用<code>run_thread()</code>进入协程调度循环了。里面的事情我们已经在上一篇中讲到了，<code>lua_resume()</code>开始执行我们的Lua代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ctx = ngx_stream_lua_create_ctx(r-&gt;session);</span><br><span class="line">ctx-&gt;entered_content_phase = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 创建入口线程 */</span></span><br><span class="line">co = ngx_stream_lua_new_thread(r, L, &amp;co_ref);</span><br><span class="line"><span class="comment">/* 将代码闭包移到入口线程中 */</span></span><br><span class="line">lua_xmove(L, co, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 设置闭包的环境表为新协程的全局表 */</span></span><br><span class="line">ngx_stream_lua_get_globals_table(co);</span><br><span class="line">lua_setfenv(co, <span class="number">-2</span>);</span><br><span class="line"><span class="comment">/* 把nginx请求保存到协程全局表中 */</span></span><br><span class="line">ngx_stream_lua_set_req(co, r);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册请求的cleanup hooks */</span></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;cleanup == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    cln = ngx_stream_lua_cleanup_add(r, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (cln == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        rc = NGX_ERROR;</span><br><span class="line">        ngx_stream_lua_finalize_request(r, rc);</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cln-&gt;handler = ngx_stream_lua_request_cleanup_handler;</span><br><span class="line">    cln-&gt;data = ctx;</span><br><span class="line">    ctx-&gt;cleanup = &amp;cln-&gt;handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx-&gt;context = NGX_STREAM_LUA_CONTEXT_SSL_CERT;</span><br><span class="line">rc = ngx_stream_lua_run_thread(L, r, ctx, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h1 id="I-O等待挂起"><a href="#I-O等待挂起" class="headerlink" title="I/O等待挂起"></a>I/O等待挂起</h1><p>我们在初始化阶段已经将Lua Ngx API设置到全局表中了，所以<code>ngx.sleep()</code>会调用到对应的C函数<code>ngx_stream_lua_ngx_sleep()</code>，里面主要是设置了一个定时器，其事件的handler是<code>ngx_stream_lua_sleep_handler()</code>。挂完定时器，就直接<code>lua_yield()</code>了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">coctx-&gt;sleep.handler = ngx_stream_lua_sleep_handler;</span><br><span class="line">coctx-&gt;sleep.data = coctx;</span><br><span class="line">coctx-&gt;sleep.<span class="built_in">log</span> = r-&gt;connection-&gt;<span class="built_in">log</span>;</span><br><span class="line"></span><br><span class="line">ngx_add_timer(&amp;coctx-&gt;sleep, (<span class="keyword">ngx_msec_t</span>) delay);</span><br><span class="line"><span class="keyword">return</span> lua_yield(L, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>回到我们的主线程<code>run_thread()</code>之后，因为是I/O等待就直接返回<code>NGX_AGAIN</code>了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rv = lua_resume(orig_coctx-&gt;co, nrets);</span><br><span class="line"><span class="keyword">switch</span> (rv) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_YIELD:</span><br><span class="line">        <span class="keyword">switch</span> (ctx-&gt;co_op) &#123;</span><br><span class="line">            <span class="keyword">case</span> NGX_STREAM_LUA_USER_CORO_NOP:</span><br><span class="line">                ctx-&gt;cur_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span> NGX_AGAIN;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样又回到了我们的<code>by_chunk()</code>函数，因为返回值是<code>NGX_AGAIN</code>所以会检查先队列里面有没有posted的协程，如果有的话会去恢复协程的执行，在我们这个例子是没有的，不过它的返回值<code>rc</code>改成了<code>NGX_DONE</code>，所以<code>ngx_stream_lua_finalize_request(r, rc);</code>里啥也没干就返回了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rc = ngx_stream_lua_run_thread(L, r, ctx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rc == NGX_ERROR || rc &gt;= NGX_OK) &#123;</span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == NGX_AGAIN) &#123;</span><br><span class="line">    rc = ngx_stream_lua_content_run_posted_threads(L, r, ctx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == NGX_DONE) &#123;</span><br><span class="line">    rc = ngx_stream_lua_content_run_posted_threads(L, r, ctx, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    rc = NGX_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_stream_lua_finalize_request(r, rc);</span><br><span class="line"><span class="keyword">return</span> rc;</span><br></pre></td></tr></table></figure>

<p>这个<code>NGX_DONE</code>的返回值往回传递到<code>ngx_stream_lua_ssl_cert_handler</code>，在这里会对不同返回值做不同处理。如果是完成<code>NGX_OK</code>或出错<code>NGX_ERROR</code>的情况，就意味着钩子的工作已经结束了。我们目前的返回值是<code>NGX_DONE</code>，说明工作还没有结束，它在返回<code>-1</code>之前，挂了两个cleanup。其中<code>_done()</code>的那个是挂在fake连接的pool上的，而<code>_aborted()</code>那个是是挂在前端连接上的。所以<code>_done()</code>函数上在钩子工作结束之后调用的，而<code>_aborted()</code>是在前端连接终止的时候调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> rc = lscf-&gt;srv.ssl_cert_handler(r, lscf, L);</span><br><span class="line"><span class="comment">/* 已经处理完毕或者出错的情况 */</span></span><br><span class="line"><span class="keyword">if</span> (rc &gt;= NGX_OK || rc == NGX_ERROR) &#123;</span><br><span class="line">    cctx-&gt;done = <span class="number">1</span>;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">return</span> cctx-&gt;exit_code;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* rc == NGX_DONE */</span></span><br><span class="line"></span><br><span class="line">cln = ngx_pool_cleanup_add(fc-&gt;pool, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">cln-&gt;handler = ngx_stream_lua_ssl_cert_done;</span><br><span class="line">cln-&gt;data = cctx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cctx-&gt;cleanup == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    cln = ngx_pool_cleanup_add(c-&gt;pool, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cln-&gt;data = cctx;</span><br><span class="line">    cctx-&gt;cleanup = &amp;cln-&gt;handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*cctx-&gt;cleanup = ngx_stream_lua_ssl_cert_aborted;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p>这样就回到了OpenSSL的领地，我们看看出去的流程是怎么样的。因为上层的返回值是<code>-1</code>，这里设置状态为<code>SSL_X509_LOOKUP</code>然后返回<code>WORK_MORE_B</code>，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> rv = s-&gt;cert-&gt;cert_cb(s, s-&gt;cert-&gt;cert_cb_arg);</span><br><span class="line"><span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    s-&gt;rwstate = SSL_X509_LOOKUP;</span><br><span class="line">    <span class="keyword">return</span> WORK_MORE_B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个返回值传递到<code>read_state_machine</code>，变成了返回<code>SUB_STATE_ERROR</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> READ_STATE_POST_PROCESS:</span><br><span class="line">    st-&gt;read_state_work = post_process_message(s, st-&gt;read_state_work);</span><br><span class="line">    <span class="keyword">switch</span> (st-&gt;read_state_work) &#123;</span><br><span class="line">    <span class="keyword">case</span> WORK_ERROR:</span><br><span class="line">        check_fatal(s, SSL_F_READ_STATE_MACHINE);</span><br><span class="line">        <span class="comment">/* Fall through */</span></span><br><span class="line">    <span class="keyword">case</span> WORK_MORE_A:</span><br><span class="line">    <span class="keyword">case</span> WORK_MORE_B:</span><br><span class="line">    <span class="keyword">case</span> WORK_MORE_C:</span><br><span class="line">        <span class="keyword">return</span> SUB_STATE_ERROR;</span><br></pre></td></tr></table></figure>

<p>传递到<code>state_machine</code>，变成了返回<code>-1</code>。最终<code>ossl_statem_accept</code>及<code>SSL_do_handshake()</code>都返回这个值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (st-&gt;state == MSG_FLOW_READING) &#123;</span><br><span class="line">    ssret = read_state_machine(s);</span><br><span class="line">    <span class="keyword">if</span> (ssret == SUB_STATE_FINISHED) &#123;</span><br><span class="line">        st-&gt;state = MSG_FLOW_WRITING;</span><br><span class="line">        init_write_state_machine(s);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* NBIO or error */</span></span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看看回到nginx之后做了什么，因为返回值是-1，所以会先去获取错误类型，因为之前在<code>cert_cb()</code>返回以后已经设置了<code>s-&gt;rwstate = SSL_X509_LOOKUP;</code>所以会返回<code>SSL_ERROR_WANT_X509_LOOKUP</code>，这里将读写事件的回调设置为ssl握手的回调以便下次恢复。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n = SSL_do_handshake(c-&gt;ssl-&gt;connection);</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">sslerr = SSL_get_error(c-&gt;ssl-&gt;connection, n);</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">if</span> (sslerr == SSL_ERROR_WANT_X509_LOOKUP)</span><br><span class="line">&#123;</span><br><span class="line">    c-&gt;read-&gt;handler = ngx_ssl_handshake_handler;</span><br><span class="line">    c-&gt;write-&gt;handler = ngx_ssl_handshake_handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ngx_handle_read_event(c-&gt;read, <span class="number">0</span>) != NGX_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ngx_handle_write_event(c-&gt;write, <span class="number">0</span>) != NGX_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NGX_AGAIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后<code>NGX_AGAIN</code>的返回值一直往上传递，直到<code>ngx_stream_core_generic_phase</code>变为<code>NGX_OK</code>。然后本次的事件处理就算结束了。</p>
<h1 id="事件触发时恢复"><a href="#事件触发时恢复" class="headerlink" title="事件触发时恢复"></a>事件触发时恢复</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ngx_process_events_and_timers</span><br><span class="line">|-- ngx_event_expire_timers</span><br><span class="line">    |-- ngx_stream_lua_sleep_handler</span><br><span class="line">        |-- ngx_stream_lua_sleep_resume</span><br><span class="line">            |-- ngx_stream_lua_run_thread</span><br></pre></td></tr></table></figure>

<p>等到定时器超时的时候，会执行我们之前设置的<code>ngx_stream_lua_sleep_handler</code>，里面会设置当前协程上下文，然后调用<code>ngx_stream_lua_sleep_resume()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">coctx = ev-&gt;data;</span><br><span class="line">ctx-&gt;cur_co_ctx = coctx;</span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;entered_content_phase) &#123;</span><br><span class="line">    (<span class="keyword">void</span>) ngx_stream_lua_sleep_resume(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ngx_stream_lua_sleep_resume</code>里调用<code>ngx_stream_lua_run_thread</code>恢复协程的执行。这样就又回到了我们的Lua代码里。</p>
<h1 id="Lua钩子正常执行结束"><a href="#Lua钩子正常执行结束" class="headerlink" title="Lua钩子正常执行结束"></a>Lua钩子正常执行结束</h1><p>接下来Lua代码执行完毕，<code>lua_resume()</code>返回，因为是协程正常结束，且没有其他在posted队列里的协程了，所以<code>run_thread()</code>直接返回<code>NGX_OK</code>。因此在<code>ngx_stream_lua_finalize_request</code>里就会实际清除fake请求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rc = ngx_stream_lua_run_thread(vm, r, ctx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rc == NGX_AGAIN) &#123;</span><br><span class="line">    <span class="keyword">return</span> ngx_stream_lua_run_posted_threads(c, vm, r, ctx, nreqs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rc == NGX_DONE) &#123;</span><br><span class="line">    ngx_stream_lua_finalize_request(r, NGX_DONE);</span><br><span class="line">    <span class="keyword">return</span> ngx_stream_lua_run_posted_threads(c, vm, r, ctx, nreqs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;entered_content_phase) &#123;</span><br><span class="line">    ngx_stream_lua_finalize_request(r, rc);</span><br><span class="line">    <span class="keyword">return</span> NGX_DONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rc;</span><br></pre></td></tr></table></figure>

<p>里面会调用到之前设置的cleanup函数，清理fake请求的时候调用<code>ngx_stream_lua_request_cleanup_handler</code>清理Lua线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cln = r-&gt;cleanup;</span><br><span class="line">r-&gt;cleanup = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (cln) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cln-&gt;handler) &#123;</span><br><span class="line">        cln-&gt;handler(cln-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cln = cln-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r-&gt;connection-&gt;destroyed = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>清理fake连接的时候调用<code>ngx_stream_lua_ssl_cert_done</code>。我们来看看<code>ngx_stream_lua_ssl_cert_done</code>里面做了什么。主要是设置了完成标志，然后把前端连接的写事件加入了<code>ngx_posted_events</code>队列里。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cctx-&gt;done = <span class="number">1</span>;</span><br><span class="line">ngx_post_event(c-&gt;write, &amp;ngx_posted_events);</span><br></pre></td></tr></table></figure>

<p>定时器超时事件完成之后返回到外层，处理后续的<code>ngx_posted_events</code>队列事件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">void</span>) ngx_process_events(cycle, timer, flags);</span><br><span class="line"></span><br><span class="line">delta = ngx_current_msec - delta;</span><br><span class="line"></span><br><span class="line">ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">               <span class="string">&quot;timer delta: %M&quot;</span>, delta);</span><br><span class="line"></span><br><span class="line">ngx_event_process_posted(cycle, &amp;ngx_posted_accept_events);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">    ngx_shmtx_unlock(&amp;ngx_accept_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (delta) &#123;</span><br><span class="line">    ngx_event_expire_timers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_event_process_posted(cycle, &amp;ngx_posted_events);</span><br></pre></td></tr></table></figure>

<p>因为前端连接的写事件已经设置成<code>ngx_ssl_handshake_handler</code>，所以会再次调用到<code>ngx_ssl_handshake-SSL_do_handshake</code>，这样就再次进入了SSL状态机，又会来到<code>ngx_stream_lua_ssl_cert_handler</code>中。因为是第二次进入了，且已经设置了<code>cctx-&gt;done</code>，所以就直接返回离开码了，其中<code>cctx-&gt;exit_code</code>就是<code>ngx.exit()</code>时的参数，<code>cctx-&gt;exit_code</code>初始化时的默认值时0，但是注意到前面第一次进入<code>ngx_stream_lua_ssl_cert_handler</code>的时候已经将默认值设为1了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cctx &amp;&amp; cctx-&gt;entered_cert_handler) &#123;</span><br><span class="line">    <span class="comment">/* not the first time */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cctx-&gt;done) &#123;</span><br><span class="line">        ngx_log_debug1(NGX_LOG_DEBUG_STREAM, c-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                       <span class="string">&quot;stream lua_certificate_by_lua:&quot;</span></span><br><span class="line">                       <span class="string">&quot; cert cb exit code: %d&quot;</span>,</span><br><span class="line">                       cctx-&gt;exit_code);</span><br><span class="line"></span><br><span class="line">        dd(<span class="string">&quot;lua ssl cert done, finally&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> cctx-&gt;exit_code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，回到了<code>tls_post_process_client_hello()</code>继续后面的握手流程了。</p>
<h1 id="Lua钩子内出错的情况"><a href="#Lua钩子内出错的情况" class="headerlink" title="Lua钩子内出错的情况"></a>Lua钩子内出错的情况</h1><p>出错的流程跟正常结束类似，只不过返回值不一样。<code>ngx.exit()</code>的实现如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ngx.<span class="built_in">exit</span> = function (rc)</span><br><span class="line">    local err = get_string_buf(ERR_BUF_SIZE)</span><br><span class="line">    local errlen = get_size_ptr()</span><br><span class="line">    local r = get_request()</span><br><span class="line">    <span class="keyword">if</span> r == nil then</span><br><span class="line">        error(<span class="string">&quot;no request found&quot;</span>)</span><br><span class="line">    end</span><br><span class="line">    errlen[<span class="number">0</span>] = ERR_BUF_SIZE</span><br><span class="line">    rc = ngx_lua_ffi_exit(r, rc, err, errlen)</span><br><span class="line">    <span class="keyword">if</span> rc == <span class="number">0</span> then</span><br><span class="line">        -- print(<span class="string">&quot;yielding...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">co_yield</span>()</span><br><span class="line">    end</span><br><span class="line">    <span class="keyword">if</span> rc == FFI_DONE then</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    end</span><br><span class="line">    error(ffi_string(err, errlen[<span class="number">0</span>]), <span class="number">2</span>)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>里面会调用ffi函数<code>ngx_stream_lua_ffi_exit()</code>，在其中设置<code>ctx-&gt;exit_code</code>，然后返回<code>NGX_OK</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx-&gt;context &amp; (NGX_STREAM_LUA_CONTEXT_SSL_CERT</span><br><span class="line">                    | NGX_STREAM_LUA_CONTEXT_SSL_CLIENT_HELLO ))</span><br><span class="line">&#123;</span><br><span class="line">    ctx-&gt;exit_code = status;</span><br><span class="line">    ctx-&gt;exited = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到<code>ngx.exit()</code>函数之后，就调用原生的<code>coroutine.yield()</code>，回到我们的主线程<code>run_thread()</code>之后，因为设置了<code>ctx-&gt;exited</code>会调用<code>ngx_stream_lua_handle_exit</code>返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rv = lua_resume(orig_coctx-&gt;co, nrets);</span><br><span class="line"><span class="keyword">switch</span> (rv) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_YIELD:</span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;exited) &#123;</span><br><span class="line">            <span class="keyword">return</span> ngx_stream_lua_handle_exit(L, r, ctx);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ngx_stream_lua_handle_exit()</code>里面调用<code>ngx_stream_lua_request_cleanup</code>清理线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ctx-&gt;cur_co_ctx-&gt;co_status = NGX_STREAM_LUA_CO_DEAD;</span><br><span class="line">ngx_stream_lua_request_cleanup(ctx, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> ctx-&gt;exit_code;</span><br></pre></td></tr></table></figure>

<p>然后返回到<code>sleep_resume</code>，此时<code>rc</code>为<code>ctx-&gt;exit_code</code>，即<code>ngx.ERROR</code>，接下来跟正常结束时一样也是结束我们的请求</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rc = ngx_stream_lua_run_thread(L, r, ctx, <span class="number">0</span>);</span><br><span class="line">...;</span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;entered_content_phase) &#123;</span><br><span class="line">    ngx_stream_lua_finalize_request(r, rc);</span><br><span class="line">    <span class="keyword">return</span> NGX_DONE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rc;</span><br></pre></td></tr></table></figure>

<p>因为是fake请求，<code>ngx_stream_lua_finalize_request</code>调用<code>ngx_stream_lua_finalize_fake_request</code>，里面将<code>cctx-&gt;exit_code</code>设为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (rc == NGX_ERROR || rc &gt;= NGX_STREAM_BAD_REQUEST) &#123;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;connection-&gt;ssl) &#123;</span><br><span class="line">        ssl_conn = r-&gt;connection-&gt;ssl-&gt;connection;</span><br><span class="line">        <span class="keyword">if</span> (ssl_conn) &#123;</span><br><span class="line">            c = ngx_ssl_get_connection(ssl_conn);</span><br><span class="line">            <span class="keyword">if</span> (c &amp;&amp; c-&gt;ssl) &#123;</span><br><span class="line">                cctx = ngx_stream_lua_ssl_get_ctx(c-&gt;ssl-&gt;connection);</span><br><span class="line">                <span class="keyword">if</span> (cctx != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    cctx-&gt;exit_code = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ngx_stream_lua_close_fake_request(r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在清理fake请求的时候调用<code>ngx_stream_lua_request_cleanup_handler</code>清理Lua线程。在清理fake连接的时候会触发<code>ngx_stream_lua_ssl_cert_done</code>，跟正常完成时一样，也是设置完成标志，然后把前端连接的写事件加入了<code>ngx_posted_events</code>队列里。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cctx-&gt;done = <span class="number">1</span>;</span><br><span class="line">ngx_post_event(c-&gt;write, &amp;ngx_posted_events);</span><br></pre></td></tr></table></figure>

<p>到此定时器的事件就结束了，开始处理后续的posted队列事件。同样地，也会再次调用<code>ngx_ssl_handshake_handler</code>最终调到到<code>ngx_stream_lua_ssl_cert_handler</code>中。因为是第二次进入了，且已经设置了<code>cctx-&gt;done</code>，所以就直接返回离开码了，而本次因为是出错<code>cctx-&gt;exit_code</code>的值是0.</p>
<p>返回到OpenSSL之后，一路往上传递错误码。。。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> rv = s-&gt;cert-&gt;cert_cb(s, s-&gt;cert-&gt;cert_cb_arg);</span><br><span class="line"><span class="keyword">if</span> (rv == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">err:</span><br><span class="line"><span class="keyword">return</span> WORK_ERROR;</span><br></pre></td></tr></table></figure>

<p>最终，<code>SSL_do_handshake</code>返回错误值，结束SSL握手。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = SSL_do_handshake(c-&gt;ssl-&gt;connection);</span><br><span class="line">sslerr = SSL_get_error(c-&gt;ssl-&gt;connection, n);</span><br><span class="line">return NGX_ERROR;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们本篇是以一个定时器为例子，对于socket I/O等待其实也是类似的流程。只不过触发事件由定时器超时变成了相应的fd的读写事件，协程的恢复由定时器时的直接恢复变成了完成本次I/O任务（或者出错）之后恢复协程。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Nginx/OpenResty</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>OpenResty</tag>
        <tag>Nginx</tag>
        <tag>钩子</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解mmap--内核代码分析及驱动demo示例</title>
    <url>/posts/5ec4fb12/</url>
    <content><![CDATA[<div class="note primary">
            <p>mmap是一个用户空间很常用的系统调用，无论是分配内存、读写大文件、链接动态库文件，还是多进程间共享内存，都可以看到其身影。本文首先介绍了进程地址空间和mmap，然后分析了内核代码以了解其实现，最后通过一个简单的demo驱动示例，加深对mmap的理解。</p>
          </div>

<span id="more"></span>

<h2 id="进程地址空间及vma"><a href="#进程地址空间及vma" class="headerlink" title="进程地址空间及vma"></a>进程地址空间及vma</h2><p>作为前置知识，先来对进程地址空间做个简单介绍，以便更好地理解后面的内容。现代操作系统的内存管理离不开硬件的支持，如分段机制、分页机制。它们用于实现内存的隔离、保护以及高效使用。进程之间地址空间相互隔离，每个进程都有一套页表，实现线性地址到物理地址的转换。</p>
<h3 id="虚拟内存映射"><a href="#虚拟内存映射" class="headerlink" title="虚拟内存映射"></a>虚拟内存映射</h3><p>下面是32位系统（x86）的进程地址空间布局图</p>
<p><img src="https://imgs.developpaper.com/imgs/1458743340-5ddbcaa6525a5_articlex.png" alt="img" loading="lazy"></p>
<p>0～3G 部分是用户空间的地址，3G～4G 部分是内核地址空间。虚拟地址从低到高分别为代码段、数据段（已初始化的静态变量）、bss段（未初始化的静态变量）、heap堆、mmap映射区、栈、命令行参数、环境变量。</p>
<p>从0xc0000000开始就是内核地址空间了。内核地址空间又分为线性内存区和高端内存区。高端内存区是用于vmalloc机制、fixmap等的。在x86体系中，最低16MB物理内存是DMA内存区，用于执行DMA操作。</p>
<p>64位系统（x86_64）上，内存地址可用空间为0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，这是一个非常巨大的地址空间。而Linux实际上只用了低47位（128T），高17位作扩展。实际用到的地址空间为<strong>0x0000000000000000 ~ 0x00007FFFFFFFFFFF</strong>（用户空间）和<strong>0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF</strong>（内核空间）。</p>
<p>在64位处理器中，由于有足够的内核空间可以线性映射物理内存，所以就不需要高端内存这个管理区了。更详细的信息可以参考<a href="https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt">内核文档</a>。</p>
<h3 id="VMA"><a href="#VMA" class="headerlink" title="VMA"></a>VMA</h3><p>进程地址空间在Linux内核中使用<code>struct vm_area_struct</code>来描述，简称<strong>VMA</strong>。由于这些地址空间归属于各个用户进程，所以在用户进程的<code>struct mm_struct</code>中也有相应的成员。进程可以通过内核的内存管理机制动态地添加或删除这些内存区域。</p>
<p>每个内存区域具有相关的权限，比如可读、可写、可执行。如果进程访问了不在有效范围内的内存区域、或非法访问了内存，那么处理器会报缺页异常，严重的会出现段错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/mm_types.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This struct defines a memory VMM memory area. There is one of these</span></span><br><span class="line"><span class="comment"> * per VM-area/task.  A VM area is any part of the process virtual memory</span></span><br><span class="line"><span class="comment"> * space that has a special rule for the page-fault handlers (ie a shared</span></span><br><span class="line"><span class="comment"> * library, the executable area etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* The first cache line has the info for VMA tree walking. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;     <span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;       <span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">                       within vm_mm. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Largest free memory gap in bytes to the left of this VMA.</span></span><br><span class="line"><span class="comment">     * Either between this VMA and vma-&gt;vm_prev, or between one of the</span></span><br><span class="line"><span class="comment">     * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps</span></span><br><span class="line"><span class="comment">     * get_unmapped_area find a free area of the right size.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_gap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Second cache line starts here. */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>    <span class="comment">/* The address space we belong to. */</span></span><br><span class="line">    <span class="keyword">pgprot_t</span> vm_page_prot;      <span class="comment">/* Access permissions of this VMA. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;     <span class="comment">/* Flags, see mm.h. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * For areas with an address space and backing store,</span></span><br><span class="line"><span class="comment">     * linkage into the address_space-&gt;i_mmap interval tree.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_last;</span><br><span class="line">    &#125; shared;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A file&#x27;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span></span><br><span class="line"><span class="comment">     * list, after a COW of one of the file pages.  A MAP_SHARED vma</span></span><br><span class="line"><span class="comment">     * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span></span><br><span class="line"><span class="comment">     * or brk vma (with NULL file) can only be in an anon_vma list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_chain</span>;</span> <span class="comment">/* Serialized by mmap_sem &amp;</span></span><br><span class="line"><span class="comment">                      * page_table_lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>  <span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Information about our backing store: */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;     <span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">                       units */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>      <span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">    <span class="keyword">void</span> * vm_private_data;     <span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">atomic_long_t</span> swap_readahead_info;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">vm_region</span>;</span>    <span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span>    <span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_userfaultfd_ctx</span> <span class="title">vm_userfaultfd_ctx</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>解释下几个主要的成员：</p>
<ul>
<li>vm_start和vm_end：表示vma的起始和结束地址，相减就是vma的长度</li>
<li>vm_next和vm_prev：链表指针</li>
<li>vm_rb：红黑树节点</li>
<li>vm_mm：所属进程的内存描述符mm_struct数据结构</li>
<li>vm_page_prot：vma的访问权限</li>
<li>vm_flags：vma的标志</li>
<li>anon_vma_chain和anon_vma：用于管理RMAP反向映射</li>
<li>vm_ops：指向操作方法结构体</li>
<li>vm_pgoff：文件映射的偏移量。</li>
<li>vm_file：指向被映射的文件</li>
</ul>
<h2 id="mmap简介"><a href="#mmap简介" class="headerlink" title="mmap简介"></a>mmap简介</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include&lt;sys/mman.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>addr：指定起始地址，为了可移植性一般设为NULL</li>
<li>length：表示映射到进程地址空间的大小</li>
<li>prot：读写属性，PROT_EXEC、PROT_READ、PROT_WRITE、PROT_NONE</li>
<li>flags：标志，如共享映射、私有映射</li>
<li>fd：文件描述符，匿名映射时设为-1。</li>
<li>offset：文件映射时，表示偏移量</li>
</ul>
<h3 id="flag标志"><a href="#flag标志" class="headerlink" title="flag标志"></a>flag标志</h3><ul>
<li>MAP_SHARED：创建一个共享的映射区域。多个进程可以这样映射同一个文件，修改后的内容会同步到磁盘文件中。</li>
<li>MAP_PRIVATE：创建写时复制的私有映射。多个进程可以私有映射同一个文件，修改之后不会同步到磁盘中。</li>
<li>MAP_ANONYMOUS：创建匿名映射，即没有关联到文件的映射</li>
<li>MAP_FIXED：使用参数addr创建映射，如果无法映射指定的地址就返回失败，addr要求按页对齐。如果指定的地址空间与已有的VMA重叠，会先销毁重叠的区域。</li>
<li>MAP_POPULATE：对于文件映射，会提前预读文件内容到映射区域，该特性只支持私有映射。</li>
</ul>
<h3 id="4类映射"><a href="#4类映射" class="headerlink" title="4类映射"></a>4类映射</h3><p>根据prot和flags的不同组合，可以分为以下4种映射类型：</p>
<ul>
<li><p>私有匿名：通常用于内存分配（大块）</p>
</li>
<li><p>私有文件：通常用于加载动态库</p>
</li>
<li><p>共享匿名：通常用于进程间共享内存，默认打开<code>/dev/zero</code>这个特殊的设备文件</p>
</li>
<li><p>共享文件：通常用于内存映射I/O，进程间通信</p>
</li>
</ul>
<h3 id="mmap内存映射原理"><a href="#mmap内存映射原理" class="headerlink" title="mmap内存映射原理"></a>mmap内存映射原理</h3><ol>
<li>当用户空间调用mmap时，系统会寻找一段满足要求的连续虚拟地址，然后创建一个新的vma插入到mm系统的链表和红黑树中。</li>
<li>调用内核空间mmap，建立文件块/设备物理地址和进程虚拟地址vma的映射关系<ol>
<li>如果是磁盘文件，没有特别设置标志的话这里只是建立映射不会实际分配内存。</li>
<li>如果是设备文件，直接通过remap_pfn_range函数建立设备物理地址到虚拟地址的映射。</li>
</ol>
</li>
<li>（如果是磁盘文件映射）当进程对这片映射地址空间进行访问时，引发缺页异常，将数据从磁盘中拷贝到物理内存。后续用户空间就可以直接对这块内核空间的物理内存进行读写，省去了用户空间跟内核空间之间的拷贝过程。</li>
</ol>
<h2 id="内核代码分析"><a href="#内核代码分析" class="headerlink" title="内核代码分析"></a>内核代码分析</h2><p>当我们在用户空间调用mmap时，首先通过系统调用进入内核空间，可以看到这里将offset转成了以页为单位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arch/x86/kernel/sys_x86_64.c</span></span><br><span class="line">SYSCALL_DEFINE6(mmap, <span class="keyword">unsigned</span> <span class="keyword">long</span>, addr, <span class="keyword">unsigned</span> <span class="keyword">long</span>, len,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>, prot, <span class="keyword">unsigned</span> <span class="keyword">long</span>, flags,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>, fd, <span class="keyword">unsigned</span> <span class="keyword">long</span>, off)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> error;</span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (off &amp; ~PAGE_MASK)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    error = sys_mmap_pgoff(addr, len, prot, flags, fd, off &gt;&gt; PAGE_SHIFT);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看系统调用<code>sys_mmap_pgoff</code>，如果是不是匿名映射，会通过fd获取file结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mm/mmap.c</span></span><br><span class="line">SYSCALL_DEFINE6(mmap_pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span>, addr, <span class="keyword">unsigned</span> <span class="keyword">long</span>, len,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>, prot, <span class="keyword">unsigned</span> <span class="keyword">long</span>, flags,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>, fd, <span class="keyword">unsigned</span> <span class="keyword">long</span>, pgoff)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> retval;</span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; MAP_ANONYMOUS)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        file = fget(fd);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    retval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看<code>vm_mmap_pgoff</code>函数，这里主要用信号量对进程地址空间做了一个保护，然后根据populate的值会prefault页表，如果是文件映射则会对文件进行预读。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mm/util.c</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">vm_mmap_pgoff</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> prot,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flag, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> populate;</span><br><span class="line">    LIST_HEAD(uf);</span><br><span class="line"></span><br><span class="line">    ret = security_mmap_file(file, prot, flag);</span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">        <span class="keyword">if</span> (down_write_killable(&amp;mm-&gt;mmap_sem))</span><br><span class="line">            <span class="keyword">return</span> -EINTR;</span><br><span class="line">        ret = do_mmap_pgoff(file, addr, len, prot, flag, pgoff,</span><br><span class="line">                    &amp;populate, &amp;uf);</span><br><span class="line">        up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">        userfaultfd_unmap_complete(mm, &amp;uf);</span><br><span class="line">        <span class="keyword">if</span> (populate)</span><br><span class="line">            mm_populate(ret, populate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>do_mmap_pgoff</code>只是简单调用<code>do_mmap</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/mm.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function"><span class="title">do_mmap_pgoff</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> prot, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span> *populate,</span></span></span><br><span class="line"><span class="params"><span class="function">    struct list_head *uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> do_mmap(file, addr, len, prot, flags, <span class="number">0</span>, pgoff, populate, uf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看<code>do_mmap</code>实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mm/mmap.c</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">do_mmap</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> prot,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">vm_flags_t</span> vm_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span> *populate,</span></span></span><br><span class="line"><span class="params"><span class="function">            struct list_head *uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    len = PAGE_ALIGN(len);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    addr = get_unmapped_area(file, addr, len, pgoff, flags);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    addr = mmap_region(file, addr, len, vm_flags, pgoff, uf);</span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR_VALUE(addr) &amp;&amp;</span><br><span class="line">        ((vm_flags &amp; VM_LOCKED) ||</span><br><span class="line">         (flags &amp; (MAP_POPULATE | MAP_NONBLOCK)) == MAP_POPULATE))</span><br><span class="line">        *populate = len;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数主要将映射长度页对齐，对prot属性和flags标志进行了检查和处理，设置了vm_flags。<code>get_unmapped_area</code>函数检查指定的地址或自动选择可用的虚拟地址。然后就调用<code>mmap_region</code>，可以看到返回之后，根据调用接口时设置的flags对populate进行了设置。如果设置了<code>MAP_LOCKED</code>，或者设置了<code>MAP_POPULATE</code>但没有设置<code>MAP_NONBLOCK</code>，就进行前面提到的prefault操作。</p>
<p>然后继续看<code>mmap_region</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mm/mmap.c</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">mmap_region</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">vm_flags_t</span> vm_flags, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff,</span></span></span><br><span class="line"><span class="params"><span class="function">        struct list_head *uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    vma = vma_merge(mm, prev, addr, addr + len, vm_flags,</span><br><span class="line">            <span class="literal">NULL</span>, file, pgoff, <span class="literal">NULL</span>, NULL_VM_UFFD_CTX);</span><br><span class="line">    <span class="keyword">if</span> (vma)    <span class="comment">// 可以跟之前的映射合并</span></span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    </span><br><span class="line">    vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);</span><br><span class="line">    vma-&gt;vm_mm = mm;</span><br><span class="line">    vma-&gt;vm_start = addr;</span><br><span class="line">    vma-&gt;vm_end = addr + len;</span><br><span class="line">    vma-&gt;vm_flags = vm_flags;</span><br><span class="line">    vma-&gt;vm_page_prot = vm_get_page_prot(vm_flags);</span><br><span class="line">    vma-&gt;vm_pgoff = pgoff;</span><br><span class="line">    INIT_LIST_HEAD(&amp;vma-&gt;anon_vma_chain);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        vma-&gt;vm_file = get_file(file);</span><br><span class="line">        error = call_mmap(file, vma);   <span class="comment">// 调用文件的mmap</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm_flags &amp; VM_SHARED) &#123;</span><br><span class="line">        error = shmem_zero_setup(vma);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数首先做了一些地址空间检查，接着<code>vma_merge</code>检查是否可以和老的映射合并，然后就是分配vma并初始化。如果是文件映射，调用<code>call_mmap</code>；如果是匿名共享映射，调用<code>shmem_zero_setup</code>，它里面会进行<code>/dev/zero</code>文件相关设置。</p>
<p><code>call_mmap</code>只是简单地调用文件句柄中的mmap操作函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/fs.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">call_mmap</span><span class="params">(struct file *file, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> file-&gt;f_op-&gt;mmap(file, vma);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是普通文件系统中的文件的话，我们以ext4为例，里面主要是设置了<code>vma-&gt;vm_ops</code>为<code>ext4_file_vm_ops</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs/ext4/file.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ext4_file_mmap</span><span class="params">(struct file *file, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    vma-&gt;vm_ops = &amp;ext4_file_vm_ops;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> <span class="title">ext4_file_vm_ops</span> =</span> &#123;</span><br><span class="line">    .fault      = ext4_filemap_fault,</span><br><span class="line">    .map_pages  = filemap_map_pages,</span><br><span class="line">    .page_mkwrite   = ext4_page_mkwrite,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>后续当访问这个vma地址空间时，就会调用相应的操作函数进行处理，比如页错误处理函数会调用<code>ext4_filemap_fault</code>，里面又会调用<code>filemap_fault</code>。</p>
<p>如果是设备文件的话，由相应的设备驱动实现mmap方法，在里面建立设备物理内存到vma地址空间的映射。接下来通过一个简单的驱动demo来演示。</p>
<p>简单总结一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mmap                        // offset转成页为单位</span><br><span class="line">+-- sys_mmap_pgoff          // 通过fd获取file</span><br><span class="line">    +-- vm_mmap_pgoff       // 信号量保护，映射完成后populate</span><br><span class="line">        +-- do_mmap_pgoff   // 简单封装</span><br><span class="line">            +-- do_mmap     // 映射长度页对齐，prot和flags检查，设置vm_flags，获取映射虚拟地址</span><br><span class="line">                +-- mmap_region      // 地址空间检查，vma_merge，vma分配及初始化</span><br><span class="line">                    |-- call_mmap    // 文件映射，简单封装</span><br><span class="line">                    |   +-- file-&gt;f_op-&gt;mmap    // 调用实际文件的mmap方法</span><br><span class="line">                    |-- shmem_zero_setup       // 匿名共享映射，/dev/zero</span><br></pre></td></tr></table></figure>



<h2 id="驱动demo"><a href="#驱动demo" class="headerlink" title="驱动demo"></a>驱动demo</h2><p>我们编写了一个简单的misc设备，在驱动加载的时候使用<code>alloc_pages</code>分配设备的物理内存（4页），当然也可以使用kmalloc或vmalloc。然后实现了几个操作方法，其中最主要的就是mmap方法，为了方便测试我们还实现了read、write、llseek等方法。</p>
<div class="note default">
            <p>ps: 驱动及测试程序代码已上传github，<a href="https://github.com/catbro666/mmap-driver-demo">catbro666/mmap-driver-demo</a></p>
          </div>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/gfp.h&gt;</span>          <span class="comment">// alloc_page</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/miscdevice.h&gt;</span>   <span class="comment">// miscdevice misc_xxx</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/uaccess.h&gt;</span>      <span class="comment">// copy_from/to_user</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEMO_NAME <span class="meta-string">&quot;demo_dev&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_ORDER 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE (PAGE_SIZE &lt;&lt; PAGE_ORDER)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">mydemodrv_device</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *device_buffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">demodrv_fops</span> =</span> &#123;</span><br><span class="line">    .owner      = THIS_MODULE,</span><br><span class="line">    .open       = demodrv_open,</span><br><span class="line">    .release    = demodrv_release,</span><br><span class="line">    .read       = demodrv_read,</span><br><span class="line">    .write      = demodrv_write,</span><br><span class="line">    .mmap       = demodev_mmap,</span><br><span class="line">    .llseek     = demodev_llseek</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">mydemodrv_misc_device</span> =</span> &#123;</span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">    .name = DEMO_NAME,</span><br><span class="line">    .fops = &amp;demodrv_fops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">demo_dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = misc_register(&amp;mydemodrv_misc_device);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(<span class="string">&quot;failed to register misc device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mydemodrv_device = mydemodrv_misc_device.this_device;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;succeeded register misc device: %s\n&quot;</span>, DEMO_NAME);</span><br><span class="line"></span><br><span class="line">    page = alloc_pages(GFP_KERNEL, PAGE_ORDER);</span><br><span class="line">    <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_page failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    device_buffer = page_address(page);</span><br><span class="line">    printk(<span class="string">&quot;device_buffer physical address: %lx, virtual address: %px\n&quot;</span>,</span><br><span class="line">           page_to_pfn(page) &lt;&lt; PAGE_SHIFT, device_buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">demo_dev_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;removing device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    __free_pages(page, PAGE_ORDER);</span><br><span class="line"></span><br><span class="line">    misc_deregister(&amp;mydemodrv_misc_device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(demo_dev_init);</span><br><span class="line">module_exit(demo_dev_exit);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;catbro666&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;mmap test module&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里主要看一下mmap方法的实现，核心函数是<code>remap_pfn_range</code>，它用于建立实际物理地址到vma虚拟地址的映射。我们来看下它的参数，第一个是要映射的用户空间vma，第二个是映射起始地址，第三个是内核内存的物理页帧号，第四个是映射区域的大小，第五个是对这个映射的页保护标志。</p>
<p>我们用到的大部分参数通过vma获取，如上一节所看到的，外层函数已经做好了vma初始化工作。因为我们是用<code>alloc_pages</code>分配的内存，其物理地址是连续的，所以映射也比较简单。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">demodev_mmap</span><span class="params">(struct file *file, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pfn_start;</span><br><span class="line">    <span class="keyword">void</span> *virt_start;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    mm = current-&gt;mm;</span><br><span class="line">    pfn_start = page_to_pfn(page) + vma-&gt;vm_pgoff;</span><br><span class="line">    virt_start = page_address(page) + (vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 映射大小不超过实际分配的物理内存大小 */</span></span><br><span class="line">    size = min(((<span class="number">1</span> &lt;&lt; PAGE_ORDER) - vma-&gt;vm_pgoff) &lt;&lt; PAGE_SHIFT,</span><br><span class="line">               vma-&gt;vm_end - vma-&gt;vm_start);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;phys_start: 0x%lx, offset: 0x%lx, vma_size: 0x%lx, map size:0x%lx\n&quot;</span>,</span><br><span class="line">           pfn_start &lt;&lt; PAGE_SHIFT, vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT,</span><br><span class="line">           vma-&gt;vm_end - vma-&gt;vm_start, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;%s: offset 0x%lx too large, max size is 0x%lx\n&quot;</span>, __func__,</span><br><span class="line">               vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT, MAX_SIZE);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外层vm_mmap_pgoff已经用信号量保护了</span></span><br><span class="line">    ret = remap_pfn_range(vma, vma-&gt;vm_start, pfn_start, size, vma-&gt;vm_page_prot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(<span class="string">&quot;remap_pfn_range failed, vm_start: 0x%lx\n&quot;</span>, vma-&gt;vm_start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        printk(<span class="string">&quot;map kernel 0x%px to user 0x%lx, size: 0x%lx\n&quot;</span>,</span><br><span class="line">               virt_start, vma-&gt;vm_start, size);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再来看下read方法的实现，主要就是从设备内存中拷贝数据到用户空间的buf中，然后更新文件偏移。write方法也是类似，这里就不再展示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span></span><br><span class="line"><span class="function"><span class="title">demodrv_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> actual_readed;</span><br><span class="line">    <span class="keyword">int</span> max_read;</span><br><span class="line">    <span class="keyword">int</span> need_read;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    max_read = PAGE_SIZE - *ppos;</span><br><span class="line">    need_read = max_read &gt; count ? count : max_read;</span><br><span class="line">    <span class="keyword">if</span> (need_read == <span class="number">0</span>)</span><br><span class="line">        dev_warn(mydemodrv_device, <span class="string">&quot;no space for read&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ret = copy_to_user(buf, device_buffer + *ppos, need_read);</span><br><span class="line">    <span class="keyword">if</span> (ret == need_read)</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    actual_readed = need_read - ret;</span><br><span class="line">    *ppos += actual_readed;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;%s actual_readed=%d, pos=%lld\n&quot;</span>, __func__, actual_readed, *ppos);</span><br><span class="line">    <span class="keyword">return</span> actual_readed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><h3 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h3><p>我们首先编译安装驱动，设备节点文件已经自动创建。查看内核日志可以看到已经成功创建了设备，并分配了内存。起始物理地址为0x5b1558000，内核虚拟地址为0xffff8d1ab1558000。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo insmod mydemodev.ko</span><br><span class="line">$ ll /dev|grep demo</span><br><span class="line">crw-------   1 root root     10,  58 12月 12 23:33 demo_dev</span><br><span class="line">$ dmesg | tail -n 2</span><br><span class="line">[110047.799513] succeeded register misc device: demo_dev</span><br><span class="line">[110047.799517] device_buffer physical address: 5b1558000, virtual address: ffff8d1ab1558000</span><br></pre></td></tr></table></figure>

<h3 id="测试程序1"><a href="#测试程序1" class="headerlink" title="测试程序1"></a>测试程序1</h3><p>接下来我们写了几个测试程序来对这个驱动进行测试。首先来看第一个测试程序，我们打开驱动设备文件<code>/dev/demo_dev</code>，然后mmap映射了1页的大小，这里前后分别sleep了5秒，是为了提供观察的时间。然后通过映射的用户空间虚拟地址进行读写测试，验证mmap是否正确映射了。首先通过虚拟地址写，随后用read读取进行比对检查。然后通过write写，随后用虚拟地址读取进行比对检查。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>      <span class="comment">// printf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span>      <span class="comment">// open</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>     <span class="comment">// read, close, getpagesize</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span>   <span class="comment">// mmap</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>     <span class="comment">// memcmp, strlen</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span>     <span class="comment">// assert</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEMO_DEV_NAME   <span class="meta-string">&quot;/dev/demo_dev&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> *addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *message = <span class="string">&quot;Hello World\n&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *message2 = <span class="string">&quot;I&#x27;m superman\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    fd = open(DEMO_DEV_NAME, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open device %s failed\n&quot;</span>, DEMO_DEV_NAME);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, (<span class="keyword">size_t</span>)getpagesize(), PROT_READ | PROT_WRITE,</span><br><span class="line">                MAP_SHARED | MAP_LOCKED, fd, <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 测试映射正确 */</span></span><br><span class="line">    <span class="comment">/* 写到mmap映射的虚拟地址中，通过read读取设备文件 */</span></span><br><span class="line">    ret = <span class="built_in">sprintf</span>(addr, <span class="string">&quot;%s&quot;</span>, message);</span><br><span class="line">    assert(ret == <span class="built_in">strlen</span>(message));</span><br><span class="line"></span><br><span class="line">    ret = read(fd, buf, <span class="number">64</span>);</span><br><span class="line">    assert(ret == <span class="number">64</span>);</span><br><span class="line">    assert(!<span class="built_in">memcmp</span>(buf, message, <span class="built_in">strlen</span>(message)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通过write写入设备文件，修改体现在mmap映射的虚拟地址 */</span></span><br><span class="line">    ret = write(fd, message2, <span class="built_in">strlen</span>(message2));</span><br><span class="line"></span><br><span class="line">    assert(ret == <span class="built_in">strlen</span>(message2));</span><br><span class="line">    assert(!<span class="built_in">memcmp</span>(addr + <span class="number">64</span>, message2, <span class="built_in">strlen</span>(message2)));</span><br><span class="line"></span><br><span class="line">    munmap(addr, (<span class="keyword">size_t</span>)getpagesize());</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们编译运行测试程序，结果如我们预期。从内核日志可以看到映射起始物理地址0x5b1558000，偏移为0，vma大小是1页，映射大小也是1页。将内核空间虚拟地址0xffff8d1ab1558000映射到了用户空间0x7f21c0f58000。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ./test1</span><br><span class="line">$ dmesg|tail -n 4</span><br><span class="line">[110691.745381] phys_start: 0x5b1558000, offset: 0x0, vma_size: 0x1000, map size:0x1000</span><br><span class="line">[110691.745388] map kernel 0xffff8d1ab1558000 to user 0x7f21c0f58000, size: 0x1000</span><br><span class="line">[110696.745816] demodrv_read actual_readed=64, pos=64</span><br><span class="line">[110696.745822] demodrv_write actual_written=13, pos=77</span><br></pre></td></tr></table></figure>

<p>与此同时，我们使用pmap观察mmap前后的进程的地址空间</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开进程地址空间</div></div><div class="fold">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo pmap -x $(pgrep test1)</span><br><span class="line">[sudo] password <span class="keyword">for</span> ssl:</span><br><span class="line">30830:   ./test1</span><br><span class="line">Address           Kbytes     RSS   Dirty Mode  Mapping</span><br><span class="line">0000557b19475000       4       4       0 r-x-- test1</span><br><span class="line">0000557b19475000       0       0       0 r-x-- test1</span><br><span class="line">0000557b19676000       4       4       4 r---- test1</span><br><span class="line">0000557b19676000       0       0       0 r---- test1</span><br><span class="line">0000557b19677000       4       4       4 rw--- test1</span><br><span class="line">0000557b19677000       0       0       0 rw--- test1</span><br><span class="line">00007f21c0941000    1948     888       0 r-x-- libc-2.27.so</span><br><span class="line">00007f21c0941000       0       0       0 r-x-- libc-2.27.so</span><br><span class="line">00007f21c0b28000    2048       0       0 ----- libc-2.27.so</span><br><span class="line">00007f21c0b28000       0       0       0 ----- libc-2.27.so</span><br><span class="line">00007f21c0d28000      16      16      16 r---- libc-2.27.so</span><br><span class="line">00007f21c0d28000       0       0       0 r---- libc-2.27.so</span><br><span class="line">00007f21c0d2c000       8       8       8 rw--- libc-2.27.so</span><br><span class="line">00007f21c0d2c000       0       0       0 rw--- libc-2.27.so</span><br><span class="line">00007f21c0d2e000      16       8       8 rw---   [ anon ]</span><br><span class="line">00007f21c0d2e000       0       0       0 rw---   [ anon ]</span><br><span class="line">00007f21c0d32000     156     156       0 r-x-- ld-2.27.so</span><br><span class="line">00007f21c0d32000       0       0       0 r-x-- ld-2.27.so</span><br><span class="line">00007f21c0f41000       8       8       8 rw---   [ anon ]</span><br><span class="line">00007f21c0f41000       0       0       0 rw---   [ anon ]</span><br><span class="line">00007f21c0f59000       4       4       4 r---- ld-2.27.so</span><br><span class="line">00007f21c0f59000       0       0       0 r---- ld-2.27.so</span><br><span class="line">00007f21c0f5a000       4       4       4 rw--- ld-2.27.so</span><br><span class="line">00007f21c0f5a000       0       0       0 rw--- ld-2.27.so</span><br><span class="line">00007f21c0f5b000       4       4       4 rw---   [ anon ]</span><br><span class="line">00007f21c0f5b000       0       0       0 rw---   [ anon ]</span><br><span class="line">00007ffdacdf1000     132       8       8 rw---   [ stack ]</span><br><span class="line">00007ffdacdf1000       0       0       0 rw---   [ stack ]</span><br><span class="line">00007ffdacf3c000      12       0       0 r----   [ anon ]</span><br><span class="line">00007ffdacf3c000       0       0       0 r----   [ anon ]</span><br><span class="line">00007ffdacf3f000       4       4       0 r-x--   [ anon ]</span><br><span class="line">00007ffdacf3f000       0       0       0 r-x--   [ anon ]</span><br><span class="line">ffffffffff600000       4       0       0 --x--   [ anon ]</span><br><span class="line">ffffffffff600000       0       0       0 --x--   [ anon ]</span><br><span class="line">---------------- ------- ------- -------</span><br><span class="line">total kB            4376    1120      68</span><br><span class="line"></span><br><span class="line">$ sudo pmap -x $(pgrep test1)</span><br><span class="line">30830:   ./test1</span><br><span class="line">Address           Kbytes     RSS   Dirty Mode  Mapping</span><br><span class="line">0000557b19475000       4       4       0 r-x-- test1</span><br><span class="line">0000557b19475000       0       0       0 r-x-- test1</span><br><span class="line">0000557b19676000       4       4       4 r---- test1</span><br><span class="line">0000557b19676000       0       0       0 r---- test1</span><br><span class="line">0000557b19677000       4       4       4 rw--- test1</span><br><span class="line">0000557b19677000       0       0       0 rw--- test1</span><br><span class="line">00007f21c0941000    1948     888       0 r-x-- libc-2.27.so</span><br><span class="line">00007f21c0941000       0       0       0 r-x-- libc-2.27.so</span><br><span class="line">00007f21c0b28000    2048       0       0 ----- libc-2.27.so</span><br><span class="line">00007f21c0b28000       0       0       0 ----- libc-2.27.so</span><br><span class="line">00007f21c0d28000      16      16      16 r---- libc-2.27.so</span><br><span class="line">00007f21c0d28000       0       0       0 r---- libc-2.27.so</span><br><span class="line">00007f21c0d2c000       8       8       8 rw--- libc-2.27.so</span><br><span class="line">00007f21c0d2c000       0       0       0 rw--- libc-2.27.so</span><br><span class="line">00007f21c0d2e000      16       8       8 rw---   [ anon ]</span><br><span class="line">00007f21c0d2e000       0       0       0 rw---   [ anon ]</span><br><span class="line">00007f21c0d32000     156     156       0 r-x-- ld-2.27.so</span><br><span class="line">00007f21c0d32000       0       0       0 r-x-- ld-2.27.so</span><br><span class="line">00007f21c0f41000       8       8       8 rw---   [ anon ]</span><br><span class="line">00007f21c0f41000       0       0       0 rw---   [ anon ]</span><br><span class="line">00007f21c0f58000       4       0       0 rw-s- demo_dev</span><br><span class="line">00007f21c0f58000       0       0       0 rw-s- demo_dev</span><br><span class="line">00007f21c0f59000       4       4       4 r---- ld-2.27.so</span><br><span class="line">00007f21c0f59000       0       0       0 r---- ld-2.27.so</span><br><span class="line">00007f21c0f5a000       4       4       4 rw--- ld-2.27.so</span><br><span class="line">00007f21c0f5a000       0       0       0 rw--- ld-2.27.so</span><br><span class="line">00007f21c0f5b000       4       4       4 rw---   [ anon ]</span><br><span class="line">00007f21c0f5b000       0       0       0 rw---   [ anon ]</span><br><span class="line">00007ffdacdf1000     132       8       8 rw---   [ stack ]</span><br><span class="line">00007ffdacdf1000       0       0       0 rw---   [ stack ]</span><br><span class="line">00007ffdacf3c000      12       0       0 r----   [ anon ]</span><br><span class="line">00007ffdacf3c000       0       0       0 r----   [ anon ]</span><br><span class="line">00007ffdacf3f000       4       4       0 r-x--   [ anon ]</span><br><span class="line">00007ffdacf3f000       0       0       0 r-x--   [ anon ]</span><br><span class="line">ffffffffff600000       4       0       0 --x--   [ anon ]</span><br><span class="line">ffffffffff600000       0       0       0 --x--   [ anon ]</span><br><span class="line">---------------- ------- ------- -------</span><br><span class="line">total kB            4380    1120      68</span><br></pre></td></tr></table></figure>

</div></div>

<p>可以看到mmap之后多了一个叫做demo_dev的段，其起始地址就是我们映射的用户空间地址0x7f21c0f58000。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00007f21c0f58000       4       0       0 rw-s- demo_dev</span><br><span class="line">00007f21c0f58000       0       0       0 rw-s- demo_dev</span><br></pre></td></tr></table></figure>

<h3 id="测试程序2"><a href="#测试程序2" class="headerlink" title="测试程序2"></a>测试程序2</h3><p>测试程序2差别不大，打开同一个设备文件，mmap建立相同的映射，然后分别通过read和虚拟地址读取前一个程序写的内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> *addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *message = <span class="string">&quot;Hello World\n&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *message2 = <span class="string">&quot;I&#x27;m superman\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 另一进程打开同一设备文件，然后用mmap映射 */</span></span><br><span class="line">    fd = open(DEMO_DEV_NAME, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open device %s failed\n&quot;</span>, DEMO_DEV_NAME);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, (<span class="keyword">size_t</span>)getpagesize(), PROT_READ | PROT_WRITE,</span><br><span class="line">                MAP_SHARED | MAP_LOCKED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通过read读取设备文件 */</span></span><br><span class="line">    ret = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    assert(ret == <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    assert(!<span class="built_in">memcmp</span>(buf, message, <span class="built_in">strlen</span>(message)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通过mmap映射的虚拟地址读取 */</span></span><br><span class="line">    assert(!<span class="built_in">memcmp</span>(addr + <span class="keyword">sizeof</span>(buf), message2, <span class="built_in">strlen</span>(message2)));</span><br><span class="line"></span><br><span class="line">    munmap(addr, (<span class="keyword">size_t</span>)getpagesize());</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行，测试结果如我们预期。同一个内核虚拟地址现在映射到了不同的用户空间虚拟地址。通过mmap我们实现了进程间通信。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ./test2</span><br><span class="line">$ dmesg|tail -n 3</span><br><span class="line">[111333.818374] phys_start: 0x5b1558000, offset: 0x0, vma_size: 0x1000, map size:0x1000</span><br><span class="line">[111333.818378] map kernel 0xffff8d1ab1558000 to user 0x7f015ee94000, size: 0x1000</span><br><span class="line">[111333.818381] demodrv_read actual_readed=64, pos=64</span><br></pre></td></tr></table></figure>

<h3 id="测试程序3"><a href="#测试程序3" class="headerlink" title="测试程序3"></a>测试程序3</h3><p>这次我们来测试一些特殊情况，映射的大小改成了1个字节，根据前面的代码分析，映射是需要页对齐的，所以预期实际会映射一个页。在一页的范围内是可以正常读写的。然后尝试写到vma映射范围之外，预期会出现段错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> *addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">off_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *message = <span class="string">&quot;Hello World\n&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *message2 = <span class="string">&quot;I&#x27;m superman\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    fd = open(DEMO_DEV_NAME, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open device %s failed\n&quot;</span>, DEMO_DEV_NAME);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 映射1个字节 */</span></span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, <span class="number">1</span>, PROT_READ | PROT_WRITE,</span><br><span class="line">                MAP_SHARED | MAP_LOCKED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 写到mmap映射的虚拟地址中，通过read读取设备文件 */</span></span><br><span class="line">    ret =<span class="built_in">sprintf</span>(addr, <span class="string">&quot;%s&quot;</span>, message);</span><br><span class="line">    assert(ret == <span class="built_in">strlen</span>(message));</span><br><span class="line"></span><br><span class="line">    ret = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    assert(ret == <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    assert(!<span class="built_in">memcmp</span>(buf, message, <span class="built_in">strlen</span>(message)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 写到一页的尾部 */</span></span><br><span class="line">    ret = <span class="built_in">sprintf</span>(addr + getpagesize() - <span class="keyword">sizeof</span>(buf), <span class="string">&quot;%s&quot;</span>, message2);</span><br><span class="line">    assert(ret == <span class="built_in">strlen</span>(message2));</span><br><span class="line"></span><br><span class="line">    offset = lseek(fd, getpagesize() - <span class="keyword">sizeof</span>(buf), SEEK_SET);</span><br><span class="line">    assert(offset == getpagesize() - <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    ret = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    assert(ret == <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    assert(!<span class="built_in">memcmp</span>(buf, message2, <span class="built_in">strlen</span>(message2)));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 写到一页之后，超出映射范围 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;expect segment error\n&quot;</span>);</span><br><span class="line">    ret = <span class="built_in">sprintf</span>(addr + getpagesize(), <span class="string">&quot;something&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;never reach here\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    munmap(addr, <span class="number">1</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们编译运行测试，结果如我们预期，实际映射了1页的大小，当尝试超出映射范围写时，出现了段错误（SIGSEGV）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ./test3</span><br><span class="line">expect segment error</span><br><span class="line">Segmentation fault</span><br><span class="line">$ dmesg|tail -n 6</span><br><span class="line">[111762.605089] phys_start: 0x5b1558000, offset: 0x0, vma_size: 0x1000, map size:0x1000</span><br><span class="line">[111762.605093] map kernel 0xffff8d1ab1558000 to user 0x7f96b5d08000, size: 0x1000</span><br><span class="line">[111762.605105] demodrv_read actual_readed=64, pos=64</span><br><span class="line">[111762.605110] demodrv_read actual_readed=64, pos=4096</span><br><span class="line">[111762.605165] test3[31001]: segfault at 7f96b5d09000 ip 0000560c0fd3ad25 sp 00007ffc5a515330 error 7 <span class="keyword">in</span> test3[560c0fd3a000+2000]</span><br><span class="line">[111762.605170] Code: e8 80 fb ff ff 48 8d 3d 1a 02 00 00 e8 14 fb ff ff e8 cf fb ff ff 48 63 d0 48 8b 45 80 48 01 d0 48 bb 73 6f 6d 65 74 68 69 6e &lt;48&gt; 89 18 66 c7 40 08 67 00 c7 85 7c ff ff ff 09 00 00 00 48 8d 3d</span><br></pre></td></tr></table></figure>

<h3 id="测试程序4"><a href="#测试程序4" class="headerlink" title="测试程序4"></a>测试程序4</h3><p>这次我们又修改了mmap的参数，这次映射了2页的大小，偏移设置为3页。因为我们设备分配的物理内存大小是4页，所以映射的第2页已经超出了实际的设备物理内存。预期映射的第一页可以正常读写，第二页会出现bus错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> *addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">off_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *message = <span class="string">&quot;Hello World\n&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *message2 = <span class="string">&quot;I&#x27;m superman\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    fd = open(DEMO_DEV_NAME, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open device %s failed\n&quot;</span>, DEMO_DEV_NAME);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 映射2页，offset 3页 */</span></span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, getpagesize() * <span class="number">2</span>, PROT_READ | PROT_WRITE,</span><br><span class="line">                MAP_SHARED | MAP_LOCKED, fd, getpagesize() * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 写到mmap映射的虚拟地址中，通过read读取设备文件 */</span></span><br><span class="line">    ret =<span class="built_in">sprintf</span>(addr, <span class="string">&quot;%s&quot;</span>, message);</span><br><span class="line">    assert(ret == <span class="built_in">strlen</span>(message));</span><br><span class="line"></span><br><span class="line">    offset = lseek(fd, getpagesize() * <span class="number">3</span>, SEEK_SET);</span><br><span class="line">    ret = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    assert(ret == <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    assert(!<span class="built_in">memcmp</span>(buf, message, <span class="built_in">strlen</span>(message)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 写到一页之后，超出实际物理内存范围 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;expect bus error\n&quot;</span>);</span><br><span class="line">    ret = <span class="built_in">sprintf</span>(addr + getpagesize(), <span class="string">&quot;something&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;never reach here\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    munmap(addr, getpagesize() * <span class="number">2</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行测试程序，结果如预期。虽然vma的大小为2页，但是实际只映射了1页的物理内存，当尝试写到第二页时出现了bus错误(SIGBUS)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ./test4</span><br><span class="line">expect bus error</span><br><span class="line">Bus error</span><br><span class="line">$ dmesg|tail -n 3</span><br><span class="line">[112105.841706] phys_start: 0x5b155b000, offset: 0x3000, vma_size: 0x2000, map size:0x1000</span><br><span class="line">[112105.841710] map kernel 0xffff8d1ab155b000 to user 0x7fe662ec4000, size: 0x1000</span><br><span class="line">[112105.841723] demodrv_read actual_readed=64, pos=12352</span><br></pre></td></tr></table></figure>



<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p><a href="https://developpaper.com/linux-virtual-address-space/">linux-virtual-address-space/</a></p>
</li>
<li><p><a href="https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt">virtual memory map</a></p>
</li>
<li><p>linux-4.15内核源码</p>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
        <tag>mmap</tag>
      </tags>
  </entry>
  <entry>
    <title>是谁断了我的连接？—从压测碰到的一个奇怪问题聊聊Nginx的连接管理和性能调测</title>
    <url>/posts/4198933e/</url>
    <content><![CDATA[<div class="note primary">
            <p>Nginx是目前使用最广泛的Web服务器之一，以高性能而著称，得益于其异步事件驱动架构，在高并发下仍然可以保持低消耗高性能，而模块化的设计也使其更易扩展，丰富了其功能。对于Nginx基本的介绍网上已有很多的文章，也有像《深入理解Nginx》这样的书籍讲解Nginx的架构设计与开发方法。本文不会涉及Nginx开发相关内容，而是以一个实际问题的定位过程作为引子，聊一下Nginx的连接管理和性能调测。如果你并不关心这个实际问题，可以直接跳到<a href="#%E8%BF%9E%E6%8E%A5%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">连接生命周期</a>。</p>
          </div>

<span id="more"></span>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>问题是这样的，我们的Nginx服务是作为HTTP反向代理，前端是HTTPS，后端是HTTP。在一次压测过程中碰到了连接异常断开的问题，但是Nginx这边没有发现任何的错误日志（已经开了Info级别也没有）。因为是在客户那边进行的测试，而且是同事在对接的项目，我并不了解第一手的情况，包括测试方法、Nginx的配置等，唯一给到我这边的就是一个抓包，只有这个是确凿的信息，其余的就是一些零星的口头转述。同事多次尝试在公司复现这个问题但没有成功。</p>
<p>抓包的情况是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/4198933e/packages-captured-in-client-environment.png" alt="packages-captured-in-client-environment.png" loading="lazy"></p>
<p>抓包文件很大，在一段很短的时间内出现很多连续的这种错误。上面的截图中是跟前端的交互，因为是压测的关系，短时间有大量的包，所以从抓包中无法确定对应的后端连接，不清楚后端连接是否已经建立，是否是后端出错了。</p>
<h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>我们首先分析下上图中抓包的情况，前面是一个GMVPN的握手，因为压测的关系，服务端回复ServerHello消息以及后面的ChangeCipherSpec消息都隔了一两秒的时间。握完手之后客户端发了两个应用数据包（对应HTTP请求头和请求体）。大概两秒之后，服务端发送了一个alert消息，然后紧接着发送了一个reset。</p>
<p>同事还观察到，抓包中从收到应用数据到连接断开的时间都是2s左右，所以猜测可能跟超时有关。reset的发送原因也是一个关键的线索，另外还有前面提到的Nginx日志（Info级别）中没有任何错误。我们就根据这几个线索来进行问题的定位，首先来分析reset的情况。</p>
<h3 id="reset原因"><a href="#reset原因" class="headerlink" title="reset原因"></a>reset原因</h3><p>有很多情况都会触发TCP的reset，其中大部分都是内核自身的行为。</p>
<ul>
<li><p>端口没有监听</p>
<p>显然可以排除这种情况，我们的连接都已经开始处理了。</p>
</li>
<li><p>防火墙拦截</p>
<p>服务器并没有配置类似的防火墙策略，这种情况也排除。</p>
</li>
<li><p>向已经关闭的socket发送消息</p>
<p>socket可能是进程主动关闭，也可能是被动关闭，也就是进程崩了的情况。显然从抓包可以看出我们的进程并没有崩，况且进程崩了也会有内核日志。那如果是进程主动关闭socket的情况呢，我们从抓包中可以看到服务端是在发送了一个Encrypted Alert消息之后紧接着就发送了reset，其间并没有收到客户端的消息，所以也可以排除这种情况。</p>
</li>
<li><p>接收缓冲区还有数据未接收时关闭该socket</p>
<p>因为我们并不清楚后端连接的情况，所以抓包中的两个应用数据包是否已经被应用层接收是无法确定的。因此，这种情况是有可能的。</p>
</li>
<li><p>SO_LINGER</p>
<p>前面几种都是内核自发的行为，不需要用户参与。SO_LINGER是一个TCP选项，可以修改close()系统调用的行为。</p>
<ul>
<li>默认不开的情况下，close调用会立即返回，发送队列一直保持到发送完成，连接通过正常的四次挥手进行关闭。</li>
<li>打开且时间设为0的情况下，直接丢弃发送缓冲区的数据，并发送RST给对方（不走4次挥手流程）。</li>
<li>打开且时间不为0的情况下，进程将阻塞直到1）所有数据发送完毕且收到对方确认，2）超时时间到。对于前者会正常关闭；对于后者，close将返回EWOULDBLOCK，然后跟第二种情况相同处理，即且丢弃发送缓冲区数据然后发送RST。这种情况socket必须是阻塞的，否则close会立即返回。</li>
</ul>
<p>了解了SO_LINGER的情况，一看Nginx代码，确实是用到了这个选项，不过只有当连接超时并且打开了reset_timeout_connection配置项时才会去设置。而这个选项默认是关闭的，且我们也没有显式地设置过，所以这种情况也排除了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (r-&gt;connection-&gt;timedout) &#123;</span><br><span class="line">    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (clcf-&gt;reset_timedout_connection) &#123;</span><br><span class="line">        linger.l_onoff = <span class="number">1</span>;</span><br><span class="line">        linger.l_linger = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (setsockopt(r-&gt;connection-&gt;fd, SOL_SOCKET, SO_LINGER,</span><br><span class="line">                       (<span class="keyword">const</span> <span class="keyword">void</span> *) &amp;linger, <span class="keyword">sizeof</span>(struct linger)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ngx_log_error(NGX_LOG_ALERT, <span class="built_in">log</span>, ngx_socket_errno,</span><br><span class="line">                          <span class="string">&quot;setsockopt(SO_LINGER) failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>至此可以得出结论，reset的原因大概率就是因为接收缓冲区还有数据的时候关闭了连接。至于连接为什么被关闭，则还需要进一步定位。</p>
<h3 id="连接关闭原因"><a href="#连接关闭原因" class="headerlink" title="连接关闭原因"></a>连接关闭原因</h3><p>接着前面的结论我们进一步排查，SSL握手显然是完成了，因为客户端已经发送了应用数据消息，所以在接收缓冲区中数据应该就是Application Data。至于请求头是否已经被读取目前还不好判断。不过从抓包可以看出，服务端是直接关闭的连接，并没有给客户端发送响应，所以可以确认服务端还没有走到应用层处理的环节，要么是还没有接收请求头、要么是还没处理完毕，否则肯定会有应用层的响应。于是问题的范围就缩小到了SSL握手完成之后、请求头处理完毕之前。</p>
<p>是不是之前提到的超时原因呢？不过同事又指出超时时间已经设置了很大（分钟级别），那会不会遗漏了某些超时呢。但是好像没有两秒这么短的超时时间，Nginx默认的超时基本都是60s级别的。于是开始寻找可能存在的超时，发现SSL阶段并没有单独的超时，在请求头读完之前就只有一个超时时间就是client_header_timeout，但是显然这个超时不是2s。我们合理假设是现场配置错了，但我在确认代码后发现如果是超时也是会有INFO级别，接收到请求前和接收到请求后都是如此。</p>
<p>所以超时这条路走不通了，大概率不是由于超时导致的连接关闭。没有办法只能继续看源码分析，看看从SSL握手完成到HTTP请求头处理完成之前，Nginx到底干了些什么。在详细看了这部分代码之后，一个在不同handler中多次出现的函数<code>ngx_reusable_connection</code>引起了我的注意。这个函数用于修改连接的reusable标记，并且ngx_cycle维护了一个resuable连接的队列，那么这个队列是干啥的呢？进一步探究发现，<code>ngx_get_connection</code>在获取新连接的时候，如果空闲的连接不足，会尝试重用部分reusable的连接（一次最多32个）。而nginx连接在完成SSL握手之后、接收到HTTP请求之前就是处于reusable状态的。我们再次打开抓包文件一数，发现连续关闭的连接正好是31/32个左右，于是我们已经有八九成的把握就是因为这个原因导致的连接断开，而且正好这种情况下我们使用版本的Nginx是没有日志的（高版本加了WARN级别日志）。</p>
<h2 id="复现问题"><a href="#复现问题" class="headerlink" title="复现问题"></a>复现问题</h2><p>为了进一步证明就是这个原因导致的连接断开，我尝试构造场景复现问题，这个问题的关键在于worker进程的总连接数不足，但是只建立前端连接又是够的，有很多连接停留在SSL握手完成又没有开始处理HTTP请求头的阶段。当其他连接的请求尝试建立后端连接时，就会把这些reusable连接踢掉。所以worker最大连接数需要大于前端连接数、小于前端连接数的两倍。</p>
<p>因为我是用自己虚拟机简单测试，客户端用wrk设置了100个连接，nginx只配了1个worker，最大连接数是120（具体数值可能有点出入，因为已经过去有段时间了记得不太清楚了）。一测试成功复现了这个问题，抓包截图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/4198933e/packages-captured-when-recurring-problem-1.jpg" alt="packages-captured-when-recurring-problem-1" loading="lazy"></p>
<p>这是跟踪的其中一个流，可以看到也是在SSL握手完成之后，收到了客户端发送的应用数据，然后发送了Alert以及RST。顺带提一下，这里后面还多了一个RST，这是因为连接关闭之后收到了客户端的一个ACK。</p>
<p>再看下一个截图，可以观察到，在这两个reusable连接被踢掉之后，立马就往后端新建了两个连接。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/4198933e/packages-captured-when-recurring-problem-2.jpg" alt="packages-captured-when-recurring-problem-2" loading="lazy"></p>
<p>至此，问题的原因基本已经确认。直接原因就是因为worker连接数不足。</p>
<h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>问题原因已经定位到，再回过头看现场的测试配置。其实按照所有worker的连接总数来算，连接是够的，而单个worker则是不够的。但是因为其他几个配置的间接作用导致了连接集中在了单个worker中。首先，因为系统版本较低不支持reuseport，只能依赖nginx自身进行进程间的连接分配。其次又配置了multi_accept，所以只要有已经就绪的TCP连接，worker进程就一直进行accept，造成单个worker进程的接收了大部分连接。这几个因素结合在一起造成了最终的问题。归根结底，还是因为对Nginx配置理解不够深入导致的。</p>
<h2 id="连接生命周期"><a href="#连接生命周期" class="headerlink" title="连接生命周期"></a>连接生命周期</h2><p>在讨论前面的问题时我们也看到了，Nginx中的连接是有几个不同的状态的，我们分成连接建立时和连接关闭时两部分来看连接的生命周期。</p>
<h3 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h3><p>下面是连接建立时一个大致的调用关系图，实际情况要比着复杂的多。任何一处都可能超时或出错提前终止连接，碰到NGX_EAGAIN则可能多次调用同一个handler。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ngx_event_accept</span><br><span class="line">|-- accept</span><br><span class="line">|-- ngx_get_connection</span><br><span class="line">+-- ngx_http_init_connection</span><br><span class="line">    |-- ngx_reusable_connection(1)</span><br><span class="line">    +-- ngx_http_ssl_handshake</span><br><span class="line">        |-- NGX_EAGAIN: ngx_reusable_connection(1)</span><br><span class="line">        |-- ngx_ssl_create_connection</span><br><span class="line">        |-- ngx_reusable_connection(0)</span><br><span class="line">        |-- ngx_ssl_handshake</span><br><span class="line">        +-- ngx_http_ssl_handshake_handler</span><br><span class="line">            |-- ngx_reusable_connection(1)</span><br><span class="line">            +-- ngx_http_wait_request_handler</span><br><span class="line">                |-- ngx_reusable_connection(0)</span><br><span class="line">                |-- ngx_http_create_request</span><br><span class="line">                +-- ngx_http_process_request_line</span><br><span class="line">                    |-- ngx_http_read_request_header</span><br><span class="line">                    |-- ngx_http_parse_request_line</span><br><span class="line">                    +-- ngx_http_process_request_headers</span><br><span class="line">                        |-- ngx_http_read_request_header</span><br><span class="line">                        |-- ngx_http_parse_header_line</span><br><span class="line">                        |-- ngx_http_process_request_header</span><br><span class="line">                        +-- ngx_http_process_request</span><br><span class="line">                            |-- Switch stat from reading to writing</span><br><span class="line">                            +-- ngx_http_handler</span><br><span class="line">                                |-- HTTP to HTTPS? certificate verify fail?</span><br><span class="line">                                +-- ngx_http_core_run_phases</span><br><span class="line">                                    +-- ngx_http_proxy_handler</span><br><span class="line">                                        +-- ngx_http_read_client_request_body</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>首先，nginx是从accept才开始接手连接的处理，在此之前则完全是内核的行为。不过在初始化阶段可以通过设置一些socket选项来改变其行为，大家比较熟知的有比如SO_REUSEPORT，TCP_DEFER_ACCEPT。前者允许多个socket绑定到在相同的地址端口对上，由内核在多个进程的socket间进行连接接收的负载均衡，后者则可以推迟连接就绪的时间，只有当收到客户端发来的应用数据时才可以accept。</p>
<p>accept之后nginx会从空闲的连接中获取一个，这个动作在ngx_get_connection中完成，然后进入HTTP初始化流程。我们这里主要关注连接状态的变化情况，它是通过<strong>ngx_resuable_connection</strong>函数进行修改。最初连接是处于free状态的，进入ngx_http_ssl_handshake完成一些基本的初始化之后，连接设置定时器开始准备接收消息，此时的超时时间是post_accept_timeout，也就是配置项中的client_header_timeout，同步地连接进入reusable状态。等到接收到SSL握手消息之后，会创建SSL连接，同步地nginx连接进入unreusable状态。后续会进入握手流程，等到握手完成之后，连接又变成了reusable状态，开始等待接收HTTP请求，此时的超时时间仍然是post_accept_timeout。直到接收到HTTP请求，连接就此进入unreusable状态。一直到请求结束为止，状态都不再变化。</p>
<h3 id="连接关闭"><a href="#连接关闭" class="headerlink" title="连接关闭"></a>连接关闭</h3><p>接下来再来看下请求结束时的情况，如果是短连接的情况会进入ngx_http_close_request流程，释放请求之后会关闭连接，连接变为free状态被放入空闲队列中。如果是长连接的情况则会进入ngx_http_set_keepalive流程，此时请求被释放，但是连接进入reusable状态，此时定时器的超时时间就是keepalive_timeout了。如果在超时时间内收到了新的请求，那么连接又变为unreusable状态，进入请求的处理流程；如果直到超时都没有收到新请求，则会调用ngx_http_close_connection关闭连接，连接变为free状态被放入空闲队列中。</p>
<p>值得注意的是，连接变成reusable状态时，肯定是处于等待什么消息的状态，同步地会有一个定时器存在。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ngx_http_finalize_request</span><br><span class="line">+-- ngx_http_finalize_connection</span><br><span class="line">    |-- ngx_http_set_keepalive</span><br><span class="line">    |   |-- ngx_http_free_request</span><br><span class="line">    |   |-- ngx_reusable_connection(1)</span><br><span class="line">    |   +-- ngx_http_keepalive_handler</span><br><span class="line">    |       |-- ngx_http_close_connection</span><br><span class="line">    |       |-- ngx_reusable_connection(0)</span><br><span class="line">    |       |-- ngx_http_create_request</span><br><span class="line">    |       +-- ngx_http_process_request_line</span><br><span class="line">    +-- ngx_http_close_request</span><br><span class="line">        |-- ngx_http_free_request</span><br><span class="line">        +-- ngx_http_close_connection</span><br><span class="line">            |-- ngx_ssl_shutdown</span><br><span class="line">            +-- ngx_close_connection</span><br><span class="line">                |-- ngx_reusable_connection(0)</span><br><span class="line">                |-- ngx_free_connection</span><br><span class="line">                +-- ngx_close_socket</span><br></pre></td></tr></table></figure>

<p>为了更清晰地表示连接状态的转移情况，我们用一张图来描述：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/4198933e/nginx-connection-life-cycle.png" alt="nginx-connection-life-cycle" loading="lazy"></p>
<h2 id="连接超时"><a href="#连接超时" class="headerlink" title="连接超时"></a>连接超时</h2><p>在连接的各个阶段都会伴随着超时的存在，只要不是进程正在处理当前连接，总会有某个定时器管着当前连接。以HTTP为例，主要有以下这些超时：</p>
<ul>
<li>client_header_timeout (60s): 在这个时间内，这个请求头必须接收完。</li>
<li>client_body_timeout (60s)：读请求头的超时时间，只是限制两次连续操作之间的间隔</li>
<li>send_timeout (60s)：发送响应给客户端的超时时间，同样只是限制两次连续操作之间的间隔</li>
<li>proxy_connect_timeout (60s)：与后端服务器建立连接的超时</li>
<li>proxy_send_timeout (60s)：发送请求给代理服务器的超时，只是限制两次连续操作之间的间隔</li>
<li>proxy_read_timeout (60s)：从代理服务器读响应的超时，只是限制两次连续操作之间的间隔</li>
<li>keepalive_timeout (75s)：长连接保持打开的时间。</li>
<li>resolver_timeout (5s): 域名解析的超时时间</li>
</ul>
<p>连接的超时控制，当然是为了防止“坏”的连接一直占用系统资源。但是我们注意到，并不是所有超时都是限制总体的时间，很多超时都只是限制两次连续操作之间的间隔。所以一个恶意的连接，其实还是可以做到长时间占用一个连接的。比如客户端发送请求体时，每次只发一个字节，但是赶在服务端超时之前发送第二个字节。对于这种情况，貌似没有太好的避免办法。不过我们可以通过限速等其他手段，限制恶意方占用的连接个数，一定程度缓解了这个问题。</p>
<h2 id="性能调测"><a href="#性能调测" class="headerlink" title="性能调测"></a>性能调测</h2><p>关于Nginx的性能调优测试，至少有以下三个部分是需要关注的：Nginx配置、网卡队列及irq、内核网络栈参数。另外在测试时应时刻关注CPU、内存、IO等系统负载状况。</p>
<h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><p>Linux下性能调优其实是一个单独的领域，我在这里不可能详细展开，一没这个时间二没这个能力，只会介绍下一些基本原则和测试的关键步骤。遵循这些建议，貌似增加了工作量，其实最终会提升你的效率，减少出错和绕弯的可能性，而且还方便后续复现与回看，下次再进行类似测试时也可以省去很多重复的工作。</p>
<p>因为我注意到很多人其实是不注意这些的，不管三七二十一上来就是一顿测试，拿到一个数据就以为万事大吉了。事实上，可能测的根本不是他想的那个东西，测试值跟真实值相去甚远。当然，只要是测试肯定会引入影响，不确定性原理已经把这块拿捏得死死的了，我们能做的就让测试值尽量接近真实值，提供有参考意义的结果。</p>
<p>废话不多说，下面是一些常用的建议：</p>
<ul>
<li>尽可能详细的记录<ul>
<li>记录软硬件配置</li>
<li>保存并整理测试结果</li>
<li>写下命令行调用，避免每次手输</li>
<li>记录查询和研究的文档和url等</li>
</ul>
</li>
<li>自动执行重复任务<ul>
<li>测试任务尽量自动化，既减小出错的可能，也减小了测试负担</li>
</ul>
</li>
<li>尽量选用低开销的工具<ul>
<li>使我们的测试值更接近真实值</li>
</ul>
</li>
<li>使用多个工具<ul>
<li>必要时可能需使用多个工具进行相互验证，排除工具本身的问题</li>
</ul>
</li>
<li>确定基线和目标<ul>
<li>单个值通常没有太大的意义，不知道它是好是坏，没有对比就没有伤害</li>
</ul>
</li>
<li>分离问题、对比、控制变量<ul>
<li>这是定位问题的基本思路</li>
</ul>
</li>
<li>做了优化之后需要重新进行完整测试<ul>
<li>因为不确定是否会对其他项目产生负面影响</li>
</ul>
</li>
</ul>
<h3 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h3><p>Nginx的配置非常多，这里列的基本都是性能测试相关的，也是我平常比较关注的。注：下面并不是一个完整的配置文件，只是为了方便观看，将这些配置放在了一起。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"><span class="attribute">worker_cpu_affinity</span> auto;</span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">1000000</span>; </span><br><span class="line"><span class="attribute">worker_priority</span> -<span class="number">10</span>;</span><br><span class="line"><span class="attribute">error_log</span> logs/error.log  <span class="literal">error</span>;</span><br><span class="line"><span class="attribute">master_process</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">8192</span>;</span><br><span class="line">    <span class="attribute">multi_accept</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">accept_mutex</span> <span class="literal">off</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> ssl reuseport backlog=<span class="number">131072</span> deferred so_keepalive=<span class="literal">off</span>; </span><br><span class="line"></span><br><span class="line">        <span class="attribute">keepalive_requests</span>  <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">keepalive_timeout</span>  <span class="number">0s</span>;</span><br><span class="line">        <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">lingering_close</span> <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">lingering_time</span> <span class="number">1</span>;</span><br><span class="line">        <span class="attribute">lingering_timeout</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_session_cache</span>   <span class="literal">off</span>;</span><br><span class="line">        <span class="comment">#ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line">        <span class="attribute">ssl_session_timeout</span>  <span class="number">5m</span>;</span><br><span class="line">        <span class="attribute">ssl_session_tickets</span> <span class="literal">off</span>;</span><br><span class="line">        <span class="comment">#ssl_verify_client on;</span></span><br><span class="line">        <span class="attribute">ssl_verify_client</span> <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">ssl_client_certificate</span> ca;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">ssl_buffer_size</span> <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_cache</span> cache_zone | <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">proxy_cache_path</span> /data/nginx/cache levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=cache_zone:<span class="number">10m</span>;</span><br><span class="line">        <span class="comment"># client/proxy buffer相关</span></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<div><div class="fold_hider"><div class="close hider_title">点击展开配置详解</div></div><div class="fold">
<h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><ul>
<li><p>worker_processes</p>
<p>一般设成auto就可以，会自动根据系统CPU核心数进行设置</p>
</li>
<li><p>worker_cpu_affinity</p>
<p>一般auto就可以，会自动每个进程绑定一个核</p>
</li>
<li><p>worker_rlimit_nofile</p>
<p>设置进程能打开的最大文件数目，底层是设置的RLIMIT_NOFILE，不能超过hard nofile</p>
</li>
<li><p>worker_priority</p>
<p>设置进程的优先级，跟nice命令干的事情差不多，值越小优先级越高。</p>
</li>
<li><p>error_log</p>
<p>把日志配置也列进来注意是为了提醒大家不要忘记修改</p>
</li>
</ul>
<h4 id="event"><a href="#event" class="headerlink" title="event"></a>event</h4><ul>
<li><p>worker_connections</p>
<p>进程连接数一定要足够，但是也不要无脑设成超大的一个值，因为这些连接的内存在启动时就会分配，可能会导致内存不足。另外提一下，这是整个worker的连接数，包括了下游和上游。</p>
</li>
<li><p>multi_accept</p>
<p>默认关闭时，进程一次只accept一个连接；打开的时候进程会一次性accept所有已经就绪的连接。这个配置需要根据具体测试场景选择，一般保持默认关闭。</p>
</li>
<li><p>accept_mutex</p>
<p>打开时每个worker轮流接收新连接，关闭时则所有worker都会收到新连接通知（即所谓的惊群效应）。如果新连接数很少，会浪费系统资源。注意当使用reuseport的时候就没有这个配置什么事了，因为内核已经做了负载均衡了。这个配置是否打开，需要根据实际的负载情况实测确定。</p>
</li>
</ul>
<h4 id="http"><a href="#http" class="headerlink" title="http"></a>http</h4><ul>
<li><p>access_log</p>
<p>性能测试时日志一般选择关闭</p>
</li>
<li><p>listen</p>
<p>listen有很多附加参数，可以配置一些socket选项</p>
<ul>
<li><p>reuseport</p>
<p>对应<code>SO_REUSEPORT</code>选项，多个worker进程创建独立的监听套接字，允许内核在worker进程间对连接的连接进行负载均衡。</p>
</li>
<li><p>deferred</p>
<p>对应<code>TCP_DEFER_ACCEPT</code>选项，可以推迟连接就绪的时间，只有当收到客户端发来的应用数据时才可以accept，可以稍微减小服务端的开销。</p>
</li>
<li><p>backlog</p>
<p>设置listen全连接队列大小，不能超过系统<code>net.core.somaxconn</code>的限制。这个需要足够大，否则会影响新建连接的速度。</p>
</li>
</ul>
</li>
<li><p>keepalive_requests/keepalive_time</p>
<p> 这两个分别设置http长连接的最大请求数和超时时间，根据实际测试指标选择是否启动</p>
</li>
<li><p>sendfile</p>
<p>是否使用sendfile()系统调用，可以直接在内核完成文件的发送，不需要再到用户态转一手</p>
</li>
<li><p>tcp_nopush</p>
<p>只有使用sendfile时才打开这个，对应Linux上的<code>TCP_CORK</code>选项，响应头和文件开头在一个包中发送，文件以满包发送，提升网络效率。</p>
</li>
<li><p>tcp_nodelay</p>
<p>对应<code>TCP_NODELAY</code>选项，该选项是针对Nagle算法（在发出去的数据还未被确认前，把新的小数据先保存起来，等到凑满一个MSS或者收到了对方的确认后再发送）。</p>
</li>
<li><p>linger_close/linger_time/linger_timeout</p>
<p>这几个控制在关闭服务端连接前是否等待和处理额外数据，以及等待的时间。</p>
</li>
<li><p>ssl_session_cache/ssl_session_timeout/ssl_session_tickets</p>
<p>这几个参数控制是否启用SSL会话重用以及超时时间，根据测试指标确定</p>
</li>
<li><p>ssl_verify_client/ssl_client_certificate</p>
<p>是否进行SSL双向认证，根据测试需求而定</p>
</li>
<li><p>ssl_buffer_size</p>
<p>发送数据时的SSL buffer大小，我们知道数据块长度越大，对称加密速度越快，所以这个默认值较大。但是如果你很关心第一个字节到达时间的话，最好将这个配置改小一点。</p>
</li>
<li><p>proxy_cache/proxy_cache_path</p>
<p>静态文件使用cache可以提高性能</p>
</li>
<li><p>client和proxy buffer相关配置</p>
<p>根据应用数据情况以及实际网络情况，client和proxy buffer相关的配置也可能影响性能。</p>
</li>
</ul>

</div></div>



<h3 id="网卡队列及irq"><a href="#网卡队列及irq" class="headerlink" title="网卡队列及irq"></a>网卡队列及irq</h3><p>在实际测试中，你可能会发现某些个CPU上的si特别高，成为了性能瓶颈。这时候就需要将网卡队列分配到不同CPU核上进行软中断的处理。</p>
<h4 id="中断号绑定"><a href="#中断号绑定" class="headerlink" title="中断号绑定"></a>中断号绑定</h4><p>irqbalance服务可以帮你自动绑定中断号，不过它是动态变化的，如果你对irqbalance的效果不满意，或者想静态绑定，也可以自己手动进行绑定。操作步骤如下：</p>
<ul>
<li><p><code>cat /proc/interrupts</code>查看对应网卡的中断号</p>
<p>下面的218到249就是eth11这个网卡对应的中断号，该网卡拥有32个队列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 218:   17094773          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0         14         22          0          0          0          0      12697          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      eth11-TxRx-0</span><br><span class="line"> 219:       3119   13271410          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      eth11-TxRx-1</span><br><span class="line"> 220:       2385          0   13265837          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      eth11-TxRx-2</span><br><span class="line"> 221:         23          0          0   13290114          0          0          0          0          0          0          0          0       2064          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      eth11-TxRx-3</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"> 245:          0         23          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          5       2000    6603326          0          0          0          0          0          0          0     149556          0          0          0          0  IR-PCI-MSI-edge      eth11-TxRx-27</span><br><span class="line"> 246:          0         23          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          5    6869437          0          0       2000  IR-PCI-MSI-edge      eth11-TxRx-28</span><br><span class="line"> 247:          0         23          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          5          0          0    6846871       2000          0  IR-PCI-MSI-edge      eth11-TxRx-29</span><br><span class="line"> 248:          0         23          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          5          0          0          0       2000    6937093          0  IR-PCI-MSI-edge      eth11-TxRx-30</span><br><span class="line"> 249:          0         23          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          5          0          0          0       2000          0          0    6837127  IR-PCI-MSI-edge      eth11-TxRx-31</span><br></pre></td></tr></table></figure></li>
<li><p>接下来将中断号绑定到CPU核上</p>
<p>示例中218号中断绑定到1号CPU</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo 00000001 &gt; /proc/irq/218/smp_affinity</span><br><span class="line">echo 00000002 &gt; /proc/irq/219/smp_affinity</span><br><span class="line">echo 00000004 &gt; /proc/irq/220/smp_affinity</span><br><span class="line">echo 00000008 &gt; /proc/irq/221/smp_affinity</span><br><span class="line">echo 00000010 &gt; /proc/irq/222/smp_affinity</span><br><span class="line">echo 00000020 &gt; /proc/irq/223/smp_affinity</span><br><span class="line">echo 00000040 &gt; /proc/irq/224/smp_affinity</span><br><span class="line">echo 00000080 &gt; /proc/irq/225/smp_affinity</span><br><span class="line"># ...</span><br><span class="line">echo 01000000 &gt; /proc/irq/242/smp_affinity</span><br><span class="line">echo 02000000 &gt; /proc/irq/243/smp_affinity</span><br><span class="line">echo 04000000 &gt; /proc/irq/244/smp_affinity</span><br><span class="line">echo 08000000 &gt; /proc/irq/245/smp_affinity</span><br><span class="line">echo 10000000 &gt; /proc/irq/246/smp_affinity</span><br><span class="line">echo 20000000 &gt; /proc/irq/247/smp_affinity</span><br><span class="line">echo 40000000 &gt; /proc/irq/248/smp_affinity</span><br><span class="line">echo 80000000 &gt; /proc/irq/249/smp_affinity</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="RPS"><a href="#RPS" class="headerlink" title="RPS"></a>RPS</h4><p>有时候你的网卡不支持多队列、或者队列数少于CPU核心数、又或是NIC的间接表（Indirection Table）的RX队列数少于CPU核心数，这个时候就需要借助内核的<a href="https://www.kernel.org/doc/Documentation/networking/scaling.txt">RPS/RFS机制</a>，在软件层面再次进行分配。比如下面的例子，NIC的间接表最大RX队列数只有16</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ethtool --show-rxfh-indir enp7s0f0</span></span><br><span class="line">RX flow <span class="built_in">hash</span> indirection table <span class="keyword">for</span> enp7s0f0 with 56 RX ring(s):</span><br><span class="line">    0:      0     1     2     3     4     5     6     7</span><br><span class="line">    8:      8     9    10    11    12    13    14    15</span><br><span class="line">   16:      0     1     2     3     4     5     6     7</span><br><span class="line">   24:      8     9    10    11    12    13    14    15</span><br><span class="line">   32:      0     1     2     3     4     5     6     7</span><br><span class="line">   40:      8     9    10    11    12    13    14    15</span><br><span class="line">   48:      0     1     2     3     4     5     6     7</span><br><span class="line">   56:      8     9    10    11    12    13    14    15</span><br><span class="line">   64:      0     1     2     3     4     5     6     7</span><br><span class="line">   72:      8     9    10    11    12    13    14    15</span><br><span class="line">   80:      0     1     2     3     4     5     6     7</span><br><span class="line">   88:      8     9    10    11    12    13    14    15</span><br><span class="line">   96:      0     1     2     3     4     5     6     7</span><br><span class="line">  104:      8     9    10    11    12    13    14    15</span><br><span class="line">  112:      0     1     2     3     4     5     6     7</span><br><span class="line">  120:      8     9    10    11    12    13    14    15</span><br><span class="line">RSS <span class="built_in">hash</span> key:</span><br><span class="line">fb:db:6a:ad:9d:49:5f:c7:d1:d9:d0:c8:bd:4c:e9:f3:60:c6:34:1e:09:c5:7f:f5:ae:bf:62:38:ca:83:a5:a2:40:c2:59:4b:32:92:6b:5b</span><br><span class="line">RSS <span class="built_in">hash</span> <span class="keyword">function</span>:</span><br><span class="line">    toeplitz: on</span><br><span class="line">    xor: off</span><br><span class="line">    crc32: off</span><br></pre></td></tr></table></figure>

<p>设置成大16的值会失败</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ethtool --set-rxfh-indir enp7s0f0 equal 56</span></span><br><span class="line">Cannot <span class="built_in">set</span> RX flow <span class="built_in">hash</span> configuration: Invalid argument</span><br></pre></td></tr></table></figure>

<p>使用RPS将16个rx队列再分配到56个核上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> 010001,00010001 &gt; /sys/class/net/enp7s0f0/queues/rx-0/rps_cpus</span><br><span class="line"><span class="built_in">echo</span> 020002,00020002 &gt; /sys/class/net/enp7s0f0/queues/rx-1/rps_cpus</span><br><span class="line"><span class="built_in">echo</span> 040004,00040004 &gt; /sys/class/net/enp7s0f0/queues/rx-2/rps_cpus</span><br><span class="line"><span class="built_in">echo</span> 080008,00080008 &gt; /sys/class/net/enp7s0f0/queues/rx-3/rps_cpus</span><br><span class="line"><span class="built_in">echo</span> 100010,00100010 &gt; /sys/class/net/enp7s0f0/queues/rx-4/rps_cpus</span><br><span class="line"><span class="built_in">echo</span> 200020,00200020 &gt; /sys/class/net/enp7s0f0/queues/rx-5/rps_cpus</span><br><span class="line"><span class="built_in">echo</span> 400040,00400040 &gt; /sys/class/net/enp7s0f0/queues/rx-6/rps_cpus</span><br><span class="line"><span class="built_in">echo</span> 800080,00800080 &gt; /sys/class/net/enp7s0f0/queues/rx-7/rps_cpus</span><br><span class="line"><span class="built_in">echo</span> 000100,01000100 &gt; /sys/class/net/enp7s0f0/queues/rx-8/rps_cpus</span><br><span class="line"><span class="built_in">echo</span> 000200,02000200 &gt; /sys/class/net/enp7s0f0/queues/rx-9/rps_cpus</span><br><span class="line"><span class="built_in">echo</span> 000400,04000400 &gt; /sys/class/net/enp7s0f0/queues/rx-10/rps_cpus</span><br><span class="line"><span class="built_in">echo</span> 000800,08000800 &gt; /sys/class/net/enp7s0f0/queues/rx-11/rps_cpus</span><br><span class="line"><span class="built_in">echo</span> 001000,10001000 &gt; /sys/class/net/enp7s0f0/queues/rx-12/rps_cpus</span><br><span class="line"><span class="built_in">echo</span> 002000,20002000 &gt; /sys/class/net/enp7s0f0/queues/rx-13/rps_cpus</span><br><span class="line"><span class="built_in">echo</span> 004000,40004000 &gt; /sys/class/net/enp7s0f0/queues/rx-14/rps_cpus</span><br><span class="line"><span class="built_in">echo</span> 008000,80008000 &gt; /sys/class/net/enp7s0f0/queues/rx-15/rps_cpus</span><br></pre></td></tr></table></figure>



<p>下图很好的描述了上面发生的事情：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/4198933e/RSS-RPS-REUSRPORT.jpg" alt="RSS-RPS-REUSRPORT" loading="lazy"></p>
<p>网卡收到包送到多个队列中，然后将队列的中断号与CPU核心绑定，如果没有充分利用CPU，借助RPS再次分配到其他CPU核心上。每个CPU核上有一个ksoftirqd在工作。SO_REUSEPORT解决socket竞争的问题，每个进程有一个独立的socket，默认情况下是对数据流（源和目的的ip端口号）做哈希值来选择送到那个socket。但是这个地方其实还是存在一点竞争，同一个socket可能被不同的核选择，Linux内核从4.5版本起已经支持SO_ATTACH_REUSEPORT_CBPF/EBPF，可以根据核心号来选择socket以消除softirq这里的竞争，配合上进程的CPU亲和性绑定可以最大程度的提升性能。不过Nginx目前还不支持这个选项。</p>
<h3 id="Linux内核网络栈参数"><a href="#Linux内核网络栈参数" class="headerlink" title="Linux内核网络栈参数"></a>Linux内核网络栈参数</h3><p>这部分由于内容太多，我不准备再展开，只是贴一个参考配置。建议大家在理解参数含义的基础上谨慎参考，不要无脑照搬，否则很可能带来反效果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">ufw <span class="built_in">disable</span>                                                                     <span class="comment">#disable Debian firewall</span></span><br><span class="line">iptables -F                                                                     <span class="comment">#flush the iptables rules</span></span><br><span class="line"><span class="comment">#TCP Memory</span></span><br><span class="line"><span class="built_in">echo</span> 16777216                &gt; /proc/sys/net/core/rmem_max</span><br><span class="line"><span class="built_in">echo</span> 16777216                &gt; /proc/sys/net/core/wmem_max</span><br><span class="line"><span class="built_in">echo</span> 16777216                &gt; /proc/sys/net/core/rmem_default</span><br><span class="line"><span class="built_in">echo</span> 16777216                &gt; /proc/sys/net/core/wmem_default</span><br><span class="line"><span class="built_in">echo</span> 16777216 16777216 16777216  &gt; /proc/sys/net/ipv4/tcp_rmem</span><br><span class="line"><span class="built_in">echo</span> 538750 538750 538750  &gt; /proc/sys/net/ipv4/tcp_wmem</span><br><span class="line"><span class="built_in">echo</span> 16777216            &gt; /proc/sys/net/core/optmem_max</span><br><span class="line"><span class="built_in">echo</span> 16777216 16777216  16777216 &gt; /proc/sys/net/ipv4/tcp_mem</span><br><span class="line"><span class="built_in">echo</span> 65536       &gt; /proc/sys/vm/min_free_kbytes                                  <span class="comment">#ensure there will always be free</span></span><br><span class="line"><span class="comment">#TCP Behavior</span></span><br><span class="line"><span class="built_in">echo</span> 0                     &gt; /proc/sys/net/ipv4/tcp_timestamps</span><br><span class="line"><span class="built_in">echo</span> 0                     &gt; /proc/sys/net/ipv4/tcp_sack</span><br><span class="line"><span class="built_in">echo</span> 0                     &gt; /proc/sys/net/ipv4/tcp_fack</span><br><span class="line"><span class="built_in">echo</span> 0                     &gt; /proc/sys/net/ipv4/tcp_dsack</span><br><span class="line"><span class="built_in">echo</span> 0                     &gt; /proc/sys/net/ipv4/tcp_moderate_rcvbuf</span><br><span class="line"><span class="built_in">echo</span> 1                     &gt; /proc/sys/net/ipv4/tcp_rfc1337</span><br><span class="line"><span class="built_in">echo</span> 600        &gt; /proc/sys/net/core/netdev_budget</span><br><span class="line"><span class="built_in">echo</span> 128                   &gt; /proc/sys/net/core/dev_weight</span><br><span class="line"><span class="built_in">echo</span> 1                     &gt; /proc/sys/net/ipv4/tcp_syncookies</span><br><span class="line"><span class="built_in">echo</span> 0                     &gt; /proc/sys/net/ipv4/tcp_slow_start_after_idle</span><br><span class="line"><span class="built_in">echo</span> 1                     &gt; /proc/sys/net/ipv4/tcp_no_metrics_save</span><br><span class="line"><span class="built_in">echo</span> 1                     &gt; /proc/sys/net/ipv4/tcp_orphan_retries</span><br><span class="line"><span class="built_in">echo</span> 0                     &gt; /proc/sys/net/ipv4/tcp_fin_timeout</span><br><span class="line"><span class="built_in">echo</span> 0                     &gt; /proc/sys/net/ipv4/tcp_tw_reuse</span><br><span class="line"><span class="built_in">echo</span> 0                     &gt; /proc/sys/net/ipv4/tcp_tw_recycle</span><br><span class="line"><span class="built_in">echo</span> 1                     &gt; /proc/sys/net/ipv4/tcp_syncookies</span><br><span class="line"><span class="built_in">echo</span> 2                       &gt; /proc/sys/net/ipv4/tcp_synack_retries</span><br><span class="line"><span class="built_in">echo</span> 2                     &gt; /proc/sys/net/ipv4/tcp_syn_retries</span><br><span class="line"><span class="built_in">echo</span> cubic                   &gt; /proc/sys/net/ipv4/tcp_congestion_control</span><br><span class="line"><span class="built_in">echo</span> 0                     &gt; /proc/sys/net/ipv4/tcp_low_latency</span><br><span class="line"><span class="built_in">echo</span> 1                     &gt; /proc/sys/net/ipv4/tcp_window_scaling</span><br><span class="line"><span class="built_in">echo</span> 1                     &gt; /proc/sys/net/ipv4/tcp_adv_win_scale</span><br><span class="line"><span class="comment">#TCP Queueing</span></span><br><span class="line"><span class="built_in">echo</span> 0                &gt; /proc/sys/net/ipv4/tcp_max_tw_buckets</span><br><span class="line"><span class="built_in">echo</span> 1025 65535            &gt; /proc/sys/net/ipv4/ip_local_port_range</span><br><span class="line"><span class="built_in">echo</span> 131072                &gt; /proc/sys/net/core/somaxconn</span><br><span class="line"><span class="built_in">echo</span> 262144            &gt; /proc/sys/net/ipv4/tcp_max_orphans</span><br><span class="line"><span class="built_in">echo</span> 262144           &gt; /proc/sys/net/core/netdev_max_backlog</span><br><span class="line"><span class="built_in">echo</span> 262144        &gt; /proc/sys/net/ipv4/tcp_max_syn_backlog</span><br><span class="line"><span class="built_in">echo</span> 4000000             &gt; /proc/sys/fs/nr_open</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 4194304     &gt; /proc/sys/net/ipv4/ipfrag_high_thresh</span><br><span class="line"><span class="built_in">echo</span> 3145728     &gt; /proc/sys/net/ipv4/ipfrag_low_thresh</span><br><span class="line"><span class="built_in">echo</span> 30      &gt; /proc/sys/net/ipv4/ipfrag_time</span><br><span class="line"><span class="built_in">echo</span> 0   &gt; /proc/sys/net/ipv4/tcp_abort_on_overflow</span><br><span class="line"><span class="built_in">echo</span> 1       &gt; /proc/sys/net/ipv4/tcp_autocorking</span><br><span class="line"><span class="built_in">echo</span> 31      &gt; /proc/sys/net/ipv4/tcp_app_win</span><br><span class="line"><span class="built_in">echo</span> 1       &gt; /proc/sys/net/ipv4/tcp_mtu_probing</span><br><span class="line"><span class="built_in">set</span> selinux=disabled</span><br><span class="line"><span class="built_in">ulimit</span> -n 1000000</span><br></pre></td></tr></table></figure>

<p>最后再重申一下，配置并不是一成不变的，需要在理解配置含义的基础上，结合自身的测试需求合理进行配置。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Nginx/OpenResty</category>
        <category>性能</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>性能调优</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx的共享内存管理--slab算法</title>
    <url>/posts/2dc32e47/</url>
    <content><![CDATA[<div class="note primary">
            <p>初次了解到slab算法，是在学习Linux内核时。内核中采用了伙伴系统（Buddy System）算法对内存页面进行管理。但是对于小对象，还用页面分配器就显得有些浪费了，于是slab就应运而生了，内核的kmalloc()就是使用slab进行管理的。nginx中的共享内存管理使用了相同的思想，当然它没有Linux内核中的slab那么复杂。</p>
          </div>

<span id="more"></span>

<h2 id="slab原理"><a href="#slab原理" class="headerlink" title="slab原理"></a>slab原理</h2><p>它的基本工作原理如下：</p>
<ol>
<li>首先对共享内存进行初始化，最前面一部分是用于管理的元数据，剩余部分按页进行划分。每个页在前面元数据中都有一个对应的页头，用于管理该页</li>
<li>元数据中有一个空闲页块链表，管理着所有空闲的页块（初始是一个完整的连续页块）</li>
<li>分配对象时将长度按2的次幂进行对齐，nginx中称其为不同的slot</li>
<li>一个页面被分配给某个slot，就只用于这种长度对象的分配，例如一个4KB页面，可以切分成64个64B的对象，或者32个128B的对象。</li>
<li>每种slot的对象都有一个未满页链表，管理着该slot所有未满且未空的页。</li>
<li>slot的对象是通过bitmap进行管理的，一个对象被分配了就将对应位置1，释放了置0，由此判断页面中哪些内存块是空闲的</li>
<li>如果某个页满了，那么就从未满页链表中移除；如果一个页从满页变为未满（即满页释放了一个对象），则重新挂到未满页链表中</li>
<li>如果分配某slot对象时，发现未满页链表空了，那么就从空闲页块链表中分配一个空闲页，分配对象之后插入该slot的未满页链表中；如果释放对象之后，这个页空了，则还给空闲页块链表</li>
<li>分配和释放页面时，空闲页块链表有切分和合并操作</li>
<li>大对象（超过半页）直接从空闲页块链表中分配，不走slot</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/2dc32e47/nginx-slab-mechanism.svg" alt="nginx-slab-mechanism" loading="lazy"></p>
<p>值得一提的是，slot根据对象的尺寸大小分成3类，对于大尺寸对象因为一个页可以分成的内存块数较少，直接用页面头中的slab字段作为bitmap就够了。而对于小尺寸对象，因为切分的块数很多，所以需要使用实际的内存页面中前面的几个块作为bitmap。</p>
<h2 id="主要数据结构"><a href="#主要数据结构" class="headerlink" title="主要数据结构"></a>主要数据结构</h2><div class="note default no-icon">
            <p>注：后面的代码都是基于Nginx-1.19.3</p>
          </div>

<p>下图给出了几个主要结构体之间的关系，以及几个主要的指针指向的共享内存的位置。从addr到last是用于管理的元数据，从start到end则实际用于分配的内存。slots和stats分别是各个slot的半满链表头和统计信息。pages是页面头数组，跟后面实际分配的内存页面一一对应。通过页面头可以找到对应页，通过页面地址也可以找到它的页面头，连续的页块其页面头也是连续的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/2dc32e47/nginx-slab-structures.svg" alt="nginx-slab-structures" loading="lazy"></p>
<p><code>ngx_shm_zone_t</code>是用于描述共享内存的结构体，data是私有数据指针，init是私有的初始化函数，tag用于区别不同的共享内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ngx_shm_zone_t是共享内存的结构体，里面包含了shm，data是私有数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_shm_zone_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>                     *data;</span><br><span class="line">    <span class="keyword">ngx_shm_t</span>                 shm;</span><br><span class="line">    ngx_shm_zone_init_pt      init;</span><br><span class="line">    <span class="keyword">void</span>                     *tag;</span><br><span class="line">    <span class="keyword">void</span>                     *sync;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>                noreuse;  <span class="comment">/* unsigned  noreuse:1; */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的shm记录了共享内存的具体信息，addr是共享内存起始地址，size是大小，name名字。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shm里的addr指向实际mmap的共享内存</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u_char      *addr;</span><br><span class="line">    <span class="keyword">size_t</span>       size;</span><br><span class="line">    <span class="keyword">ngx_str_t</span>    name;</span><br><span class="line">    <span class="keyword">ngx_log_t</span>   *<span class="built_in">log</span>;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>   exists;   <span class="comment">/* unsigned  exists:1;  */</span></span><br><span class="line">&#125; <span class="keyword">ngx_shm_t</span>;</span><br></pre></td></tr></table></figure>

<p><code>ngx_slab_pool_t</code>用于管理slab，它位于共享内存的最开头。min_size/min_shift记录了最小的slot的尺寸及对应位偏移，free是前面已经提到的空闲页块链表头。pages/last/stats/start/end/data/addr都是指针，指向共享内存的不同位置，具体参看下图。lock和mutex用于保护共享内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共享内存最开头是ngx_slab_pool_t，它用于管理slab，后面会详细介绍它的字段</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_shmtx_sh_t</span>    lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span>            min_size;     <span class="comment">// 分配内存最小尺寸，8</span></span><br><span class="line">    <span class="keyword">size_t</span>            min_shift;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_slab_page_t</span>  *pages;        <span class="comment">// 指向页面头数组</span></span><br><span class="line">    <span class="keyword">ngx_slab_page_t</span>  *last;         <span class="comment">// 指向页面头数组末尾</span></span><br><span class="line">    <span class="keyword">ngx_slab_page_t</span>   <span class="built_in">free</span>;         <span class="comment">// 空闲页面链表头</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_slab_stat_t</span>  *stats;        <span class="comment">// 指向统计数组</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>        pfree;        <span class="comment">// 总空闲页面数</span></span><br><span class="line"></span><br><span class="line">    u_char           *start;        <span class="comment">// 实际数据页面起始位置</span></span><br><span class="line">    u_char           *end;          <span class="comment">// 共享内存结束位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_shmtx_t</span>       mutex;</span><br><span class="line"></span><br><span class="line">    u_char           *log_ctx;</span><br><span class="line">    u_char            zero;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span>          log_nomem:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>             *data;         <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span>             *addr;</span><br><span class="line">&#125; <span class="keyword">ngx_slab_pool_t</span>;</span><br></pre></td></tr></table></figure>

<p><code>ngx_slab_page_s</code>用于管理页面，就是我们前面所说的页面头，它既作为链表节点，又记录一些页面的信息。slab字段在不同情况下用途也不同，prev除了作为链表指针，低位还用于表示页面类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面头，用于管理页面</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_slab_page_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span>         slab;         <span class="comment">// 对于空闲页面头节点，表示当前节点页块大小；空闲页面非头节点，为FREE；对于已分配页块，第一个页是pages | NGX_SLAB_PAGE_START，其余是NGX_SLAB_PAGE_BUSY；对于slab页面，小对象slab记录shift值，中对象slab用作bitmap，大对象slab高位用作bitmap，低位记录shift值</span></span><br><span class="line">    <span class="keyword">ngx_slab_page_t</span>  *next;         <span class="comment">// 不在链表中时，为NULL</span></span><br><span class="line">    <span class="keyword">uintptr_t</span>         prev;         <span class="comment">// 对于已经分配的页，低位还兼职表示页类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>ngx_slab_stat_t</code>用于统计slot的信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于统计slot信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>        total;  <span class="comment">// 总共有多少个对象</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>        used;   <span class="comment">// 目前使用了多少个</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>        reqs;   <span class="comment">// 请求该slot次数，累加计数器</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>        fails;  <span class="comment">// 请求失败的次数，累加计数器</span></span><br><span class="line">&#125; <span class="keyword">ngx_slab_stat_t</span>;</span><br></pre></td></tr></table></figure>



<h2 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h2><h3 id="首次启动"><a href="#首次启动" class="headerlink" title="首次启动"></a>首次启动</h3><p>共享初始化的主要函数调用关系如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ngx_shared_memory_add()		<span class="comment">// 初始化ngx_shm_zone_t，并放到全局链表cf-&gt;cycle-&gt;shared_memory中</span></span><br><span class="line">ngx_init_cycle()</span><br><span class="line">  ngx_shm_alloc(&amp;shm_zone[i].shm)      <span class="comment">// 分配内存</span></span><br><span class="line">  ngx_init_zone_pool(cycle, &amp;shm_zone[i])     <span class="comment">// slab初始化</span></span><br><span class="line">    ngx_slab_init()</span><br><span class="line">  shm_zone[i].init(&amp;shm_zone[i], oshm_zone[n].data) <span class="comment">// 各共享内存私有的初始化函数，例如ngx_ssl_session_cache_init，主要负责初始化ngx_ssl_session_cache_t</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在配置处理阶段，将shm_zone加到链表中</li>
<li>然后在init_cycle中分配共享内存，初始化shm_zone</li>
<li>ngx_slab_init()主要初始化ngx_slab_pool_t结构体</li>
<li>完成通用的初始化之后，进行各共享内存私有的初始化操作</li>
</ul>
<p>ngx_slab_init()是所有共享内存共同的初始化操作，主要是初始化ngx_slab_pool_t结构体中的各个字段。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_slab_init</span><span class="params">(<span class="keyword">ngx_slab_pool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u_char           *p;</span><br><span class="line">    <span class="keyword">size_t</span>            size;</span><br><span class="line">    <span class="keyword">ngx_int_t</span>         m;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>        i, n, pages;</span><br><span class="line">    <span class="keyword">ngx_slab_page_t</span>  *slots, *page;</span><br><span class="line"></span><br><span class="line">    pool-&gt;min_size = (<span class="keyword">size_t</span>) <span class="number">1</span> &lt;&lt; pool-&gt;min_shift;</span><br><span class="line"></span><br><span class="line">    slots = ngx_slab_slots(pool);</span><br><span class="line"></span><br><span class="line">    p = (u_char *) slots;</span><br><span class="line">    size = pool-&gt;end - p;</span><br><span class="line"></span><br><span class="line">    ngx_slab_junk(p, size);</span><br><span class="line"></span><br><span class="line">    n = ngx_pagesize_shift - pool-&gt;min_shift;  <span class="comment">// slot的种类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">/* only &quot;next&quot; is used in list head */</span></span><br><span class="line">        slots[i].slab = <span class="number">0</span>;</span><br><span class="line">        slots[i].next = &amp;slots[i];</span><br><span class="line">        slots[i].prev = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p += n * <span class="keyword">sizeof</span>(<span class="keyword">ngx_slab_page_t</span>);</span><br><span class="line"></span><br><span class="line">    pool-&gt;stats = (<span class="keyword">ngx_slab_stat_t</span> *) p;</span><br><span class="line">    ngx_memzero(pool-&gt;stats, n * <span class="keyword">sizeof</span>(<span class="keyword">ngx_slab_stat_t</span>));</span><br><span class="line"></span><br><span class="line">    p += n * <span class="keyword">sizeof</span>(<span class="keyword">ngx_slab_stat_t</span>);</span><br><span class="line"></span><br><span class="line">    size -= n * (<span class="keyword">sizeof</span>(<span class="keyword">ngx_slab_page_t</span>) + <span class="keyword">sizeof</span>(<span class="keyword">ngx_slab_stat_t</span>));</span><br><span class="line"></span><br><span class="line">    pages = (<span class="keyword">ngx_uint_t</span>) (size / (ngx_pagesize + <span class="keyword">sizeof</span>(<span class="keyword">ngx_slab_page_t</span>)));               <span class="comment">// 计算页数</span></span><br><span class="line"></span><br><span class="line">    pool-&gt;pages = (<span class="keyword">ngx_slab_page_t</span> *) p; <span class="comment">// 指向页面头数组</span></span><br><span class="line">    ngx_memzero(pool-&gt;pages, pages * <span class="keyword">sizeof</span>(<span class="keyword">ngx_slab_page_t</span>));</span><br><span class="line"></span><br><span class="line">    page = pool-&gt;pages;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* only &quot;next&quot; is used in list head */</span></span><br><span class="line">    pool-&gt;<span class="built_in">free</span>.slab = <span class="number">0</span>;</span><br><span class="line">    pool-&gt;<span class="built_in">free</span>.next = page;</span><br><span class="line">    pool-&gt;<span class="built_in">free</span>.prev = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始只有一个大的块</span></span><br><span class="line">    page-&gt;slab = pages;                  <span class="comment">// 页块的页数</span></span><br><span class="line">    page-&gt;next = &amp;pool-&gt;<span class="built_in">free</span>;            <span class="comment">// 指向空闲链表的哨兵</span></span><br><span class="line">    page-&gt;prev = (<span class="keyword">uintptr_t</span>) &amp;pool-&gt;<span class="built_in">free</span>;<span class="comment">// 指向空闲链表的哨兵</span></span><br><span class="line"></span><br><span class="line">    pool-&gt;start = ngx_align_ptr(p + pages * <span class="keyword">sizeof</span>(<span class="keyword">ngx_slab_page_t</span>),</span><br><span class="line">                                ngx_pagesize);  <span class="comment">// 实际数据页面开始位置</span></span><br><span class="line"></span><br><span class="line">    m = pages - (pool-&gt;end - pool-&gt;start) / ngx_pagesize;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        pages -= m;</span><br><span class="line">        page-&gt;slab = pages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool-&gt;last = pool-&gt;pages + pages;      <span class="comment">// 页面头数组的末尾</span></span><br><span class="line">    pool-&gt;pfree = pages;                   <span class="comment">// 总空闲页面数</span></span><br><span class="line"></span><br><span class="line">    pool-&gt;log_nomem = <span class="number">1</span>;</span><br><span class="line">    pool-&gt;log_ctx = &amp;pool-&gt;zero;</span><br><span class="line">    pool-&gt;zero = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来<code>shm_zone[i].init()</code>是各共享内存私有的初始化，一般会初始化私有数据，然后将指针赋值到<code>ngx_shm_zone_t</code>和<code>ngx_slab_pool_t</code>的私有数据<code>data</code>字段。</p>
<h3 id="reload"><a href="#reload" class="headerlink" title="reload"></a>reload</h3><p>reload的时候默认是重用之前的共享内存的，除非<code>ngx_shm_zone_s</code>中的<code>noreuse</code>置1了，但是这个字段目前是代码写死的，并没有作为配置开放。所以reload时一般只是执行如下函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ngx_shared_memory_add()</span><br><span class="line">shm_zone[i].init(&amp;shm_zone[i], oshm_zone[n].data)</span><br></pre></td></tr></table></figure>

<p>不过有一种情况下，reload也会重新生成共享内存，那就是大小改变了的时候。</p>
<h2 id="分配逻辑"><a href="#分配逻辑" class="headerlink" title="分配逻辑"></a>分配逻辑</h2><p>分配逻辑和释放逻辑是slab的核心，想完全理解需要仔细阅读接下来4个函数。</p>
<h3 id="分配页面"><a href="#分配页面" class="headerlink" title="分配页面"></a>分配页面</h3><p>页面分配逻辑比较简单，剩余的空闲页块是一个链表，<code>pool-&gt;free</code>是头节点，用作哨兵。遍历链表寻找足够大的空闲页块，如果页块正好等于请求的大小，那么将其从链表中移除，如果页块还有剩余，将剩余部分的第一个页面头插入链表中，如果剩余块大于1页，那么将最后一页的页面头的prev指向其第一个页面头的位置（合并页块时需要用到）。</p>
<p>对于分配的页块，第一个页面头记录页块头标志，并记录了页块大小，后面的页面头记录BUSY标志。prev的最后两位表示页类型，<code>NGX_SLAB_PAGE</code>表示是整页分配。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ngx_slab_page_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_slab_alloc_pages</span><span class="params">(<span class="keyword">ngx_slab_pool_t</span> *pool, <span class="keyword">ngx_uint_t</span> pages)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_slab_page_t</span>  *page, *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (page = pool-&gt;<span class="built_in">free</span>.next; page != &amp;pool-&gt;<span class="built_in">free</span>; page = page-&gt;next) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;slab &gt;= pages) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (page-&gt;slab &gt; pages) &#123;   <span class="comment">// 有剩余的情况</span></span><br><span class="line">                page[page-&gt;slab - <span class="number">1</span>].prev = (<span class="keyword">uintptr_t</span>) &amp;page[pages];  <span class="comment">// 这一步是合并时候用的，找到它的块头</span></span><br><span class="line">                <span class="comment">// 剩余部分仍然插入链表中</span></span><br><span class="line">                page[pages].slab = page-&gt;slab - pages;</span><br><span class="line">                page[pages].next = page-&gt;next;</span><br><span class="line">                page[pages].prev = page-&gt;prev;</span><br><span class="line"></span><br><span class="line">                p = (<span class="keyword">ngx_slab_page_t</span> *) page-&gt;prev;</span><br><span class="line">                p-&gt;next = &amp;page[pages];</span><br><span class="line">                page-&gt;next-&gt;prev = (<span class="keyword">uintptr_t</span>) &amp;page[pages];</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                     <span class="comment">// 正好的情况</span></span><br><span class="line">                p = (<span class="keyword">ngx_slab_page_t</span> *) page-&gt;prev;  <span class="comment">// 将节点从链表移除</span></span><br><span class="line">                p-&gt;next = page-&gt;next;</span><br><span class="line">                page-&gt;next-&gt;prev = page-&gt;prev;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第一个页记录页数</span></span><br><span class="line">            page-&gt;slab = pages | NGX_SLAB_PAGE_START;</span><br><span class="line">            page-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            page-&gt;prev = NGX_SLAB_PAGE;</span><br><span class="line"></span><br><span class="line">            pool-&gt;pfree -= pages;  <span class="comment">// 更新剩余空闲页数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (--pages == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> page;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 其余页设为BUSY</span></span><br><span class="line">            <span class="keyword">for</span> (p = page + <span class="number">1</span>; pages; pages--) &#123;</span><br><span class="line">                p-&gt;slab = NGX_SLAB_PAGE_BUSY;</span><br><span class="line">                p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                p-&gt;prev = NGX_SLAB_PAGE;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> page;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;log_nomem) &#123;</span><br><span class="line">        ngx_slab_error(pool, NGX_LOG_CRIT,</span><br><span class="line">                       <span class="string">&quot;ngx_slab_alloc() failed: no memory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分配对象"><a href="#分配对象" class="headerlink" title="分配对象"></a>分配对象</h3><p>小对象根据尺寸大小，分成了3类，即代码中的<code>NGX_SLAB_BIG</code>、<code>NGX_SLAB_EXACT</code>和<code>NGX_SLAB_SMALL</code>。之所以要分成三类，是为了节省管理的内存开销。其中exact的表示页面头中的slab字段正好可以用作一个页面的bitmap。small的就需要使用页面最前面的内存块来作为bitamp了，此时slab用于记录该页的shift值（即它属于哪个slot）。而对于big的，因为内存块数较少，slab字段高位用作bitmap，低位则记录shift值。</p>
<p>对于超大对象直接分配页，否则遍历对应的slot半满链表中获取一个空闲内存块，找到后将相应的bit位置位，如果链表为空则先分配一个新页，然后插入slot半满链表中。如果分配一个对象后页面满了，则将其从半满链表中移除。</p>
<p><code>ngx_slab_alloc_locked</code>是最核心的一个函数了，有兴趣的可以看看它是怎么操作bitmap和链表的。代码中基本都做了注释，这里就不再赘述了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_slab_alloc_locked</span><span class="params">(<span class="keyword">ngx_slab_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span>            s;</span><br><span class="line">    <span class="keyword">uintptr_t</span>         p, m, mask, *bitmap;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>        i, n, slot, shift, <span class="built_in">map</span>;</span><br><span class="line">    <span class="keyword">ngx_slab_page_t</span>  *page, *prev, *slots;</span><br><span class="line">    <span class="comment">// 超大对象直接分配页</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; ngx_slab_max_size) &#123;</span><br><span class="line"></span><br><span class="line">        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, ngx_cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                       <span class="string">&quot;slab alloc: %uz&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">        page = ngx_slab_alloc_pages(pool, (size &gt;&gt; ngx_pagesize_shift)</span><br><span class="line">                                          + ((size % ngx_pagesize) ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span> (page) &#123;</span><br><span class="line">            p = ngx_slab_page_addr(pool, page);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 小对象选择对应slot</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; pool-&gt;min_size) &#123;</span><br><span class="line">        shift = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (s = size - <span class="number">1</span>; s &gt;&gt;= <span class="number">1</span>; shift++) &#123; <span class="comment">/* void */</span> &#125;</span><br><span class="line">        slot = shift - pool-&gt;min_shift;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shift = pool-&gt;min_shift;</span><br><span class="line">        slot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对应slot请求+1</span></span><br><span class="line">    pool-&gt;stats[slot].reqs++;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, ngx_cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="string">&quot;slab alloc: %uz slot: %ui&quot;</span>, size, slot);</span><br><span class="line"></span><br><span class="line">    slots = ngx_slab_slots(pool);</span><br><span class="line">    page = slots[slot].next;   <span class="comment">// slot的链表</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (page-&gt;next != page) &#123;  <span class="comment">// 链表为空，跳到后面分配新的1页</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shift &lt; ngx_slab_exact_shift) &#123;  <span class="comment">// 需要使用页面开头部分空间作为bitmap</span></span><br><span class="line"></span><br><span class="line">            bitmap = (<span class="keyword">uintptr_t</span> *) ngx_slab_page_addr(pool, page); <span class="comment">// 页面开头是bitmap</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">map</span> = (ngx_pagesize &gt;&gt; shift) / (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>)); <span class="comment">// 几个uintptr_t大小的map</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="built_in">map</span>; n++) &#123;  <span class="comment">// 遍历寻找一个空闲的对象</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bitmap[n] != NGX_SLAB_BUSY) &#123;  <span class="comment">// 当前bitmap块没有全置位</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (m = <span class="number">1</span>, i = <span class="number">0</span>; m; m &lt;&lt;= <span class="number">1</span>, i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (bitmap[n] &amp; m) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 第n个map的第i位（从右往左数）</span></span><br><span class="line">                        bitmap[n] |= m;</span><br><span class="line">                        <span class="comment">// 总共第几位 * 对象大小 = 对象地址关于页地址的偏移</span></span><br><span class="line">                        i = (n * <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>) + i) &lt;&lt; shift;</span><br><span class="line"></span><br><span class="line">                        p = (<span class="keyword">uintptr_t</span>) bitmap + i; <span class="comment">// p为对象地址</span></span><br><span class="line"></span><br><span class="line">                        pool-&gt;stats[slot].used++;   <span class="comment">// 正在使用的+1</span></span><br><span class="line">                        <span class="comment">// 如果当前bitmap满了，检查后面的是否都满了</span></span><br><span class="line">                        <span class="keyword">if</span> (bitmap[n] == NGX_SLAB_BUSY) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (n = n + <span class="number">1</span>; n &lt; <span class="built_in">map</span>; n++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (bitmap[n] != NGX_SLAB_BUSY) &#123;</span><br><span class="line">                                    <span class="keyword">goto</span> done;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 如果整个页都用完了，将其从slot链表中移除</span></span><br><span class="line">                            prev = ngx_slab_page_prev(page);</span><br><span class="line">                            prev-&gt;next = page-&gt;next;</span><br><span class="line">                            page-&gt;next-&gt;prev = page-&gt;prev;</span><br><span class="line"></span><br><span class="line">                            page-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                            page-&gt;prev = NGX_SLAB_SMALL;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">goto</span> done;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shift == ngx_slab_exact_shift) &#123; <span class="comment">// 页面头中的slab正好作为bimap</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (m = <span class="number">1</span>, i = <span class="number">0</span>; m; m &lt;&lt;= <span class="number">1</span>, i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (page-&gt;slab &amp; m) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                page-&gt;slab |= m;  <span class="comment">// 置位</span></span><br><span class="line">                <span class="comment">// 该页如果满了，移出slot链表</span></span><br><span class="line">                <span class="keyword">if</span> (page-&gt;slab == NGX_SLAB_BUSY) &#123;</span><br><span class="line">                    prev = ngx_slab_page_prev(page);</span><br><span class="line">                    prev-&gt;next = page-&gt;next;</span><br><span class="line">                    page-&gt;next-&gt;prev = page-&gt;prev;</span><br><span class="line"></span><br><span class="line">                    page-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                    page-&gt;prev = NGX_SLAB_EXACT;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取对象地址</span></span><br><span class="line">                p = ngx_slab_page_addr(pool, page) + (i &lt;&lt; shift);</span><br><span class="line"></span><br><span class="line">                pool-&gt;stats[slot].used++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* shift &gt; ngx_slab_exact_shift */</span></span><br><span class="line">            <span class="comment">// 111...11，1页对象个数个1</span></span><br><span class="line">            mask = ((<span class="keyword">uintptr_t</span>) <span class="number">1</span> &lt;&lt; (ngx_pagesize &gt;&gt; shift)) - <span class="number">1</span>;</span><br><span class="line">            mask &lt;&lt;= NGX_SLAB_MAP_SHIFT;  <span class="comment">// 移到高位上，为啥? 因为低位还要记录shift。为啥需要记录shift，因为在释放对象的时候需要知道大小</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (m = (<span class="keyword">uintptr_t</span>) <span class="number">1</span> &lt;&lt; NGX_SLAB_MAP_SHIFT, i = <span class="number">0</span>;</span><br><span class="line">                 m &amp; mask;</span><br><span class="line">                 m &lt;&lt;= <span class="number">1</span>, i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (page-&gt;slab &amp; m) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                page-&gt;slab |= m;  <span class="comment">// 置位</span></span><br><span class="line">                <span class="comment">// 该页如果满了，移出slot链表</span></span><br><span class="line">                <span class="keyword">if</span> ((page-&gt;slab &amp; NGX_SLAB_MAP_MASK) == mask) &#123;</span><br><span class="line">                    prev = ngx_slab_page_prev(page);</span><br><span class="line">                    prev-&gt;next = page-&gt;next;</span><br><span class="line">                    page-&gt;next-&gt;prev = page-&gt;prev;</span><br><span class="line"></span><br><span class="line">                    page-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                    page-&gt;prev = NGX_SLAB_BIG;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                p = ngx_slab_page_addr(pool, page) + (i &lt;&lt; shift);</span><br><span class="line"></span><br><span class="line">                pool-&gt;stats[slot].used++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ngx_slab_error(pool, NGX_LOG_ALERT, <span class="string">&quot;ngx_slab_alloc(): page is busy&quot;</span>);</span><br><span class="line">        ngx_debug_point();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配新页</span></span><br><span class="line">    page = ngx_slab_alloc_pages(pool, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shift &lt; ngx_slab_exact_shift) &#123;</span><br><span class="line">            bitmap = (<span class="keyword">uintptr_t</span> *) ngx_slab_page_addr(pool, page);</span><br><span class="line">            <span class="comment">// 计算需要开头几个对象作为bitmap: n = 1页对象个数 / 1个对象位数</span></span><br><span class="line">            n = (ngx_pagesize &gt;&gt; shift) / ((<span class="number">1</span> &lt;&lt; shift) * <span class="number">8</span>);</span><br><span class="line">            <span class="comment">// 不满1个对象，使用1对象</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                n = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 接下来初始化bitmap，将bitmap本身占用的对象置1，将申请的目标对象置1</span></span><br><span class="line">            <span class="comment">/* &quot;n&quot; elements for bitmap, plus one requested */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (n + <span class="number">1</span>) / (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>)); i++) &#123;</span><br><span class="line">                bitmap[i] = NGX_SLAB_BUSY;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不满一个bitmap的部分置1</span></span><br><span class="line">            m = ((<span class="keyword">uintptr_t</span>) <span class="number">1</span> &lt;&lt; ((n + <span class="number">1</span>) % (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>)))) - <span class="number">1</span>;</span><br><span class="line">            bitmap[i] = m;</span><br><span class="line">            <span class="comment">// 剩余bitmap置0</span></span><br><span class="line">            <span class="built_in">map</span> = (ngx_pagesize &gt;&gt; shift) / (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = i + <span class="number">1</span>; i &lt; <span class="built_in">map</span>; i++) &#123;</span><br><span class="line">                bitmap[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            page-&gt;slab = shift;  <span class="comment">// slab记录shift</span></span><br><span class="line">            page-&gt;next = &amp;slots[slot]; <span class="comment">// 插入slot链表头</span></span><br><span class="line">            page-&gt;prev = (<span class="keyword">uintptr_t</span>) &amp;slots[slot] | NGX_SLAB_SMALL;</span><br><span class="line"></span><br><span class="line">            slots[slot].next = page;</span><br><span class="line">            <span class="comment">// 增加该slot总对象数（不包括bitmap本身占用的对象）</span></span><br><span class="line">            pool-&gt;stats[slot].total += (ngx_pagesize &gt;&gt; shift) - n;</span><br><span class="line"></span><br><span class="line">            p = ngx_slab_page_addr(pool, page) + (n &lt;&lt; shift);</span><br><span class="line"></span><br><span class="line">            pool-&gt;stats[slot].used++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shift == ngx_slab_exact_shift) &#123;</span><br><span class="line"></span><br><span class="line">            page-&gt;slab = <span class="number">1</span>;  <span class="comment">// 申请的对象置位</span></span><br><span class="line">            <span class="comment">// 插入slot链表头</span></span><br><span class="line">            page-&gt;next = &amp;slots[slot];</span><br><span class="line">            page-&gt;prev = (<span class="keyword">uintptr_t</span>) &amp;slots[slot] | NGX_SLAB_EXACT;</span><br><span class="line"></span><br><span class="line">            slots[slot].next = page;</span><br><span class="line">            <span class="comment">// 增加该slot总对象数</span></span><br><span class="line">            pool-&gt;stats[slot].total += <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>);</span><br><span class="line"></span><br><span class="line">            p = ngx_slab_page_addr(pool, page);</span><br><span class="line"></span><br><span class="line">            pool-&gt;stats[slot].used++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* shift &gt; ngx_slab_exact_shift */</span></span><br><span class="line">            <span class="comment">// 高位申请的对象置位 + 低位记录shift</span></span><br><span class="line">            page-&gt;slab = ((<span class="keyword">uintptr_t</span>) <span class="number">1</span> &lt;&lt; NGX_SLAB_MAP_SHIFT) | shift;</span><br><span class="line">            page-&gt;next = &amp;slots[slot];</span><br><span class="line">            page-&gt;prev = (<span class="keyword">uintptr_t</span>) &amp;slots[slot] | NGX_SLAB_BIG;</span><br><span class="line"></span><br><span class="line">            slots[slot].next = page;</span><br><span class="line"></span><br><span class="line">            pool-&gt;stats[slot].total += ngx_pagesize &gt;&gt; shift;</span><br><span class="line"></span><br><span class="line">            p = ngx_slab_page_addr(pool, page);</span><br><span class="line"></span><br><span class="line">            pool-&gt;stats[slot].used++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pool-&gt;stats[slot].fails++;  <span class="comment">// 分配对象失败次数</span></span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line"></span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, ngx_cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="string">&quot;slab alloc: %p&quot;</span>, (<span class="keyword">void</span> *) p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *) p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="释放逻辑"><a href="#释放逻辑" class="headerlink" title="释放逻辑"></a>释放逻辑</h2><h3 id="释放页面"><a href="#释放页面" class="headerlink" title="释放页面"></a>释放页面</h3><p>如果是释放多个页面，将后面的页面头都清零。如果是slot页，将其从slot链表中移除。然后尝试合并前后的页面，从而组成更大的连续页。合并完成后，插入到空闲页块链表中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_slab_free_pages</span><span class="params">(<span class="keyword">ngx_slab_pool_t</span> *pool, <span class="keyword">ngx_slab_page_t</span> *page,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">ngx_uint_t</span> pages)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_slab_page_t</span>  *prev, *join;</span><br><span class="line"></span><br><span class="line">    pool-&gt;pfree += pages;</span><br><span class="line"></span><br><span class="line">    page-&gt;slab = pages--;</span><br><span class="line">    <span class="comment">// 第二页开始的页面头都清零</span></span><br><span class="line">    <span class="keyword">if</span> (pages) &#123;</span><br><span class="line">        ngx_memzero(&amp;page[<span class="number">1</span>], pages * <span class="keyword">sizeof</span>(<span class="keyword">ngx_slab_page_t</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// next不都等于NULL么? 不等于NULL表示是slot页，将其从slot链表中移除 </span></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;next) &#123;</span><br><span class="line">        prev = ngx_slab_page_prev(page);</span><br><span class="line">        prev-&gt;next = page-&gt;next;</span><br><span class="line">        page-&gt;next-&gt;prev = page-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试合并后面的页面</span></span><br><span class="line">    join = page + page-&gt;slab;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (join &lt; pool-&gt;last) &#123;  <span class="comment">// 检查后面是否还有页</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ngx_slab_page_type(join) == NGX_SLAB_PAGE) &#123;  <span class="comment">// 是整页</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (join-&gt;next != <span class="literal">NULL</span>) &#123;            <span class="comment">// 在空闲页链表中</span></span><br><span class="line">                pages += join-&gt;slab;             <span class="comment">// 加上合并块的页数</span></span><br><span class="line">                page-&gt;slab += join-&gt;slab;        <span class="comment">// 增加页块大小</span></span><br><span class="line">                <span class="comment">// 将join块从空闲链表中移除</span></span><br><span class="line">                prev = ngx_slab_page_prev(join);</span><br><span class="line">                prev-&gt;next = join-&gt;next;</span><br><span class="line">                join-&gt;next-&gt;prev = join-&gt;prev;</span><br><span class="line">                <span class="comment">// 清理页块头，恢复指针和标志</span></span><br><span class="line">                join-&gt;slab = NGX_SLAB_PAGE_FREE;</span><br><span class="line">                join-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                join-&gt;prev = NGX_SLAB_PAGE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试合并前面的页</span></span><br><span class="line">    <span class="keyword">if</span> (page &gt; pool-&gt;pages) &#123;  <span class="comment">// 前面还有页</span></span><br><span class="line">        join = page - <span class="number">1</span>;       <span class="comment">// join指向被释放页的前一页</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ngx_slab_page_type(join) == NGX_SLAB_PAGE) &#123;  <span class="comment">// 是整页</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (join-&gt;slab == NGX_SLAB_PAGE_FREE) &#123;  <span class="comment">// 不是页块头</span></span><br><span class="line">                join = ngx_slab_page_prev(join);     <span class="comment">// join指向页块头</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (join-&gt;next != <span class="literal">NULL</span>) &#123;            <span class="comment">// 在空闲链表中</span></span><br><span class="line">                pages += join-&gt;slab;             <span class="comment">// 加上合并块的页数</span></span><br><span class="line">                join-&gt;slab += page-&gt;slab;        <span class="comment">// 增加页块大小</span></span><br><span class="line">                <span class="comment">// 将join块从空闲链表中移除</span></span><br><span class="line">                prev = ngx_slab_page_prev(join);</span><br><span class="line">                prev-&gt;next = join-&gt;next;</span><br><span class="line">                join-&gt;next-&gt;prev = join-&gt;prev;</span><br><span class="line">                <span class="comment">// 清理页块头，恢复指针和标志</span></span><br><span class="line">                page-&gt;slab = NGX_SLAB_PAGE_FREE;</span><br><span class="line">                page-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                page-&gt;prev = NGX_SLAB_PAGE;</span><br><span class="line"></span><br><span class="line">                page = join;     <span class="comment">// 更新页块头</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果页块大于1页，将最后一页的prev指向页块头，合并时用</span></span><br><span class="line">    <span class="keyword">if</span> (pages) &#123;</span><br><span class="line">        page[pages].prev = (<span class="keyword">uintptr_t</span>) page;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将页块插入空闲页链表头</span></span><br><span class="line">    page-&gt;prev = (<span class="keyword">uintptr_t</span>) &amp;pool-&gt;<span class="built_in">free</span>;</span><br><span class="line">    page-&gt;next = pool-&gt;<span class="built_in">free</span>.next;</span><br><span class="line"></span><br><span class="line">    page-&gt;next-&gt;prev = (<span class="keyword">uintptr_t</span>) page;</span><br><span class="line"></span><br><span class="line">    pool-&gt;<span class="built_in">free</span>.next = page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放对象"><a href="#释放对象" class="headerlink" title="释放对象"></a>释放对象</h3><p>首先根据对象指针获取到对应的页面头以及相应的页面信息，然后根据页面类型做不同的处理。对于slot对象，将对应的bit位复位。如果释放该对象前页面是满的，则将该页面重新插入slot半满链表。如果释放该对象后页面空了，则释放该页。</p>
<p>如果你已经了解了分配逻辑，那么释放逻辑应该很好理解。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_slab_free_locked</span><span class="params">(<span class="keyword">ngx_slab_pool_t</span> *pool, <span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span>            size;</span><br><span class="line">    <span class="keyword">uintptr_t</span>         slab, m, *bitmap;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>        i, n, type, slot, shift, <span class="built_in">map</span>;</span><br><span class="line">    <span class="keyword">ngx_slab_page_t</span>  *slots, *page;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, ngx_cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;slab free: %p&quot;</span>, p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((u_char *) p &lt; pool-&gt;start || (u_char *) p &gt; pool-&gt;end) &#123;</span><br><span class="line">        ngx_slab_error(pool, NGX_LOG_ALERT, <span class="string">&quot;ngx_slab_free(): outside of pool&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算释放的指针在第几页</span></span><br><span class="line">    n = ((u_char *) p - pool-&gt;start) &gt;&gt; ngx_pagesize_shift;</span><br><span class="line">    page = &amp;pool-&gt;pages[n];  <span class="comment">// 获取对应页面头</span></span><br><span class="line">    slab = page-&gt;slab;</span><br><span class="line">    type = ngx_slab_page_type(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NGX_SLAB_SMALL:</span><br><span class="line"></span><br><span class="line">        shift = slab &amp; NGX_SLAB_SHIFT_MASK;</span><br><span class="line">        size = (<span class="keyword">size_t</span>) <span class="number">1</span> &lt;&lt; shift;</span><br><span class="line">        <span class="comment">// 检查指针是否对象对齐</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>) p &amp; (size - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> wrong_chunk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第几个对象: n = 页中的偏移 / 对象大小</span></span><br><span class="line">        n = ((<span class="keyword">uintptr_t</span>) p &amp; (ngx_pagesize - <span class="number">1</span>)) &gt;&gt; shift;</span><br><span class="line">        m = (<span class="keyword">uintptr_t</span>) <span class="number">1</span> &lt;&lt; (n % (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>)));</span><br><span class="line">        n /= <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>);</span><br><span class="line">        bitmap = (<span class="keyword">uintptr_t</span> *)</span><br><span class="line">                             ((<span class="keyword">uintptr_t</span>) p &amp; ~((<span class="keyword">uintptr_t</span>) ngx_pagesize - <span class="number">1</span>));  <span class="comment">// 页起始地址，获取bitmap</span></span><br><span class="line">      <span class="comment">// 第n个bitmap的m位</span></span><br><span class="line">        <span class="keyword">if</span> (bitmap[n] &amp; m) &#123;</span><br><span class="line">            slot = shift - pool-&gt;min_shift;</span><br><span class="line">            <span class="comment">// 如果当前页不在slot链表中（即释放前是满的），重新加回链表</span></span><br><span class="line">            <span class="keyword">if</span> (page-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                slots = ngx_slab_slots(pool);</span><br><span class="line"></span><br><span class="line">                page-&gt;next = slots[slot].next;</span><br><span class="line">                slots[slot].next = page;</span><br><span class="line"></span><br><span class="line">                page-&gt;prev = (<span class="keyword">uintptr_t</span>) &amp;slots[slot] | NGX_SLAB_SMALL;</span><br><span class="line">                page-&gt;next-&gt;prev = (<span class="keyword">uintptr_t</span>) page | NGX_SLAB_SMALL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清bit位</span></span><br><span class="line">            bitmap[n] &amp;= ~m;</span><br><span class="line">            <span class="comment">// 计算需要开头几个对象作为bitmap: n = 1页对象个数 / 1个对象位数</span></span><br><span class="line">            n = (ngx_pagesize &gt;&gt; shift) / ((<span class="number">1</span> &lt;&lt; shift) * <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                n = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 接下来检查除了bitmap本身占用的对象外，是否还有其他对象</span></span><br><span class="line">            <span class="comment">// 已经被bitmap占满的uintptr_t不用检查，对于bitmap对象和实际数据对象混用的uintptr_t需要unmask掉bitmap的部分</span></span><br><span class="line">            i = n / (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>));</span><br><span class="line">            m = ((<span class="keyword">uintptr_t</span>) <span class="number">1</span> &lt;&lt; (n % (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>)))) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bitmap[i] &amp; ~m) &#123;</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// map = 多少个uintptr_t大小的map</span></span><br><span class="line">            <span class="built_in">map</span> = (ngx_pagesize &gt;&gt; shift) / (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = i + <span class="number">1</span>; i &lt; <span class="built_in">map</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bitmap[i]) &#123;</span><br><span class="line">                    <span class="keyword">goto</span> done;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果空了，就释放该页</span></span><br><span class="line">            ngx_slab_free_pages(pool, page, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 减去slot的对象个数</span></span><br><span class="line">            pool-&gt;stats[slot].total -= (ngx_pagesize &gt;&gt; shift) - n;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> chunk_already_free;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NGX_SLAB_EXACT:</span><br><span class="line"></span><br><span class="line">        m = (<span class="keyword">uintptr_t</span>) <span class="number">1</span> &lt;&lt;</span><br><span class="line">                (((<span class="keyword">uintptr_t</span>) p &amp; (ngx_pagesize - <span class="number">1</span>)) &gt;&gt; ngx_slab_exact_shift);  <span class="comment">// 目标对象对应的位</span></span><br><span class="line">        size = ngx_slab_exact_size;</span><br><span class="line">        <span class="comment">// 检查对齐</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>) p &amp; (size - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> wrong_chunk;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slab &amp; m) &#123;</span><br><span class="line">            slot = ngx_slab_exact_shift - pool-&gt;min_shift;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slab == NGX_SLAB_BUSY) &#123;  <span class="comment">// bitmap是满的，重新加入链表</span></span><br><span class="line">                slots = ngx_slab_slots(pool);</span><br><span class="line"></span><br><span class="line">                page-&gt;next = slots[slot].next;</span><br><span class="line">                slots[slot].next = page;</span><br><span class="line"></span><br><span class="line">                page-&gt;prev = (<span class="keyword">uintptr_t</span>) &amp;slots[slot] | NGX_SLAB_EXACT;</span><br><span class="line">                page-&gt;next-&gt;prev = (<span class="keyword">uintptr_t</span>) page | NGX_SLAB_EXACT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            page-&gt;slab &amp;= ~m;  <span class="comment">// 清bit位</span></span><br><span class="line">            <span class="comment">// 如果空了，就释放该页</span></span><br><span class="line">            <span class="keyword">if</span> (page-&gt;slab) &#123;</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ngx_slab_free_pages(pool, page, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            pool-&gt;stats[slot].total -= <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> chunk_already_free;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NGX_SLAB_BIG:</span><br><span class="line"></span><br><span class="line">        shift = slab &amp; NGX_SLAB_SHIFT_MASK;</span><br><span class="line">        size = (<span class="keyword">size_t</span>) <span class="number">1</span> &lt;&lt; shift;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>) p &amp; (size - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> wrong_chunk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标对象对应的位</span></span><br><span class="line">        m = (<span class="keyword">uintptr_t</span>) <span class="number">1</span> &lt;&lt; ((((<span class="keyword">uintptr_t</span>) p &amp; (ngx_pagesize - <span class="number">1</span>)) &gt;&gt; shift)</span><br><span class="line">                              + NGX_SLAB_MAP_SHIFT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slab &amp; m) &#123;</span><br><span class="line">            slot = shift - pool-&gt;min_shift;</span><br><span class="line">            <span class="comment">// 如果当前页不在slot链表中（即释放前是满的），重新加回链表</span></span><br><span class="line">            <span class="keyword">if</span> (page-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                slots = ngx_slab_slots(pool);</span><br><span class="line"></span><br><span class="line">                page-&gt;next = slots[slot].next;</span><br><span class="line">                slots[slot].next = page;</span><br><span class="line"></span><br><span class="line">                page-&gt;prev = (<span class="keyword">uintptr_t</span>) &amp;slots[slot] | NGX_SLAB_BIG;</span><br><span class="line">                page-&gt;next-&gt;prev = (<span class="keyword">uintptr_t</span>) page | NGX_SLAB_BIG;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            page-&gt;slab &amp;= ~m;</span><br><span class="line">            <span class="comment">// 如果空了，就释放该页</span></span><br><span class="line">            <span class="keyword">if</span> (page-&gt;slab &amp; NGX_SLAB_MAP_MASK) &#123;</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ngx_slab_free_pages(pool, page, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            pool-&gt;stats[slot].total -= ngx_pagesize &gt;&gt; shift;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> chunk_already_free;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NGX_SLAB_PAGE:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>) p &amp; (ngx_pagesize - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> wrong_chunk;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(slab &amp; NGX_SLAB_PAGE_START)) &#123;</span><br><span class="line">            ngx_slab_error(pool, NGX_LOG_ALERT,</span><br><span class="line">                           <span class="string">&quot;ngx_slab_free(): page is already free&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slab == NGX_SLAB_PAGE_BUSY) &#123;</span><br><span class="line">            ngx_slab_error(pool, NGX_LOG_ALERT,</span><br><span class="line">                           <span class="string">&quot;ngx_slab_free(): pointer to wrong page&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size = slab &amp; ~NGX_SLAB_PAGE_START;</span><br><span class="line"></span><br><span class="line">        ngx_slab_free_pages(pool, page, size);</span><br><span class="line"></span><br><span class="line">        ngx_slab_junk(p, size &lt;&lt; ngx_pagesize_shift);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* not reached */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line"></span><br><span class="line">    pool-&gt;stats[slot].used--;  <span class="comment">// 对象使用数减1</span></span><br><span class="line"></span><br><span class="line">    ngx_slab_junk(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">wrong_chunk:</span><br><span class="line"></span><br><span class="line">    ngx_slab_error(pool, NGX_LOG_ALERT,</span><br><span class="line">                   <span class="string">&quot;ngx_slab_free(): pointer to wrong chunk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">chunk_already_free:</span><br><span class="line"></span><br><span class="line">    ngx_slab_error(pool, NGX_LOG_ALERT,</span><br><span class="line">                   <span class="string">&quot;ngx_slab_free(): chunk is already free&quot;</span>);</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="共享内存销毁"><a href="#共享内存销毁" class="headerlink" title="共享内存销毁"></a>共享内存销毁</h2><p>前面讲了初始化、分配逻辑、释放逻辑，为了不失完整性，这里再讲下销毁逻辑。</p>
<p>搜索了整个代码并没有发现释放共享内存的地方，只有在cycle_init()失败时会munmap()释放新创建的共享内存、或者reload的时候释放掉被替换的共享内存。</p>
<p>所以猜测是在进程退出的时候自动进行了释放。那么如何进行验证呢？我们编写一个简单的测试程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *addr = (<span class="keyword">char</span> *)<span class="number">0x7f1000000000</span>;</span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="number">8192</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = mmap(addr, size, PROT_READ|PROT_WRITE,</span><br><span class="line">                   MAP_SHARED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr p = %p, size = %zu\n&quot;</span>, p, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了测试方便，参数里指定了一个建议的地址。运行程序输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">addr p = 0x7f1000000000, size = 8192</span><br></pre></td></tr></table></figure>

<p>然后，我们编写一个systemtap脚本，打印参数信息和调用栈信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">probe kernel.function(<span class="string">&quot;unmap_page_range&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ($addr != <span class="number">0x7f1000000000</span>)</span><br><span class="line">        next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr: 0x%lx, size: %lu\n&quot;</span>, $addr, $end-$addr);</span><br><span class="line">    print_backtrace();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们运行stap脚本，然后执行<code>./a.out</code>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--------</span><br><span class="line">addr: 0x7f1000000000, size: 8192</span><br><span class="line"> 0xffffffff8bc168e0 : unmap_page_range+0x0/0xd00 [kernel]</span><br><span class="line"> 0xffffffff8bc1765d : unmap_single_vma+0x7d/0xf0 [kernel]</span><br><span class="line"> 0xffffffff8bc179a1 : unmap_vmas+0x51/0xb0 [kernel]</span><br><span class="line"> 0xffffffff8bc21535 : exit_mmap+0xb5/0x1d0 [kernel]</span><br><span class="line"> 0xffffffff8ba8b5e7 : mmput+0x57/0x140 [kernel]</span><br><span class="line"> 0xffffffff8ba93b22 : do_exit+0x352/0xb90 [kernel]</span><br><span class="line"> 0xffffffff8ba943e3 : do_group_exit+0x43/0xb0 [kernel]</span><br><span class="line"> 0xffffffff8ba94464 : SyS_exit_group+0x14/0x20 [kernel]</span><br><span class="line"> 0xffffffff8ba03a43 : do_syscall_64+0x73/0x130 [kernel]</span><br><span class="line"> 0xffffffff8c400085 : entry_SYSCALL_64_after_hwframe+0x41/0xa6 [kernel]</span><br><span class="line"> 0xffffffff8c400085 : entry_SYSCALL_64_after_hwframe+0x41/0xa6 [kernel]</span><br><span class="line">--------</span><br></pre></td></tr></table></figure>

<p>可以看到在进程退出的时候，自动unmap了我们用mmap分配的内存。</p>
<h2 id="统计与监控"><a href="#统计与监控" class="headerlink" title="统计与监控"></a>统计与监控</h2><p><a href="https://github.com/hongxiaolong/ngx_slab_stat">ngx_slab_stat模块</a>可以用于查看slab的统计信息，它的效果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">^_^$ curl http://127.0.0.1:50090/slab</span><br><span class="line">* shared memory: SSL</span><br><span class="line">total:          64(KB) free:          20(KB) size:           4(KB)</span><br><span class="line">pages:          20(KB) start:00007FA1F9D8C000 end:00007FA1F9D9B000</span><br><span class="line">slot:           8(Bytes) total:         504 used:           1 reqs:           1 fails:           0</span><br><span class="line">slot:          16(Bytes) total:         254 used:           1 reqs:           1 fails:           0</span><br><span class="line">slot:          32(Bytes) total:         127 used:           1 reqs:           1 fails:           0</span><br><span class="line">slot:          64(Bytes) total:          64 used:           2 reqs:           2 fails:           0</span><br><span class="line">slot:         128(Bytes) total:          32 used:          12 reqs:          15 fails:           0</span><br><span class="line">slot:         256(Bytes) total:          16 used:           2 reqs:           2 fails:           0</span><br><span class="line">slot:         512(Bytes) total:           8 used:           1 reqs:           1 fails:           0</span><br><span class="line">slot:        1024(Bytes) total:           4 used:           1 reqs:           1 fails:           0</span><br><span class="line">slot:        2048(Bytes) total:           2 used:           2 reqs:           5 fails:           0</span><br></pre></td></tr></table></figure>

<p>主要就是读取<code>ngx_slab_stat_t</code>结构体中的那些统计信息。当然它需要编译时加入该模块，然后加入相应配置项，访问接口才能获取。如果这些不可接受的话，也可以使用systemtap非侵入式地实现类似功能。</p>
<h2 id="ssl-session-cache"><a href="#ssl-session-cache" class="headerlink" title="ssl session cache"></a>ssl session cache</h2><p>最后提一下ssl session cache，它是一个实际使用共享内存的例子，也是我为什么会写这篇博客的原因。<code>ngx_ssl_session_cache_init</code>是其私有的初始化函数，主要是初始化<code>ngx_ssl_session_cache_t</code>结构，包括红黑树和队列的初始化。红黑树用于session cache的查找，队列用于过期淘汰。然后将指针赋值到<code>ngx_shm_zone_t</code>和<code>ngx_slab_pool_t</code>的私有数据<code>data</code>字段。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ngx_int_t</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_ssl_session_cache_init</span><span class="params">(<span class="keyword">ngx_shm_zone_t</span> *shm_zone, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span>                    len;</span><br><span class="line">    <span class="keyword">ngx_slab_pool_t</span>          *shpool;</span><br><span class="line">    <span class="keyword">ngx_ssl_session_cache_t</span>  *cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        shm_zone-&gt;data = data;</span><br><span class="line">        <span class="keyword">return</span> NGX_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shpool = (<span class="keyword">ngx_slab_pool_t</span> *) shm_zone-&gt;shm.addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shm_zone-&gt;shm.exists) &#123;</span><br><span class="line">        shm_zone-&gt;data = shpool-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> NGX_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cache = ngx_slab_alloc(shpool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_ssl_session_cache_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shpool-&gt;data = cache;</span><br><span class="line">    shm_zone-&gt;data = cache;</span><br><span class="line"></span><br><span class="line">    ngx_rbtree_init(&amp;cache-&gt;session_rbtree, &amp;cache-&gt;sentinel,</span><br><span class="line">                    ngx_ssl_session_rbtree_insert_value);</span><br><span class="line"></span><br><span class="line">    ngx_queue_init(&amp;cache-&gt;expire_queue);</span><br><span class="line"></span><br><span class="line">    len = <span class="keyword">sizeof</span>(<span class="string">&quot; in SSL session shared cache \&quot;\&quot;&quot;</span>) + shm_zone-&gt;shm.name.len;</span><br><span class="line"></span><br><span class="line">    shpool-&gt;log_ctx = ngx_slab_alloc(shpool, len);</span><br><span class="line">    <span class="keyword">if</span> (shpool-&gt;log_ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_sprintf(shpool-&gt;log_ctx, <span class="string">&quot; in SSL session shared cache \&quot;%V\&quot;%Z&quot;</span>,</span><br><span class="line">                &amp;shm_zone-&gt;shm.name);</span><br><span class="line"></span><br><span class="line">    shpool-&gt;log_nomem = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>ngx_ssl_new_session()</code>用于创建新session cache，每次创建都会先尝试淘汰最多2个过期session，这样既保证了cache不会堆积、又是惰性淘汰不会让事件占用太长时间。每次申请失败，都有一次强制淘汰的机会。因为底层的slab机制，所以不管淘汰几个过期的session都是无法保证新session一定申请成功的。除非淘汰的对象跟新分配的属于同一个slot，或者淘汰了对象之后正好空出了一个页。</p>
<p>因为ssl session cache本来就是属于一种优化，所以优化失败也是正常的。如果比较在意这个，那么当出现强制淘汰时就已经说明共享内存空间不够了，需要相应地增加缓存容量或者减小超时时间。缓存容量和超时时间应满足下面的关系：</p>
<p><code>缓存容量 &gt; ∑ [( TPS / 超时时间 ) * 单个大小]</code></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Nginx/OpenResty</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>slab</tag>
        <tag>共享内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Openresty Lua协程调度机制</title>
    <url>/posts/150430f0/</url>
    <content><![CDATA[<div class="note primary">
            <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>OpenResty（后面简称：OR）是一个基于Nginx和Lua的高性能Web平台，它内部集成大量的Lua API以及第三方模块，可以利用它快速搭建支持高并发、极具动态性和扩展性的Web应用、Web服务或动态网关。</p><p>OR最大的特点就是，将Lua协程与Nginx事件驱动模型及非阻塞I/O结合起来。使用户可以在handler中使用 <strong>同步但是依然是非阻塞</strong> 的方式编写其应用代码，而无需关心底层的协程调度以及与Nginx事件驱动模型的交互。</p><p>本文将先从总体上介绍OR的协程调度机制，然后结合源码以及Lua栈的情况来详细了解各个部分是如何实现的，包括其异常保护、协程初始化、协程的恢复和执行、协程的挂起、协程的执行结束、协程出错的情况。</p><p>本文主要关注调度函数内部的逻辑，如果想了解外部的调用流程。可以参看<a href="../30b81f82/">Openresty Lua钩子调用完整流程</a></p>
          </div>

<span id="more"></span>

<div class="note default">
            <p>注：<code>lua-nginx</code>模块与<code>stream-lua-nginx</code>模块的主体部分类似，后者实现相对简单一点。下面的讨论将基于<code>stream-lua</code>模块。</p><p>为了防止歧义，文中用到的一些术语明确一下：</p><ul><li><code>主线程</code>：表示外层调用<code>run_thread()</code>的OS线程</li><li><code>入口线程</code>：每个handler被调用时会创建一个入口线程，用于执行lua代码</li><li><code>用户线程</code>：用户在Lua代码中通过<code>ngx.thread.spawn()</code>创建的线程</li><li><code>用户协程</code>：用户在Lua代码中通过<code>coroutine.create()</code>创建的协程</li><li><code>协程</code>：泛指所有协程，包括入口线程、用户线程和用户协程</li><li><code>vm</code>：表示Lua虚拟机</li><li><code>L</code>：视出现的上下文，一般表示父协程，在创建入口线程的时候表示Lua VM</li><li><code>co</code>：一般表示新创建的协程</li><li><code>L栈： |协程表|新协程|顶|</code>：表示Lua栈结构，最右边是栈顶</li></ul>
          </div>

<h1 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h1><p>在深入了解协程调度机制之前，我们先来认识一下主要的数据结构：</p>
<ul>
<li>协程上下文：<code>ngx_stream_lua_co_ctx_t</code><ul>
<li>协程内部栈（<code>coctx-&gt;co</code>）</li>
<li>协程状态（<code>coctx-&gt;co_status</code>）</li>
<li>维护协程之间关系的数据（父协程<code>coctx-&gt;parent_co_ctx</code>、僵尸子线程<code>coctx-&gt;zombie_child_threads</code>）</li>
<li>用户相关数据（<code>coctx-&gt;data</code>）</li>
<li>在Lua的registry表中对应该线程指针的引用值（<code>co_ref</code>）</li>
<li>一些状态标记（是否是用户线程<code>is_uthread</code>、是否因创建新线程<code>thread_spawn_yielded</code>被yield)</li>
</ul>
</li>
<li>模块上下文：<code>ngx_stream_lua_ctx_t</code><ul>
<li><code>ctx-&gt;cur_co_ctx</code>（当前调度协程上下文）</li>
<li><code>ctx-&gt;co_op</code>（协程是以何种方式YIELD）</li>
</ul>
</li>
<li>核心调度函数：<code>ngx_stream_lua_run_thread()</code></li>
</ul>
<h1 id="协程调度"><a href="#协程调度" class="headerlink" title="协程调度"></a>协程调度</h1><p>首先你可能很好奇OR为什么要在C引擎层面自己实现协程的调度？或者说这么做的好处是什么？我觉得最主要的原因还是减轻开发者的负担。</p>
<h2 id="原生Lua-coroutine接口"><a href="#原生Lua-coroutine接口" class="headerlink" title="原生Lua coroutine接口"></a>原生Lua coroutine接口</h2><p>我们知道Lua是个非常轻巧的语言，它不像Go有自己的调度器。Lua原生的对协程的操作无非就是<code>coroutine.resume()</code>和<code>coroutine.yield()</code>。这两者是成对出现的，协程<code>coroutine.yield()</code>之后肯定回到父协程<code>coroutine.resume()</code>的地方，恢复子协程需要显式再次<code>coroutine.resume()</code>。如果要在Lua代码层面实现非阻塞I/O，那么父协程必须处理子协程I/O等待的情况，并在事件发生时恢复子协程的执行。如果需要同时进行多个任务，那么父协程就需要负责多个协程间的调度。因为协程的拓扑可能是一个复杂的树状结构，所以协程的调度管理将变得异常复杂。</p>
<h2 id="OpenResty实现"><a href="#OpenResty实现" class="headerlink" title="OpenResty实现"></a>OpenResty实现</h2><p>OR在C引擎层帮我们把这些事情都做了，你无须再关心所有这些，只需专心写你的业务逻辑。为了支持同步非阻塞的方式编写应用代码，OR重写了<code>coroutine</code>的接口函数，从而接管了协程的调度，并在<code>coroutine</code>基础上封装抽象出了<code>thread</code>的概念。无论是<code>coroutine</code>还是<code>thread</code>，I/O等待对于用户都是透明的，用户无需关心。两者的主要区别是，<code>coroutine</code>父子之间的协作度更高，<code>coroutine.yield()</code>和<code>coroutine.resume()</code>成对出现。在子协程执行完成（出错）或者显式<code>coroutine.yield()</code>之前，父协程一直处于等待状态。而<code>thread</code>则由调度器进行调度，子<code>thread</code>一旦开始执行就不再受父协程控制了，在需要并发请求时很有用。<code>thread</code>提供了<code>spawn()</code>、<code>wait()</code>等接口，<code>spawn()</code>执行参数中指定的函数，直到执行完毕、出错或者I/O等待时返回。<code>wait()</code>则使父协程可以同步等待子线程执行完毕、获取结果。</p>
<div class="note primary">
            <p>OR在对协程调度上，最核心的改动是其创建新协程时的行为（<code>coroutine.resume()</code>, <code>ngx.thread.spawn()</code>）。它不会直接调用<code>lua_resume()</code>，而是先<code>lua_yield()</code>回到主线程，然后由主线程再根据情况<code>lua_resume()</code>下一个协程。Lua代码域内从来不会直接调用<code>lua_resume()</code>，理解了这一点你就理解了OpenResty协程调度的精髓。</p>
          </div>

<p>所以OR中协程拓扑是一个单层的结构，它只有<strong>一个入口点</strong>。这样使得协程调度更加灵活，I/O事件的触发时回调函数也更容易实现。</p>
<p>OR调度器根据<code>lua_resume()</code>的返回值，确定协程是挂起了、结束了还是出错了。因为OR改动了创建新协程时行为，同时又抽象了thread概念，所以如果是协程挂起的情况，还需要知道是什么原因挂起，以便做相应的不同处理。是继续调度？还是返回上层？我们前面提到的<code>ctx-&gt;co_op</code>便是做这个用途。</p>
<h2 id="协程调度逻辑"><a href="#协程调度逻辑" class="headerlink" title="协程调度逻辑"></a>协程调度逻辑</h2><p>协程的调度在核心调度函数<code>ngx_stream_lua_run_thread()</code>中进行，它是创建或恢复协程的唯一入口点。最初是由配置的Lua钩子调用（图中<code>ssl_cert_handler()</code>），如果碰到了I/O等待的情况，后续则由对应的事件handler（图中的<code>sleep_handler()</code>和<code>read_handler()</code>）再次拉起。<code>run_thread()</code>里面实现了一个调度循环，循环里面先从<code>ctx-&gt;cur_co_ctx</code>获取下一个待resume的协程上下文，然后<code>lua_resume()</code>执行或恢复该协程，其返回值<code>LUA_YIELD</code>表示协程挂起，<code>0</code>表示协程执行结束，其余的表示协程出错了。其中协程挂起又分为四种不同的情况：即等待I/O、新建thread、<code>coroutine.resume()</code>和<code>coroutine.yield()</code>。根据不同的情况，决定是跳到循环前面继续恢复下一个协程，还是返回上层函数。</p>
<p>下图是协程调度主要逻辑的示意图，可以看到在Lua代码域中无论是新建、挂起或恢复协程，都是先调用<code>lua_yield()</code>回到主线程。I/O操作例如<code>ngx.tcp.receive()</code>如果碰到了I/O等待，会在内部注册epoll事件（对于sleep的情况是定时器），然后自动<code>lua_yield()</code>，当事件触发时继续未完成的I/O操作，完成之后再调用<code>run_thread()</code>恢复之前被挂起的协程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/150430f0/openresty-lua-coroutine-schedule.svg" loading="lazy"></p>
<h1 id="异常保护"><a href="#异常保护" class="headerlink" title="异常保护"></a>异常保护</h1><p>作为一个调度器，OpenResty扮演者类似操作系统内核的角色，不过它的调度对象是Lua协程。作为一个“内核”，无论其调度对象出了什么问题，都不应该使这个系统崩溃，而是应该将错误信息打印出来。</p>
<p>Openresty内部就做了一个这样的异常保护，其原理就是用<code>setjmp</code>、<code>longjmp</code>包住了<code>run_thread()</code>里面的整个协程调度逻辑。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 首先注册虚拟机的panic回调 */</span></span><br><span class="line">lua_atpanic(L, ngx_stream_lua_atpanic);</span><br><span class="line"><span class="comment">/* setjmp保存环境 */</span></span><br><span class="line">NGX_LUA_EXCEPTION_TRY &#123;</span><br><span class="line">    <span class="comment">/* 执行调度逻辑 */</span></span><br><span class="line">&#125; NGX_LUA_EXCEPTION_CATCH &#123;</span><br><span class="line">    <span class="comment">/* 出现异常时走到这里 */</span></span><br><span class="line">    dd(<span class="string">&quot;nginx execution restored&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ngx_stream_lua_atpanic()</code>的实现也非常简单，只是简单地打印崩溃日志，然后调用<code>NGX_LUA_EXCEPTION_THROW(1);</code>恢复nginx的执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_stream_lua_atpanic</span><span class="params">(lua_State *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NGX_LUA_ABORT_AT_PANIC</span></span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    u_char                  *s = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span>                   len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lua_type(L, <span class="number">-1</span>) == LUA_TSTRING) &#123;</span><br><span class="line">        s = (u_char *) lua_tolstring(L, <span class="number">-1</span>, &amp;len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        s = (u_char *) <span class="string">&quot;unknown reason&quot;</span>;</span><br><span class="line">        len = <span class="keyword">sizeof</span>(<span class="string">&quot;unknown reason&quot;</span>) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_log_stderr(<span class="number">0</span>, <span class="string">&quot;lua atpanic: Lua VM crashed, reason: %*s&quot;</span>, len, s);</span><br><span class="line">    ngx_quit = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  restore nginx execution */</span></span><br><span class="line">    NGX_LUA_EXCEPTION_THROW(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* impossible to reach here */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这几个宏定义分别如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_LUA_EXCEPTION_TRY                                                \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (setjmp(ngx_stream_lua_exception) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_LUA_EXCEPTION_CATCH                                              \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_LUA_EXCEPTION_THROW(x)                                           \</span></span><br><span class="line"><span class="meta">    longjmp(ngx_stream_lua_exception, (x))</span></span><br></pre></td></tr></table></figure>



<h1 id="协程初始化"><a href="#协程初始化" class="headerlink" title="协程初始化"></a>协程初始化</h1><h2 id="钩子的入口线程"><a href="#钩子的入口线程" class="headerlink" title="钩子的入口线程"></a>钩子的入口线程</h2><p><code>ngx_stream_lua_new_thread()</code>用于创建入口线程</p>
<p>OR中需要在Registry表中存储每个创建出来的Lua线程的reference，这个存储协程的表在Registry表中对应的key是全局变量<code>ngx_stream_lua_coroutines_key</code>的地址，因此下面这段代码就是从Registry表中查询这个储存协程的表，返回到栈顶：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 返回栈顶元素的索引，等于栈中元素的个数 */</span></span><br><span class="line">base = lua_gettop(L);</span><br><span class="line"><span class="comment">/* 将存储协程的表对应的key压栈 */</span></span><br><span class="line">lua_pushlightuserdata(L, ngx_stream_lua_lightudata_mask(</span><br><span class="line">                      coroutines_key));</span><br><span class="line"><span class="comment">/* 将key出栈，获取Registry表中key对应的元素，然后将结果入栈 */</span></span><br><span class="line">lua_rawget(L, LUA_REGISTRYINDEX);</span><br></pre></td></tr></table></figure>

<p>接下来创建一个新的协程，同时初始化其全局表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建Lua协程，返回的新lua_State跟原有的lua_State共享所有的全局对象（如表），</span></span><br><span class="line"><span class="comment">   但是有一个独立的执行栈。 协程依赖垃圾回收销毁 */</span></span><br><span class="line"><span class="comment">/* L栈： |协程表|新协程|顶| */</span></span><br><span class="line">co = lua_newthread(L);  </span><br><span class="line"><span class="comment">/* 创建该协程的全局表，设置_G field为全局表自己 */</span></span><br><span class="line"><span class="comment">/* L栈： |协程表|新协程|协程新的全局表|顶| */</span></span><br><span class="line">ngx_stream_lua_create_new_globals_table(co, <span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line"><span class="comment">/* 再创建一个新表 */</span></span><br><span class="line"><span class="comment">/* L栈： |协程表|新协程|协程新的全局表|新表|顶| */</span></span><br><span class="line">lua_createtable(co, <span class="number">0</span>, <span class="number">1</span>);  </span><br><span class="line"><span class="comment">/* 拿到全局表 */</span></span><br><span class="line"><span class="comment">/* L栈： |协程表|新协程|协程新的全局表|新表|旧全局表|顶| */</span></span><br><span class="line">ngx_stream_lua_get_globals_table(co);   </span><br><span class="line"><span class="comment">/* 新表的__index的值为栈顶的值，也即就全局表 */</span></span><br><span class="line"><span class="comment">/* L栈： |协程表|新协程|协程新的全局表|新表|顶| */</span></span><br><span class="line">lua_setfield(co, <span class="number">-2</span>, <span class="string">&quot;__index&quot;</span>);    </span><br><span class="line"><span class="comment">/* 新表出栈，将其设为索引-2处即协程新的全局表的元表 */</span></span><br><span class="line"><span class="comment">/* L栈： |协程表|新协程|协程新的全局表|顶| */</span></span><br><span class="line">lua_setmetatable(co, <span class="number">-2</span>);</span><br><span class="line"><span class="comment">/* 设置协程新的全局表到对应索引，其_G field是自己，</span></span><br><span class="line"><span class="comment">   其元表是新表，新表的__index是父协程的全局表 */</span></span><br><span class="line"><span class="comment">/* L栈： |协程表|新协程|顶| */</span></span><br><span class="line">ngx_stream_lua_set_globals_table(co);</span><br></pre></td></tr></table></figure>

<p>这一块的逻辑有点绕，我们来稍微理一下，其实就是用新建的全局表替换了旧的全局表，其中新的全局表的<code>_G</code>字段是它自己，新全局表的元表中<code>__index</code>元方法是旧的全局表。</p>
<p>此时的Lua虚拟机栈顶情况如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L-&gt;top      |   栈顶    |</span><br><span class="line">L-&gt;top - 1  |Lua_State*|    新创建的协程</span><br><span class="line">L-&gt;top -2   | Lua Table|    存储协程引用的表</span><br></pre></td></tr></table></figure>

<p>下面一步就是在Lua虚拟机中为这个新协程创建一个reference：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 为栈顶对象（即新协程），创建并返回一个协程表中的引用 */</span></span><br><span class="line"><span class="comment">/* 当前栈： |协程表|顶| */</span></span><br><span class="line">*ref = luaL_ref(L, <span class="number">-2</span>);</span><br><span class="line"><span class="keyword">if</span> (*ref == LUA_NOREF) &#123;</span><br><span class="line">    lua_settop(L, base);  <span class="comment">/* restore main thread stack */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后恢复堆栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置栈顶索引 */</span></span><br><span class="line"><span class="comment">/* 当前栈： |顶| */</span></span><br><span class="line">lua_settop(L, base);    </span><br><span class="line"><span class="keyword">return</span> co;</span><br></pre></td></tr></table></figure>

<p>以上步骤还只是创建了一个什么都不能做的Lua协程，回到<code>_by_chunk()</code>函数之后还需要把入口函数放入协程中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将lua虚拟机VM栈上的入口函数闭包移到新创建的协程栈上，</span></span><br><span class="line"><span class="comment">   这样新协程就有了虚拟机已经解析完毕的代码了。*/</span></span><br><span class="line">lua_xmove(L, co, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 拿到co全局表，放到栈顶 */</span></span><br><span class="line"><span class="comment">/* 当前栈： |入口closure|全局表|顶| */</span></span><br><span class="line">ngx_stream_lua_get_globals_table(co);</span><br><span class="line"><span class="comment">/* 将全局表设为入口closure的环境表 */</span></span><br><span class="line"><span class="comment">/* 当前栈： |入口closure|顶|*/</span></span><br><span class="line">lua_setfenv(co, <span class="number">-2</span>);</span><br></pre></td></tr></table></figure>

<p>至此，协程入口函数以及环境表已经设置好。接下来就是让它能够运行起来，让调度器能够调度它运行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将nginx请求保存到协程全局表 */</span></span><br><span class="line">ngx_stream_lua_set_req(co, r);</span><br><span class="line"></span><br><span class="line">ctx-&gt;cur_co_ctx = &amp;ctx-&gt;entry_co_ctx;</span><br><span class="line">ctx-&gt;cur_co_ctx-&gt;co = co;</span><br><span class="line">ctx-&gt;cur_co_ctx-&gt;co_ref = co_ref;</span><br></pre></td></tr></table></figure>

<p>接下来就是注册cleanup钩子，然后<code>ngx_stream_lua_run_thread()</code>。</p>
<h2 id="用户创建的uthread"><a href="#用户创建的uthread" class="headerlink" title="用户创建的uthread"></a>用户创建的uthread</h2><p>用户线程由<code>ngx.thread.spawn()</code>创建，对应的C实现是<code>ngx_stream_lua_uthread_spawn()</code>。首先它会调<code>ngx_stream_lua_coroutine_create_helper()</code>创建一个新的协程。</p>
<h3 id="创建协程"><a href="#创建协程" class="headerlink" title="创建协程"></a>创建协程</h3><p>注意协程都是在worker的虚拟机上创建的（不考虑cache off的情况的话）。但是用户协程会继承父协程的全局表，其父子关系由OR进行维护。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取虚拟机 */</span></span><br><span class="line">vm = ngx_stream_lua_get_lua_vm(r, ctx);</span><br><span class="line"><span class="comment">/* 创建新协程 */</span></span><br><span class="line">co = lua_newthread(vm);</span><br><span class="line"><span class="comment">/* 然后创建coctx，设置其co、co_status值 */</span></span><br><span class="line">coctx = ngx_stream_lua_create_co_ctx;</span><br><span class="line">coctx-&gt;co = co;</span><br><span class="line">coctx-&gt;co_status = NGX_STREAM_LUA_CO_SUSPENDED;</span><br></pre></td></tr></table></figure>

<p>此时父协程的栈如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 当前栈: |entry_func|args|顶| */</span><br></pre></td></tr></table></figure>

<p>接下来将父协程的全局表给新创建的协程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* make new coroutine share globals of the parent coroutine.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> globals don&#x27;t have to be separated! */</span></span><br><span class="line"><span class="comment">/* 拷贝父协程的全局表到栈上 */</span></span><br><span class="line"><span class="comment">/* L栈: |entry_func|args|全局表|顶| */</span></span><br><span class="line">ngx_stream_lua_get_globals_table(L);</span><br><span class="line"><span class="comment">/* 将全局表移动到新创建的协程co的栈上 */</span></span><br><span class="line"><span class="comment">/* L栈: |entry_func|args|顶| */</span></span><br><span class="line">lua_xmove(L, co, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 从新协程栈上写入其的全局表 */</span></span><br><span class="line">ngx_stream_lua_set_globals_table(co);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将新协程从进程虚拟机，移动到父协程中 */</span></span><br><span class="line"><span class="comment">/* L栈: |entry_func|args|新协程|顶| */</span></span><br><span class="line">lua_xmove(vm, L, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 入口函数拷贝到L栈顶 */</span></span><br><span class="line"><span class="comment">/* L栈: |entry_func|args|新协程|entry_func|顶|*/</span></span><br><span class="line">lua_pushvalue(L, <span class="number">1</span>); </span><br><span class="line"><span class="comment">/* 将入口函数从L移到co栈中 */</span></span><br><span class="line"><span class="comment">/* L栈: |entry_func|args|新协程|顶| */</span></span><br><span class="line"><span class="comment">/* co栈: |entry_func|顶|*/</span></span><br><span class="line">lua_xmove(L, co, <span class="number">1</span>);  </span><br></pre></td></tr></table></figure>

<p><code>create_helper</code>函数返回之后，L的栈顶是新协程，co的栈顶是入口函数。</p>
<h3 id="初始化uthread"><a href="#初始化uthread" class="headerlink" title="初始化uthread"></a>初始化uthread</h3><p><code>ngx_stream_lua_coroutine_create_helper</code>返回之后，进行uthread的初始化。</p>
<p>此时，父协程L是这样的：</p>
<ul>
<li>栈顶是新创建的协程</li>
<li>然后是参数和入口函数</li>
</ul>
<p>在此之前，先在registry表中保存一个该协程的ref。（到现在还没搞明白这个ref是干嘛用的？除了创建线程和删除线程，貌似只有检查线程是否活着的时候会查一下这个ref，只是检查状态用<code>coctx-&gt;co_status</code>不是也能做到么？8.12更新，之所以要把线程锚定到注册表上，是为了防止被当成垃圾回收。这也解释了为什么只有线程需要锚定到注册表上，而用户协程不需要。因为用户协程肯定由其父协程保留着一个引用。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* anchor the newly created coroutine into the Lua registry */</span></span><br><span class="line"><span class="comment">/* 把新创建的协程写入Lua registry表中 */</span></span><br><span class="line"><span class="comment">/* 将ngx_stream_lua_coroutines_key的地址压入栈中 */</span></span><br><span class="line">lua_pushlightuserdata(L, &amp;ngx_stream_lua_coroutines_key);</span><br><span class="line"><span class="comment">/* 从registry表中获取协程表 */</span></span><br><span class="line"><span class="comment">/* L栈: |entry_func|args|新协程|协程表|顶|*/</span></span><br><span class="line">lua_rawget(L, LUA_REGISTRYINDEX);</span><br><span class="line"><span class="comment">/* 将新协程压栈 */</span></span><br><span class="line"><span class="comment">/* L栈: |entry_func|args|新协程|协程表|新协程|顶|*/</span></span><br><span class="line">lua_pushvalue(L, <span class="number">-2</span>);</span><br><span class="line"><span class="comment">/* -2位置是注册表，为新协程创建在报表中的索引 */</span></span><br><span class="line"><span class="comment">/* L栈: |entry_func|args|新协程|协程表|顶| */</span></span><br><span class="line">coctx-&gt;co_ref = luaL_ref(L, <span class="number">-2</span>);    <span class="comment">// </span></span><br><span class="line"><span class="comment">/* 弹出协程表 */</span></span><br><span class="line"><span class="comment">/* L栈: |entry_func|args|新协程|顶| */</span></span><br><span class="line">lua_pop(L, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>接下来是初始化运行环境：</p>
<p>此时的，L的栈情况如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|entry_func|参数1|...|参数n|新协程|</span><br><span class="line">    1        2   ...  -2    -1</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 由于lua函数压栈顺序是从左到右</span></span><br><span class="line"><span class="comment">     * 因此1就是压入的第一个参数，而spawn的第一个参数就是入口函数</span></span><br><span class="line"><span class="comment">     * 把栈顶元素（即新协程）移动到1，覆盖入口函数，入口函数前面已经拷贝到新协程栈上了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* L栈: |新协程|args|顶| */</span></span><br><span class="line">    lua_replace(L, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 将参数移到新协程栈中 */</span></span><br><span class="line">    <span class="comment">/* L栈: |新协程|顶|*/</span></span><br><span class="line">    <span class="comment">/* co栈: |入口函数|args|顶| */</span></span><br><span class="line">    lua_xmove(L, coctx-&gt;co, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置状态，将父协程放入post_thread队列中，设置协程的父子关系，设置新协程为下一个调度的线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置状态 */</span></span><br><span class="line">coctx-&gt;co_status = NGX_STREAM_LUA_CO_RUNNING;</span><br><span class="line">ctx-&gt;co_op = NGX_STREAM_LUA_USER_THREAD_RESUME;</span><br><span class="line">ctx-&gt;cur_co_ctx-&gt;thread_spawn_yielded = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将父协程放入post_thread队列中 */</span></span><br><span class="line">ngx_stream_lua_post_thread(r, ctx, ctx-&gt;cur_co_ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存子线程的父协程上下文为当前协程 */</span></span><br><span class="line">coctx-&gt;parent_co_ctx = ctx-&gt;cur_co_ctx;</span><br><span class="line"><span class="comment">/* 切换当前协程为新创建的协程 */</span></span><br><span class="line">ctx-&gt;cur_co_ctx = coctx;</span><br></pre></td></tr></table></figure>

<p>最后，spawn函数的返回值是新创建的协程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将原协程的执行权切换出去，这里的参数1表示栈上留了一个值，这里是指新创建的协程</span></span><br><span class="line"><span class="comment"> * 主线程并不会取这个值，而是等到新线程spawn返回时作为返回值。</span></span><br><span class="line"><span class="comment"> * 此时L栈中是新协程，co栈中是参数和入口函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> lua_yield(L, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="用户创建的coroutine"><a href="#用户创建的coroutine" class="headerlink" title="用户创建的coroutine"></a>用户创建的coroutine</h2><p>OR替换了原生的coroutine接口，当存在<code>getfenv(0).__ngx_req</code>时（全局环境保存了nginx请求），使用重写后的coroutine接口函数。</p>
<p><code>coroutine.create()</code>创建新协程部分跟uthread是一样的，都是调用<code>ngx_stream_lua_coroutine_create_helper()</code>。Lua函数返回新协程。此时新协程栈中是入口函数。</p>
<p><code>coroutine.resume()</code>用于开始或恢复新协程，其对应的C函数是<code>ngx_http_lua_coroutine_resume()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 首先，获取到协程 */</span></span><br><span class="line"><span class="comment">/* L栈: |co|参数|,  co栈: |入口函数| */</span></span><br><span class="line">co = lua_tothread(L, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 然后设置状态和父子关系 */</span></span><br><span class="line"><span class="comment">/* 父协程为normal */</span></span><br><span class="line">p_coctx-&gt;co_status = NGX_HTTP_LUA_CO_NORMAL;</span><br><span class="line"></span><br><span class="line">coctx-&gt;parent_co_ctx = p_coctx;</span><br><span class="line"></span><br><span class="line">dd(<span class="string">&quot;set coroutine to running&quot;</span>);</span><br><span class="line"><span class="comment">/* 子协程为running */</span></span><br><span class="line">coctx-&gt;co_status = NGX_HTTP_LUA_CO_RUNNING;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置co_op告知主线程yield类型 */</span></span><br><span class="line">ctx-&gt;co_op = NGX_HTTP_LUA_USER_CORO_RESUME;</span><br><span class="line"><span class="comment">/* 设置下一个调度协程为新协程 */</span></span><br><span class="line">ctx-&gt;cur_co_ctx = coctx;</span><br></pre></td></tr></table></figure>

<p>接下来，将控制权交还给主协程，并把参数传给主线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此时L栈: |co|参数|， co栈: |入口函数| */</span></span><br><span class="line"><span class="comment">/* lua_gettop(L) - 1表示留在栈中的返回值个数，</span></span><br><span class="line"><span class="comment"> * 由主线程取用之后，在lua_resume新协程时传递 */</span></span><br><span class="line"><span class="comment">/* 减一个，表示不传底下的co */</span></span><br><span class="line"><span class="keyword">return</span> lua_yield(L, lua_gettop(L) - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h1 id="协程执行和恢复"><a href="#协程执行和恢复" class="headerlink" title="协程执行和恢复"></a>协程执行和恢复</h1><p>OR中协程的执行和恢复总是由主线程来进行，不管是<code>coroutine.resume()</code>还是<code>ngx.thread.spawn()</code>，都是先<code>lua_yield()</code>回到主线程之后，在主线程中<code>lua_resume()</code>。</p>
<p>注意到前面创建阶段，thread是<code>lua_yield(L, 1)</code>，coroutine是<code>lua_yield(L, lua_gettop(L) - 1)</code>。yield到主线程之后，我们继续看调度程序的处理。</p>
<h2 id="uthread"><a href="#uthread" class="headerlink" title="uthread"></a>uthread</h2><p>先获取参数个数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 因为入口函数和参数已经在新线程栈中了,所以从新协程中获取参数个数，-1是除掉入口函数 */</span></span><br><span class="line">nrets = lua_gettop(ctx-&gt;cur_co_ctx-&gt;co) - <span class="number">1</span>;    </span><br></pre></td></tr></table></figure>

<p>然后跳到主循环的前面，执行新线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 保存新协程coctx */</span></span><br><span class="line">orig_coctx = ctx-&gt;cur_co_ctx;</span><br><span class="line"><span class="comment">/* 执行新线程，其中nrets为参数个数 */</span></span><br><span class="line">rv = lua_resume(orig_coctx-&gt;co, nrets);</span><br></pre></td></tr></table></figure>

<p>在<code>lua_resume</code>中就会开始新线程的执行。当新线程执行完毕或因I/O中断yield之后，会恢复父协程。在恢复父协程之前，先设置参数个数为1，即之前留在栈上的新协程co。恢复父协程之后，<code>ngx.thread.spawn()</code>函数就返回了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx-&gt;cur_co_ctx-&gt;thread_spawn_yielded) &#123;</span><br><span class="line">    ctx-&gt;cur_co_ctx-&gt;thread_spawn_yielded = <span class="number">0</span>;</span><br><span class="line">    nrets = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="coroutine"><a href="#coroutine" class="headerlink" title="coroutine"></a>coroutine</h2><p>同样是先获取参数个数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取父协程 */</span></span><br><span class="line">old_co = ctx-&gt;cur_co_ctx-&gt;parent_co_ctx-&gt;co;</span><br><span class="line"><span class="comment">/* 因为参数还在父协程栈中，所以从父协程栈中获取参数个数 */</span></span><br><span class="line">nrets = lua_gettop(old_co);</span><br><span class="line"><span class="keyword">if</span> (nrets) &#123;</span><br><span class="line">    <span class="comment">/* 将参数从父协程移到子协程 */</span></span><br><span class="line">    lua_xmove(old_co, ctx-&gt;cur_co_ctx-&gt;co, nrets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时子协程栈中是参数和入口函数。</p>
<p>然后跳到主循环的前面，执行新协程，跟前面uthread时一样。</p>
<h1 id="协程挂起"><a href="#协程挂起" class="headerlink" title="协程挂起"></a>协程挂起</h1><p>协程的挂起分为两种情况：</p>
<ul>
<li>一种是内部在I/O等待时自动挂起，这种情况用户不用参与，OR会自动将相应的事件及其handler挂到事件驱动上，当事件被唤醒时继续未完成的I/O操作，完成之后由调度器恢复之前挂起的协程。</li>
<li>另一种是用户在Lua代码主动调用<code>coroutine.yield()</code>挂起。此时由调度器根据情况决定执行下一个执行的协程。</li>
</ul>
<h2 id="显式主动挂起"><a href="#显式主动挂起" class="headerlink" title="显式主动挂起"></a>显式主动挂起</h2><p>我们先来看用户主动挂起的情况，<code>coroutine.yield()</code>对应的C函数为<code>ngx_stream_lua_coroutine_yield()</code>。我们先来看看它里面干了些什么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 首先修改当前协程的状态为挂起 */</span></span><br><span class="line">coctx = ctx-&gt;cur_co_ctx;</span><br><span class="line">coctx-&gt;co_status = NGX_STREAM_LUA_CO_SUSPENDED;</span><br><span class="line"><span class="comment">/* 设置co_op */</span></span><br><span class="line">ctx-&gt;co_op = NGX_STREAM_LUA_USER_CORO_YIELD;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果不是用户线程（也即是普通coroutine），且有父协程，</span></span><br><span class="line"><span class="comment">   将其父协程状态设置为running */</span></span><br><span class="line"><span class="keyword">if</span> (!coctx-&gt;is_uthread &amp;&amp; coctx-&gt;parent_co_ctx) &#123;</span><br><span class="line">    coctx-&gt;parent_co_ctx-&gt;co_status = NGX_STREAM_LUA_CO_RUNNING;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 最后将控制权交还主线程，将所有yield参数传递给主线程 */</span></span><br><span class="line"><span class="keyword">return</span> lua_yield(L, lua_gettop(L));</span><br></pre></td></tr></table></figure>

<p>回到主线程之后，根据待挂起协程是thread还是corotine进行不同处理。</p>
<h3 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ngx_stream_lua_is_thread(ctx)) &#123;</span><br><span class="line">    <span class="comment">/* 丢弃coroutine.yield()的任何参数 */</span></span><br><span class="line">    lua_settop(ctx-&gt;cur_co_ctx-&gt;co, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 因为thread由调度器负责调度，所以将当前线程的状态改为running，为什么不在前面一起改？*/</span></span><br><span class="line">    ctx-&gt;cur_co_ctx-&gt;co_status = NGX_STREAM_LUA_CO_RUNNING;</span><br><span class="line">    <span class="comment">/* 如果已经有pending的线程，则放到队列中 */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;posted_threads) &#123;</span><br><span class="line">        ngx_stream_lua_post_thread(r, ctx, ctx-&gt;cur_co_ctx);</span><br><span class="line">        ctx-&gt;cur_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 否则，立即恢复线程 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="coroutine-1"><a href="#coroutine-1" class="headerlink" title="coroutine"></a>coroutine</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取当前栈的高度，也即coroutine.yield()的参数个数 */</span></span><br><span class="line">nrets = lua_gettop(ctx-&gt;cur_co_ctx-&gt;co);</span><br><span class="line"><span class="comment">/* 设置父协程为下一个调度的协程 */</span></span><br><span class="line">next_coctx = ctx-&gt;cur_co_ctx-&gt;parent_co_ctx;</span><br><span class="line">next_co = next_coctx-&gt;co;</span><br><span class="line"><span class="comment">/* 将参数从子协程栈中移到父协程栈中 */</span></span><br><span class="line"><span class="keyword">if</span> (nrets) &#123;</span><br><span class="line">    dd(<span class="string">&quot;moving %d return values to next co&quot;</span>, nrets);</span><br><span class="line">    lua_xmove(ctx-&gt;cur_co_ctx-&gt;co, next_co, nrets);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NGX_LUA_USE_ASSERT</span></span><br><span class="line">    ctx-&gt;cur_co_ctx-&gt;co_top -= nrets;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 如果不是wrap封装的，还要加一个true，作为第一个参数 */</span></span><br><span class="line"><span class="keyword">if</span> (!ctx-&gt;cur_co_ctx-&gt;is_wrap) &#123;</span><br><span class="line">    <span class="comment">/* prepare return values for coroutine.resume</span></span><br><span class="line"><span class="comment">     * (true plus any retvals)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lua_pushboolean(next_co, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 插入1的位置，作为第一个参数 */</span></span><br><span class="line">    lua_insert(next_co, <span class="number">1</span>);</span><br><span class="line">    nrets++; <span class="comment">/* add the true boolean value */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx-&gt;cur_co_ctx = next_coctx;</span><br><span class="line"><span class="comment">/* 回到主循环的前面，resume父协程 */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h2 id="I-O等待场景"><a href="#I-O等待场景" class="headerlink" title="I/O等待场景"></a>I/O等待场景</h2><p>I/O等待的场景有很多，不过其背后的原理都差不多：</p>
<ul>
<li>定义一个事件，设置恢复时的handler及对应协程上下文，然后<code>lua_yield()</code>回到<code>run_thread()</code>。</li>
<li>主线程将<code>ctx-&gt;cur_co_ctx</code>设为空之后，直接返回<code>NGX_AGAIN</code>，如果有<code>posted_thread</code>会继续执行，否则将控制权交还给nginx层</li>
<li>后续当事件发生时，继续未完成的操作，完成之后将保存的协程上下文设为<code>ctx-&gt;cur_co_ctx</code>，然后调用<code>ngx_stream_lua_run_thread()</code>恢复协程的执行。</li>
</ul>
<p>这里举两个典型的例子:</p>
<h3 id="ngx-sleep"><a href="#ngx-sleep" class="headerlink" title="ngx.sleep()"></a>ngx.sleep()</h3><p>它的C函数实现是<code>ngx_stream_lua_ngx_sleep()</code>，先定义设置好handler和coctx，挂上定时器，然后<code>lua_yield()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    ngx_stream_lua_cleanup_pending_operation(coctx);</span><br><span class="line">    coctx-&gt;cleanup = ngx_stream_lua_sleep_cleanup;</span><br><span class="line">    coctx-&gt;data = r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 保存恢复时的handler和协程上下文 */</span></span><br><span class="line">    coctx-&gt;sleep.handler = ngx_stream_lua_sleep_handler;</span><br><span class="line">    coctx-&gt;sleep.data = coctx;</span><br><span class="line">    coctx-&gt;sleep.<span class="built_in">log</span> = r-&gt;connection-&gt;<span class="built_in">log</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当delay为0时，放入post_event队列或添加定时器 */</span></span><br><span class="line">    <span class="keyword">if</span> (delay == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_POSTED_DELAYED_EVENTS_PATCH</span></span><br><span class="line">        dd(<span class="string">&quot;posting 0 sec sleep event to head of delayed queue&quot;</span>);</span><br><span class="line"></span><br><span class="line">        coctx-&gt;sleep.delayed = <span class="number">1</span>;</span><br><span class="line">        ngx_post_event(&amp;coctx-&gt;sleep, &amp;ngx_posted_delayed_events);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        ngx_log_error(NGX_LOG_WARN, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;ngx.sleep(0)&quot;</span></span><br><span class="line">                      <span class="string">&quot; called without delayed events patch, this will&quot;</span></span><br><span class="line">                      <span class="string">&quot; hurt performance&quot;</span>);</span><br><span class="line">        ngx_add_timer(&amp;coctx-&gt;sleep, (<span class="keyword">ngx_msec_t</span>) delay);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">/* 添加定时器 */</span></span><br><span class="line">        ngx_add_timer(&amp;coctx-&gt;sleep, (<span class="keyword">ngx_msec_t</span>) delay);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 外层函数*/</span></span><br><span class="line">    <span class="keyword">return</span> lua_yield(L, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在<code>run_thread()</code>里将当前协程上下文置为<code>NULL</code>，然后返回<code>NGX_AGAIN</code></p>
<p>在<code>by_chunk()</code>里会先检查有没有在post队列里的线程，如果没有则返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rc = ngx_stream_lua_run_thread(L, r, ctx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rc == NGX_ERROR || rc &gt;= NGX_OK) &#123;</span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == NGX_AGAIN) &#123;</span><br><span class="line">    rc = ngx_stream_lua_content_run_posted_threads(L, r, ctx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == NGX_DONE) &#123; <span class="comment">/* 这里DONE的情况只有HTTP子请求的时候会出现 */</span></span><br><span class="line">    rc = ngx_stream_lua_content_run_posted_threads(L, r, ctx, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    rc = NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当定时器超时时，它会执行<code>sleep_handler()</code>，设置<code>ctx-&gt;cur_co_ctx</code>然后执行<code>run_thread()</code>恢复协程调度。</p>
<h3 id="ngx-tcp-receive"><a href="#ngx-tcp-receive" class="headerlink" title="ngx.tcp.receive()"></a>ngx.tcp.receive()</h3><p>其对应的C函数实现是<code>ngx_stream_lua_socket_tcp_receive()</code>，里面会调<code>ngx_stream_lua_socket_tcp_receive_helper()</code>。碰到读等待的情况，也是先设置好handler和coctx，然后<code>lua_yield()</code>。我们来看下里面代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这里0表示还未进行协程切换 */</span></span><br><span class="line">u-&gt;read_waiting = <span class="number">0</span>;</span><br><span class="line">u-&gt;read_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取的主要逻辑由此函数处理 */</span></span><br><span class="line">rc = ngx_stream_lua_socket_tcp_read(r, u);</span><br><span class="line"><span class="comment">/* 不管是成功、出错或等待I/O，肯定会返回 */</span></span><br><span class="line"><span class="keyword">if</span>(rc == NGX_ERROR) &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(rc == NGX_OK) &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rc == NGX_AGAIN */</span></span><br><span class="line"><span class="comment">/* 如果是等待I/O的情况，设置事件触发时的handler、当前协程上下文 */</span></span><br><span class="line">u-&gt;read_event_handler = ngx_stream_lua_socket_read_handler;</span><br><span class="line">coctx = lctx-&gt;cur_co_ctx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置请求的写事件handler，这个是返回到Lua层前调用的handler */</span></span><br><span class="line">r-&gt;write_event_handler = ngx_stream_lua_content_wev_handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存当前协程上下文到u上 */</span></span><br><span class="line">u-&gt;read_co_ctx = coctx;</span><br><span class="line"><span class="comment">/* 表示是后续是需要协程恢复的 */</span></span><br><span class="line">u-&gt;read_waiting = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 设置准备返回值的回调 */</span></span><br><span class="line">u-&gt;read_prepare_retvals = ngx_stream_lua_socket_tcp_receive_retval_handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lua_yield(L, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>回到<code>run_thread()</code>，同样是将当前协程上下文置为<code>NULL</code>，然后返回<code>NGX_AGAIN</code>。</p>
<p>当事件被触发时，执行前面设置的<code>ngx_stream_lua_socket_read_handler()</code>，里面又会调用读取操作核心函数<code>ngx_stream_lua_socket_tcp_read()</code>。如果继续碰到等待I/O，handler直接结束，等待下一次事件。如果是完成或出错，会执行如下操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 恢复该值为0 */</span></span><br><span class="line">u-&gt;read_waiting = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 获取协程上下文 */</span></span><br><span class="line">coctx = u-&gt;read_co_ctx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置协程恢复的handler */</span></span><br><span class="line">ctx-&gt;resume_handler = ngx_stream_lua_socket_tcp_read_resume;</span><br><span class="line"><span class="comment">/* 设置下一个调度的上下文，为之前调用读取操作的协程 */</span></span><br><span class="line">ctx-&gt;cur_co_ctx = coctx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个handler就是yield之前设置的那个，它里面调用 ctx-&gt;resume_handler */</span></span><br><span class="line">r-&gt;write_event_handler(r);  </span><br></pre></td></tr></table></figure>

<p><code>r-&gt;write_event_handler(r);</code>是返回Lua层前调用的handler，里面会调用<code>resume_handler</code>。<code>ngx_stream_lua_socket_tcp_read_resume()</code>只是封装了一下，最终都是调用的<code>ngx_stream_lua_socket_tcp_resume_helper()</code>，我们看来下它的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 待恢复协程上下文 */</span></span><br><span class="line">coctx = ctx-&gt;cur_co_ctx;</span><br><span class="line"></span><br><span class="line">u = coctx-&gt;data;</span><br><span class="line">prepare_retvals = u-&gt;read_prepare_retvals;</span><br><span class="line"><span class="comment">/* 准备返回值 */</span></span><br><span class="line">nret = prepare_retvals(r, u, ctx-&gt;cur_co_ctx-&gt;co);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复协程调度，回到Lua层 */</span></span><br><span class="line">rc = ngx_stream_lua_run_thread(vm, r, ctx, nret);</span><br></pre></td></tr></table></figure>

<p>至于完成的条件，取决与不同的调用方式。如果是读取固定字节数的话，会维护一个剩余待读取的字节数<code>u-&gt;rest</code>。如果是读取一行，则读取到<code>\n</code>就结束。如果是readall，则一直读到<code>u-&gt;eof</code>为止。</p>
<h1 id="协程执行完毕"><a href="#协程执行完毕" class="headerlink" title="协程执行完毕"></a>协程执行完毕</h1><p>为了不失完整性，再说一下正常结束和出错时的情况。正常执行完毕时，会设置协程状态，然后清理它的僵尸子线程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将当前协程状态置为DEAD */</span></span><br><span class="line">ctx-&gt;cur_co_ctx-&gt;co_status = NGX_STREAM_LUA_CO_DEAD;</span><br><span class="line"><span class="comment">/* 如果子线程有僵尸线程，则清理之 */</span></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;cur_co_ctx-&gt;zombie_child_threads) &#123;</span><br><span class="line">    ngx_stream_lua_cleanup_zombie_child_uthreads(</span><br><span class="line">        r, L, ctx, ctx-&gt;cur_co_ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，根据结束的协程的类型不同执行不同的操作：</p>
<h2 id="入口线程"><a href="#入口线程" class="headerlink" title="入口线程"></a>入口线程</h2><p>此时直接删除线程即可，然后根据是否还有用户线程，选择返回<code>NGX_AGAIN</code>或<code>NGX_OK</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ngx_stream_lua_is_entry_thread(ctx)) &#123;</span><br><span class="line">    <span class="comment">/* 将虚拟机栈清空 */</span></span><br><span class="line">    lua_settop(L, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 删除当前线程，会从REGISTY表中解引用当前协程的`coctx-&gt;co_ref` */</span></span><br><span class="line">    ngx_stream_lua_del_thread(r, L, ctx, ctx-&gt;cur_co_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果还有其他用户线程，返回NGX_AGAIN */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;uthreads) &#123;</span><br><span class="line">        ctx-&gt;cur_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> NGX_AGAIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* all user threads terminated already */</span></span><br><span class="line">    <span class="keyword">goto</span> done;      <span class="comment">/* 到这就圆满结束了 return NGX_OK; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h2><p>此时如果父协程已经死了，处理方式跟入口线程一样，即删除线程，然后根据是否还有任何用户线程或入口线程，选择返回<code>NGX_AGAIN</code>或<code>NGX_OK</code>。</p>
<p>如果父协程还活着，并且已经在wait它了，直接恢复父协程。否则，加入到父协程的僵尸线程列表中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx-&gt;cur_co_ctx-&gt;is_uthread) &#123;</span><br><span class="line">    <span class="comment">/* 清空虚拟机栈 */</span></span><br><span class="line">    lua_settop(L, <span class="number">0</span>); </span><br><span class="line">    <span class="comment">/* 获取父协程 */</span></span><br><span class="line">    parent_coctx = ctx-&gt;cur_co_ctx-&gt;parent_co_ctx;</span><br><span class="line">    <span class="comment">/* 如果父协程还活着 */</span></span><br><span class="line">    <span class="keyword">if</span> (ngx_stream_lua_coroutine_alive(parent_coctx)) &#123;</span><br><span class="line">        <span class="comment">/* 并且在wait当前线程，则恢复父协程 */</span></span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;cur_co_ctx-&gt;waited_by_parent) &#123;</span><br><span class="line">            ngx_stream_lua_probe_info(<span class="string">&quot;parent already waiting&quot;</span>);</span><br><span class="line">            ctx-&gt;cur_co_ctx-&gt;waited_by_parent = <span class="number">0</span>;</span><br><span class="line">            success = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> user_co_done;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 否则将当前线程挂到父协程的僵尸子线程中 */</span></span><br><span class="line">        <span class="keyword">if</span> (ngx_stream_lua_post_zombie_thread(r, parent_coctx,</span><br><span class="line">                                              ctx-&gt;cur_co_ctx)</span><br><span class="line">            != NGX_OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 压入第一个返回值true，以备后续wait时返回 */</span></span><br><span class="line">        lua_pushboolean(ctx-&gt;cur_co_ctx-&gt;co, <span class="number">1</span>);</span><br><span class="line">        lua_insert(ctx-&gt;cur_co_ctx-&gt;co, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* 设置当前线程状态为ZOMBIE */</span></span><br><span class="line">        ctx-&gt;cur_co_ctx-&gt;co_status = NGX_STREAM_LUA_CO_ZOMBIE;</span><br><span class="line">        ctx-&gt;cur_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> NGX_AGAIN;       <span class="comment">/* 返回上层 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果父协程已经死了，直接删除当前线程</span></span><br><span class="line"><span class="comment">     * 会从REGISTY表中解引用当前协程的`coctx-&gt;co_ref` */</span></span><br><span class="line">    ngx_stream_lua_del_thread(r, L, ctx, ctx-&gt;cur_co_ctx);</span><br><span class="line">    ctx-&gt;uthreads--;</span><br><span class="line">    <span class="comment">/* 如果没有用户线程了 */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;uthreads == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 入口线程在活着，返回上层 */</span></span><br><span class="line">        <span class="keyword">if</span> (ngx_stream_lua_entry_thread_alive(ctx)) &#123;</span><br><span class="line">            ctx-&gt;cur_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> NGX_AGAIN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* all threads terminated already */</span></span><br><span class="line">        <span class="keyword">goto</span> done;  <span class="comment">/* 到这就圆满结束了 return NGX_OK; */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果还有其他用户线程，返回上层 */</span></span><br><span class="line">    ctx-&gt;cur_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> NGX_AGAIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户协程"><a href="#用户协程" class="headerlink" title="用户协程"></a>用户协程</h2><p>剩下的就是用户协程的情况，这个情况跟用户线程被父协程wait的情况是一样的。主要是将返回值移动到父协程栈中，然后跳到主循环前面恢复父协程的执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">success = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 获取返回值个数 */</span></span><br><span class="line">nrets = lua_gettop(ctx-&gt;cur_co_ctx-&gt;co);</span><br><span class="line">next_coctx = ctx-&gt;cur_co_ctx-&gt;parent_co_ctx;</span><br><span class="line">next_co = next_coctx-&gt;co;</span><br><span class="line"><span class="comment">/* 将返回值移到父协程栈中 */</span></span><br><span class="line"><span class="keyword">if</span> (nrets) &#123;</span><br><span class="line">    lua_xmove(ctx-&gt;cur_co_ctx-&gt;co, next_co, nrets);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 如果是用户线程，删除之 */</span></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;cur_co_ctx-&gt;is_uthread) &#123;</span><br><span class="line">    ngx_stream_lua_del_thread(r, L, ctx, ctx-&gt;cur_co_ctx);</span><br><span class="line">    ctx-&gt;uthreads--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 除了wrap的用户协程，加上第一个true的返回值 */</span></span><br><span class="line"><span class="keyword">if</span> (!ctx-&gt;cur_co_ctx-&gt;is_wrap) &#123;</span><br><span class="line">    <span class="comment">/* ended successfully, coroutine.resume returns true plus</span></span><br><span class="line"><span class="comment">     * any return values</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lua_pushboolean(next_co, success);</span><br><span class="line">    lua_insert(next_co, <span class="number">1</span>);</span><br><span class="line">    nrets++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置父协程的状态为RUNNING */</span></span><br><span class="line">ctx-&gt;cur_co_ctx = next_coctx;</span><br><span class="line">next_coctx-&gt;co_status = NGX_STREAM_LUA_CO_RUNNING;</span><br><span class="line"><span class="comment">/* 回到主循环前面，恢复父协程的执行 */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>



<h1 id="出错的情况"><a href="#出错的情况" class="headerlink" title="出错的情况"></a>出错的情况</h1><p>大致处理步骤是，恢复<code>cur_co_ctx</code>，获取虚拟机L栈上错误信息，获取当前协程栈中错误信息，后面的操作类似协程执行完毕时，根据不同的情况选择恢复父协程或者返回上层。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 恢复cur_co_ctx */</span></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;cur_co_ctx != orig_coctx) &#123;</span><br><span class="line">    ctx-&gt;cur_co_ctx = orig_coctx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 设置当前协程状态为DEAD */</span></span><br><span class="line">ctx-&gt;cur_co_ctx-&gt;co_status = NGX_HTTP_LUA_CO_DEAD;</span><br><span class="line"><span class="comment">/* 获取错误信息 */</span></span><br><span class="line"><span class="keyword">if</span> (orig_coctx-&gt;is_uthread</span><br><span class="line">    || orig_coctx-&gt;is_wrap</span><br><span class="line">    || ngx_http_lua_is_entry_thread(ctx))</span><br><span class="line">&#123;</span><br><span class="line">    ngx_http_lua_thread_traceback(L, orig_coctx-&gt;co, orig_coctx);</span><br><span class="line">    trace = lua_tostring(L, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lua_isstring(orig_coctx-&gt;co, <span class="number">-1</span>)) &#123;</span><br><span class="line">        msg = lua_tostring(orig_coctx-&gt;co, <span class="number">-1</span>);</span><br><span class="line">        dd(<span class="string">&quot;user custom error msg: %s&quot;</span>, msg);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg = <span class="string">&quot;unknown reason&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户线程-1"><a href="#用户线程-1" class="headerlink" title="用户线程"></a>用户线程</h2><p>跟正常结束的处理一样，除了第一个返回值是false。</p>
<p>此时如果父协程已经死了，直接删除线程，然后根据是否还有任何用户线程或入口线程，选择返回<code>NGX_AGAIN</code>或<code>NGX_OK</code>。</p>
<p>如果父协程还活着，并且已经在wait它了，直接恢复父协程。否则，加入到父协程的僵尸线程列表中。</p>
<h2 id="入口线程-1"><a href="#入口线程-1" class="headerlink" title="入口线程"></a>入口线程</h2><p><code>ngx_stream_lua_request_cleanup()</code>清理当前请求，里面会清理掉所有的用户创建的协程，然后清理入口协程自己。最后返回错误码。</p>
<h2 id="用户协程-1"><a href="#用户协程-1" class="headerlink" title="用户协程"></a>用户协程</h2><p>如果是wrap的协程，将错误传递给父协程（就好像是父协程出错了，然后父协程重新走一遍上面的出错处理流程）。</p>
<p>如果是普通协程，则恢复父协程的执行，返回false和错误信息。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://openresty-reference.readthedocs.io/en/latest/Lua_Nginx_API/">Lua-Ngx-API</a></li>
<li><a href="https://github.com/openresty/stream-lua-nginx-module">stream-lua-nginx源码</a></li>
<li><a href="https://www.lua.org/manual/5.1/manual.html">lua-5.1-manual</a></li>
<li><a href="https://www.codedump.info/post/20190501-lua-stream/">lua stream实现分析</a></li>
</ul>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Nginx/OpenResty</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>OpenResty</tag>
        <tag>Nginx</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在裸机上直接运行程序—王爽《汇编语言》课程设计2</title>
    <url>/posts/8054db72/</url>
    <content><![CDATA[<div class="note primary">
            <p>平常我们的程序基本都是运行在操作系统之上，很少有机会直接在裸机上运行程序。现代操作系统需要支持多任务环境的工作方式，这要求CPU在硬件上提供支持。以Intel处理器为例，从80286/80386开始，CPU开始支持工作在保护模式，为多任务环境提供保护机制。</p><p>操作系统为我们提供了保护和抽象，这方便了开发和使用，但是同时也对学习者了解计算机底层工作原理造成了一定的障碍。本文通过编码实践王爽老师《汇编语言》中的课程设计2，与寄存器、内存、显存、中断、外设等进行了近距离的亲密接触，通过这次实践也算是入门汇编了吧。</p>
          </div>

<span id="more"></span>

<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>计算机上电之后，CPU自动从FFFF:0单元处开始执行，这里有一条跳转指令，CPU转去执行BIOS中的硬件系统检测和初始化程序。初始化程序将从0:0单元处开始建立中断向量表。硬件系统检测和初始化完成之后，调用int 19h进行操作系统引导。从软盘或硬盘第一个扇区读取内容到0:7c00，然后CS:IP指向0:7c00开始执行。</p>
<p>这个课程设计的任务就是编写一个可以直接在裸机上运行的程序，具体功能如下：</p>
<ol>
<li>列出功能选项，让用户通过键盘进行选择，界面如下。<ol>
<li>reset pc            ; 重新启动计算机</li>
<li>start system                ; 引导现有的操作系统</li>
<li>clock                             ; 进入时钟程序</li>
<li>set clock                       ; 设置时钟</li>
</ol>
</li>
<li>用户输入“1”后重新启动计算机（重新跳转到ffff:0单元）</li>
<li>用户输入“2”后引导现有的操作系统（读取硬盘C的0道0面1扇区进行引导）</li>
<li>用户输入“3”后，执行动态显示当前日期、时间的程序（循环读取CMOS），格式：年/月/日 时:分:秒。按下F1键后，改变显示颜色；按下Esc键后，返回到主选单（利用键盘中断）</li>
<li>用户输入“4”后，用户可输入字符串更改CMOS中的日期时间，更改后返回到主选单</li>
</ol>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>首先需要准备一个常用虚拟机，VMware/VirtualBox等都可以</li>
<li>准备<a href="https://winworldpc.com/product/ms-dos/622">MS-DOS 6.22映像</a>，或者<a href="https://www.dosbox.com/download.php?main=1">DOSBox</a>，作为开发和调试的环境，DOS 6.22虚拟机的安装可以参考<a href="https://www.cnblogs.com/pchmonster/p/8372902.html">这里</a></li>
<li>准备debug、masm、link程序，分别是DOS下的调试器、编译器和链接器，可以从<a href="https://github.com/xDarkLemon/DOSBox_MASM/tree/master/masm">这里</a>下载</li>
</ul>
<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>由前面的背景知识可知，计算机刚上电之后，CPU会自动执行硬件系统检测及初始化工作，这些操作我们用户是无法进行插手的。完成初始化之后，将调用int 19h读取启动设备第一个扇区的内容到0:7c00，从这里开始我们就接手CPU的控制权了。</p>
<h3 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h3><p>所以我们首先要做的就是制作一个启动盘，我们这里选用1.44M的软盘，它比硬盘具有更高的优先级。创建一个空的软盘映像非常简单，在Window下可以使用WinImage工具，在Linux上则直接使用如下dd命令即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=floppy.img bs=512 count=2880</span><br></pre></td></tr></table></figure>

<h3 id="安装程序"><a href="#安装程序" class="headerlink" title="安装程序"></a>安装程序</h3><p>有了软盘映像之后，接下来的任务就是将我们的程序写到软盘上，这个可以通过一个安装程序来完成，借助int 13h中断将任务程序的二进制代码写到软盘上。</p>
<h3 id="任务程序引导部分"><a href="#任务程序引导部分" class="headerlink" title="任务程序引导部分"></a>任务程序引导部分</h3><p>如前所述，int 19h会帮我们将启动盘的第一个扇区读到0:7c00，然后CPU从0:7c00开始执行。一个扇区基本不可能放下我们整个任务程序，所以我们需要将任务程序分成两个部分：引导部分和主体部分。引导部分的代码负责把剩余主体部分读到内存中。我们这里选择读到0:7e00h处，紧跟在第一个扇区后面。读完之后就跳转到主体部分代码的开头继续执行。</p>
<h3 id="任务程序主体部分"><a href="#任务程序主体部分" class="headerlink" title="任务程序主体部分"></a>任务程序主体部分</h3><p>主体部分完成我们程序的主要功能</p>
<ol>
<li>首先我们需要注册一个新的int 9中断例程，包装BIOS提供的中断例程，因为我们需要根据用户的键盘输入做不同的操作。这个中断例程是我们程序的核心。</li>
<li>接着显示几个选项供用户选择</li>
<li>然后进入循环，根据模式标志决定是否显示时间</li>
</ol>
<h3 id="int-9中断例程"><a href="#int-9中断例程" class="headerlink" title="int 9中断例程"></a>int 9中断例程</h3><p>int9中断例程负责处理用户的键盘输入，分为两个状态。</p>
<ul>
<li>用户在主选单时<ul>
<li>输入按键1：重新启动计算机，跳到ffff:0执行</li>
<li>输入按键2：首先复原BIOS的int9中断例程，然后清屏，将硬盘的第一个扇区读取到内存0:7c00处，然后跳转到0:7c00进行硬盘引导</li>
<li>输入按键3：保存屏幕（主选单），清屏，修改模式为1（动态显示时间）</li>
<li>输入按键4：首先需要复原BIOS的int9中断例程，保存屏幕（主选单），清屏，显示提示字符串，等待用户输入日期时间，检查格式是否正确，将时间设置到CMOS RTC上。完成之后恢复屏幕，重新安装我们包装的int 9中断例程。</li>
</ul>
</li>
<li>用户在时钟程序时<ul>
<li>输入按键F1：改变显示的颜色</li>
<li>输入按键Esc：恢复屏幕，修改模式为0（主选单）</li>
</ul>
</li>
</ul>
<h3 id="处理用户输入的时间"><a href="#处理用户输入的时间" class="headerlink" title="处理用户输入的时间"></a>处理用户输入的时间</h3><p>我们使用一个字符栈来保存用户输入的字符，同时用一个变量top保存当前栈顶的位置。</p>
<ul>
<li>当用户输入字符时：首先检查是否到栈顶， 到了栈顶则忽略，否则将字符入栈，然后更新屏幕显示</li>
<li>当用户输入退格键时：如果栈是空的，不做啥操作，否则弹出一个字符，然后更新屏幕显示</li>
<li>当用户输入Enter键时：结束输入过程</li>
</ul>
<h2 id="避坑指南"><a href="#避坑指南" class="headerlink" title="避坑指南"></a>避坑指南</h2><p>笔者在编码测试过程碰到了许多的问题，汇编的调试不是那么方便，有些bug还藏得比较隐蔽，所以花了不少时间来调试问题。笔者痛定思痛，含泪总结了下面这几条，希望对有类似经历的朋友有所帮助。</p>
<ul>
<li>逻辑独立的程序块最好设计成子程序<ul>
<li>一方面，是因为条件转移指令只能是短转移，程序太长会超出其范围。</li>
<li>另一方面，代码逻辑更加清晰，而且可以单独进行单元测试，否则全部写到一块后面问题会比较难定位。</li>
<li>子程序在实现的时候一定要标注好参数和返回值的情况，前提条件和后置条件，这关系到寄存器的使用。</li>
</ul>
</li>
<li>寄存器的保护<ul>
<li>被调用者保护的寄存器：调用方在调用子函数前，需要先备份它。我们这里主要是返回值用到的寄存器。</li>
<li>调用者保护的寄存器：子函数在修改前需要先保存原值</li>
<li>push和pop一定要对应，顺序相反，建议加了一个push之后立马写对应的pop，否则很可能遗忘。</li>
</ul>
</li>
<li>内存的操作<ul>
<li>处理内存的时候一定要注意长度，尤其是寄存器一起使用的指令，要使用对应长度的寄存器，这个如果搞错了编译器也是不会给出报错的。</li>
<li>内存寻址时段寄存器最好不要省略，避免疏忽造成不必要的bug。（比如用到了bp寄存器，段地址默认在ss中）</li>
</ul>
</li>
<li>合理安排寄存器的使用<ul>
<li>寄存器是稀缺资源，总共就这么十几个，有些使用场景还受限</li>
<li>首先确定内存寻址需要用到的寄存器，内存寻址只能使用这几个寄存器：bx/bp、di/si。可以单独使用，也可以左右两个组合使用。提示：其中bx可以分成bl和bh使用，其他几个则只能作为整体使用，所以有些场景可能只有bx能胜任。</li>
<li>其次是确定指令、子程序或中断规定使用的寄存器</li>
<li>字节的操作只能使用ah/al、bh/hl、ch/cl、dh/dl，其余寄存器不能拆分使用。</li>
<li>如果寄存器实在不够用，就只能临时先压栈，然后用完再出栈。或者将程序分拆为多个子程序。</li>
</ul>
</li>
<li>注意标号的偏移地址，是其在安装程序中的偏移地址，并不是后面任务程序从启动盘被读取到内存中之后的偏移地址。所以我们访问数据时需要对偏移地址做修正。（<code>call 标号</code>指令在编译成机器码时会转成相对位移，所以可以直接使用标号）</li>
<li>留心程序中的竞争问题，因为中断随时可能发生，需要注意中断例程和主程序中都用到的数据，必要时可以关中断。</li>
<li>名字相似的指令不要打错，比如and和add指令，它们真的太像了，我至少在它们上面栽了两个跟头。</li>
</ul>
<h2 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h2><p>接下来来看实际代码实现，首先看下整体的框架，然后看每个部分的细节。</p>
<h3 id="程序框架"><a href="#程序框架" class="headerlink" title="程序框架"></a>程序框架</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code, ss:stack, ds:data</span><br><span class="line">stack segment</span><br><span class="line">    dw 64 dup(0)</span><br><span class="line">stack ends</span><br><span class="line">data segment</span><br><span class="line">    mes db &#x27;fail to write to floppy!&#x27;, 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">; 任务程序引导部分（1个扇区512字节）</span><br><span class="line">; 功能: 将任务程序的主体部分读入内存</span><br><span class="line">; 第一个扇区由BIOS读入内存0:7c00h处</span><br><span class="line">boot:</span><br><span class="line">; 从第二个扇区开始读取到0:7e00h处</span><br><span class="line">; 然后跳转到任务程序主体部分task</span><br><span class="line">        省略...</span><br><span class="line">        db 512-($-boot) dup(0)  ; pad到512字节</span><br><span class="line">        </span><br><span class="line">; 任务程序主体部分（3个扇区1536字节）</span><br><span class="line">; 功能：处理用户输入，执行对应操作</span><br><span class="line">; 程序位于内存0:7e00h处</span><br><span class="line">task:</span><br><span class="line">        省略...</span><br><span class="line">        db 1536-($-task) dup(0)  ; pad到3个扇区的长度</span><br><span class="line">        </span><br><span class="line">; 任务程序数据部分（1个扇区512字节）</span><br><span class="line">dat:</span><br><span class="line">        省略...</span><br><span class="line">        db 512-($-dat) dup(0)           ; pad到512字节</span><br><span class="line">        </span><br><span class="line">; 安装程序: 将任务程序写到软盘上</span><br><span class="line">start:</span><br><span class="line">        省略...</span><br><span class="line">ok:</span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>可以看到我们的代码段分为4大块，除了安装程序之外，是任务程序的引导部分、主体部分以及数据部分。我们在任务程序的每个部分最后都做了补0处理，补齐到扇区的长度，使操作更方便。另外，将数据单独放在一个扇区中，方便计算偏移，进行数据的访问。</p>
<h3 id="安装程序-1"><a href="#安装程序-1" class="headerlink" title="安装程序"></a>安装程序</h3><p>我们先来看安装程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 安装程序: 将任务程序写到软盘上</span><br><span class="line">start:</span><br><span class="line">        mov ax, data</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov ax, stack</span><br><span class="line">        mov ss, ax</span><br><span class="line">        mov sp, 128</span><br><span class="line"></span><br><span class="line">        mov ax, cs</span><br><span class="line">        mov es, ax</span><br><span class="line">        mov bx, offset boot     ; es:bx 指向缓存数据的内存地址</span><br><span class="line"></span><br><span class="line">        mov al, 5               ; 读写的扇区数</span><br><span class="line">        mov ch, 0               ; 磁道号</span><br><span class="line">        mov cl, 1               ; 扇区号</span><br><span class="line">        mov dl, 0               ; 驱动器号  软驱从0开始，0:软驱A，1:软驱B；</span><br><span class="line">                                ; 硬盘从80h开始，80h：硬盘C，81h：硬盘D</span><br><span class="line">        mov dh, 0               ; 磁头号（对于软盘即面号）</span><br><span class="line">        mov ah, 3               ; 功能号，2表示读扇区，3表示写扇区</span><br><span class="line">        int 13h</span><br><span class="line"></span><br><span class="line">        cmp ah, 0</span><br><span class="line">        je ok</span><br><span class="line">        mov dh, 10</span><br><span class="line">        mov dl, 10</span><br><span class="line">        mov si, 0</span><br><span class="line">        call showstr</span><br><span class="line">ok:</span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br></pre></td></tr></table></figure>

<p>首先设置段寄存器，然后将es:bx指向代码段的开头即boot的位置，我们将从这个位置开始写5个扇区到软盘中。如果写磁盘成功，则程序结束；否则显示一条错误信息。其中<code>showstr</code>是我们封装的子程序，用于在屏幕指定位置显示以0结尾的字符串。</p>
<h3 id="任务程序引导部分-1"><a href="#任务程序引导部分-1" class="headerlink" title="任务程序引导部分"></a>任务程序引导部分</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 任务程序引导部分（1个扇区512字节）</span><br><span class="line">; 功能: 将任务程序的主体部分读入内存</span><br><span class="line">; 第一个扇区由BIOS读入内存0:7c00h处</span><br><span class="line">boot:</span><br><span class="line">; 从第二个扇区开始读取到0:7e00h处</span><br><span class="line">; 然后跳转到任务程序主体部分task</span><br><span class="line">        mov ax, 0</span><br><span class="line">        mov es, ax</span><br><span class="line">        mov bx, 7e00h           ; es:bx 指向接收从扇区读取数据的内存区</span><br><span class="line"></span><br><span class="line">        mov al, 4               ; 读取的扇区数</span><br><span class="line">        mov ch, 0               ; 磁道号(0~79)</span><br><span class="line">        mov cl, 2               ; 扇区号(1~18)，第二个扇区开始</span><br><span class="line">        mov dl, 0               ; 驱动器号  软驱从0开始，0:软驱A，1:软驱B</span><br><span class="line">                                ; 硬盘从80h开始，80h：硬盘C，81h：硬盘D</span><br><span class="line">        mov dh, 0               ; 磁头号(0~1)（对于软盘即面号）</span><br><span class="line">        mov ah, 2               ; 功能号，2表示读扇区，3表示写扇区</span><br><span class="line">        int 13h</span><br><span class="line">        ; 这里失败的话，回退到从硬盘启动</span><br><span class="line"></span><br><span class="line">        jmp bx                  ; 跳转到任务程序主体部分task</span><br><span class="line"></span><br><span class="line">        db 512-($-boot) dup(0)  ; pad到512字节</span><br></pre></td></tr></table></figure>

<p>引导部分负责将任务程序的主体部分读到内存中，我们这里选择读到0:7e00h处，紧跟在第一个引导扇区后面。总共读了4个扇区，其中3个扇区代码、1个扇区数据。读完之后，跳转到0:7e00h处执行。</p>
<h3 id="数据部分"><a href="#数据部分" class="headerlink" title="数据部分"></a>数据部分</h3><p>我们将所有的数据集中到了一起以方便访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 任务程序数据部分（1个扇区512字节）</span><br><span class="line">dat:</span><br><span class="line">    ; 相对task偏移+7e00h</span><br><span class="line">    ; m1:0, m2:1, m3:2, m4:3, m5:4</span><br><span class="line">    dw offset m1-task+7e00h, offset m2-task+7e00h, offset m3-task+7e00h</span><br><span class="line">    dw offset m4-task+7e00h, offset m5-task+7e00h</span><br><span class="line">    m1 db &#x27;--------------------------------------MENU--------------------------------------&#x27;, 0</span><br><span class="line">    m2 db &#x27;1) reset pc&#x27;, 0          ; 重新启动计算机</span><br><span class="line">    m3 db &#x27;2) start system&#x27;, 0      ; 引导现有的操作系统</span><br><span class="line">    m4 db &#x27;3) clock&#x27;, 0             ; 进入时钟程序</span><br><span class="line">    m5 db &#x27;4) set clock&#x27;, 0         ; 设置时间</span><br><span class="line">    prompt db &#x27;time format: yy/MM/dd hh:mm:ss&#x27;, 0   ; 设置时间提示字符串</span><br><span class="line">    timeformat db &#x27;yy/MM/dd hh:mm:ss&#x27;, 0            ; 时间格式</span><br><span class="line">    timeoffset db 9, 8, 7, 4, 2, 0                  ; CMOS时间各项寄存器号</span><br><span class="line">    old9 dd 0                       ; 保存int9中断原本的地址</span><br><span class="line">    mode db 0                       ; int9中断例程模式，0表示主选项，1表示时间程序</span><br><span class="line">    charstk db 32 dup(0)            ; 设置时间的字符栈</span><br><span class="line">    top dw 0</span><br><span class="line">    digitoffset db 0,1,3,4,6,7,9,10,12,13,15,16     ; 时间字符串中数字的偏移</span><br><span class="line">    daysofmonth db 0,31,29,31,30,31,30,31,31,30,31,30,31     ; 每个月的天数</span><br><span class="line">    hextable db &#x27;0123456789ABCDEF&#x27;  ; 十六进制打印</span><br><span class="line"></span><br><span class="line">    db 512-($-dat) dup(0)           ; pad到512字节</span><br></pre></td></tr></table></figure>



<h3 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h3><p>引导程序将程序的剩余部分读取到内存之后，会跳转到主程序开始这里开始执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 任务程序主体部分（3个扇区1536字节）</span><br><span class="line">; 功能：处理用户输入，执行对应操作</span><br><span class="line">; 程序位于内存0:7e00h处</span><br><span class="line">task:</span><br><span class="line">;主程序逻辑：</span><br><span class="line">;- 首先注册主菜单int9中断例程</span><br><span class="line">;- 显示菜单</span><br><span class="line">;- 无限循环, 根据模式标志决定是否显示时间</span><br><span class="line">        mov ax, 0               ;</span><br><span class="line">        mov ds, ax              ; 主程序中将ds设为0</span><br><span class="line"></span><br><span class="line">        call mount9             ; 注册包装过的int9中断例程</span><br><span class="line"></span><br><span class="line">        mov cx, 5               ; 显示主菜单，5行</span><br><span class="line">        mov di, 0               ;</span><br><span class="line">        mov dh, 0               ; 行号</span><br><span class="line">        mov dl ,0               ; 列号</span><br><span class="line">s:</span><br><span class="line">        mov si, 8400h[di]       ; 菜单字符串偏移</span><br><span class="line">        call showstr</span><br><span class="line">        inc dh</span><br><span class="line">        add di, 2               ; 指向下一个字符串的偏移</span><br><span class="line">        loop s                  ;</span><br><span class="line"></span><br><span class="line">        mov dh, 5               ; 行号</span><br><span class="line">        mov dl, 0               ; 列号</span><br><span class="line">        mov bx, 0               ; bh页号</span><br><span class="line">        mov ah, 2               ; 功能号2: 设置光标</span><br><span class="line">        int 10h</span><br><span class="line">        </span><br><span class="line">        mov bx, offset mode-task+7e00h</span><br><span class="line">        mov si, offset timeformat-task+7e00h    ; +3</span><br><span class="line">        mov dh, 0</span><br><span class="line">        mov dl, 0</span><br><span class="line">        ; 进入无限循环</span><br><span class="line">s1:</span><br><span class="line">        call getclock           ; 从CMOS读取时间</span><br><span class="line">        pushf</span><br><span class="line">        cli                     ; 屏蔽中断，防止中断中将模式改为0后，还显示时间</span><br><span class="line">        cmp byte ptr [bx], 0    ; 模式值</span><br><span class="line">        je skiptime</span><br><span class="line">        call showstr            ; 显示从CMOS读取的时间</span><br><span class="line">skiptime:</span><br><span class="line">        popf</span><br><span class="line">        jmp s1</span><br></pre></td></tr></table></figure>

<p><code>getclock</code>是我们封装的一个子程序，用于从CMOS读取时间写到<code>timeformat</code>所在的位置。最后在显示字符串的地方，我们关闭了中断，因为int 9中断中随时可能将发生，如果在主程序判断模式的值和完成时间显示之间，中断例程将模式从1改为0，那么显示就会出现问题。</p>
<h3 id="中断例程的注册及恢复"><a href="#中断例程的注册及恢复" class="headerlink" title="中断例程的注册及恢复"></a>中断例程的注册及恢复</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 用于注册新的int 9中断例程，原来的中断向量保存在old9的位置</span><br><span class="line">mount9:</span><br><span class="line">        push ax</span><br><span class="line">        push si</span><br><span class="line">        mov si, offset old9-task+7e00h</span><br><span class="line">        mov ax, ds:[9*4]        ; 保存原来的中断例程的偏移地址</span><br><span class="line">        mov [si], ax            ; 保存到old9位置</span><br><span class="line">        mov ax, ds:[9*4+2]      ; 保存原来的中断例程的段地址</span><br><span class="line">        mov [si].2, ax          ; 保存到old9+2位置</span><br><span class="line"></span><br><span class="line">        pushf</span><br><span class="line">        cli                     ; 屏蔽中断，防止中断向量出现非法状态</span><br><span class="line">        mov ds:[9*4], offset int9 + 7c00h   ; 设置新的int9偏移, +7c00h修正</span><br><span class="line">        mov word ptr ds:[9*4+2], 0h     ; 新的int9段地址, 9000h</span><br><span class="line">        popf</span><br><span class="line"></span><br><span class="line">        pop si</span><br><span class="line">        pop ax</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p><code>mount9</code>用于注册新的int 9中断例程，将对应的中断向量设置为新的中断例程<code>int9</code>的偏移地址。因为我们还要用来原来的中断例程，所以将其中断向量保存在<code>old9</code>所在的位置。</p>
<p>同样地，这里在修改中断向量之前，我们也屏蔽了中断。因为修改偏移地址和段地址至少需要两个指令，如果在两者之间正好发生了中断，那么中断向量就处于一个非法的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 恢复int 9中断例程为BIOS自带的那个</span><br><span class="line">umount9:</span><br><span class="line">        push ax</span><br><span class="line">        push si</span><br><span class="line">        mov si, offset old9-task+7e00h</span><br><span class="line">        pushf</span><br><span class="line">        cli                     ; 屏蔽中断，防止中断向量出现非法状态</span><br><span class="line">        mov ax, [si]</span><br><span class="line">        mov ds:[9*4], ax        ; 偏移地址</span><br><span class="line">        mov ax, [si].2</span><br><span class="line">        mov ds:[9*4+2], ax      ; 段地址</span><br><span class="line">        popf</span><br><span class="line"></span><br><span class="line">        pop si</span><br><span class="line">        pop ax</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p><code>umount9</code>则是将old9中保存的中断向量恢复到中断向量表中对应的位置。</p>
<h3 id="int-9中断例程实现"><a href="#int-9中断例程实现" class="headerlink" title="int 9中断例程实现"></a>int 9中断例程实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;主选菜单int9中断例程逻辑：（处理字符1~4）</span><br><span class="line">;- 用户输入1，重新启动计算机，跳到ffff:0执行</span><br><span class="line">;- 用户输入2，首先复原int9中断例程，然后清屏，将硬盘第一个扇区内容读到0:7c00，跳转到0:7c00</span><br><span class="line">;- 用户输入3，保存屏幕(主选单)，清屏，修改模式为1(动态显示时间)</span><br><span class="line">;- 用户输入4，首先复原int9中断例程，保存屏幕(主选单)，清屏，显示提示字符串</span><br><span class="line">;             等待用户输入日期时间，检查格式是否正确，将时间设置到CMOS RTC上</span><br><span class="line">;             完成之后恢复屏幕，重新安装我们包装的int 9中断例程。</span><br><span class="line">;</span><br><span class="line">;时钟程序int9中断例程逻辑：（处理F1和Esc）</span><br><span class="line">;- 用户输入F1，改变显示颜色</span><br><span class="line">;- 用户输入Esc，恢复屏幕，修改模式为0（主选单）</span><br><span class="line">int9:</span><br><span class="line">        push ax</span><br><span class="line">        push bx</span><br><span class="line">        push si</span><br><span class="line"></span><br><span class="line">        pushf                   ; 中断过程：标志寄存器入栈</span><br><span class="line">        mov si, offset old9-task+7e00h</span><br><span class="line">        call dword ptr [si]     ; 中断过程：模拟int9</span><br><span class="line"></span><br><span class="line">int9s:</span><br><span class="line">        mov ah, 1               ; int9进来，键盘缓冲区不一定有数据</span><br><span class="line">        int 16h</span><br><span class="line">        je int9ret</span><br><span class="line"></span><br><span class="line">        mov ah, 0</span><br><span class="line">        int 16h                 ; 读取键盘缓冲区,防止键盘缓冲区溢出</span><br><span class="line">                                ; (ah)=scan code, (al)=ascii</span><br><span class="line">                                </span><br><span class="line">int9s1:</span><br><span class="line">        ;in al, 60h      ; 从60h端口读取扫描码</span><br><span class="line">        mov bx, offset mode-task+7e00h</span><br><span class="line">        mov al, [bx]            ; 获取模式值</span><br><span class="line">        cmp al, 1</span><br><span class="line">        je timemode</span><br><span class="line">        cmp ah, 02              ; 1的扫描码02</span><br><span class="line">        je sub1</span><br><span class="line">        cmp ah, 03              ; 2的扫描码03</span><br><span class="line">        je sub2</span><br><span class="line">        cmp ah, 04              ; 3的扫描码04</span><br><span class="line">        je sub3</span><br><span class="line">        cmp ah, 05              ; 4的扫描码05</span><br><span class="line">        je sub4</span><br><span class="line">        jmp int9ret</span><br><span class="line">timemode:</span><br><span class="line">        cmp ah, 3bh             ; F1的扫描码3bh</span><br><span class="line">        je subf1</span><br><span class="line">        cmp ah, 01              ; Esc的扫描码01</span><br><span class="line">        je subesc</span><br><span class="line">        jmp int9ret</span><br><span class="line">int9ret:</span><br><span class="line">        pop si</span><br><span class="line">        pop bx</span><br><span class="line">        pop ax</span><br><span class="line">        iret</span><br></pre></td></tr></table></figure>

<p>首先调用BIOS的int 9中断例程进行处理，这里为了模拟<code>int</code>指令的操作，我们手动模拟中断过程。中断过程可以简单描述如下：</p>
<ol>
<li>取得中断类型码N</li>
<li>pushf</li>
<li>TF=0, IF=0</li>
<li>push CS</li>
<li>push IP</li>
<li>(IP)=(N*4), (CS)=(N*4+2)</li>
</ol>
<p>其中第一步已经知道，我们需要手动执行<code>pushf</code>将标志寄存器入栈，第三步外部已经置0也可以省略，4～6步通过<code>call</code>指令实现。</p>
<p>然后我们通过int 16h中断从键盘缓冲区读取数据，为了防止缓冲区溢出，这里读取之后将缓冲区中对应数据移除。（实际测试发现如果不移除，缓冲区满了之后键盘输入就没有响应了）。</p>
<p>获取到键盘扫描码之后，首先判断当前模式，如果是模式0，处理按键1~4；如果是模式1，处理按键F1和Esc。处理结束之后都会跳到int9ret处中断返回。</p>
<p>接下来依次来看每个按键的处理</p>
<h4 id="按键1-重新启动"><a href="#按键1-重新启动" class="headerlink" title="按键1: 重新启动"></a>按键1: 重新启动</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub1:</span><br><span class="line">        pop si</span><br><span class="line">        pop ax</span><br><span class="line">        mov ax, 0ffffh</span><br><span class="line">        push ax</span><br><span class="line">        mov ax, 0</span><br><span class="line">        push ax</span><br><span class="line">        retf                    ; 0ffffh:0</span><br></pre></td></tr></table></figure>

<p>按键1的处理非常简单，直接跳转到ffff:0即可。</p>
<h4 id="按键2-boot操作系统"><a href="#按键2-boot操作系统" class="headerlink" title="按键2: boot操作系统"></a>按键2: boot操作系统</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub2:</span><br><span class="line">        push cx</span><br><span class="line">        push dx</span><br><span class="line">        push es</span><br><span class="line">        call umount9            ; 调用umount9</span><br><span class="line"></span><br><span class="line">        ; 清屏</span><br><span class="line">        mov ah, 0               ; 功能号0, 清屏</span><br><span class="line">        call screen</span><br><span class="line"></span><br><span class="line">        mov dh, 0               ; 行号</span><br><span class="line">        mov dl, 0               ; 列号</span><br><span class="line">        mov bx, 0               ; bh页号</span><br><span class="line">        mov ah, 2               ; 功能号2: 设置光标</span><br><span class="line">        int 10h</span><br><span class="line"></span><br><span class="line">; 从硬盘第一个扇区读取到0:7c00h处</span><br><span class="line">; 然后跳转</span><br><span class="line">        mov ax, 0</span><br><span class="line">        mov es, ax</span><br><span class="line">        mov bx, 7c00h           ; es:bx 指向接收从扇区读取数据的内存区</span><br><span class="line"></span><br><span class="line">        mov al, 1               ; 读取的扇区数</span><br><span class="line">        mov ch, 0               ; 磁道号</span><br><span class="line">        mov cl, 1               ; 扇区号，第一个扇区开始</span><br><span class="line">        mov dl, 80h             ; 驱动器号  软驱从0开始，0:软驱A，1:软驱B；硬盘从80h开始，80h：硬盘C，81h：硬盘D</span><br><span class="line">        mov dh, 0               ; 磁头号（对于软盘即面号）</span><br><span class="line">        mov ah, 2               ; 功能号，2表示读扇区，3表示写扇区</span><br><span class="line">        int 13h</span><br><span class="line"></span><br><span class="line">        ; 需要清栈么</span><br><span class="line">        jmp bx                  ; 跳转到硬盘引导</span><br></pre></td></tr></table></figure>

<p>按键2从硬盘引导现有操作系统，为了不影响后面的显示，我们先进行清屏操作，将光标设到开头，然后将硬盘的第一个扇区读取到0:7c00处，最后跳转到0:7c00处开始执行。</p>
<h4 id="按键3-动态显示CMOS时间"><a href="#按键3-动态显示CMOS时间" class="headerlink" title="按键3: 动态显示CMOS时间"></a>按键3: 动态显示CMOS时间</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub3:</span><br><span class="line">        ; 保存屏幕</span><br><span class="line">        mov ah, 2               ; 功能号2, 保存</span><br><span class="line">        call screen</span><br><span class="line"></span><br><span class="line">        ; 清屏</span><br><span class="line">        mov ah, 0               ; 功能号0, 清屏</span><br><span class="line">        call screen</span><br><span class="line"></span><br><span class="line">        mov byte ptr [bx], 1    ; 模式改为1</span><br><span class="line"></span><br><span class="line">        push dx</span><br><span class="line">        mov dh, 0               ; 行号</span><br><span class="line">        mov dl, 17              ; 列号</span><br><span class="line">        mov bx, 0               ; bx已经不用了, 可以覆盖</span><br><span class="line">        mov ah, 2               ; 功能号2: 设置光标</span><br><span class="line">        int 10h</span><br><span class="line">        pop dx</span><br><span class="line"></span><br><span class="line">        jmp int9ret</span><br></pre></td></tr></table></figure>

<p><code>screen</code>是我们封装的一个子程序，负责屏幕相关操作。首先保存当前屏幕（主选单），然后清屏，将模式改为1，最后为了美观一点将光标设置到了时间后面。中断例程只是修改了模式，时间的动态显示在外面中程序循环中进行。因为在动态显示时间的时候，也是需要处理键盘按键中断的。</p>
<h4 id="按键4-设置CMOS时间"><a href="#按键4-设置CMOS时间" class="headerlink" title="按键4: 设置CMOS时间"></a>按键4: 设置CMOS时间</h4><p>按键4的处理稍微有点复杂，我们一点点来看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub4:</span><br><span class="line">        push dx</span><br><span class="line">        call umount9            ; 恢复原来的int 9中断例程</span><br><span class="line"></span><br><span class="line">        mov ah, 2               ; 功能号2, 保存屏幕</span><br><span class="line">        call screen</span><br><span class="line"></span><br><span class="line">sub4s:</span><br><span class="line">        mov ah, 0               ; 功能号0, 清屏</span><br><span class="line">        call screen</span><br><span class="line"></span><br><span class="line">        mov si, offset prompt-task+7e00h</span><br><span class="line">        mov dh, 0</span><br><span class="line">        mov dl, 0</span><br><span class="line">        call showstr            ; 显示提示字符串</span><br><span class="line"></span><br><span class="line">        mov dh, 1               ; 行号</span><br><span class="line">        mov bx, 0               ; bx已经不用了, 可以覆盖</span><br><span class="line">        mov ah, 2               ; 功能号2: 设置光标</span><br><span class="line">        int 10h</span><br><span class="line">        mov si, offset charstk-task+7e00h</span><br><span class="line">        call inputclock         ; 用户输入字符串</span><br><span class="line">        call checkclock         ; 检查字符串格式是否合法</span><br><span class="line">        cmp ah, 0</span><br><span class="line">        jne sub4s               ; 格式不正确，重新输入</span><br><span class="line"></span><br><span class="line">        call setclock           ; 写到CMOS RTC</span><br><span class="line"></span><br><span class="line">        mov ah, 3               ; 功能号3, 恢复屏幕</span><br><span class="line">        call screen             ; call screen</span><br><span class="line"></span><br><span class="line">        mov dh, 5               ; 行号</span><br><span class="line">        mov dl, 0               ; 列号</span><br><span class="line">        mov bx, 0               ; bx已经不用了, 可以覆盖</span><br><span class="line">        mov ah, 2               ; 功能号2: 设置光标</span><br><span class="line">        int 10h</span><br><span class="line"></span><br><span class="line">        call mount9             ; 重新注册新的int9中断例程</span><br><span class="line">        pop dx</span><br><span class="line">        jmp int9ret</span><br></pre></td></tr></table></figure>

<p>首先调用<code>umount9</code>恢复原来的int 9中断例程，不再额外处理那些键盘输入，接着保存当前屏幕（主选单）并清屏，然后显示一个提示字符串并显示光标到下一行。</p>
<p>这些准备工作做完之后，就调用<code>intputclock</code>让用户输入字符串，用户完成输入之后调用<code>checkclock</code>检查格式是否正确，如果不正确跳到前面重新输入。如果格式正确，则调用<code>setclock</code>将时间写到CMOS上。</p>
<p>完成设置之后，还有一些恢复的工作别忘了，需要恢复屏幕及光标位置，然后重新注册int 9中断例程。</p>
<h4 id="按键F1-修改显示颜色"><a href="#按键F1-修改显示颜色" class="headerlink" title="按键F1: 修改显示颜色"></a>按键F1: 修改显示颜色</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subf1:</span><br><span class="line">        mov ah, 1               ; 功能号1, 修改颜色</span><br><span class="line">        call screen</span><br><span class="line">        jmp int9ret</span><br></pre></td></tr></table></figure>

<p>因为我们将屏幕的相关操作都封装成了screen函数，所以这里简单调用即可</p>
<h4 id="按键Esc-退出时间显示，恢复为主选单"><a href="#按键Esc-退出时间显示，恢复为主选单" class="headerlink" title="按键Esc: 退出时间显示，恢复为主选单"></a>按键Esc: 退出时间显示，恢复为主选单</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subesc:</span><br><span class="line">        ; 恢复屏幕</span><br><span class="line">        mov ah, 3               ; 功能号3, 恢复</span><br><span class="line">        call screen</span><br><span class="line"></span><br><span class="line">        mov byte ptr [bx], 0    ; 模式改为0</span><br><span class="line"></span><br><span class="line">        push dx</span><br><span class="line">        mov dh, 5               ; 行号</span><br><span class="line">        mov dl, 0               ; 列号</span><br><span class="line">        mov bx, 0               ; bx已经不用了, 可以覆盖</span><br><span class="line">        mov ah, 2               ; 功能号2: 设置光标</span><br><span class="line">        int 10h</span><br><span class="line">        pop dx</span><br><span class="line"></span><br><span class="line">        jmp int9ret</span><br></pre></td></tr></table></figure>

<p>这个也比较简单，恢复屏幕，设置光标位置，将模式修改为0。</p>
<h3 id="屏幕操作子程序"><a href="#屏幕操作子程序" class="headerlink" title="屏幕操作子程序"></a>屏幕操作子程序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 屏幕相关操作</span><br><span class="line">; ah 功能号: 0清屏, 1换颜色, 2保存当前屏幕，3恢复保存的屏幕</span><br><span class="line">; 从第0页保存到第1页，从第1页恢复到第0页</span><br><span class="line">screen:</span><br><span class="line">        push ax</span><br><span class="line">        push bx</span><br><span class="line">        push cx</span><br><span class="line">        push ds</span><br><span class="line">        push es</span><br><span class="line">        push si</span><br><span class="line">        push di</span><br><span class="line"></span><br><span class="line">        cmp ah, 0</span><br><span class="line">        je clear</span><br><span class="line">        cmp ah, 1</span><br><span class="line">        je color</span><br><span class="line">        cmp ah, 2</span><br><span class="line">        je save</span><br><span class="line">        cmp ah, 3</span><br><span class="line">        je restore</span><br><span class="line">        jmp screenret</span><br><span class="line">        </span><br><span class="line">        ; 省略</span><br><span class="line">screenret:</span><br><span class="line">        pop di</span><br><span class="line">        pop si</span><br><span class="line">        pop es</span><br><span class="line">        pop ds</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        pop ax</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p><code>screen</code>子程序包含4个功能，由ah寄存器指定功能号。</p>
<p>(ah)=0表示清屏操作，修改第0页的显示缓冲区，所有字符都改成空格，颜色属性改成黑底白字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear:</span><br><span class="line">        mov ax, 0b800h                  ; 显示缓冲区第0页起始地址</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov si, 0</span><br><span class="line">        mov cx, 2000                    ; 80 * 25</span><br><span class="line">clears:</span><br><span class="line">        mov byte ptr [si], &#x27; &#x27;          ; 清屏</span><br><span class="line">        mov byte ptr [si].1, 00000111b  ; 黑底白字</span><br><span class="line">        add si, 2</span><br><span class="line">        loop clears</span><br><span class="line">        jmp screenret</span><br></pre></td></tr></table></figure>

<p>(ah)=1表示修改显示颜色，操作跟上面类似</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">color:</span><br><span class="line">        mov ax, 0b800h                  ; 显示缓冲区第0页起始地址</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov si, 1</span><br><span class="line">        mov cx, 2000                    ; 80 * 25</span><br><span class="line">colors:</span><br><span class="line">        inc byte ptr [si]               ; 修改颜色</span><br><span class="line">        add si, 2</span><br><span class="line">        loop colors</span><br><span class="line">        jmp screenret</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(ah)=2表示保存当前屏幕，我们选择将显示缓冲区第0页内容拷贝到了第1页中。这里使用了串处理指令简化代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save:</span><br><span class="line">        mov ax, 0b800h                  ; 第0页起始地址</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov si, 0</span><br><span class="line">        mov ax, 0b8fah                  ; 第1页起始地址</span><br><span class="line">        mov es, ax</span><br><span class="line">        mov di, 0</span><br><span class="line">        mov cx, 4000                    ; 80 * 25 * 2</span><br><span class="line">        cld                             ; df=0</span><br><span class="line">        rep movsb</span><br><span class="line">        jmp screenret</span><br></pre></td></tr></table></figure>

<p>(ah)=2表示恢复保存的屏幕，也即执行跟前一个相反的操作，将第1页的内容拷贝到第0页。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">restore:</span><br><span class="line">        mov ax, 0b8fah                  ; 第1页起始地址</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov si, 0</span><br><span class="line">        mov ax, 0b800h                  ; 第0页起始地址</span><br><span class="line">        mov es, ax</span><br><span class="line">        mov di, 0</span><br><span class="line">        mov cx, 4000</span><br><span class="line">        cld                             ; df=0</span><br><span class="line">        rep movsb</span><br></pre></td></tr></table></figure>

<h3 id="时间输入子程序"><a href="#时间输入子程序" class="headerlink" title="时间输入子程序"></a>时间输入子程序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 输入时间，从键盘缓冲区读取</span><br><span class="line">; dh, dl 显示的行号列号</span><br><span class="line">; ds:si 指向字符栈起始位置</span><br><span class="line">inputclock:</span><br><span class="line">        push ax</span><br><span class="line">        push bx</span><br><span class="line">        push si</span><br><span class="line"></span><br><span class="line">        mov bx, offset top-task+7e00h</span><br><span class="line">        mov word ptr [bx], 0    ; top先清0</span><br><span class="line"></span><br><span class="line">        ; 先清空键盘缓冲区</span><br><span class="line">cleanbuf:</span><br><span class="line">        mov ah, 1</span><br><span class="line">        int 16h</span><br><span class="line">        je getstrs</span><br><span class="line">        mov ah, 0</span><br><span class="line">        int 16h</span><br><span class="line">        jmp cleanbuf</span><br><span class="line">        </span><br><span class="line">getstrs:</span><br><span class="line">        mov ah, 0</span><br><span class="line">        int 16h</span><br><span class="line">        cmp al, 20h             ; ASCII码小于20h，说明不是字符</span><br><span class="line">        jb nochar</span><br><span class="line">        mov ah, 0</span><br><span class="line">        call charstack          ; 字符入栈</span><br><span class="line">        mov ah, 2</span><br><span class="line">        call charstack          ; 显示栈中的字符</span><br><span class="line">        jmp getstrs</span><br><span class="line">nochar:</span><br><span class="line">        cmp ah, 0eh             ; 退格键的扫描码</span><br><span class="line">        je backspace</span><br><span class="line">        cmp ah, 1ch             ; Enter键的扫描码</span><br><span class="line">        je enter</span><br><span class="line">        jmp getstrs</span><br><span class="line">backspace:</span><br><span class="line">        mov ah, 1</span><br><span class="line">        call charstack          ; 字符出栈</span><br><span class="line">        mov ah, 2</span><br><span class="line">        call charstack          ; 显示栈中的字符</span><br><span class="line">        jmp getstrs</span><br><span class="line">enter:</span><br><span class="line">        pop si</span><br><span class="line">        pop bx</span><br><span class="line">        pop ax</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>我们使用一个字符栈来保存用户输入的字符串，为了代码的简洁将字符栈的相关操作封装成了<code>charstack</code>子程序。</p>
<p>首先将top清零，保险起见将键盘缓冲区清理了一下。接下来调用int 16h中断读取用户的键盘输入，如果是字符就入栈，如果是退格键就出栈，如果是Enter键则结束输入。每次用户做了修改之后，更新显示。</p>
<p>字符栈的子程序实现如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 字符栈的入栈、出栈和显示</span><br><span class="line">; 参数说明: (ah)=功能号，0入栈，1出栈，2显示</span><br><span class="line">;           ds:si 指向字符栈空间</span><br><span class="line">;           对于0号功能: (al)=入栈字符</span><br><span class="line">;           对于1号功能: (al)=返回的字符</span><br><span class="line">;           对于2号功能: (dh)和(dl)=字符串在屏幕上显示的行、列</span><br><span class="line">charstack:</span><br><span class="line">        push bx</span><br><span class="line">        push di</span><br><span class="line">        push es</span><br><span class="line">        push bp</span><br><span class="line">        mov bp, offset top-task+7e00h</span><br><span class="line">        cmp ah, 0</span><br><span class="line">        je charpush</span><br><span class="line">        cmp ah, 1</span><br><span class="line">        je charpop</span><br><span class="line">        cmp ah, 2</span><br><span class="line">        je charshow</span><br><span class="line">        jmp charret</span><br><span class="line">        </span><br><span class="line">charpush:</span><br><span class="line">        mov bx, ds:[bp]         ; top的值</span><br><span class="line">        cmp bx, 31              ; 防止溢出</span><br><span class="line">        ja charret</span><br><span class="line">        mov [si][bx], al</span><br><span class="line">        inc word ptr ds:[bp]</span><br><span class="line">        jmp charret</span><br><span class="line">charpop:</span><br><span class="line">        cmp word ptr ds:[bp], 0</span><br><span class="line">        je charret</span><br><span class="line">        dec word ptr ds:[bp]</span><br><span class="line">        mov bx, ds:[bp]</span><br><span class="line">        mov al, [si][bx]</span><br><span class="line">        jmp charret</span><br><span class="line">charshow:</span><br><span class="line">        mov bx, 0b800h</span><br><span class="line">        mov es, bx</span><br><span class="line">        mov ax, 160</span><br><span class="line">        mul dh                  ; 行号*160</span><br><span class="line">        mov di, ax</span><br><span class="line">        mov ax, 2</span><br><span class="line">        mul dl                  ; 列号*2</span><br><span class="line">        add di, ax</span><br><span class="line"></span><br><span class="line">        mov bx, 0</span><br><span class="line">charshows:</span><br><span class="line">        cmp bx, ds:[bp]</span><br><span class="line">        jne noempty</span><br><span class="line">        mov byte ptr es:[di], &#x27; &#x27;</span><br><span class="line"></span><br><span class="line">        push dx</span><br><span class="line">        mov dl, bl</span><br><span class="line">        mov bx, 0               ; bx已经不用了, 可以覆盖</span><br><span class="line">        mov ah, 2               ; 功能号2: 设置光标</span><br><span class="line">        int 10h</span><br><span class="line">        pop dx</span><br><span class="line">        jmp charret</span><br><span class="line">noempty:</span><br><span class="line">        mov al, [si][bx]</span><br><span class="line">        mov es:[di], al</span><br><span class="line">        mov byte ptr es:[di+2], &#x27; &#x27;</span><br><span class="line">        inc bx</span><br><span class="line">        add di, 2</span><br><span class="line">        jmp charshows</span><br><span class="line"></span><br><span class="line">charret:</span><br><span class="line">        pop bp</span><br><span class="line">        pop es</span><br><span class="line">        pop di</span><br><span class="line">        pop bx</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>(ah)表示功能号，0入栈，1出栈，2显示。注意入栈和出栈时要检查栈顶位置，防止溢出。另外，在显示的时候，我们将最后一个字符后面的位置也置成了空格，是为了处理退格的情况。</p>
<h3 id="时间检查子程序"><a href="#时间检查子程序" class="headerlink" title="时间检查子程序"></a>时间检查子程序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 检查时间格式是否正确</span><br><span class="line">; 参数: ds:si指向字符栈起始位置</span><br><span class="line">; 返回: (ah)=0表示格式正确, (ah)=1表示格式错误</span><br><span class="line">; yy/MM/dd hh:mm:ss</span><br><span class="line">checkclock:</span><br><span class="line">        push bx</span><br><span class="line">        push cx</span><br><span class="line">        push dx</span><br><span class="line">        push si</span><br><span class="line">        push di</span><br><span class="line">        push ax</span><br><span class="line"></span><br><span class="line">        ; 检查数字</span><br><span class="line">        mov di, offset digitoffset-task+7e00h</span><br><span class="line">        mov bx, 0</span><br><span class="line">        mov cx, 12</span><br><span class="line">        </span><br><span class="line">checkdigits:</span><br><span class="line">        mov bl, [di]            ; 获取数字在字符串中的偏移量</span><br><span class="line">        mov al, [si][bx]</span><br><span class="line">        call isdigit            ; 检查对应位置是否是数字</span><br><span class="line">        cmp ah, 0</span><br><span class="line">        jne checkfail           ; 返回值0表示是数字</span><br><span class="line">        inc di</span><br><span class="line">        loop checkdigits</span><br><span class="line"></span><br><span class="line">        ; 检查特殊符号</span><br><span class="line">        mov cx, 5</span><br><span class="line">        mov di, offset timeformat-task+7e00h</span><br><span class="line">        mov bx, 2               ; +3</span><br><span class="line">checksigns:</span><br><span class="line">        mov al, [di][bx]</span><br><span class="line">        cmp [si][bx], al        ; 检查对应位置的符号是否正确</span><br><span class="line">        jne checkfail</span><br><span class="line">        add bx, 3</span><br><span class="line">        loop checksigns</span><br><span class="line"></span><br><span class="line">        ; 检查日期</span><br><span class="line">        call checkdate          ; 检查日期是否合法，包括闰年的检查</span><br><span class="line">        cmp ah, 0</span><br><span class="line">        jne checkfail</span><br><span class="line"></span><br><span class="line">        ; 检查时间</span><br><span class="line">        add si, 9</span><br><span class="line">        call checktime          ; 检查时间是否合法</span><br><span class="line">        cmp ah, 0</span><br><span class="line">        jne checkfail</span><br><span class="line"></span><br><span class="line">        pop ax</span><br><span class="line">        mov ah, 0</span><br><span class="line">        jmp checkend</span><br><span class="line">checkfail:</span><br><span class="line">        pop ax</span><br><span class="line">        mov ah, 1</span><br><span class="line">checkend:</span><br><span class="line">        pop di</span><br><span class="line">        pop si</span><br><span class="line">        pop dx</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p><code>checkclock</code>子程序用于检查格式，首先要确保用户输入的字符串是<code>yy/MM/dd hh:mm:ss</code>格式的，这部分比较简单，其中<code>isdigit</code>用于检查某个字符是否是数字。然后还要检查日期和时间是否合法的，因为这块比较复杂，分别封装成了两个子程序<code>checkdate</code>和<code>checktime</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 检查日期是否合法</span><br><span class="line">; 参数: ds:si指向字符串起始位置</span><br><span class="line">; 返回: (ah)=0表示格式正确, (ah)=1表示格式错误</span><br><span class="line">; YY/MM/dd</span><br><span class="line">checkdate:</span><br><span class="line">        push bx</span><br><span class="line">        push si</span><br><span class="line">        push di</span><br><span class="line">        push ax</span><br><span class="line"></span><br><span class="line">        ; 检查月份是否超出</span><br><span class="line">        add si, 3               ; 月份从位置3开始</span><br><span class="line">        call char2number        ; 将ds:si所指位置的两个字符转成数值</span><br><span class="line">        cmp al, 1               ; 月份有效值1到12</span><br><span class="line">        jb datefail</span><br><span class="line">        cmp al, 12</span><br><span class="line">        ja datefail</span><br><span class="line"></span><br><span class="line">        mov bx, 0</span><br><span class="line">        mov bl, al              ; 月份先保存到bl</span><br><span class="line"></span><br><span class="line">        ; 检查日期是否超出</span><br><span class="line">        add si, 3               ; 日期从位置6开始</span><br><span class="line">        call char2number</span><br><span class="line">        cmp al, 1               ; 日期最小1</span><br><span class="line">        jb datefail</span><br><span class="line"></span><br><span class="line">        mov di, offset daysofmonth-task+7e00h</span><br><span class="line">        cmp al, [di][bx]</span><br><span class="line">        ja datefail             ; 最大根据月份来判断</span><br><span class="line"></span><br><span class="line">        ; 不是2月29日不用检查闰年</span><br><span class="line">        cmp al, 29</span><br><span class="line">        jne datepass</span><br><span class="line">        cmp bl, 2</span><br><span class="line">        jne datepass</span><br><span class="line">    </span><br><span class="line">        ; 检查闰年</span><br><span class="line">        mov bh, al              ; 日期先保存到bl</span><br><span class="line">        mov ax, 0</span><br><span class="line">        sub si, 6</span><br><span class="line">        call char2number</span><br><span class="line">        add ax, 1900            ; (al)&gt;=90, 认为是19YY</span><br><span class="line">        cmp ax, 1990</span><br><span class="line">        jnb nineteenth</span><br><span class="line">        add ax, 100             ; (al)&lt;90, 认为是20YY</span><br><span class="line">nineteenth:</span><br><span class="line">        call isleapyear         ; 判断ax所表示的年份是否是闰年</span><br><span class="line">        cmp ah, 0</span><br><span class="line">        jne datepass            ; 闰年不能有2月29日</span><br><span class="line">datefail:</span><br><span class="line">        pop ax</span><br><span class="line">        mov ah, 1</span><br><span class="line">        jmp dateend</span><br><span class="line">datepass:</span><br><span class="line">        pop ax</span><br><span class="line">        mov ah, 0</span><br><span class="line">dateend:</span><br><span class="line">        pop di</span><br><span class="line">        pop si</span><br><span class="line">        pop dx</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>首先看日期的检查，月份的有效值1到12，日期的最小值也是1，最大值根据月份来决定，我们已经将每个月的天数做成了表格放在数据中，可以直接查表获取。其中<code>char2number</code>用于将两个字符转成字节型数值。</p>
<p>如果是2月29日，还需要检查是否是闰年，我们将闰年的检查封装成了<code>isleapyear</code>子程序，篇幅原因不再展示。另外，因为<a href="https://wiki.osdev.org/CMOS#The_Real-Time_Clock">CMOS RTC时间</a>不一定有表示世纪的寄存器，我们将大于等于90的年份认为是20世纪，其余的认为是21世纪。</p>
<p><code>checktime</code>子程序比较简单，这里不再赘述。</p>
<h3 id="CMOS-RTC时间的读写"><a href="#CMOS-RTC时间的读写" class="headerlink" title="CMOS RTC时间的读写"></a><a href="https://wiki.osdev.org/CMOS#The_Real-Time_Clock">CMOS RTC时间</a>的读写</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 设置CMOS RTC时间</span><br><span class="line">; 参数: ds:si指向字符串起始位置</span><br><span class="line">; 实际测试，不是闰年也设置不了2月29日</span><br><span class="line">; 2月28日直接跳到3月1日, 暂不清楚原因</span><br><span class="line">setclock:</span><br><span class="line">        push ax</span><br><span class="line">        push cx</span><br><span class="line">        push si</span><br><span class="line">        push di</span><br><span class="line"></span><br><span class="line">        mov di, offset timeoffset-task+7e00h</span><br><span class="line">        mov cx, 6               ; 循环次数</span><br><span class="line">setclocks:</span><br><span class="line">        mov al, [di]            ; 获取内存单元号</span><br><span class="line">        out 70h, al             ; 写到控制端口</span><br><span class="line"></span><br><span class="line">        mov ah, [si]            ; 十位字符</span><br><span class="line">        sub ah, 30h             ; 实际数值</span><br><span class="line">        push cx</span><br><span class="line">        mov cl, 4               ; 左移位数</span><br><span class="line">        shl ah, cl              ; 高4位放十位的值</span><br><span class="line">        pop cx</span><br><span class="line">        mov al, [si].1          ; 个位字符</span><br><span class="line">        sub al, 30h             ; 实际数值</span><br><span class="line">        add al, ah              ; 相加</span><br><span class="line"></span><br><span class="line">        out 71h, al             ; 写到数据端口</span><br><span class="line"></span><br><span class="line">        add si, 3</span><br><span class="line">        inc di</span><br><span class="line">        loop setclocks</span><br><span class="line"></span><br><span class="line">        pop di</span><br><span class="line">        pop si</span><br><span class="line">        pop cx</span><br><span class="line">        pop ax</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>我们通过端口来跟外设通信，CMOS RAM芯片有两个端口70h和71h，70h是地址端口，存放要访问的CMOS RAM单元地址；71h为数据端口，存放要读写的数据。每次对CMOS RAM的读写分两步进行，首先将地址写入端口70h，然后将数据写到71h端口。</p>
<p>我们依次将年月日时分秒的值写入CMOS中，其中时间信息都是以BCD码的形式存放的，一个字节表示两个十进制数。所以写之前，先要将两个字符转化对应的BCD码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 设置CMOS RTC时间</span><br><span class="line">; 参数: ds:si指向字符串起始位置</span><br><span class="line">getclock:</span><br><span class="line">        push ax</span><br><span class="line">        push cx</span><br><span class="line">        push si</span><br><span class="line">        push di</span><br><span class="line"></span><br><span class="line">        mov di, offset timeoffset-task+7e00h</span><br><span class="line">        mov cx, 6               ; 循环次数</span><br><span class="line">getclocks:</span><br><span class="line">        mov al, [di]            ; 获取内存单元号</span><br><span class="line">        out 70h, al             ; 写到控制端口</span><br><span class="line">        in al, 71h              ; 从数据端口读取</span><br><span class="line"></span><br><span class="line">        mov ah, al</span><br><span class="line">        push cx</span><br><span class="line">        mov cl, 4               ; 右移位数</span><br><span class="line">        shr ah, cl              ; ah中为十位</span><br><span class="line">        pop cx</span><br><span class="line">        and al, 00001111b       ; al中为个位</span><br><span class="line">        add ah, 30h             ; 对应ascii码</span><br><span class="line">        add al, 30h             ; 对应ascii码</span><br><span class="line">        mov [si], ah</span><br><span class="line">        mov [si].1, al</span><br><span class="line"></span><br><span class="line">        add si, 3</span><br><span class="line">        inc di</span><br><span class="line">        loop getclocks</span><br><span class="line"></span><br><span class="line">        pop di</span><br><span class="line">        pop si</span><br><span class="line">        pop cx</span><br><span class="line">        pop ax</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p><code>getclock</code>子程序用于从CMOS读取，操作正好相反，这里不再赘述。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>最终完成整个程序之后，可以按如下步骤进行测试（这里我是在DOSBox环境下开发的，程序文件名为design2.asm）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Z:\&gt;mount c ~</span><br><span class="line">Z:\&gt;c:</span><br><span class="line">C:\&gt;masm design2;</span><br><span class="line">C:\&gt;link design2;</span><br><span class="line">C:\&gt;imgmount 0 c:\floppy.img -t floppy -fs none</span><br><span class="line">C:\&gt;design2.ext</span><br><span class="line">C:\&gt;imgmount -u 0</span><br></pre></td></tr></table></figure>

<p>首先进行编译、链接，因为软盘映像我们前面已经做好，这里直接挂载即可，然后运行design2安装程序将任务程序写到软盘中，最后再卸载软盘映像。</p>
<p>现在我们就可以把这个软盘映像放到虚拟机上进行测试了，如果虚拟机没有创建过软驱的话需要先创建一个，选择启动时连接这个软驱，然后启动虚拟机，接下来就是见证奇迹的时刻了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>完整的代码已上传<a href="https://github.com/catbro666/assembly-course-design2">Github</a>，欢迎交流讨论。</p>
]]></content>
      <categories>
        <category>理解计算机</category>
      </categories>
      <tags>
        <tag>8086</tag>
        <tag>汇编</tag>
        <tag>DOS</tag>
      </tags>
  </entry>
  <entry>
    <title>VIM常用快捷键和插件整理</title>
    <url>/posts/d6ca5270/</url>
    <content><![CDATA[<div class="note primary">
            <p>本文不会介绍基本的VIM使用方法，如果你对VIM的几种模式、基本的编辑、移动和选取等还不了解，推荐你先看一下这篇<a href="https://coolshell.cn/articles/5426.html">简明 VIM 练级攻略</a>，写得还是不错的，基本上最常用的命令都有了。如果你不是vim重度用户的话，知道这些命令已经足够。只能说vim的水太深，根据自身情况在编辑效率和学习成本之间做个平衡吧。</p>
          </div>

<span id="more"></span>

<p>这里有一个vim cheat sheet图，可以作为快速查阅用。要了解具体的命令推荐查看vim的help文档，内容写得非常详细。</p>
<p><img src="https://coolshell.cn/wp-content/uploads/2011/09/vim_cheat_sheet_for_programmers_print.png" alt="vim cheet sheet" loading="lazy"></p>
<h2 id="Vim编辑命令一般格式"><a href="#Vim编辑命令一般格式" class="headerlink" title="Vim编辑命令一般格式"></a>Vim编辑命令一般格式</h2><p>vim中编辑命令的结构</p>
<p><code>&lt;number&gt; &lt;operator&gt; &lt;number&gt; &lt;text object or motion&gt;</code></p>
<p>motion或对象前可以包含一个数字，如果operator前也带了一个数字，两者是<strong>相乘</strong>的关系。</p>
<p>例如<code>2d3w</code>，删除6个单词。</p>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>操作符也是可选的，如果没有则变成了移动命令，而非编辑命令。</p>
<p>vim默认的operator有</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>c</strong></td>
<td>change</td>
</tr>
<tr>
<td><strong>d</strong></td>
<td>delete</td>
</tr>
<tr>
<td><strong>y</strong></td>
<td>yank into register</td>
</tr>
<tr>
<td>~</td>
<td>swap case (only if ‘tildep’ is set)</td>
</tr>
<tr>
<td>g~</td>
<td>swap case</td>
</tr>
<tr>
<td>gu</td>
<td>make lowercase</td>
</tr>
<tr>
<td>gU</td>
<td>make uppercase</td>
</tr>
<tr>
<td>!</td>
<td>filter through an external program</td>
</tr>
<tr>
<td>=</td>
<td>filter through ‘equalprg’ or C-indenting if empty</td>
</tr>
<tr>
<td>gq</td>
<td>text formatting</td>
</tr>
<tr>
<td>g?</td>
<td>ROT13 encoding</td>
</tr>
<tr>
<td>&gt;</td>
<td>shift right</td>
</tr>
<tr>
<td>&lt;</td>
<td>shift left</td>
</tr>
<tr>
<td>zf</td>
<td>define a fold</td>
</tr>
<tr>
<td>g@</td>
<td>call function set with the ‘operatorfunc’ option</td>
</tr>
</tbody></table>
<p>操作要么影响整行，要么影响起止位置之间的字符。移动有inclusive和exclusive之分。</p>
<p>如果操作pending了（即操作符已经输入了，motion还没有），有一些特殊映射可以使用（:omap）。</p>
<p>motion也可以使用命令，例如<code>d:call FindEnd()</code>，如果命令多于一行不能重复。</p>
<p>可以在操作符后输入<code>v</code>、<code>V</code>或<code>CTRL-V</code>，强制将motion转换为逐字符、逐行、逐块。其中对于v，如果本身就是逐字符的，则转换inclusive/exclusive。</p>
<p>扩展的操作符：</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nnoremap Y</td>
<td>:CopyText&lt;cr&gt;</td>
<td>拷贝到指定字符</td>
</tr>
<tr>
<td>nnoremap D</td>
<td>:DeleteText&lt;cr&gt;</td>
<td>删除到指定字符</td>
</tr>
<tr>
<td>nnoremap C</td>
<td>:ChangeText&lt;cr&gt;</td>
<td>改写到某个字符</td>
</tr>
</tbody></table>
<p>成对符号的操作：</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>例子</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cs”‘</td>
<td>“Hello world!” -&gt; ‘Hello world!’</td>
<td>“改成‘</td>
</tr>
<tr>
<td>cs’&lt;q&gt;</td>
<td>‘Hello world!’ -&gt; &lt;q&gt;Hello world!&lt;/q&gt;</td>
<td>‘改成&lt;q&gt;对</td>
</tr>
<tr>
<td>cst”</td>
<td>&lt;q&gt;Hello world!&lt;/q&gt; -&gt; “Hello world!”</td>
<td>&lt;q&gt;对改成”，t表示完整匹配&lt;q&gt;</td>
</tr>
<tr>
<td>ds”</td>
<td>“Hello world!” -&gt; Hello world!</td>
<td>去掉”</td>
</tr>
<tr>
<td>dst</td>
<td>&lt;q&gt;Hello world!&lt;/q&gt; -&gt; Hello world!</td>
<td>t表示完整匹配&lt;q&gt;，而不是单个&lt;</td>
</tr>
<tr>
<td>ysiw]</td>
<td>Hello world! -&gt; [Hello] world!</td>
<td>光标所在单词加括号，右括号不加空格</td>
</tr>
<tr>
<td>ysiw{</td>
<td>Hello world! -&gt; { Hello } world!</td>
<td>光标所在单词加括号，左括号加空格</td>
</tr>
<tr>
<td>yss)</td>
<td>{ Hello } world! -&gt; ({ Hello } world!)</td>
<td>整行加()对</td>
</tr>
</tbody></table>
<p>可以跟vim-repeat配合，使用<code>.</code>重复之前的操作。</p>
<h2 id="左右移动"><a href="#左右移动" class="headerlink" title="左右移动"></a>左右移动</h2><table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
<th>inclusive/exclusive</th>
</tr>
</thead>
<tbody><tr>
<td><strong>h</strong></td>
<td>左移</td>
<td>e</td>
</tr>
<tr>
<td><strong>l</strong></td>
<td>右移</td>
<td>e</td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>移到行首</td>
<td>e</td>
</tr>
<tr>
<td><strong>^</strong></td>
<td>移到行首第一个非空字符</td>
<td>e</td>
</tr>
<tr>
<td><strong>$</strong></td>
<td>移到行尾</td>
<td>i</td>
</tr>
<tr>
<td>g_</td>
<td>移到行尾第一个非空字符</td>
<td>i</td>
</tr>
<tr>
<td><strong>g0</strong></td>
<td>移到当前行屏幕最左字符</td>
<td>e</td>
</tr>
<tr>
<td>g^</td>
<td>移到屏幕行第一个非空字符</td>
<td>e</td>
</tr>
<tr>
<td>gm</td>
<td>类似g0，但是屏幕移动</td>
<td>e</td>
</tr>
<tr>
<td>g$</td>
<td>屏幕行的最后一个非空字符</td>
<td>i</td>
</tr>
<tr>
<td><strong>｜</strong></td>
<td>到当前行的屏幕中的第[count]列</td>
<td>e</td>
</tr>
<tr>
<td><strong>f{char}</strong></td>
<td>移动到右边第[count]个{char}字符出现处</td>
<td>i</td>
</tr>
<tr>
<td><strong>F{char}</strong></td>
<td>移动到左边第[count]个{char}字符出现处</td>
<td>e</td>
</tr>
<tr>
<td><strong>t{char}</strong></td>
<td>移动到右边第[count]个{char}字符前</td>
<td>i</td>
</tr>
<tr>
<td><strong>T{char}</strong></td>
<td>移动到左边第[count]个{char}字符后</td>
<td>e</td>
</tr>
<tr>
<td>;</td>
<td>重复最近一个f,t,F,T [count]次</td>
<td></td>
</tr>
<tr>
<td>,</td>
<td>重复最近一个f,t,F,T 相反方向[count]次</td>
<td></td>
</tr>
</tbody></table>
<h2 id="上下移动"><a href="#上下移动" class="headerlink" title="上下移动"></a>上下移动</h2><table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
<th>inclusive/exclusive</th>
</tr>
</thead>
<tbody><tr>
<td><strong>k</strong></td>
<td>上移</td>
<td>i</td>
</tr>
<tr>
<td><strong>j</strong></td>
<td>下移</td>
<td>i</td>
</tr>
<tr>
<td>gk</td>
<td>上移显示行，行折叠时或者与操作符使用时</td>
<td>e</td>
</tr>
<tr>
<td>gj</td>
<td>下移显示行</td>
<td>e</td>
</tr>
<tr>
<td>-</td>
<td>上移，在第一个非空字符</td>
<td></td>
</tr>
<tr>
<td>_</td>
<td>下移[count] -1行，第一个非空字符</td>
<td></td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>到第[count]行，默认最后一行，第一个非空字符</td>
<td></td>
</tr>
<tr>
<td><strong>gg</strong></td>
<td>到第[count]行，默认第一行，第一个非空字符</td>
<td></td>
</tr>
<tr>
<td>:[range]</td>
<td>光标跳到[range]的最后一行，相比G不改jumplist</td>
<td></td>
</tr>
<tr>
<td><strong>{count}%</strong></td>
<td>跳到文件百分之{count}处，第一个非空字符</td>
<td></td>
</tr>
</tbody></table>
<h2 id="单词移动"><a href="#单词移动" class="headerlink" title="单词移动"></a>单词移动</h2><table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
<th>inclusive/exclusive</th>
</tr>
</thead>
<tbody><tr>
<td><strong>w</strong></td>
<td>往前[count]个words</td>
<td>e</td>
</tr>
<tr>
<td><strong>W</strong></td>
<td>往前[count]个WORDS</td>
<td>e</td>
</tr>
<tr>
<td><strong>e</strong></td>
<td>往前到第[count]个words的最后，空行不停</td>
<td>i</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>往前到第[count]个WORDS的最后，空行不停</td>
<td>i</td>
</tr>
<tr>
<td><strong>b</strong></td>
<td>往回[count]个words</td>
<td>e</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>往回[count]个WORDS</td>
<td>e</td>
</tr>
<tr>
<td><strong>ge</strong></td>
<td>往回到第[count]个words的最后</td>
<td>i</td>
</tr>
<tr>
<td><strong>gE</strong></td>
<td>往回到第[count]个WORDS的最后</td>
<td>i</td>
</tr>
<tr>
<td><strong>&lt;leader&gt; w</strong></td>
<td>跳到指定单词处</td>
<td></td>
</tr>
</tbody></table>
<p>其中<strong>word</strong>由字母、数字、下划线的序列组成，或者其他非空字符的序列，以空白符分隔。可以用<code>iskeyword</code>选项修改。空行也当成一个word。</p>
<p><strong>WORD</strong>由非空字符序列组成，以空白符分隔。空行也当成一个WORD。</p>
<p>特殊情况：</p>
<ul>
<li><code>cw</code>和<code>cW</code>当作<code>ce</code>和<code>cE</code>处理（如果光标在非空字符上的话）</li>
<li>当<code>w</code>跟操作符一起使用，当最后一个移过的单词是一行最后时，单词尾部成为操作文本的尾部，不是下一行的开始。</li>
</ul>
<h2 id="文本对象移动"><a href="#文本对象移动" class="headerlink" title="文本对象移动"></a>文本对象移动</h2><table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
<th>inclusive/exclusive</th>
</tr>
</thead>
<tbody><tr>
<td>(</td>
<td>回移[count]个句子</td>
<td>e</td>
</tr>
<tr>
<td>)</td>
<td>前移[count]个句子</td>
<td>e</td>
</tr>
<tr>
<td>{</td>
<td>回移[count]个段落</td>
<td>e</td>
</tr>
<tr>
<td>}</td>
<td>前移[count]个段落</td>
<td>e</td>
</tr>
<tr>
<td>]]</td>
<td>前移[count]个小节或第1列中的下一个‘{’。如果和操作符一起使用，则也停在第一列的’}’下</td>
<td>e</td>
</tr>
<tr>
<td>][</td>
<td>前移[count]个小节或第1列中的下一个‘}’</td>
<td>e</td>
</tr>
<tr>
<td>[[</td>
<td>回移[count]个小节或第1列中的前一个‘{’</td>
<td>e</td>
</tr>
<tr>
<td>[]</td>
<td>回移[count]个小节或第1列中的前一个‘}’</td>
<td>e</td>
</tr>
</tbody></table>
<p><strong>句子</strong>：由<code>.</code>或<code>!</code>或<code>?</code>结尾，后面要么时行尾、要么是空格或tab。<code>.</code>或<code>!</code>或<code>?</code>后面可以跟任意数目的’)’、’]’、’”‘、’’’。</p>
<p><strong>段落</strong>：由空行之后开始，或者由段落宏开始。小节的边界也是段落的边界。注意空行不是段落的边界。</p>
<h2 id="文本的对象选取"><a href="#文本的对象选取" class="headerlink" title="文本的对象选取"></a>文本的对象选取</h2><p>这是一系列只能在visual模式或者操作符之后才能用的命令。<code>a</code>命令选取n个对象，包括空白。<code>i</code>命令选取一个内部对象不带空白或者只选取空白，所以<code>i</code>命令肯定比<code>a</code>命令选得少。</p>
<p><code>v3aw</code>，<code>d2iw</code>。</p>
<p>可以跟各种文本对象组合。如aw, iw, aW, iW, as, is句子, ap, ip段落, a], a[, i], i[是[]块，a), a(, ab, i), i(, ib是块，a&gt;, a&lt;, i&gt;, i&lt;是尖括号块，at, it是tag块，a}, a{, aB, i}, i{, iB是块，a”, a’, a`,i”, i’, i`是引用的字符串。</p>
<p>扩展文本对象</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
<th>inclusive/exclusive</th>
</tr>
</thead>
<tbody><tr>
<td><strong>if</strong></td>
<td>函数文件对象，内部代码块</td>
<td></td>
</tr>
<tr>
<td><strong>af</strong></td>
<td>函数文件对象，整个函数</td>
<td></td>
</tr>
<tr>
<td>iF</td>
<td>函数参数对象，整个函数</td>
<td></td>
</tr>
<tr>
<td><strong>aF</strong></td>
<td>函数参数对象，整个函数包含前后的空行</td>
<td></td>
</tr>
<tr>
<td>i,</td>
<td>内部参数，不包括后面的逗号和空格</td>
<td></td>
</tr>
<tr>
<td>a,</td>
<td>参数，包含逗号和空格</td>
<td></td>
</tr>
</tbody></table>
<h3 id="当在操作符后面使用时"><a href="#当在操作符后面使用时" class="headerlink" title="当在操作符后面使用时"></a>当在操作符后面使用时</h3><ul>
<li><p>对于非块对象</p>
<p>a系列命令，作用于对象及其后面的空白。如果对象后面没有空白或光标在对象之前的空白上，对象前面的空白也包含进来。</p>
<p>i系列命令，如果光标在对象上，作用于对象；如果光标在空白上，作用于空白</p>
</li>
<li><p>对于块对象</p>
<p>作用于光标所在的块（光标在块内或括号上）。a系列命令包括括号，i系列不包括括号。</p>
</li>
</ul>
<h3 id="当在Visual模式使用时"><a href="#当在Visual模式使用时" class="headerlink" title="当在Visual模式使用时"></a>当在Visual模式使用时</h3><ul>
<li><p>如果是刚进入Visual模式</p>
<p>选择一个对象，就跟前面使用操作符时一样</p>
</li>
<li><p>如果不是刚进入visual模式</p>
<p>对于非块对象，visual区域扩展一个对象或下一个对象前的空白，或者扩展两者。选取方法取决于光标运动方向。对于块对象，往外扩展一层。</p>
</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>下面是删除命令为例的一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;dl&quot;    delete character (alias: &quot;x&quot;)           dl</span><br><span class="line">&quot;diw&quot;   delete inner word                       diw</span><br><span class="line">&quot;daw&quot;   delete a word                           daw</span><br><span class="line">&quot;diW&quot;   delete inner WORD (see WORD)            diW</span><br><span class="line">&quot;daW&quot;   delete a WORD (see WORD)                daW</span><br><span class="line">&quot;dgn&quot;   delete the next search pattern match    dgn</span><br><span class="line">&quot;dd&quot;    delete one line                         dd</span><br><span class="line">&quot;dis&quot;   delete inner sentence                   dis</span><br><span class="line">&quot;das&quot;   delete a sentence                       das</span><br><span class="line">&quot;dib&quot;   delete inner &#x27;(&#x27; &#x27;)&#x27; block              dib</span><br><span class="line">&quot;dab&quot;   delete a &#x27;(&#x27; &#x27;)&#x27; block                  dab</span><br><span class="line">&quot;dip&quot;   delete inner paragraph                  dip</span><br><span class="line">&quot;dap&quot;   delete a paragraph                      dap</span><br><span class="line">&quot;diB&quot;   delete inner &#x27;&#123;&#x27; &#x27;&#125;&#x27; block              diB</span><br><span class="line">&quot;daB&quot;   delete a &#x27;&#123;&#x27; &#x27;&#125;&#x27; block                  daB</span><br></pre></td></tr></table></figure>



<h2 id="搜索替换"><a href="#搜索替换" class="headerlink" title="搜索替换"></a>搜索替换</h2><p>也是光标的跳转。在按回车之前可以按<strong>ctrl+j/k</strong>来上下选择。</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>map /</td>
<td>&lt;Plug&gt;(incsearch-forward)</td>
<td>往下搜索</td>
</tr>
<tr>
<td>map  ?</td>
<td>&lt;Plug&gt;(incsearch-backward)</td>
<td>往上搜索</td>
</tr>
<tr>
<td>map g/</td>
<td>&lt;Plug&gt;(incsearch-stay)</td>
<td>按回车后光标不动</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nnoremap &lt;leader&gt;f</td>
<td>:LeaderfFile .&lt;cr&gt;</td>
<td>当前目录下文件搜索，tab选择</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;F</td>
<td>:Ack!&lt;space&gt;</td>
<td>文本正则匹配</td>
</tr>
<tr>
<td>rr</td>
<td></td>
<td>normal下替换掉光标所在单词，visual替换选中文本</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;r</td>
<td>:ReplaceTo&lt;space&gt;</td>
<td>全文替换单词</td>
</tr>
</tbody></table>
<h2 id="文件跳转"><a href="#文件跳转" class="headerlink" title="文件跳转"></a>文件跳转</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nnoremap &lt;leader&gt;U</td>
<td>:GoToFunImpl&lt;cr&gt;</td>
<td>跳到函数实现</td>
</tr>
<tr>
<td>nnoremap &lt;silent&gt; &lt;leader&gt;a</td>
<td>:Switch&lt;cr&gt;</td>
<td>C++头文件和源文件切换</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;u</td>
<td>:YcmCompleter GoToDeclaration&lt;cr&gt;</td>
<td>跳转的函数声明</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;o</td>
<td>:YcmCompleter GoToInclude&lt;cr&gt;</td>
<td>跳转到include文件</td>
</tr>
<tr>
<td>Ctrl + ]</td>
<td></td>
<td>ctags跳转到函数或变量定义处</td>
</tr>
<tr>
<td>Ctrl + t</td>
<td></td>
<td>ctags返回跳转前的地方</td>
</tr>
</tbody></table>
<p>buffer切换</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nnoremap &lt;c-p&gt;</td>
<td>:PreviousBuffer&lt;cr&gt;</td>
<td>切换到上一个buffer</td>
</tr>
<tr>
<td>nnoremap &lt;c-n&gt;</td>
<td>:NextBuffer&lt;cr&gt;</td>
<td>切换到下一个buffer</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;d</td>
<td>:CloseCurrentBuffer&lt;cr&gt;</td>
<td>关闭当前buffer</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;D</td>
<td>:BufOnly&lt;cr&gt;</td>
<td>删除除当前buffer外的所有buffer</td>
</tr>
</tbody></table>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p><code>:Git</code>后加对应git命令，还有一些扩展命令，如<code>:Gread</code>、<code>:Ggrep</code>等。</p>
<p>git commit浏览器。</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nnoremap &lt;leader&gt;g</td>
<td>:GV</td>
<td>打开commit浏览器，可以加git log选项</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;G</td>
<td>:GV!</td>
<td>只列出影响当前文件的commits</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;gg</td>
<td>:GV?</td>
<td>当前文件revisions的位置列表</td>
</tr>
</tbody></table>
<p><code>:GV</code>和<code>:GV?</code>可以用于visual模式，追踪选择行的变化。</p>
<p>在列表中界面</p>
<p><code>o</code>或<code>&lt;cr&gt;</code>，单个commit，显示其内容。</p>
<p><code>o</code>或<code>&lt;cr&gt;</code>，多个commits，显示所选范围的变化</p>
<p><code>O</code>，打开一个新tab显示，而不是分隔窗口</p>
<p><code>.</code>，当前光标所在commit，开始一条命令<code>:Git [CURSOR] SHA</code></p>
<p><code>q</code>或<code>gq</code>关闭</p>
<h2 id="自动生成与格式化"><a href="#自动生成与格式化" class="headerlink" title="自动生成与格式化"></a>自动生成与格式化</h2><p>CPP辅助</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nnoremap &lt;leader&gt;y</td>
<td>:CopyCode&lt;cr&gt;</td>
<td>拷贝函数或变量</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;p</td>
<td>:PasteCode&lt;cr&gt;</td>
<td>生成函数实现或变量定义</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;&lt;leader&gt;fp</td>
<td>:FormatFunParam&lt;cr&gt;</td>
<td>格式化函数参数</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;&lt;leader&gt;if</td>
<td>:FormatIf&lt;cr&gt;</td>
<td>格式化if-else</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;&lt;leader&gt;t</td>
<td>:GenTryCatch&lt;cr&gt;</td>
<td>生成try-catch块</td>
</tr>
</tbody></table>
<p>文本对齐。</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nnoremap &lt;leader&gt;=</td>
<td>:Tab /=&lt;cr&gt;</td>
<td>关于=号对齐</td>
</tr>
<tr>
<td></td>
<td>:Tab /,/r1c1l0&lt;cr&gt;</td>
<td>逗号分隔，右对齐空一个，中对齐空一格左对齐不空</td>
</tr>
</tbody></table>
<p>快速注释</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>gcc</td>
<td></td>
<td>单行注释</td>
</tr>
<tr>
<td>gc</td>
<td></td>
<td>visual模式注释选择行</td>
</tr>
<tr>
<td>gcap</td>
<td></td>
<td>注释一整段</td>
</tr>
<tr>
<td>:7,17Commentary</td>
<td></td>
<td>注释所选行</td>
</tr>
<tr>
<td>gcgc</td>
<td></td>
<td>去掉所有相邻注释行的注释</td>
</tr>
</tbody></table>
<p>新建文件时模版<code>~/.vim/plugged/prepare-code/snippet</code></p>
<h2 id="vim与shell交互"><a href="#vim与shell交互" class="headerlink" title="vim与shell交互"></a>vim与shell交互</h2><ul>
<li><code>:!command</code></li>
</ul>
<p>不退出vim，执行shell命令，例如<code>:!ls -l</code></p>
<ul>
<li><code>:!!</code></li>
</ul>
<p>执行上一次的命令</p>
<ul>
<li><code>:r !command </code>或<code>!!command</code></li>
</ul>
<p>将命令执行结果插入到当前行的下一行，例如<code>:r date</code></p>
<ul>
<li><code>:start,end !command</code></li>
</ul>
<p>将指定行范围中的内容输入到shell命令进行处理，并用输出结果替换指定内容，例如<code>:62,72 !sort</code>。</p>
<p>可以只指定单行，<code>:62 !tr &quot;[a-z]&quot; &quot;[A-Z]&quot;</code>，将62行转成大写字母。</p>
<p>当前行可以用<code>.</code>表示，例如<code>. !tr &quot;[a-z]&quot; &quot;[A-Z]&quot;</code></p>
<ul>
<li><code>:start,end w !command</code></li>
</ul>
<p>将指定行范围中的内容输入到shell命令进行处理，但是只是显示结果，不会改变当前文件的内容。例如，<code>:62,72 w !sort</code></p>
<ul>
<li><code>:shell</code></li>
</ul>
<p>不退出vim，新开一个shell，exit之后回到vim。</p>
<ul>
<li><code>:terminal</code>或<code>:vertical :term</code></li>
</ul>
<p>在新建的分割窗口中进入终端。可以用<code>Ctrl-W N</code>或<code>Ctrl-\ Ctrl-N</code>在终端buffer中进入Normal模式，注意前者的N是大写的，需要按住shift。Terminal-Normal模式下可以选择复制文本。点击<code>i</code>键可以返回到Terminal-Job模式。</p>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nnoremap &lt;silent&gt;&lt;leader&gt;t</td>
<td>:TagBarToggle .&lt;cr&gt;</td>
<td>显式右边栏，方法变量</td>
</tr>
<tr>
<td>nnoremap &lt;silent&gt;&lt;leader&gt;n</td>
<td>:NERDTreeToggle .&lt;cr&gt;</td>
<td>显式左边栏，文件目录</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;ff</td>
<td>:YcmCompleter FixIt&lt;cr&gt;</td>
<td>自动修复错误</td>
</tr>
<tr>
<td>nmap &lt;F5&gt;</td>
<td>:YcmDiags&lt;cr&gt;</td>
<td>诊断错误</td>
</tr>
</tbody></table>
<h2 id="快捷键映射"><a href="#快捷键映射" class="headerlink" title="快捷键映射"></a>快捷键映射</h2><p>map系列命令语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&lt;mode&gt;][nore]map [&lt;args&gt;] &#123;lhs&#125; &#123;rhs&#125;</span><br></pre></td></tr></table></figure>

<p>第一个可选字符表示模式</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>模式</th>
</tr>
</thead>
<tbody><tr>
<td>n</td>
<td>normal only</td>
</tr>
<tr>
<td>v</td>
<td>visual and select</td>
</tr>
<tr>
<td>o</td>
<td>operator-pending</td>
</tr>
<tr>
<td>x</td>
<td>visual only</td>
</tr>
<tr>
<td>s</td>
<td>select only</td>
</tr>
<tr>
<td>i</td>
<td>insert</td>
</tr>
<tr>
<td>c</td>
<td>command-line</td>
</tr>
<tr>
<td>l</td>
<td>insert, command-line, regexp-search</td>
</tr>
</tbody></table>
<p>noremap    不递归映射</p>
<p>例如，下面的例子是正常的</p>
<p>noremap    Y y</p>
<p>noremap    y Y</p>
<p>常用的参数有</p>
<p><code>&lt;silent&gt;</code>表示静默映射，不会显示Vim在处理rhs过程中对界面产生的变化。</p>
<p><code>&lt;buffer&gt;</code>表示这个映射只是在当前的buffer中定义，而不是定义全局的映射</p>
<p><code>&lt;expr&gt;</code> 表示{rhs}是一个<code>Vim表达式</code> ，而不是按键序列，见下文</p>
<p>表达式的例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">noremap  &lt;expr&gt;0     col(&#x27;.&#x27;) == 1 ? &#x27;^&#x27;: &#x27;0&#x27;</span><br></pre></td></tr></table></figure>

<p>在normal或visual模式下，按0键可以实现让光标在首列和首个非空白字符之间的切换。</p>
<h2 id="插件整理"><a href="#插件整理" class="headerlink" title="插件整理"></a>插件整理</h2><p><a href="https://github.com/chxuan/vimplus">vimplus</a>是一个vim自动配置工具，基本上包含了下面所有的插件，可以傻瓜式一键安装使用。</p>
<h3 id="ctags"><a href="#ctags" class="headerlink" title="ctags"></a>ctags</h3><p>跳转到标签定义处，需要事先生成索引文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctags -R .</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>快捷键</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + ]</td>
<td>跳转到函数或变量定义处</td>
</tr>
<tr>
<td>Ctrl + t</td>
<td>返回跳转前的地方</td>
</tr>
</tbody></table>
<p>注意只有在索引所在目录下才能实现跳转</p>
<h3 id="chxuan-cpp-mode"><a href="#chxuan-cpp-mode" class="headerlink" title="chxuan/cpp-mode"></a><a href="https://github.com/chxuan/cpp-mode">chxuan/cpp-mode</a></h3><p>提供生成函数实现、函数声明/实现跳转、.h .cpp切换等功能</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nnoremap &lt;leader&gt;y</td>
<td>:CopyCode&lt;cr&gt;</td>
<td>拷贝函数或变量</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;p</td>
<td>:PasteCode&lt;cr&gt;</td>
<td>生成函数实现或变量定义</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;U</td>
<td>:GoToFunImpl&lt;cr&gt;</td>
<td>跳到函数实现</td>
</tr>
<tr>
<td>nnoremap &lt;silent&gt; &lt;leader&gt;a</td>
<td>:Switch&lt;cr&gt;</td>
<td>C++头文件和源文件切换</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;&lt;leader&gt;fp</td>
<td>:FormatFunParam&lt;cr&gt;</td>
<td>格式化函数参数</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;&lt;leader&gt;if</td>
<td>:FormatIf&lt;cr&gt;</td>
<td>格式化if-else</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;&lt;leader&gt;t</td>
<td>:GenTryCatch&lt;cr&gt;</td>
<td>生成try-catch块</td>
</tr>
</tbody></table>
<h3 id="chxuan-vim-edit"><a href="#chxuan-vim-edit" class="headerlink" title="chxuan/vim-edit"></a><a href="https://github.com/chxuan/vim-edit">chxuan/vim-edit</a></h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nnoremap Y</td>
<td>:CopyText&lt;cr&gt;</td>
<td>拷贝到指定字符</td>
</tr>
<tr>
<td>nnoremap D</td>
<td>:DeleteText&lt;cr&gt;</td>
<td>删除到指定字符</td>
</tr>
<tr>
<td>nnoremap C</td>
<td>:ChangeText&lt;cr&gt;</td>
<td>改写到某个字符</td>
</tr>
<tr>
<td>rr</td>
<td></td>
<td>normal下替换掉光标所在单词，visual替换选中文本</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;r</td>
<td>:ReplaceTo&lt;space&gt;</td>
<td>全文替换单词</td>
</tr>
</tbody></table>
<h3 id="chxuan-prepare-code"><a href="#chxuan-prepare-code" class="headerlink" title="chxuan/prepare-code"></a><a href="https://github.com/chxuan/prepare-code">chxuan/prepare-code</a></h3><p>新建文件时自动生成代码，模板在<code>~/.vim/plugged/prepare-code/snippet</code>目录下</p>
<h3 id="chxuan-vim-buffer"><a href="#chxuan-vim-buffer" class="headerlink" title="chxuan/vim-buffer"></a><a href="https://github.com/chxuan/vim-buffer">chxuan/vim-buffer</a></h3><p>buffer切换</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nnoremap &lt;c-p&gt;</td>
<td>:PreviousBuffer&lt;cr&gt;</td>
<td>切换到上一个buffer</td>
</tr>
<tr>
<td>nnoremap &lt;c-n&gt;</td>
<td>:NextBuffer&lt;cr&gt;</td>
<td>切换到下一个buffer</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;d</td>
<td>:CloseCurrentBuffer&lt;cr&gt;</td>
<td>关闭当前buffer</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;D</td>
<td>:BufOnly&lt;cr&gt;</td>
<td>删除除当前buffer外的所有buffer</td>
</tr>
</tbody></table>
<h3 id="preservim-tagbar"><a href="#preservim-tagbar" class="headerlink" title="preservim/tagbar"></a><a href="https://github.com/preservim/tagbar">preservim/tagbar</a></h3><p>右边栏，显式方法变量</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nnoremap &lt;silent&gt;&lt;leader&gt;t</td>
<td>:TagBarToggle .&lt;cr&gt;</td>
<td>显式右边栏</td>
</tr>
</tbody></table>
<h3 id="ycm-core-YouCompleteMe"><a href="#ycm-core-YouCompleteMe" class="headerlink" title="ycm-core/YouCompleteMe"></a><a href="https://github.com/ycm-core/YouCompleteMe">ycm-core/YouCompleteMe</a></h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nnoremap &lt;leader&gt;u</td>
<td>:YcmCompleter GoToDeclaration&lt;cr&gt;</td>
<td>跳转的函数声明</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;o</td>
<td>:YcmCompleter GoToInclude&lt;cr&gt;</td>
<td>跳转到include文件</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;ff</td>
<td>:YcmCompleter FixIt&lt;cr&gt;</td>
<td>自动修复错误</td>
</tr>
<tr>
<td>nmap &lt;F5&gt;</td>
<td>:YcmDiags&lt;cr&gt;</td>
<td>诊断错误</td>
</tr>
</tbody></table>
<h3 id="Yggdroot-LeaderF"><a href="#Yggdroot-LeaderF" class="headerlink" title="Yggdroot/LeaderF"></a><a href="https://github.com/Yggdroot/LeaderF">Yggdroot/LeaderF</a></h3><p>文件模糊搜索，按tab进行选择</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nnoremap &lt;leader&gt;f</td>
<td>:LeaderfFile .&lt;cr&gt;</td>
<td>当前目录下文件搜索，tab选择</td>
</tr>
</tbody></table>
<h3 id="mileszs-ack-vim"><a href="#mileszs-ack-vim" class="headerlink" title="mileszs/ack.vim"></a><a href="https://github.com/mileszs/ack.vim">mileszs/ack.vim</a></h3><p>ack文本搜索</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nnoremap &lt;leader&gt;F</td>
<td>:Ack!&lt;space&gt;</td>
<td>文本正则匹配</td>
</tr>
</tbody></table>
<p>!表示不自动跳到第一个匹配。</p>
<p>可以考虑替换成[junegunn/fzf.vim]，使用rg/ag更快。</p>
<h3 id="easymotion-vim-easymotion"><a href="#easymotion-vim-easymotion" class="headerlink" title="easymotion/vim-easymotion"></a><a href="https://github.com/easymotion/vim-easymotion">easymotion/vim-easymotion</a></h3><p>normal模式光标快速跳转，visual模式选择到指定位置。</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>map &lt;leader&gt;w</td>
<td>&lt;Plug&gt;(easymotion-bd-w)</td>
<td>选取至指定位置</td>
</tr>
<tr>
<td>nmap &lt;leader&gt;w</td>
<td>&lt;Plug&gt;(easymotion-overwin-w)</td>
<td>跳转到指定位置</td>
</tr>
</tbody></table>
<h3 id="haya14busa-incsearch-vim"><a href="#haya14busa-incsearch-vim" class="headerlink" title="haya14busa/incsearch.vim"></a><a href="https://github.com/haya14busa/incsearch.vim">haya14busa/incsearch.vim</a></h3><p>文本搜索，其实跟前一个类似，也是光标的跳转。</p>
<p>在按回车之前可以按ctrl+j/k来上下选择。</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>map /</td>
<td>&lt;Plug&gt;(incsearch-forward)</td>
<td>往下搜索</td>
</tr>
<tr>
<td>map  ?</td>
<td>&lt;Plug&gt;(incsearch-backward)</td>
<td>往上搜索</td>
</tr>
<tr>
<td>map g/</td>
<td>&lt;Plug&gt;(incsearch-stay)</td>
<td>按回车后光标不动</td>
</tr>
</tbody></table>
<h3 id="jiangmiao-auto-pairs"><a href="#jiangmiao-auto-pairs" class="headerlink" title="jiangmiao/auto-pairs"></a><a href="https://github.com/jiangmiao/auto-pairs">jiangmiao/auto-pairs</a></h3><p>自动补全成对符号</p>
<h3 id="preservim-nerdtree"><a href="#preservim-nerdtree" class="headerlink" title="preservim/nerdtree"></a><a href="https://github.com/preservim/nerdtree">preservim/nerdtree</a></h3><p>显式左边栏，目录。</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nnoremap &lt;silent&gt;&lt;leader&gt;n</td>
<td>:NERDTreeToggle .&lt;cr&gt;</td>
<td>显式左边栏</td>
</tr>
</tbody></table>
<h3 id="vim-nerdtree-syntax-highlight"><a href="#vim-nerdtree-syntax-highlight" class="headerlink" title="vim-nerdtree-syntax-highlight"></a><a href="https://github.com/tiagofumo/vim-nerdtree-syntax-highlight">vim-nerdtree-syntax-highlight</a></h3><p>左边栏文件类型高亮</p>
<h3 id="godlygeek-tabular"><a href="#godlygeek-tabular" class="headerlink" title="godlygeek/tabular"></a><a href="https://github.com/godlygeek/tabular">godlygeek/tabular</a></h3><p>文本对齐。</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nnoremap &lt;leader&gt;=</td>
<td>:Tab /=&lt;cr&gt;</td>
<td>关于=号对齐</td>
</tr>
<tr>
<td></td>
<td>:Tab /,/r1c1l0&lt;cr&gt;</td>
<td>逗号分隔，右对齐空一个，中对齐空一格左对齐不空</td>
</tr>
</tbody></table>
<p>默认是左对齐，下一个字段前空一格。可以通过一个字母加数字指定格式，其中l/c/r分别表示左对齐/居中对齐/右对齐，紧跟的数字表示下一个字段前插入的空格数。如果指定了多个格式会依次使用，用完了再从第一个开始。注意这个分隔符本身也算一个字段。分隔符并不一定是单个字符，其实可以是正则表达式。</p>
<h3 id="tpope-vim-fugitive"><a href="#tpope-vim-fugitive" class="headerlink" title="tpope/vim-fugitive"></a><a href="https://github.com/tpope/vim-fugitive">tpope/vim-fugitive</a></h3><p>集成Git，<code>:Git</code>后加对应git命令，还有一些扩展命令，如<code>:Gread</code>、<code>:Ggrep</code>等。</p>
<h3 id="tpope-vim-surround"><a href="#tpope-vim-surround" class="headerlink" title="tpope/vim-surround"></a><a href="https://github.com/tpope/vim-surround">tpope/vim-surround</a></h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>例子</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cs”‘</td>
<td>“Hello world!” -&gt; ‘Hello world!’</td>
<td>“改成‘</td>
</tr>
<tr>
<td>cs’&lt;q&gt;</td>
<td>‘Hello world!’ -&gt; &lt;q&gt;Hello world!&lt;/q&gt;</td>
<td>‘改成&lt;q&gt;对</td>
</tr>
<tr>
<td>cst”</td>
<td>&lt;q&gt;Hello world!&lt;/q&gt; -&gt; “Hello world!”</td>
<td>&lt;q&gt;对改成”，t表示完整匹配&lt;q&gt;</td>
</tr>
<tr>
<td>ds”</td>
<td>“Hello world!” -&gt; Hello world!</td>
<td>去掉”</td>
</tr>
<tr>
<td>dst</td>
<td>&lt;q&gt;Hello world!&lt;/q&gt; -&gt; Hello world!</td>
<td>t表示完整匹配&lt;q&gt;，而不是单个&lt;</td>
</tr>
<tr>
<td>ysiw]</td>
<td>Hello world! -&gt; [Hello] world!</td>
<td>光标所在单词加括号，右括号不加空格</td>
</tr>
<tr>
<td>ysiw{</td>
<td>Hello world! -&gt; { Hello } world!</td>
<td>光标所在单词加括号，左括号加空格</td>
</tr>
<tr>
<td>yss)</td>
<td>{ Hello } world! -&gt; ({ Hello } world!)</td>
<td>整行加()对</td>
</tr>
</tbody></table>
<p>可以跟vim-repeat配合，使用<code>.</code>重复之前的操作。</p>
<h3 id="tpope-vim-commentary"><a href="#tpope-vim-commentary" class="headerlink" title="tpope/vim-commentary"></a><a href="https://github.com/tpope/vim-commentary">tpope/vim-commentary</a></h3><p>快速注释</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>gcc</td>
<td></td>
<td>单行注释</td>
</tr>
<tr>
<td>gc</td>
<td></td>
<td>visual模式注释选择行</td>
</tr>
<tr>
<td>gcap</td>
<td></td>
<td>注释一整段</td>
</tr>
<tr>
<td>:7,17Commentary</td>
<td></td>
<td>注释所选行</td>
</tr>
<tr>
<td>gcgc</td>
<td></td>
<td>去掉所有相邻注释行的注释</td>
</tr>
</tbody></table>
<h3 id="tpope-vim-repeat"><a href="#tpope-vim-repeat" class="headerlink" title="tpope/vim-repeat"></a><a href="https://github.com/tpope/vim-repeat">tpope/vim-repeat</a></h3><p><code>.</code>操作支持map，支持tpope/vim-repeat等插件。</p>
<h3 id="tpope-vim-endwise"><a href="#tpope-vim-endwise" class="headerlink" title="tpope/vim-endwise"></a><a href="https://github.com/tpope/vim-endwise">tpope/vim-endwise</a></h3><p>if do等尾部补全</p>
<h3 id="octol-vim-cpp-enhanced-highlight"><a href="#octol-vim-cpp-enhanced-highlight" class="headerlink" title="octol/vim-cpp-enhanced-highlight"></a><a href="https://github.com/octol/vim-cpp-enhanced-highlight">octol/vim-cpp-enhanced-highlight</a></h3><p>cpp额外的语法高亮，增加了标准库/boost函数、容器、类型的高亮。</p>
<h3 id="vim-airline-vim-airline"><a href="#vim-airline-vim-airline" class="headerlink" title="vim-airline/vim-airline"></a><a href="https://github.com/vim-airline/vim-airline">vim-airline/vim-airline</a></h3><p>状态栏美化</p>
<h3 id="vim-airline-vim-airline-themes"><a href="#vim-airline-vim-airline-themes" class="headerlink" title="vim-airline/vim-airline-themes"></a><a href="https://github.com/vim-airline/vim-airline-themes">vim-airline/vim-airline-themes</a></h3><p>状态栏主题库</p>
<h3 id="ryanoasis-vim-devicons"><a href="#ryanoasis-vim-devicons" class="headerlink" title="ryanoasis/vim-devicons"></a><a href="https://github.com/ryanoasis/vim-devicons">ryanoasis/vim-devicons</a></h3><p>显示文件类型图表</p>
<h3 id="junegunn-vim-slash"><a href="#junegunn-vim-slash" class="headerlink" title="junegunn/vim-slash"></a><a href="https://github.com/junegunn/vim-slash">junegunn/vim-slash</a></h3><p>光标移动后清除搜索的高亮</p>
<h3 id="junegunn-gv-vim"><a href="#junegunn-gv-vim" class="headerlink" title="junegunn/gv.vim"></a><a href="https://github.com/junegunn/gv.vim">junegunn/gv.vim</a></h3><p>git commit浏览器。</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nnoremap &lt;leader&gt;g</td>
<td>:GV</td>
<td>打开commit浏览器，可以加git log选项</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;G</td>
<td>:GV!</td>
<td>只列出影响当前文件的commits</td>
</tr>
<tr>
<td>nnoremap &lt;leader&gt;gg</td>
<td>:GV?</td>
<td>当前文件revisions的位置列表</td>
</tr>
</tbody></table>
<p><code>:GV</code>和<code>:GV?</code>可以用于visual模式，追踪选择行的变化。</p>
<p>在列表中界面</p>
<p><code>o</code>或<code>&lt;cr&gt;</code>，单个commit，显示其内容。</p>
<p><code>o</code>或<code>&lt;cr&gt;</code>，多个commits，显示所选范围的变化</p>
<p><code>O</code>，打开一个新tab显示，而不是分隔窗口</p>
<p><code>.</code>，当前光标所在commit，开始一条命令<code>:Git [CURSOR] SHA</code></p>
<p><code>q</code>或<code>gq</code>关闭</p>
<h3 id="kana-vim-textobj-user"><a href="#kana-vim-textobj-user" class="headerlink" title="kana/vim-textobj-user"></a><a href="https://github.com/kana/vim-textobj-user">kana/vim-textobj-user</a></h3><p>自定义文本对象。例如下面定义了<code>ad</code>/<code>id</code>选取一个日期如<code>2013-03-16</code>，<code>at</code>/<code>it</code>选取一个时间如<code>22:04:21</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call textobj#user#plugin(&#x27;datetime&#x27;, &#123;</span><br><span class="line">\   &#x27;date&#x27;: &#123;</span><br><span class="line">\     &#x27;pattern&#x27;: &#x27;\&lt;\d\d\d\d-\d\d-\d\d\&gt;&#x27;,</span><br><span class="line">\     &#x27;select&#x27;: [&#x27;ad&#x27;, &#x27;id&#x27;],</span><br><span class="line">\   &#125;,</span><br><span class="line">\   &#x27;time&#x27;: &#123;</span><br><span class="line">\     &#x27;pattern&#x27;: &#x27;\&lt;\d\d:\d\d:\d\d\&gt;&#x27;,</span><br><span class="line">\     &#x27;select&#x27;: [&#x27;at&#x27;, &#x27;it&#x27;],</span><br><span class="line">\   &#125;,</span><br><span class="line">\ &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="kana-vim-textobj-indent"><a href="#kana-vim-textobj-indent" class="headerlink" title="kana/vim-textobj-indent"></a><a href="https://github.com/kana/vim-textobj-indent">kana/vim-textobj-indent</a></h3><p> indented blocks of lines的文本对象，不知道他指的啥</p>
<h3 id="kana-vim-textobj-syntax"><a href="#kana-vim-textobj-syntax" class="headerlink" title="kana/vim-textobj-syntax"></a><a href="https://github.com/kana/vim-textobj-syntax">kana/vim-textobj-syntax</a></h3><p>语法高亮项目的文本对象</p>
<h3 id="kana-vim-textobj-function"><a href="#kana-vim-textobj-function" class="headerlink" title="kana/vim-textobj-function"></a><a href="https://github.com/kana/vim-textobj-function">kana/vim-textobj-function</a></h3><p>函数的文本对象，af if aF iF</p>
<h3 id="sgur-vim-textobj-parameter"><a href="#sgur-vim-textobj-parameter" class="headerlink" title="sgur/vim-textobj-parameter"></a><a href="https://github.com/sgur/vim-textobj-parameter">sgur/vim-textobj-parameter</a></h3><p>函数参数文本对象，默认是a, i,</p>
<h3 id="Shougo-echodoc-vim"><a href="#Shougo-echodoc-vim" class="headerlink" title="Shougo/echodoc.vim"></a><a href="https://github.com/Shougo/echodoc.vim">Shougo/echodoc.vim</a></h3><p>补全时在命令行显示函数签名。</p>
<h3 id="rhysd-clever-f-vim"><a href="#rhysd-clever-f-vim" class="headerlink" title="rhysd/clever-f.vim"></a><a href="https://github.com/rhysd/clever-f.vim">rhysd/clever-f.vim</a></h3><p>增强的f/F/t/T，多次连续可以只按一个字符，与第一大小写相同则同方向，否则反方向。</p>
<h3 id="vim-scripts-indentpython-vim"><a href="#vim-scripts-indentpython-vim" class="headerlink" title="vim-scripts/indentpython.vim"></a><a href="https://github.com/vim-scripts/indentpython.vim">vim-scripts/indentpython.vim</a></h3><p>python缩进脚本</p>
<h3 id="rhysd-github-complete-vim"><a href="#rhysd-github-complete-vim" class="headerlink" title="rhysd/github-complete.vim"></a><a href="https://github.com/rhysd/github-complete.vim">rhysd/github-complete.vim</a></h3><p>github补全，包括emoji、用户名、仓库名、issue号、链接URL补全。</p>
<h3 id="DrwaIt"><a href="#DrwaIt" class="headerlink" title="DrwaIt"></a><a href="">DrwaIt</a></h3><p>vim画图工具，</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;leader&gt;di</td>
<td>:DrawIt</td>
<td>开始画图模式</td>
</tr>
<tr>
<td>&lt;leader&gt;ds</td>
<td>:DIstop</td>
<td>结束画图模式</td>
</tr>
<tr>
<td>&lt;leader&gt;a 选择模式</td>
<td></td>
<td>画箭头</td>
</tr>
<tr>
<td>&lt;leader&gt;b 选择模式</td>
<td></td>
<td>画矩形</td>
</tr>
<tr>
<td>&lt;leader&gt;e 选择模式</td>
<td></td>
<td>画椭圆</td>
</tr>
<tr>
<td>&lt;leader&gt;l 选择模式</td>
<td></td>
<td>画直线</td>
</tr>
<tr>
<td>&lt;leader&gt;c</td>
<td></td>
<td>画布增大</td>
</tr>
<tr>
<td>&lt;leader&gt;f</td>
<td></td>
<td>字符某个填充</td>
</tr>
<tr>
<td>&lt;leader&gt;s</td>
<td></td>
<td>追加空格至文本宽度（默认78）</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>space</td>
<td></td>
<td>切换画图/擦除模式</td>
</tr>
<tr>
<td>r/R</td>
<td></td>
<td>替换模式</td>
</tr>
<tr>
<td>&lt;&gt;^v</td>
<td></td>
<td>插入箭头，前面加&lt;leader&gt;粗箭头</td>
</tr>
</tbody></table>
<h3 id="dense-analysis-ale"><a href="#dense-analysis-ale" class="headerlink" title="dense-analysis/ale"></a><a href="https://github.com/dense-analysis/ale">dense-analysis/ale</a></h3>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章搞懂密码学基础及SSL/TLS协议</title>
    <url>/posts/e92ef4b4/</url>
    <content><![CDATA[<div class="note primary">
            <p>SSL协议是现代网络通信中重要的一环，它提供了传输层上的数据安全。为了方便大家的理解，本文将先从加密学的基础知识入手，然后展开对SSL协议原理、流程以及一些重要的特性的详解，最后会扩展介绍一下国密SSL协议的差异、安全性以及TLS 1.3的关键新特性。</p><p>限于篇幅以及个人知识水平，本文不会涉及过于细节的内容。特别地，本文将不涉及算法的具体原理，也不涉及实际代码的实现。而是试图以图表等直观的方式来了解基本的原理以及流程。</p>
          </div>

<span id="more"></span>

<h1 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h1><h2 id="古典的密码"><a href="#古典的密码" class="headerlink" title="古典的密码"></a>古典的密码</h2><p>密码学的历史可以追溯到很久以前，早在罗马共和国时期，据说凯撒就使用凯撒密码和他的将军进行通信。</p>
<h3 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h3><p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Caesar3.svg" alt="Caesar Cipher" loading="lazy"></p>
<p>凯撒密码就是一个简单地移位操作。凯撒密钥非常容易被破解，使用<strong>暴力破解</strong>的方式把密钥从0到25都尝试一遍就可以了。</p>
<h3 id="简单替换密码"><a href="#简单替换密码" class="headerlink" title="简单替换密码"></a>简单替换密码</h3><p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/simple-substitution-cipher.png" alt="Simple Substitution Cipher" loading="lazy"></p>
<p>简单替换密码，其明文字母表和密文字母表之间是一种随机的映射关系。这种方式密钥空间为<code>26! ~= 4 * 10^26</code>，这已经无法使用暴力破解方式来找到正确的密钥。但是可以使用<strong>频率分析</strong>来破译。</p>
<h3 id="Enigma密码机"><a href="#Enigma密码机" class="headerlink" title="Enigma密码机"></a>Enigma密码机</h3><p>二战时期德国使用的一系列转子机械加解密机器。尽管此机器的安全性较高，但盟军的密码学家们还是成功地破译了大量由这种机器加密的信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Enigma.jpg" alt="Enigma" loading="lazy"></p>
<p>主要弱点：</p>
<ul>
<li>将通信密码连续输入两次并加密</li>
<li>通信密码是人为选定</li>
<li>必须派发国防军密码本</li>
</ul>
<h2 id="对称密码"><a href="#对称密码" class="headerlink" title="对称密码"></a>对称密码</h2><h3 id="块密码和流密码"><a href="#块密码和流密码" class="headerlink" title="块密码和流密码"></a>块密码和流密码</h3><p>上面几种密码其实都属于对称密码的范畴，对称加密算法可以分为块密码和流密码两种：</p>
<ul>
<li>块密码（block cipher）：每次只能处理特定长度的数据块。一个块的长度就叫块长度（分组长度）</li>
<li>流密码（stream cipher）：对数据流进行连续处理的一类密码算法。一般以1比特、8比特或32比特为单位进行加密和解密。</li>
</ul>
<h3 id="AES-Advanced-Encryption-Standard"><a href="#AES-Advanced-Encryption-Standard" class="headerlink" title="AES (Advanced Encryption Standard)"></a>AES (Advanced Encryption Standard)</h3><p>AES是目前最常用的对称算法之一。对称加密算法，顾名思义，就是<strong>加密和解密使用相同的密钥</strong>。发送方使用密钥K对明文P进行加密得到密文C，然后将密文C发送给接收方，接收方使用相同的密钥K对密文进行解密，得到明文P。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/symmetric-cipher-flow.png" alt="symmetric-cipher-flow" loading="lazy"></p>
<p>AES采用的是Rijndael算法，下图是Rijndael加密中一轮的操作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/RijndaelEncrypt.png" alt="RijndaelEncrypt" loading="lazy"></p>
<p>每一轮都会进行字节替换、行位移、列混合和轮密钥异或，使得输入的位得到充分的<strong>混淆</strong>。一个块的加密会经过很多轮的操作，最终得到密文。</p>
<p>因为这4轮操作都是<strong>可逆</strong>的，解密的时候就是一个相反的过程。</p>
<h2 id="块密码的模式"><a href="#块密码的模式" class="headerlink" title="块密码的模式"></a>块密码的模式</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而块与块之间进行<strong>迭代的方法</strong>就称为分组密码的<strong>模式（mode）</strong>。</p>
<p>常用模式由：ECB、CBC、OFB、CFB、CTR等。这边限于篇幅，仅介绍ECB、CBC、CTR三种。</p>
<h4 id="ECB模式"><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h4><p>ECB是最简单的一种模式，每个块是独立进行加密的。将明文分组加密之后的结果直接成为密文分组。当最后一个明文分组的内容小于分组长度时，需要用一些特定的数据进行填充（padding）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Ecb_encryption.png" alt="Ecb_encryption" loading="lazy"></p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Ecb_decryption.png" alt="Ecb_decryption" loading="lazy"></p>
<p>ECB模式有非常显著的<strong>缺点</strong>：同样的明文块会被加密成相同的密文块；因此，它不能很好的隐藏数据模式。在某些场合，这种方法不能提供严格的数据保密性。</p>
<p>比如下面的企鹅图，用ECB模式加密之后得到中间的图，还是能很明显地看出图片的轮廓，不能很好的保护数据的机密性。而用其他模式加密之后，就得到如第三个图所示的结果，已经看不出明显的特征。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/ecb-penguin1.jpg" alt="原图" loading="lazy"> <img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/ecb-penguin2.jpeg" alt="ECB模式" loading="lazy"><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/ecb-penguin3.jpg" alt="其他模式" loading="lazy"></p>
<h4 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h4><p>CBC模式中，每个明文块先与前一个密文块进行异或，再进行加密。所以每个明文块都依赖于前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量（IV）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Cbc_encryption.png" alt="Cbc_encryption" loading="lazy"></p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Cbc_decryption.png" alt="Cbc_decryption" loading="lazy"></p>
<p>CBC是TLS1.2时代最为常用的工作模式。它没有ECB模式那个相同原文加密称相同密文的问题，但是也因此导致其并行计算能力不如ECB模式。</p>
<h4 id="CTR模式"><a href="#CTR模式" class="headerlink" title="CTR模式"></a>CTR模式</h4><p>计数器模式其实是将块加密转换成了流加密，它对一个逐次累加的计数器进行加密，然后用加密的比特序列与明文进行XOR操作得到密文。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/CTR_encryption_2.svg" alt="CTR_encryption" loading="lazy"></p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/CTR_decryption_2.svg" alt="CTR_decryption" loading="lazy"></p>
<p>计数器的作用跟CBC模式中的IV类似，保证相同的明文会加密成不同的密文。相比CBC等模式，CTR模式还有如下<strong>优点</strong>：它非常适合并行计算、错误密文中的对应比特只会影响明文中的对应比特。</p>
<h3 id="AEAD（Authenticated-Encryption-with-Associated-Data）"><a href="#AEAD（Authenticated-Encryption-with-Associated-Data）" class="headerlink" title="AEAD（Authenticated Encryption with Associated Data）"></a>AEAD（Authenticated Encryption with Associated Data）</h3><p>前面的那些模式都已经被发现存在不同程序的缺点或问题。在TLS1.3时代，只保留了AEAD类型的加密模式。AEAD在加密的同时增加了认证的功能，常用的有GCM、CCM、Ploy1305。</p>
<h4 id="GCM（Galois-Counter-Mode）"><a href="#GCM（Galois-Counter-Mode）" class="headerlink" title="GCM（Galois/Counter Mode）"></a>GCM（Galois/Counter Mode）</h4><p>GCM中的G是指的GMAC（关于MAC我们稍后会讲到），C就是指的我们前面提到的CTR计数器模式。下图右上角的部分就是上面的Counter模式加密，剩余部分则是GMAC。最终的结果包含初始计数器值、加密密文和MAC值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/GCM-Galois_Counter_Mode_with_IV.svg" alt="GCM-Galois_Counter_Mode_with_IV" loading="lazy"></p>
<h2 id="公钥密码（非对称密码）"><a href="#公钥密码（非对称密码）" class="headerlink" title="公钥密码（非对称密码）"></a>公钥密码（非对称密码）</h2><p>在使用对称加密时，一定会碰到<strong>密钥分发（密钥交换）</strong>的问题。使用预先共享密钥具有局限性，需要一种安全的方式将密钥交给对方。于是就引出了公钥密码。</p>
<h3 id="公钥密码算法（RSA、国密SM2）"><a href="#公钥密码算法（RSA、国密SM2）" class="headerlink" title="公钥密码算法（RSA、国密SM2）"></a>公钥密码算法（RSA、国密SM2）</h3><p>最常用的公钥密钥算法要数大名鼎鼎的RSA了，国密中则有SM2算法。公钥密码有两个密钥，其中一个是公开密钥，公开密钥可以散布，另一个是私有密钥，需要自己严密保管。比如Bob要发消息给Alice，Bob用Alice的公钥对消息进行加密，然后发送给Alice，Alice则用自己的私钥进行解密。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Public_key_encryption.svg" alt="Public_key_encryption" loading="lazy"></p>
<h3 id="Diffie-Hellman密钥交换"><a href="#Diffie-Hellman密钥交换" class="headerlink" title="Diffie-Hellman密钥交换"></a>Diffie-Hellman密钥交换</h3><p>另一种常用的公钥密码是DH类算法，可以用下图来形象地解释DH算法的原理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Diffie-Hellman_Key_Exchange.svg" alt="Diffie-Hellman_Key_Exchange" loading="lazy"></p>
<p>首先双方协商一个相同的底色（算法参数），然后各自生成自己私有的颜色（相当于私钥），并通过混合得到对应的公有颜色（相当于公钥）。随后双方交换各自的公有颜色，并与自己的私钥颜色混合，最终协商出一个相同的颜色（即交换的密钥）。窃听者就算得到了双方交换的这些信息，也无法生成相同的密钥，<strong>求解离散对象问题的困难度</strong>保证了DH算法的安全性。</p>
<h3 id="ECDH和ECDHE"><a href="#ECDH和ECDHE" class="headerlink" title="ECDH和ECDHE"></a>ECDH和ECDHE</h3><p><code>ECDH</code>是基于椭圆曲线的DH算法，原理上跟DH基本一样，主要是把有限域上的模幂运算替换成了椭圆曲线上的点乘运算。相比DH算法速度更快，可逆更难。</p>
<p>DH和ECDH都是使用的一个固定密钥，一旦密钥泄漏，以前所有的密文消息就都都破解了。<code>ECDHE</code>则提供了前向安全性，它每次使用一个临时的密钥，基于这个临时密钥进行密钥交换生成会话密钥。就算这个临时密钥泄漏了，也只影响本次SSL会话的消息。</p>
<h2 id="单向散列函数（Hash）"><a href="#单向散列函数（Hash）" class="headerlink" title="单向散列函数（Hash）"></a>单向散列函数（Hash）</h2><p>前面的对称密钥和公钥密码解决了信息传输的<strong>机密性</strong>问题，使我们传输的信息不被窃听。但是还没有解决<strong>完整性</strong>的问题，消息有可能在中途被“<strong>篡改</strong>”。所以就轮到单向散列函数出场了。</p>
<p><strong>单向散列函数</strong>可以根据输入的信息，计算出一个固定长度的散列值（摘要值），这个散列值可以作为消息的指纹用于检查消息的完整性。修改了原始消息的任意1个比特，最终生成的散列值可能就完全不同了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Cryptographic_Hash_Function.svg" alt="Cryptographic_Hash_Function" loading="lazy"></p>
<p>理想的散列函数具有以下几个性质：</p>
<ol>
<li>确定性：同样的消息总是产生同样的散列值</li>
<li>任何给定消息能够快速计算出散列值</li>
<li>单向性：无法通过散列值反算出消息</li>
<li><strong>弱抗碰撞性</strong>：难以找到可以生成给定散列值的消息</li>
<li><strong>强抗碰撞性</strong>：难以找到可以生成两条相同散列值的消息</li>
<li>消息的一个小的改动会导致Hash值的巨大变化</li>
</ol>
<h2 id="消息认证码（MAC）"><a href="#消息认证码（MAC）" class="headerlink" title="消息认证码（MAC）"></a>消息认证码（MAC）</h2><p>单向散列函数虽然保证了消息的<strong>完整性</strong>，但是聪明的攻击者可以将消息连同其散列值一起篡改了，而接收方却无法进行识别。所以还需要对消息进行<strong>认证</strong>，传统的认证方法有手写签名、盖章、手印、身份证、口令（其实是个共享密钥）等。在密码领域则可以通过消息认证码的方法进行认证。消息认证码相比单向散列函数，多了一个共享密钥对消息进行认证。攻击者因为没有这个密钥，所以无法伪造出MAC值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/MAC-vs-HASH.png" alt="MAC-vs-HASH" loading="lazy"></p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/HMAC-use-scene.png" alt="HMAC-use-scene" loading="lazy"></p>
<h3 id="MAC的问题"><a href="#MAC的问题" class="headerlink" title="MAC的问题"></a>MAC的问题</h3><ul>
<li>MAC跟对称密码一样需要一个共享密钥，所以也会有密钥分发的问题。</li>
<li>无法对第三方证明</li>
<li>无法防止否认</li>
</ul>
<h2 id="数字签名（RSA、ECDSA）"><a href="#数字签名（RSA、ECDSA）" class="headerlink" title="数字签名（RSA、ECDSA）"></a>数字签名（RSA、ECDSA）</h2><p>为了解决MAC的问题，又引入了数字签名。</p>
<p>数字签名同样属于公钥密码的范畴。跟之前不同的地方是，它使用私钥进行加密（该操作叫作签名），任何人都可以用公钥进行解密（该操作叫作验签）。因为公钥是公开的，所以解决了第三方证明的问题。又因为私钥只有本人具有，没有私钥的人事实上无法生成这段密文，所以也可以防止否认。所以MAC的三个问题都可以由数字签名解决。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Private_key_signing.svg" alt="Private_key_signing" loading="lazy"></p>
<p>通常配合散列函数使用，同时保证了完整性，也加快了速度。如下图所示，Alice发送消息给Bob。她先把自己的公钥发送给Bob，接着她对消息先计算一个散列值，然后用自己的私钥对这个散列值进行加密得到消息的签名值。然后她将初始的消息和签名一同发送给Bob。Bob收到之后，对消息进行同样的散列函数计算得到散列值，同时用Alice的公钥对签名数据进行解密，得到解密后散列值，然后在比较两个计算得到散列值是否一致，以验证签名的有效性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/DigitalSignature.png" alt="DigitalSignature" loading="lazy"></p>
<h2 id="数字证书、-CA"><a href="#数字证书、-CA" class="headerlink" title="数字证书、 CA"></a>数字证书、 CA</h2><p>到目前为止，我们的公钥密码、数字签名解决了机密性、完整性、可以进行认证以及防止否认等。但其实这一切都是基于一个大前提：就是<strong>公钥是属于真正的发送者</strong>。如果公钥是伪造的、那么这一切就都失效了。前面提到的数字签名只能保证对方拥有这个公钥对应的私钥，但是没法认证公钥所有者本身的身份。</p>
<p>为了解决这个问题，数字证书应运而出。它的解决方式就是让一个<strong>可信的第三方</strong>来对公钥进行签名。这个可信的第三方，我们一般称之为<strong>Certificate authorities（CA）</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Chain-of-trust-with-cert.svg" loading="lazy"></p>
<p>我们来看看实际证书是什么样子的。其中<code>Subject</code>是证书拥有者的信息，<code>Issuer</code>就是其签发者的信息，<code>Subject Public Key Info</code>是实际的公钥信息，这里用的是RSA 2048位的密钥。证书最后就是CA用自己的私钥对这个证书的签名。任何拥有CA的证书（包含公钥）的人都可以对这个证书进行验证，从而验证公钥所有者的身份。<code>Validity</code>是这个证书的有效期。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ openssl x509 -<span class="keyword">in</span> ~/sharefile/certs/rsa-user.pem -text -noout</span><br><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number:</span><br><span class="line">            a2:95:90:e8:e0:f6:3a:e4</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">        Issuer: C=CN, ST=SH, L=Shanghai, O=Awesome Software, OU=SSL Group, CN=RSA_CA_Cert/emailAddress=ssl@ca.com</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Nov  5 01:47:05 2018 GMT</span><br><span class="line">            Not After : Nov  2 01:47:05 2028 GMT</span><br><span class="line">        Subject: C=CN, ST=SH, L=Shanghai, O=Awesome Software, OU=SSL Group, CN=RSA_USER/emailAddress=rsa@site.com</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: rsaEncryption</span><br><span class="line">                Public-Key: (2048 bit)</span><br><span class="line">                Modulus:</span><br><span class="line">                    00:f4:a0:b6:57:e7:68:39:98:39:13:11:b9:61:ee:</span><br><span class="line">                    1d:5c:60:c6:53:51:ec:0e:59:53:0e:12:75:1c:5b:</span><br><span class="line">                    b1:b7:e4:dd:4d:c8:c1:b8:eb:07:32:12:a1:<span class="built_in">fc</span>:50:</span><br><span class="line">                    33:d9:63:4a:30:7f:b4:b5:e9:87:d9:71:33:65:ab:</span><br><span class="line">                    56:54:ba:34:92:06:9a:af:ff:84:8e:a3:29:af:46:</span><br><span class="line">                    61:3b:45:39:c5:a8:0a:f9:ae:fb:d4:2b:20:5a:9d:</span><br><span class="line">                    ce:00:fe:c9:87:b2:f4:d2:f8:bf:b7:2e:7a:79:5e:</span><br><span class="line">                    94:54:7d:f9:09:73:4a:ec:c7:22:01:79:4c:62:11:</span><br><span class="line">                    55:a9:d3:3b:f8:ef:3e:1d:56:e3:2f:34:ef:c6:0f:</span><br><span class="line">                    2c:94:40:01:a3:6f:1e:3b:61:bd:79:00:bf:26:f7:</span><br><span class="line">                    d6:c3:a6:22:22:50:f0:6e:aa:03:1e:ea:d9:e6:ad:</span><br><span class="line">                    4d:a9:60:4f:6d:81:80:f4:f9:a9:89:31:ab:f1:a3:</span><br><span class="line">                    9b:1a:a2:57:ed:44:30:39:<span class="built_in">fc</span>:3a:3a:c3:6e:c8:a6:</span><br><span class="line">                    db:2e:14:c1:3b:6b:5b:ca:ab:b7:0d:fb:85:39:08:</span><br><span class="line">                    bf:6b:41:c1:f6:42:b1:3f:9c:45:5c:4c:37:8e:7d:</span><br><span class="line">                    c6:18:f8:9b:87:16:80:7f:25:34:8f:14:a9:02:2e:</span><br><span class="line">                    7c:07:c9:8a:21:77:33:03:6a:9c:86:f1:73:9c:c8:</span><br><span class="line">                    2d:f1</span><br><span class="line">                Exponent: 65537 (0x10001)</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Basic Constraints:</span><br><span class="line">                CA:FALSE</span><br><span class="line">            X509v3 Key Usage:</span><br><span class="line">                Digital Signature, Non Repudiation, Key Encipherment</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">         30:cf:b2:9f:50:ea:d7:0d:e2:87:50:e6:bd:d7:b0:17:12:31:</span><br><span class="line">         b1:9f:59:16:50:60:bc:52:c0:46:7a:43:d0:34:43:48:d0:bd:</span><br><span class="line">         e1:a0:dc:75:a2:60:a0:c9:8f:ed:d4:36:14:18:75:c0:ef:c3:</span><br><span class="line">         92:fa:43:fa:34:5a:12:77:2f:03:00:eb:a6:db:d9:6b:50:ff:</span><br><span class="line">         44:56:22:c6:51:73:73:9a:4b:fd:bb:53:ff:2b:7e:97:55:d3:</span><br><span class="line">         4d:bb:bd:26:69:37:8d:71:30:41:bf:fd:48:40:<span class="built_in">fc</span>:6f:<span class="built_in">cd</span>:e2:</span><br><span class="line">         b7:4a:90:6f:a2:11:85:a7:88:d3:61:d5:03:0a:50:98:cc:0e:</span><br><span class="line">         aa:d5:83:38:b4:d5:f0:06:ff:a5:eb:d4:e6:54:14:e9:65:af:</span><br><span class="line">         36:a5:e4:3e:8b:78:18:0b:d6:7c:cc:f1:a3:da:7a:03:fd:89:</span><br><span class="line">         23:f0:e1:3e:af:7b:b1:7a:53:82:11:4a:5e:1d:84:b6:0b:cc:</span><br><span class="line">         96:b4:3a:8a:43:cf:ff:b3:3a:be:47:e0:40:c0:48:15:b4:f3:</span><br><span class="line">         2d:2b:73:b8:07:d2:21:83:3c:c4:4c:c2:31:17:4e:4c:15:da:</span><br><span class="line">         66:fd:06:9a:b7:ed:b5:9e:71:a3:40:0b:39:12:3c:7b:cb:cb:</span><br><span class="line">         a0:af:d0:c7:fe:59:41:35:04:7f:f3:f3:38:d0:d0:ac:7a:15:</span><br><span class="line">         7e:fa:ee:fd</span><br></pre></td></tr></table></figure>

<p>在实际使用中，通常会使用多级证书链，每一级证书由上一级CA签发，并由上一级CA的证书进行验签。最终的Root CA证书只能由它自己签发的，也即用自己的私钥对自己的公钥进行签名，否则就无限递归了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/CA-signing-of-digital-certificates.svg" alt="CA-signing-of-digital-certificates" loading="lazy"></p>
<p>所以数字证书实际上是一种信任链的传递，将对众多个体的身份认证转移到对少数几个CA的身份认证，可以减少遭到中间人攻击的风险。从公钥密码和证书这些出发就引出了<strong>公钥基础设置（PKI）</strong>：这是为了能够更有效地运用公钥而制定的一系列规范和规格的总称。</p>
<h2 id="混合密码系统"><a href="#混合密码系统" class="headerlink" title="混合密码系统"></a>混合密码系统</h2><p>那么有了公钥密码，是不是就不需要对称密码了呢？公钥密码虽然解决了对称密码的密钥分发问题，但是在计算速度上却远低于对称密码，相差几个数量级。下面是用<code>openssl speed</code>测试RSA1024和AES128的结果。AES128（相同块大小）的速度大概是RSA1024签名的1200倍，是验签的70倍。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ openssl speed rsa1024</span><br><span class="line">                  sign    verify    sign/s verify/s</span><br><span class="line">rsa 1024 bits 0.000103s 0.000006s   9732.8 162578.8</span><br><span class="line"></span><br><span class="line">$ openssl speed -evp aes128</span><br><span class="line"><span class="built_in">type</span>             16 bytes     64 bytes    256 bytes   1024 bytes   8192 bytes  16384 bytes</span><br><span class="line">aes-128-cbc    1075884.36k  1452740.12k  1510392.06k  1530545.83k  1537414.49k  1537114.11k</span><br></pre></td></tr></table></figure>

<p>因为对称密码和非对称密码各有优缺点，所以在实际应用中通常将两者结合起来，使用非对称密码来完成密钥交换，然后生成会话密钥作为对称密码的密钥，使用对称密码对信息进行加解密。</p>
<h2 id="随机数发生器"><a href="#随机数发生器" class="headerlink" title="随机数发生器"></a>随机数发生器</h2><p>截止目前，我们已经解决了很多问题，包括机密性、完整性、认证性、防抵赖，但其实还有一个大问题我们没有解决：即我们的<strong>会话密钥</strong>如何生成？一个安全的算法其所有的安全性应该都是基于其<strong>密钥的安全性</strong>，如果我们的密钥可以被轻易破解或预测，那我们前面构建的一切就都土崩瓦解了。所以随机数发生器就在这里起到了至关重要的作用。</p>
<p>随机数同样在<strong>防重放攻击</strong>中具有重要的作用，所谓重放攻击，就是攻击者将窃听的数据保存下来，在后面再原样发送给接收者，以达到其特定的攻击目的。防重放的常用手段有使用序号、时间戳、随机数等。</p>
<p>这里留个问题给大家思考，因为机密性和完整性的保护，攻击者既不能解密消息，又不能对消息进行篡改，那么重放有什么用呢？</p>
<p>理想的随机数发生器具有以下特性：</p>
<ul>
<li>随机性：不存在统计学偏差，是完全杂乱的数列</li>
<li>不可预测性：不能从过去的数列推测出下一个出现的数</li>
<li>不可重现性：除非将数列本身保存下来，否则不能重现相同的数列</li>
</ul>
<h2 id="密钥派生函数-key-derivation-function"><a href="#密钥派生函数-key-derivation-function" class="headerlink" title="密钥派生函数 key derivation function"></a>密钥派生函数 key derivation function</h2><p>KDF可用于将密钥材料扩展为更长的密钥或获取所需格式的密钥。TLS 1.2中是用的PRF算法，TLS 1.3中则是用的HKDF算法。</p>
<h1 id="SSL-TLS协议详解"><a href="#SSL-TLS协议详解" class="headerlink" title="SSL/TLS协议详解"></a>SSL/TLS协议详解</h1><h2 id="什么是SSL-TLS协议"><a href="#什么是SSL-TLS协议" class="headerlink" title="什么是SSL/TLS协议"></a>什么是SSL/TLS协议</h2><p>好了，有了前面的密码学基础，我们就可以正式进入TLS协议的介绍。前面介绍的基本都是独立的算法或者是几个算法结合起来的组件，而SSL/TLS协议则是基于这些底层的算法原语和组件，最终拼装而成的一个<strong>成品的密码学协议</strong>。</p>
<p>SSL全称是<code>Secure Sockets Layer</code>，安全套接字层，它是由网景公司(Netscape)设计的主要用于Web的安全传输协议，目的是为网络通信提供机密性、认证性及数据完整性保障。如今，SSL已经成为互联网保密通信的工业标准。</p>
<p>SSL最初的几个版本(SSL 1.0、SSL2.0、SSL 3.0)由网景公司设计和维护，从3.1版本开始，SSL协议由因特网工程任务小组(IETF)正式接管，并更名为TLS(Transport Layer Security)，发展至今已有TLS 1.0、TLS1.1、TLS1.2这几个版本。目前主流的还是TLS1.2，不过TLS1.3即将是大势所趋。</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Published</th>
<th>Status</th>
</tr>
</thead>
<tbody><tr>
<td>SSL 1.0</td>
<td>Unpublished</td>
<td>Unpublished</td>
</tr>
<tr>
<td>SSL 2.0</td>
<td>1995</td>
<td>Deprecated in 2011 (RFC <a href="https://datatracker.ietf.org/doc/html/rfc6176">6176</a>)</td>
</tr>
<tr>
<td>SSL 3.0</td>
<td>1996</td>
<td>Deprecated in 2015 (RFC <a href="https://datatracker.ietf.org/doc/html/rfc7568">7568</a>)</td>
</tr>
<tr>
<td>TLS 1.0</td>
<td>1999</td>
<td>Deprecated in 2020 (RFC <a href="https://datatracker.ietf.org/doc/html/rfc8996">8996</a>)[<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#cite_note-tls-deprecation-8">8]</a>[<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#cite_note-:3-9">9]</a>[<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#cite_note-:4-10">10]</a></td>
</tr>
<tr>
<td>TLS 1.1</td>
<td>2006</td>
<td>Deprecated in 2020 (RFC <a href="https://datatracker.ietf.org/doc/html/rfc8996">8996</a>)[<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#cite_note-tls-deprecation-8">8]</a>[<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#cite_note-:3-9">9]</a>[<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#cite_note-:4-10">10]</a></td>
</tr>
<tr>
<td>TLS 1.2</td>
<td>2008</td>
<td></td>
</tr>
<tr>
<td>TLS 1.3</td>
<td>2018</td>
<td></td>
</tr>
</tbody></table>
<p>SSL/TLS协议能够提供的安全目标主要包括如下几个：</p>
<div class="note info no-icon">
            <ul><li><p><strong>机密性</strong>：借助加密防止第三方窃听</p></li><li><p><strong>认证性</strong>：借助数字证书认证服务器端和客户端身份，防止身份伪造</p></li><li><p><strong>完整性</strong>：借助消息认证码(MAC)保障数据完整性，防止消息篡改</p></li><li><p><strong>防重放</strong>：防止重放攻击</p></li></ul>
          </div>



<h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><p>相信大家对TCP/IP 5层模型已经非常熟悉了，TLS协议就如其名字所说的（Transport Layer Security），用于保障传输层的安全。它位于传输层之上，应用层之下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS-layered-structure.svg" alt="TLS-layered-structure" loading="lazy"></p>
<p>SSL/TLS协议有一个高度模块化的架构，其内部又分为很多子协议：Handshake协议、Alert协议、ChangeCipherSpec协议、Application协议。它们底层都是基于Record协议，记录层协议负责识别不同的上层消息类型以及消息的分段加密认证等。</p>
<ul>
<li>Handshake协议：包括协商安全参数和算法套件、服务器身份认证(客户端身份认证可选)、密钥交换</li>
<li>Application协议：用于传输应用层数据</li>
<li>ChangeCipherSpec 协议：一条消息表明握手协议已经完成</li>
<li>Alert 协议：对握手协议中一些异常的错误提醒，分为fatal和warning两个级别，fatal类型的错误会直接中断SSL连接，而warning级别的错误一般情况下SSL连接会继续，只是会给出错误警告</li>
</ul>
<p>SSL/TLS协议被设计为一个两阶段协议，分为<strong>握手阶段</strong>和<strong>应用阶段</strong>。</p>
<p><strong>握手阶段</strong>：也称协商阶段，在这一阶段主要目标就是进行我们前面已经提到过的协商安全参数和算法套件、身份认证（基于数字证书）以及密钥交换生成后续加密通信所使用的密钥。</p>
<p><strong>应用阶段</strong>：双方使用握手阶段协商好的密钥进行安全通信。</p>
<h2 id="SSL-record"><a href="#SSL-record" class="headerlink" title="SSL record"></a>SSL record</h2><p>SSL记录层包的格式，跟其下的IP或TCP层类似，所有在SSL会话上交换的数据都按如下格式封装成帧。记录层协议负责识别不同的消息类型，也负责对消息的分段、压缩、消息认证和完整性保护、加密等工作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS-record-structure.svg" alt="TLS-record-structure" loading="lazy"></p>
<p>一个典型的记录层工作流（分组密码算法）如下：</p>
<ul>
<li>记录层接收到应用层的数据</li>
<li>将接收到的数据分块</li>
<li>使用协商的MAC key计算MAC或HMAC，并增加到记录块中</li>
<li>使用协商的Cipher Key将记录数据加密</li>
</ul>
<p>当加密的数据到了接收端，对方则进行相反的操作：解密数据、验证MAC、重组数据并交给应用层。</p>
<p>所有这些工作都由SSL层完成了，对于上层应用是完全透明的。</p>
<p>对于握手阶段的消息，payload是明文，当然就没有MAC和Padding。其他消息的payload都是密文。</p>
<p>对于<strong>流加密算法</strong>，没有后面的padding。对于<strong>块加密算法</strong>的记录，根据使用的算法在payload之前有可选的IV字段。</p>
<p>对于<strong>AEAD算法</strong>，因为认证已经包含在算法里了，所以没有后面的MAC和Padding字段。payload之前有一个外部nonce字段。</p>
<h2 id="算法套件CipherSuites"><a href="#算法套件CipherSuites" class="headerlink" title="算法套件CipherSuites"></a>算法套件CipherSuites</h2><p>在深入握手流程之前，我们先来了解一下算法套件的概念。前面在密码学基础部分我们已经了解到了各种算法，包括认证算法、密钥交换算法、对称密码算法、完整性认证的算法。</p>
<h3 id="TLS-1-2"><a href="#TLS-1-2" class="headerlink" title="TLS 1.2-"></a>TLS 1.2-</h3><p>一个<strong>算法套件</strong>是一个SSL连接中用到的这些算法类型的组合，包含如下几个部分：</p>
<ul>
<li>Key Exchange（Kx）</li>
<li>Authentication（Au）</li>
<li>Encryption（Enc）</li>
<li>Message Authentication Code（Mac）</li>
</ul>
<p>常见的算法套件类型比如<code>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256</code>，<code>TLS_RSA_WITH_AES_256_GCM_SHA384</code>、<code>TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384</code>、<code>ECC_SM2_WITH_SM4_SM3</code>（国密）、<code>ECDHE_SM2_WITH_SM4_SM3</code>（国密）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/CipherSuite1_2.png" alt="CipherSuite1_2" loading="lazy"></p>
<p>以<code>ECDHE-ECDSA-AES128-GCM-SHA256</code>为例，前面的<code>ECDHE</code>表示密钥交换算法，<code>ECDSA</code>表示身份认证算法，<code>AES128-GCM</code>表示对称加密算法，其中<code>128</code>表示块长度，<code>GCM</code>是其模式，<code>SHA256</code>表示哈希算法。对于<code>AEAD</code>因为消息认证和加密已经合并到一起了，最后的<code>SHA256</code>只表示密钥派生函数的算法，而对于传统的数据加密和认证分开的算法套件，它还表示<code>MAC</code>的算法。</p>
<p>可以通过如下命令查看每种算法套件的详细情况：<code>openssl ciphers -V | column -t | less</code>。</p>
<h3 id="TLS-1-3"><a href="#TLS-1-3" class="headerlink" title="TLS 1.3"></a>TLS 1.3</h3><p>对于TLSv1.3，因为已经将密钥交换和身份认证算法从算法套件中独立出去，算法套件只表示加密算法和密钥派生函数。之所以要独立出去，是因为支持的算法越来越多了，导致相乘之后算法套件数量庞大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/CipherSuite1_3.png" alt="CipherSuite1_3" loading="lazy"></p>
<p>可以用如下命令查看当前支持哪些TLS 1.3算法套件：<code>openssl ciphers -V | column -t | grep &#39;TLSv1.3&#39;</code>。</p>
<h2 id="SSL-handshake"><a href="#SSL-handshake" class="headerlink" title="SSL handshake"></a>SSL handshake</h2><p>终于进入核心的握手协议部分了。如前所述，SSL握手主要干以下几件事情：首先得商量双方用什么算法套件，然后根据需要认证对方的身份（基于数字证书），最后基于选择的算法套件进行密钥交换生成后续加密通信所使用的密钥。（本节描述的是TLS 1.2及以前版本的情况）</p>
<p>下图是一个完整SSL握手的建立流程:</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS-full-handshake-flow.svg" alt="TLS-full-handshake-flow" loading="lazy"></p>
<p>首先是TCP的3次握手建立TCP连接，然后客户端发起SSL握手。一次完整的SSL握手包含两次交互，第一次主要是完成算法套件的选择。第二次交互主要是完成身份认证以及密钥交换。这些都协商完成之后，SSL的安全通道就建立完成了。后续的应用数据就会在安全通道上进行加密传输。</p>
<h3 id="密钥交换流程-RSA"><a href="#密钥交换流程-RSA" class="headerlink" title="密钥交换流程-RSA"></a>密钥交换流程-RSA</h3><p>基于RSA的密钥交换流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/SSL-keyexchange-RSA.jpeg" alt="SSL-keyexchange-RSA" loading="lazy"></p>
<p>我们来模拟下协商过程：</p>
<ul>
<li><span class="label info">客户端</span>：Hi，服务端，我这边支持这些算法，这是我本次的随机数。</li>
<li><span class="label success">服务端</span>：好的，我看看，我们就选用这个算法套件吧，这是我本次的随机数，这是我的证书，你用这个证书里的公钥来加密预主密钥。</li>
<li><span class="label info">客户端</span>：稍等我验下证书，嗯，的确是服务端的证书。这是用证书中公钥加密的预主密钥。（使用两个随机数+预主密钥计算主密钥，然后生成会话密钥。。。）好了，我这边OK了。</li>
<li><span class="label success">服务端</span>：收到。（用私钥解密出预主密钥，使用两个随机数+预主密钥计算主密钥，然后生成会话密钥。。。）好了，我这边也OK了。</li>
<li><span class="label info">客户端</span>：这是加密的应用数据。。。</li>
<li><span class="label success">服务端</span>：这是加密的应用数据。。。</li>
</ul>
<p>注：上面的流程是单向认证（服务端没有验证客户端的身份），如果服务端也需要验客户端的身份，会在第一次交互中发送<code>Certificate Request</code>消息，客户端相应的在第二次交互中发送自己的<code>Certificate</code>以及<code>CertificateVerify</code>消息给服务端。</p>
<h3 id="密钥交换流程-DH"><a href="#密钥交换流程-DH" class="headerlink" title="密钥交换流程-DH"></a>密钥交换流程-DH</h3><p>基于DH的密钥交换流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/SSL-keyexchange-DH.jpeg" alt="SSL-keyexchange-DH" loading="lazy"></p>
<p>我们同样来模拟下协商过程：</p>
<ul>
<li><span class="label info">客户端</span>：Hi，服务端，我这边支持这些算法，这是我本次的随机数。</li>
<li><span class="label success">服务端</span>：好的，我看看，我们就选用这个算法套件吧，这是我本次的随机数，给你我的证书。我这边用这个DH参数，这是对应的签名。</li>
<li><span class="label info">客户端</span>：稍等我验下证书和签名，嗯，的确是服务端的证书，签名也没有问题。这是我这边的DH参数。（使用DH参数推导出预主密钥，再使用两个随机数+预主密钥计算主密钥，然后生成会话密钥。。。）好了，我这边OK了。</li>
<li><span class="label success">服务端</span>：收到。（使用DH参数推导预主密钥，再使用两个随机数+预主密钥计算主密钥，然后生成会话密钥。。。）好了，我这边也OK了。</li>
<li><span class="label info">客户端</span>：这是加密的应用数据。。。</li>
<li><span class="label success">服务端</span>：这是加密的应用数据。。。</li>
</ul>
<h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><p>通过第一次ClientHello和ServerHello的交互、以及密钥交换的过程，客户端和服务端双方，都得到了client随机数、server随机数以及预主密钥。接下来就可以通过这些来计算主密钥了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">master_secret = PRF(pre_master_secret, &quot;master secret&quot;,</span><br><span class="line">                    ClientHello.random + ServerHello.random)</span><br><span class="line">                    [0..47];</span><br></pre></td></tr></table></figure>

<p>得到主密钥之后，再将其扩展为一个安全字节序列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key_block = PRF(SecurityParameters.master_secret,</span><br><span class="line">                     &quot;key expansion&quot;,</span><br><span class="line">                     SecurityParameters.server_random +</span><br><span class="line">                     SecurityParameters.client_random);</span><br></pre></td></tr></table></figure>

<p>然后分别切分为MAC密钥、对称加密的key和IV。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client_write_MAC_key[SecurityParameters.mac_key_length]</span><br><span class="line">server_write_MAC_key[SecurityParameters.mac_key_length]</span><br><span class="line">client_write_key[SecurityParameters.enc_key_length]</span><br><span class="line">server_write_key[SecurityParameters.enc_key_length]</span><br><span class="line">client_write_IV[SecurityParameters.fixed_iv_length]</span><br><span class="line">server_write_IV[SecurityParameters.fixed_iv_length]</span><br></pre></td></tr></table></figure>

<p>画成图的话大概是下面这个样子。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS1_2-Key-Calculation.png" alt="TLS1_2-Key-Calculation" loading="lazy"></p>
<h2 id="Session重用"><a href="#Session重用" class="headerlink" title="Session重用"></a>Session重用</h2><p>SSL握手额外引入了<strong>两次交互</strong>以及<strong>CPU密集型</strong>的算法运算。每次连接都进行SSL握手时非常耗费性能的，有没有什么办法进行性能优化呢？显然提升硬件性能、软件性能都是有效的方法。其实SSL从协议层面也考虑了这个问题，它提供了“会话重用”的特性。双方在建立前一次SSL连接之后，可以将SSL会话保存下来。下一次想要在建立SSL连接的时候，可以直接恢复之前的SSL会话，从而简化SSL握手流程。Session重用的时候只需要进行一次SSL握手交互，而且不需要再进行身份认证和密钥交换，从而大幅减小了整个流程的延迟和计算开销。</p>
<p>事实上，如果浏览器要对同个站点发起多个连接，它通常就会等第一个SSL握手完成后再发起其他的连接，这样其他的连接就可以复用之前的那个Session。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS-half-handshake-flow.svg" alt="TLS-half-handshake-flow" loading="lazy"></p>
<p>Session重用有两种机制，分别为Session IDs和Session tickets。</p>
<h3 id="Session-ID"><a href="#Session-ID" class="headerlink" title="Session ID"></a>Session ID</h3><p>我们来看下使用Session ID时的Session重用流程。从前面密钥交换的流程图中可以看到，服务端在<code>Server Hello</code>消息中会发送本次会话的<code>Session ID</code>给客户端。完成握手之后，服务端会保存本次的Session。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/session_resumption_with_session_id.jpeg" alt="session_resumption_with_session_id" loading="lazy"></p>
<p>后续客户端可以通过恢复这个Session来建立SSL连接。具体做法就是在<code>ClientHello</code>消息中带上要恢复的Session ID，然后服务端会根据Session ID去查找对应的会话，如果一切都OK的话，就会根据保存的会话恢复出会话密钥等信息。如果服务端不支持会话重用、或者没找到Session ID、或者会话已经过期了，那么就退化到完整的SSL握手。</p>
<h3 id="Session-Ticket"><a href="#Session-Ticket" class="headerlink" title="Session Ticket"></a>Session Ticket</h3><p>Session ID机制它要求服务端保存每个客户端的session cache，这会在服务端造成几个问题：内存的额外开销、要求Session的保存和淘汰策略、然后对有多个服务器的站点，如何高性能地共享session cache提出了挑战。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/session_resumption_with_session_ticket.jpeg" alt="session_resumption_with_session_ticket" loading="lazy"></p>
<p>Session Ticket机制的提出就是为了解决Session ID的问题。Session Ticket不需要服务端保存每个客户端的会话。取而代之，如果客户端宣称它支持session ticket，服务端会发送给客户端一个<code>New Session Ticket</code>消息，其中包含了会话相关的加密数据，加密的密钥只有服务端知道。</p>
<p>客户端会保存这个session ticket，当需要会话恢复的时候，它会在<code>ClientHello</code>消息的<code>SessionTicket</code>扩展中带上这个session ticket。服务端在收到之后解密出其中的session数据从而恢复上次的会话。</p>
<p>所以Session Ticket机制对于服务端来说是一种无状态（stateless）的重用，不需要服务端保存session cache，当然也就没有多服务器同步的问题。</p>
<h2 id="证书的吊销（黑名单）"><a href="#证书的吊销（黑名单）" class="headerlink" title="证书的吊销（黑名单）"></a>证书的吊销（黑名单）</h2><p>我们在介绍证书的时候已经看到了证书有一个有效期，在有效期外是无法验证通过的。但是如果我们想在有效期内就让证书失效该怎么办？比如公司员工离职了、或者私钥泄漏等，总不可能把发出去的证书收回来吧。</p>
<p>所以就引入了证书的吊销，CA可以吊销某张证书，在验证证书有效性的时候进行额外的黑名单验证。黑名单的验证有如下几种机制：</p>
<h3 id="Certificate-Revocation-List-CRL"><a href="#Certificate-Revocation-List-CRL" class="headerlink" title="Certificate Revocation List (CRL)"></a>Certificate Revocation List (CRL)</h3><p>CRL，即证书吊销列表。CA机构维护一个被吊销证书的列表，里面是被吊销证书的信息。验证证书方需要下载这个列表，进行黑名单的验证。</p>
<p>CRL的缺陷也很明显：证书验证方必须下载这个列表，且下载的列表跟实际CA机构的列表之间可能不同步。如果一个证书实际已经被吊销，但是并没有在本地列表中，就可能形成安全隐患。</p>
<h3 id="Online-Certificate-Status-Protocol-OCSP"><a href="#Online-Certificate-Status-Protocol-OCSP" class="headerlink" title="Online Certificate Status Protocol (OCSP)"></a>Online Certificate Status Protocol (OCSP)</h3><p>OCSP，即在线证书状态协议。它通过在线请求的方式来进行黑名单验证，不需要下载整个 list，只需要将该证书的序列号发送给 CA 进行验证。部署 OCSP 对 CA也引入了一定的要求，CA 需要搭建的一个高性能的服务器来提供验证服务。万一服务器挂掉了，那所有的黑名单验证就会当成是通过，有一定的安全隐患。</p>
<h3 id="OCSP-Stapling"><a href="#OCSP-Stapling" class="headerlink" title="OCSP Stapling"></a>OCSP Stapling</h3><p>OCSP Stapling是OCSP标准的一个扩展，主要目标就是提升性能和安全性。证书拥有者自己定期向OCSP服务器发送请求。获取OCSP响应，这个响应是基于时间戳的，而且由CA直接签名。</p>
<p>OCSP Stapling提升整体的性能，一方面证书验证方不需要再直接请求CA的服务器去查询状态，另一方面CA的OCSP服务器的压力也减小了。</p>
<h2 id="Server-Name-Indication（SNI）"><a href="#Server-Name-Indication（SNI）" class="headerlink" title="Server Name Indication（SNI）"></a>Server Name Indication（SNI）</h2><p>当一个站点上部署了多个Server时（相当于一个IP映射了多个域名），不同的Server可能需要使用不同的证书。问题是如何在SSL握手阶段知道是访问那个host（还没到HTTP阶段，无法用请求头里的<code>HOST</code>字段），从而决定使用对应的证书呢？</p>
<p>SNI就是为了解决这个问题，具体做法是在<code>ClientHello</code>扩展中带上SNI，服务端就能从中得知需要访问哪个host，从而选择相应的证书。</p>
<h1 id="GMSSL协议差异"><a href="#GMSSL协议差异" class="headerlink" title="GMSSL协议差异"></a>GMSSL协议差异</h1><p>GMSSL修改自TLS1.1，总体上与TLS协议的差异不大。详见《GMT 0024-2014 SSL VPN技术规范》。</p>
<h2 id="协议号"><a href="#协议号" class="headerlink" title="协议号"></a>协议号</h2><p>TLSv1.0, TSLv1.1, TLSv1.2、TLSv1.3的协议号分别为<code>0x0301</code>、<code>0x0302</code>、<code>0x0303</code>、<code>0x0304</code>。</p>
<p>而国密的版本号是<code>0x0101</code>。</p>
<h2 id="算法套件"><a href="#算法套件" class="headerlink" title="算法套件"></a>算法套件</h2><p>新增了国密的SM1/2/3/4等算法，定义了多个算法套件，其中比较常用的如<code>ECC_SM4_SM3</code>和<code>ECDHE_SM4_SM3</code>。<code>ECDHE_SM4_SM3</code>要求必须双向认证。</p>
<p>其中<code>ECC_SM4_SM3</code>的密钥交换过程类似RSA的密钥交换过程，由客户端用服务端的公钥对预主密钥进行加密后发送给服务端。<code>ECDHE_SM4_SM3</code>的密钥交换过程与普通TLS的ECDHE密钥交换类似，预主密钥由客户端和服务端双方推导得出。<code>ECC_SM4_SM3</code>和<code>ECDHE_SM4_SM3</code>的身份认证是都是通过SM2的签名/验签来完成。</p>
<h2 id="双证书体系"><a href="#双证书体系" class="headerlink" title="双证书体系"></a>双证书体系</h2><h3 id="证书消息"><a href="#证书消息" class="headerlink" title="证书消息"></a>证书消息</h3><p>国密SSL采用双证书体系：一个签名证书、一个加密证书。其中签名证书用于身份认证、加密证书用于密钥交换。发送<code>Certificate</code>消息时需要同时发送两个证书，格式与标准TLS报文格式一样，第一个证书是签名证书、第二个证书是加密证书。</p>
<h3 id="ECC-SM4-SM3密钥交换"><a href="#ECC-SM4-SM3密钥交换" class="headerlink" title="ECC_SM4_SM3密钥交换"></a>ECC_SM4_SM3密钥交换</h3><p>因为采用了双证书体系，在SSL状态机上略微有点不同。<code>ECC_SM4_SM3</code>的密钥交换过程如下：服务端发送<code>Certificate</code>消息之后，还要发送一个<code>ServerKeyExchange</code>消息（这跟RSA密钥交换有所不同），<code>ServerKeyExchange</code>中包含了一个签名值，签名由服务端签名证书对应的私钥（签名私钥）进行计算，签名的内容包括了ClientHello和ServerHello中的随机数以及加密证书。</p>
<p>客户端验证证书和签名之后，使用服务端加密证书加密预主密钥，发送给服务端，服务端则由自己的加密私钥进行解密得到预主密钥。</p>
<h3 id="ECDHE-SM4-SM3密钥交换"><a href="#ECDHE-SM4-SM3密钥交换" class="headerlink" title="ECDHE_SM4_SM3密钥交换"></a>ECDHE_SM4_SM3密钥交换</h3><p><code>ECDHE_SM4_SM3</code>的密钥交换过程如下：服务端发送<code>Certificate</code>消息之后，同样发送一个<code>ServerKeyExchange</code>消息，<code>ServerKeyExchange</code>中包含了一个签名值，签名由服务端签名证书对应的私钥（签名私钥）进行计算。签名的内容跟<code>ECC_SM4_SM3</code>时有所不同，包括了ClientHello和ServerHello中的随机数以及服务端ECDH参数（曲线、公钥）。国密ECDHE的密钥推导计算方式跟TLS也有所不同，TLS只需要对方的临时公钥和自己的临时私钥参与计算，而国密需要对方的临时公钥和固定公钥（即加密证书中的公钥）及自己的临时私钥和固定私钥（即加密私钥）参与计算。所以国密<code>ECDHE</code>必须是双向认证，因为服务端在进行密钥推导的时候也需要用到客户端的加密证书。</p>
<p>客户端验证证书和签名之后，发送自己的证书给服务端，接着根据<code>ServerKeyExchange</code>中ECDH参数信息生成自己的临时密钥，然后同自己的加密密钥、服务端临时公钥和加密公钥一起进行密钥推导得到预主密钥。并将自己的临时密钥参数通过<code>ClientKeyExchange</code>消息发送给服务端，服务端同样使用自己的临时密钥、加密密钥、客户端的临时公钥和加密公钥一起进行密钥推导得到预主密钥。</p>
<p>因为是双向认证，客户端在发送<code>ClientKeyExchange</code>消息之后，还需要发送一个<code>CertificateVerify</code>消息，签名的内容为从ClientHello消息开始到目前为止的所有已经交换的握手消息。</p>
<h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><h2 id="常见攻击"><a href="#常见攻击" class="headerlink" title="常见攻击"></a>常见攻击</h2><p>有些是针对协议设计上的漏洞，有些则是针对实现的bug，经常结合降级攻击手段一起使用。因为篇幅原因，这里仅挑选两个有代表性的重协商攻击和Heartbleed着重介绍一下，对于其余攻击感兴趣的可以参考<a href="https://datatracker.ietf.org/doc/html/rfc7457">rfc7457-已知攻击总结</a></p>
<ul>
<li>重协商攻击</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/renegotiation-attack.png" loading="lazy"></p>
<p>中间人在不需要劫持、解密SSL/TLS连接的情况下，成功地将自己伪造的数据插入到用户真正数据之前。中间人如果了解APP协议（如HTTPS）的话，则会精心构造不完整的数据，让服务器的APP程序认为发生粘包，将数据暂缓不处理，继续等待后续的数据上来。例如攻击者先发送了如下的半拉子请求</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/bank/sendmoney.asp?acct=attacker&amp;amount=1000000</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">X-Ignore-This:</span><br></pre></td></tr></table></figure>

<p>后面当客户端发送过来真正的请求</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/ebanking</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>validcookie</span><br></pre></td></tr></table></figure>

<p>APP程序将请求拼接，真正的请求头被屏蔽了，但是却保留了用户的Cookie信息，从而利用用户的Cookie去访问网站内容。服务端会以为前面发送的请求是真正的客户端发送的。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/bank/sendmoney.asp?acct=attacker&amp;amount=1000000</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">X-Ignore-This</span><span class="punctuation">: </span>GET /ebanking HTTP/1.1</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>validcookie</span><br></pre></td></tr></table></figure>



<p>这个漏洞成因在于，客户端认为的首次协商却被服务器认为是重协商，以及首次协商和重协商之间缺少关联性。解决办法就是禁用重协商或者使用<a href="https://datatracker.ietf.org/doc/html/rfc5746">安全重协商</a>。安全重协商会增加一个安全重协商标志，以及确认首次协商和重协商的关联性校验，从而确保中间人的攻击行为可以被识别并拒绝，保证重协商安全。</p>
<p>我们来看看安全重协商是如何保证安全的，对于前面的ClientHello2里面不携带安全重协商表示的情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/renegotiation-attack-fix1.png" alt="renegotiation-attack-fix1" loading="lazy"></p>
<p>对于前面的ClientHello2里面携带安全重协商表示的情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/renegotiation-attack-fix2.png" alt="renegotiation-attack-fix2" loading="lazy"></p>
<p>无论哪种情况都能保证中间人无机可乘。而这个安全重协商的标识就是提供了一个新的扩展性<code>renegotiation_info</code>。因为SSLv3/TLS 1.0不支持扩展，所以提供了另一种方法，即在算法套件列表中加上<code>TLS_EMPTY_RENEGOTIATION_INFO_SCSV（0xFF）</code>，这个不是一个真正的算法套件，只是起标识作用。</p>
<p>安全重协商的流程如下：</p>
<pre><code> 1. 在连接建立第一次SSL握手期间，双方通过`renegotiation_info`扩展或`SCSV`套件通知对方自己支持安全重协商
 2. 然后在握手结束之后，client和server都分别记录`Finish`消息之中的`client_verify_data`和`server_verify_data`
 3. 重协商时client在`ClientHello`中包含`client_verify_data`，server在`ServerHello`中包含`client_verify_data`和`server_verify_data`。对于受害者，如果协商中不会携带这些数据则连接无法建立。而Finished消息由于是加密的，攻击者无法得到client_verify_data和server_verify_data的值。
</code></pre>
<ul>
<li><a href="https://heartbleed.com/">Heartbleed</a></li>
</ul>
<p>这是OpenSSL库一个实现上的bug，而不是TLS协议本身的bug。这个bug是由于TLS heartbeat扩展的实现没有进行正确的输入验证（缺少边界检查）导致的。bug的命名也从heartbeat而来。由于没有进行边界检查，导致可以读取的数据超出允许的范围。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Simplified_Heartbleed_explanation.svg" alt="Simplified_Heartbleed_explanation" loading="lazy"></p>
<p>这个bug当前造成了非常广泛的影响，有调查显示在这个漏洞公布后几年，仍有许多网站暴露在此攻击之下。这个bug告诫我们就算协议是安全的，实现仍然可能引入安全问题。安全性就像一个木桶，整体的安全性取决于最短的那块木板。</p>
<ul>
<li>CRIME和BREACH攻击</li>
</ul>
<p>这两个攻击都是基于压缩算法，通过改变请求正文，对比被压缩后的密文长度，可以破解出某些信息。</p>
<p>CRIME通过在受害者的浏览器中运行JavaScript代码并同时监听HTTPS传输数据，能够解密会话Cookie，主要针对TLS压缩。</p>
<p>Javascript代码尝试一位一位的暴力破解Cookie的值。中间人组件能够观察到每次破解请求和响应的密文，寻找不同，一旦发现了一个，他会和执行破解的Javascript通信并继续破解下一位。</p>
<p>BREACH攻击是CRIME攻击的升级版，攻击方法和CRIME相同，不同的是BREACH利用的不是SSL/TLS压缩，而是HTTP压缩。所以要抵御BREACH攻击必须禁用HTTP压缩。</p>
<ul>
<li>BEAST攻击</li>
</ul>
<p>TLS 在 1.1版本之前，下一个记录的IV是直接使用的前一个记录的密文。BEAST攻击就是利用了这一点，攻击者控制受害者发送大量请求，利用可预测性IV猜测关键信息。解决方法就是部署TLS 1.1或者更高级的版本。</p>
<ul>
<li>RC4攻击</li>
</ul>
<p>基于RC4算法的安全性，RC4目前已经不安全，应该禁用。</p>
<ul>
<li>POODLE攻击</li>
</ul>
<p>是SSL 3.0设计上的漏洞，使用了非确定性的CBC-padding，使中间人攻击者更容易通过padding-oracle攻击获取明文数据。</p>
<ul>
<li>降级攻击（版本回退攻击）</li>
</ul>
<p>欺骗服务器使用低版本的不安全的TLS协议，常和其他攻击手段结合使用。删除后向兼容性通常是防止降低攻击的唯一方法。</p>
<h2 id="前向安全性"><a href="#前向安全性" class="headerlink" title="前向安全性"></a>前向安全性</h2><p>如果没有前向安全性，一旦私钥泄漏，不仅将来的会话会受影响，过去的会话也都会受影响。一个耐心的黑客，可以先把以前截获的数据先保存下来，一旦私钥泄露或被破解，就可以破解之前的所有密文。这就是所谓的<strong>今日截获，明日破解</strong>。</p>
<p>TLS的实现之一就是通过使用临时的DH密钥交换来生成会话密钥，<strong>一次一密</strong>保证了即使黑客花大力气破解了这一次的会话密钥，也只是这次通信被攻击，之前的历史消息不会受到影响。这我们已经在第一部分中讲到了。</p>
<p>但即使是使用了临时DH密钥交换，服务端的session管理机制也会影响到前向安全性。前面Session重用的部分我们讲到了session ticket，它的保护完全是依赖于对称加密，所以长时间有效的session ticket密钥会阻止前向安全性的实现。</p>
<p>在实践中，应该优先使用临时DH密钥交换类算法套件，session的有效期不宜设置过长，session ticket的key也应该经常更换。</p>
<h1 id="TLS-1-3新特性"><a href="#TLS-1-3新特性" class="headerlink" title="TLS 1.3新特性"></a>TLS 1.3新特性</h1><p>TLS 1.3相比TLS 1.2改动巨大，它的主要改进目标是<strong>最大兼容</strong>、<strong>强化安全</strong>、<strong>提升性能</strong>。</p>
<p>下面列举了相比TLS 1.3的<strong>主要差异</strong>：</p>
<ul>
<li>对称加密算法只保留了AEAD类算法，将密钥交换和认证算法从算法套件的概念中分离出去了</li>
<li>增加了0-RTT模式</li>
<li>移除了静态RSA和DH密钥协商（现在所有基于公钥的密钥交换都提供了前向安全性）</li>
<li>现在所有的<code>ServerHello</code>后的握手消息都是加密的</li>
<li>密钥派生函数重新设计，KDF换成了标准的<code>HKDF</code></li>
<li>握手状态机大幅重构，砍掉了多余的消息如<code>ChangeCipherSpec</code></li>
<li>使用统一的PSK模型，替代了之前的Session Resumption（包括Session ID和Session Ticket）及早期TLS版本基于PSK（rfc4279）的算法套件</li>
</ul>
<p>这里介绍几个关键的特性</p>
<h2 id="密钥交换模式"><a href="#密钥交换模式" class="headerlink" title="密钥交换模式"></a>密钥交换模式</h2><p>TLS 1.3提出了3种密钥交换模式：</p>
<ul>
<li>(EC)DHE</li>
<li>PSK-only（pre-shared symmetric key）</li>
<li>PSK with (EC)DHE 前两者的结合，具有前向安全性</li>
</ul>
<h2 id="1-RTT握手"><a href="#1-RTT握手" class="headerlink" title="1-RTT握手"></a>1-RTT握手</h2><p>如前所述，TLS 1.2的完整握手有2个RTT，第一个RTT是<code>ClientHello/ServerHello</code>，第二个RTT是<code>ServerKeyExchange/ClientKeyExchange</code>。之所以需要两个RTT是因为TLS 1.2支持多种密钥交换算法及各种不同的参数，这些都依赖第一个RTT去协商出来。TLS 1.3直接大刀阔斧，砍掉了各种自定义的group、curve，砍掉了RSA密钥交换，只剩下为数不多的几个密钥交换算法，实际应用中大部分使用<code>ECDH P-256</code>或<code>X25519</code>。所以干脆让客户端缓存服务器上一次用的是啥密钥交换算法，把<code>KeyExchange</code>直接合入第一个RTT。如果服务器发现客户端发上来的算法不对，那么再告诉它正确的，让客户端重试就好了。（这就引入了<code>HelloRetryRequest</code>消息）。这样基本没有副作用，就可以降到1-RTT了。</p>
<p>TLS 1.3的完整握手流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       Client                                           Server</span><br><span class="line"></span><br><span class="line">Key  ^ ClientHello</span><br><span class="line">Exch | + key_share*</span><br><span class="line">     | + signature_algorithms*</span><br><span class="line">     | + psk_key_exchange_modes*</span><br><span class="line">     v + pre_shared_key*       --------&gt;</span><br><span class="line">                                                  ServerHello  ^ Key</span><br><span class="line">                                                 + key_share*  | Exch</span><br><span class="line">                                            + pre_shared_key*  v</span><br><span class="line">                                        &#123;EncryptedExtensions&#125;  ^  Server</span><br><span class="line">                                        &#123;CertificateRequest*&#125;  v  Params</span><br><span class="line">                                               &#123;Certificate*&#125;  ^</span><br><span class="line">                                         &#123;CertificateVerify*&#125;  | Auth</span><br><span class="line">                                                   &#123;Finished&#125;  v</span><br><span class="line">                               &lt;--------  [Application Data*]</span><br><span class="line">     ^ &#123;Certificate*&#125;</span><br><span class="line">Auth | &#123;CertificateVerify*&#125;</span><br><span class="line">     v &#123;Finished&#125;              --------&gt;</span><br><span class="line">       [Application Data]      &lt;-------&gt;  [Application Data]</span><br><span class="line"></span><br><span class="line">              +  Indicates noteworthy extensions sent in the</span><br><span class="line">                 previously noted message.</span><br><span class="line"></span><br><span class="line">              *  Indicates optional or situation-dependent</span><br><span class="line">                 messages/extensions that are not always sent.</span><br><span class="line"></span><br><span class="line">              &#123;&#125; Indicates messages protected using keys</span><br><span class="line">                 derived from a [sender]_handshake_traffic_secret.</span><br><span class="line"></span><br><span class="line">              [] Indicates messages protected using keys</span><br><span class="line">                 derived from [sender]_application_traffic_secret_N.</span><br><span class="line"></span><br><span class="line">               Figure 1: Message Flow for Full TLS Handshake</span><br></pre></td></tr></table></figure>

<p>握手过程可以分成三个阶段：</p>
<ul>
<li>密钥交换：建立共享密钥材料，选择加密参数。此阶段后的所有信息都是加密的。</li>
<li>服务端参数：建立其他握手参数，如客户端是否需要认证、应用层协议支持</li>
<li>认证：身份认证，提供密钥确认和握手完整性</li>
</ul>
<h2 id="重用和PSK"><a href="#重用和PSK" class="headerlink" title="重用和PSK"></a>重用和PSK</h2><p>TLS的PSK可以直接在带外建立，也可以通过前一个连接的会话建立。一旦一个握手完成了之后，服务端就会给客户端发送一个PSK id，对应初始握手推导出的密钥。（对应TLS 1.2及之前版本的Session ID和Session Tickets，这两个机制在TLS 1.3中都弃用了）。</p>
<p>PSK可以单独使用，或者跟(EC)DHE密钥交换结合使用以提供前向安全性。</p>
<p>重用和PSK的握手流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       Client                                               Server</span><br><span class="line"></span><br><span class="line">Initial Handshake:</span><br><span class="line">       ClientHello</span><br><span class="line">       + key_share               --------&gt;</span><br><span class="line">                                                       ServerHello</span><br><span class="line">                                                       + key_share</span><br><span class="line">                                             &#123;EncryptedExtensions&#125;</span><br><span class="line">                                             &#123;CertificateRequest*&#125;</span><br><span class="line">                                                    &#123;Certificate*&#125;</span><br><span class="line">                                              &#123;CertificateVerify*&#125;</span><br><span class="line">                                                        &#123;Finished&#125;</span><br><span class="line">                                 &lt;--------     [Application Data*]</span><br><span class="line">       &#123;Certificate*&#125;</span><br><span class="line">       &#123;CertificateVerify*&#125;</span><br><span class="line">       &#123;Finished&#125;                --------&gt;</span><br><span class="line">                                 &lt;--------      [NewSessionTicket]</span><br><span class="line">       [Application Data]        &lt;-------&gt;      [Application Data]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Subsequent Handshake:</span><br><span class="line">       ClientHello</span><br><span class="line">       + key_share*</span><br><span class="line">       + pre_shared_key          --------&gt;</span><br><span class="line">                                                       ServerHello</span><br><span class="line">                                                  + pre_shared_key</span><br><span class="line">                                                      + key_share*</span><br><span class="line">                                             &#123;EncryptedExtensions&#125;</span><br><span class="line">                                                        &#123;Finished&#125;</span><br><span class="line">                                 &lt;--------     [Application Data*]</span><br><span class="line">       &#123;Finished&#125;                --------&gt;</span><br><span class="line">       [Application Data]        &lt;-------&gt;      [Application Data]</span><br><span class="line"></span><br><span class="line">            Figure 3: Message Flow for Resumption and PSK</span><br></pre></td></tr></table></figure>

<p>这种情况下服务端的身份通过PSK认证，所以服务端不发送<code>Certficate</code>和<code>CertificateVerify</code>消息。当客户端通过PSK提议重用的时候，也应该提供<code>key_share</code>扩展，以便服务端在拒绝重用的时候回退到全握手。</p>
<h2 id="有副作用的0-RTT握手"><a href="#有副作用的0-RTT握手" class="headerlink" title="有副作用的0-RTT握手"></a>有副作用的0-RTT握手</h2><p>当客户端和服务端共享一个PSK的时候（无论是通过外部获得还是通过前面的握手获得），TLS 1.3允许客户端在第一个flight上就发送数据（early data）。客户端使用PSK来认证服务端及加密early data。</p>
<p>0-RTT的握手流程如下，与PSK重用的1-RTT握手相比，增加<code>early_data</code>扩展以及第一个flight上的0-RTT应用数据。当接收到服务端的<code>Finished</code>消息之后，会发送一个<code>EndOfEarlyData</code>消息指示后面加密密钥的更换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client                                               Server</span><br><span class="line"></span><br><span class="line">ClientHello</span><br><span class="line">+ early_data</span><br><span class="line">+ key_share*</span><br><span class="line">+ psk_key_exchange_modes</span><br><span class="line">+ pre_shared_key</span><br><span class="line">(Application Data*)     --------&gt;</span><br><span class="line">                                                ServerHello</span><br><span class="line">                                           + pre_shared_key</span><br><span class="line">                                               + key_share*</span><br><span class="line">                                      &#123;EncryptedExtensions&#125;</span><br><span class="line">                                              + early_data*</span><br><span class="line">                                                 &#123;Finished&#125;</span><br><span class="line">                        &lt;--------       [Application Data*]</span><br><span class="line">(EndOfEarlyData)</span><br><span class="line">&#123;Finished&#125;              --------&gt;</span><br><span class="line">[Application Data]      &lt;-------&gt;        [Application Data]</span><br><span class="line"></span><br><span class="line">      +  Indicates noteworthy extensions sent in the</span><br><span class="line">         previously noted message.</span><br><span class="line"></span><br><span class="line">      *  Indicates optional or situation-dependent</span><br><span class="line">         messages/extensions that are not always sent.</span><br><span class="line"></span><br><span class="line">      () Indicates messages protected using keys</span><br><span class="line">         derived from a client_early_traffic_secret.</span><br><span class="line"></span><br><span class="line">      &#123;&#125; Indicates messages protected using keys</span><br><span class="line">         derived from a [sender]_handshake_traffic_secret.</span><br><span class="line"></span><br><span class="line">      [] Indicates messages protected using keys</span><br><span class="line">         derived from [sender]_application_traffic_secret_N.</span><br><span class="line"></span><br><span class="line">      Figure 4: Message Flow for a 0-RTT Handshake</span><br></pre></td></tr></table></figure>

<p>0-RTT的数据安全性较弱：</p>
<ul>
<li>0-RTT数据没有前向安全性，因为其加密密钥单纯是从PSK推导出来的</li>
<li>跨连接可以重放0-RTT里的应用数据（常规的TLS 1.3 1-RTT数据通过服务端随机数来防重放）</li>
</ul>
<h2 id="密钥派生过程"><a href="#密钥派生过程" class="headerlink" title="密钥派生过程"></a>密钥派生过程</h2><p>密钥派生过程用到了HKDF-Extract和HKDF-Expand函数，以及如下的函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKDF-Expand-Label(Secret, Label, Context, Length) =</span><br><span class="line">      HKDF-Expand(Secret, HkdfLabel, Length)</span><br></pre></td></tr></table></figure>

<p>其中<code>HkdfLabel</code>表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">  uint16 length = Length;</span><br><span class="line">  opaque label&lt;7..255&gt; = &quot;tls13 &quot; + Label;</span><br><span class="line">  opaque context&lt;0..255&gt; = Context;</span><br><span class="line">&#125; HkdfLabel;</span><br><span class="line"></span><br><span class="line">Derive-Secret(Secret, Label, Messages) = HKDF-Expand-Label(</span><br><span class="line">  Secret, Label, Transcript-Hash(Messages), Hash.length)</span><br></pre></td></tr></table></figure>



<p>不管是哪种密钥交换模式都给走完下面的整个流程，当没有对应的输入密钥材料（IKM），对应的位置用Hash长度的0值字符串代替。例如没有PSK的话，Early Secret就是<code>HKDF-Extract(0, 0)</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS1_3-Key-Schedule.png" alt="TLS1_3-Key-Schedule" loading="lazy"></p>
<p>其中<code>exporter_secret</code>是导出密钥，用于用户自定义的其他用途。<code>resumption_master_secret</code>用于生成ticket。<code>client_early_traffic_secret</code>用于推导0-RTT的early-data密钥，<code>*_handshake_traffic_secret</code>用于推到握手消息的加密密钥，<code>*_application_traffic_secret_N</code>用于推导应用消息的加密密钥。</p>
<h1 id="常见实现"><a href="#常见实现" class="headerlink" title="常见实现"></a>常见实现</h1><p>OpenSSL：非常流行的开源实现、代码量最大、写得最烂？</p>
<p>LibreSSL：也是OpenSSL的一个fork，OpenBSD项目</p>
<p>BoringSSL：是OpenSSL的一个fork分支，主要用于Google的Chrome/Chromium、Android以及其他应用</p>
<p>JSSE（Java Secure Socket Extension）：Java实现</p>
<p>NSS：最初由网景开发的库，现在主要被浏览器和客户端软件使用，比如Firefox使用的就是NSS库（Mozilla开发）。</p>
<p>go.crypto：Go语言的实现</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://introspelliam.github.io/2018/03/20/crypto/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BBSSL-TLS%E5%AE%9E%E7%8E%B0/">深度解读SSL/TLS实现</a></li>
<li><a href="https://blog.helong.info/blog/2015/09/07/tls-protocol-analysis-and-crypto-protocol-design/#1-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%88%86%E5%B1%82%E6%8A%BD%E8%B1%A1">TLS协议分析</a></li>
<li><a href="https://juejin.cn/post/6844903624640823310#heading-5">完全吃透</a></li>
<li><a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/">Keyless SSL</a></li>
<li><a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">wiki-Transport_Layer_Security</a></li>
<li><a href="https://hpbn.co/transport-layer-security-tls/">Transport Layer Security</a></li>
<li><a href="https://www.crypto101.io/">Crypto101</a></li>
<li><a href="https://xiaoxueying.gitbooks.io/graphic-cryptology/content/index.html">graphic-cryptology</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA算法原理</a></li>
<li><a href="https://www.pediy.com/kssd/pediy06/pediy6014.htm">ECC加密算法入门</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc5246">TLS1.2-rfc5246</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc8446">TLS1.3-rfc8446</a></li>
<li><a href="https://en.wikipedia.org/wiki/OCSP_stapling">OCSP_stapling</a></li>
<li><a href="http://drops.xmd5.com/static/drops/tips-4403.html">常见HTTPS攻击方法</a></li>
</ul>
]]></content>
      <categories>
        <category>加密与安全</category>
      </categories>
      <tags>
        <tag>SSL/TLS</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>如何编写一个多进程性能测试程序</title>
    <url>/posts/e416d910/</url>
    <content><![CDATA[<div class="note primary">
            <p>在工作中经常碰到需要写一些多进程/多线程的测试程序，用来测试接口的性能。本文将会从零开始一点点增加代码，最终完成一个简易的多进程测试程序编写。该程序支持实时打印测试进结果和最终测试结果的统计。</p><p>同时，本文还涵盖了以下知识点，可以作为学习参考：</p><ul><li>使用<code>getopt_long()</code>处理命令行选项和参数</li><li>使用<code>fork()</code>和<code>wait()</code>处理多进程</li><li>使用<code>sigaction()</code>配合<code>alarm()</code>处理定时信号<code>SIGALRM</code></li><li>使用<code>shmget()</code>、<code>shmat()</code>、<code>shmdt()</code>、<code>shmctl()</code>等通过共享内存进行进程间通信</li><li>使用<code>sigaction()</code>捕获<code>SIGINT</code>和<code>SIGQUIT</code>信号，在程序终止前做共享内存清理工作</li></ul>
          </div>

<span id="more"></span>

<p>本文源码已开源<a href="https://github.com/catbro666/multi-process-test-demo">Github</a></p>
<h1 id="选项和参数的处理"><a href="#选项和参数的处理" class="headerlink" title="选项和参数的处理"></a>选项和参数的处理</h1><p>为了使测试程序更高的可用性，我们<code>getopt</code>来处理选项和参数。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>      <span class="comment">// printf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span>     <span class="comment">// getopt_long</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>     <span class="comment">// strtol, abort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>     <span class="comment">// LONG_MIN, LONG_MAX</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowHelpInfo</span><span class="params">(<span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [options]\n\n&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Options:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    -p/--proc         Number of processes (default: 1)\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    -d/--duration     Duration of test (unit: s, default: 10)\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    -h/--help         Show the help info\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Example:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    %s -p 4 -d 30\n&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> option_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> procs = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> duration = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  定义命令行参数列表，option结构的含义如下（详见 man 3 getopt）：</span></span><br><span class="line"><span class="comment">     *  struct option &#123;</span></span><br><span class="line"><span class="comment">     *      const char *name;       // 参数的完整名称，对应命令中的 --xxx</span></span><br><span class="line"><span class="comment">     *      int  has_arg;           // 该参数是否带有一个值，如 –-config xxx.conf</span></span><br><span class="line"><span class="comment">     *      int *flag;              // 一般设置为NULL</span></span><br><span class="line"><span class="comment">     *      int  val;               // 解析到该参数后getopt_long函数的返回值，</span></span><br><span class="line"><span class="comment">     *                      // 为了方便维护，一般对应getopt_long调用时第三个参数</span></span><br><span class="line"><span class="comment">     *  &#125;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">arg_options</span>[] =</span></span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">&quot;proc&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;p&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;duration&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;d&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;help&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="string">&#x27;h&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  注意：传递给getopt_long的第三个参数对应了命令行参数的缩写形式，如-h等，</span></span><br><span class="line"><span class="comment">     *  如果字符后面带有冒号&quot;:&quot;，则说明该参数后跟一个值，如-c xxxxxx</span></span><br><span class="line"><span class="comment">     *  如果开头有冒号&quot;:&quot;，则当一个选项缺少参数时，返回&quot;:&quot;，否则，返回&quot;?&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt_long(argc, argv, <span class="string">&quot;:p:d:h&quot;</span>, arg_options, &amp;option_index)</span><br><span class="line">            ) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//fprintf(stdout,&quot;option is -%c, optarv is %s\n&quot;, c, optarg);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">            procs = strtol(optarg, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (procs == LONG_MIN || procs == LONG_MAX) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The number of processes (%s) is overflow\n\n&quot;</span>,</span><br><span class="line">                        optarg);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (procs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The number of processes must be &gt; 0\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            duration = strtol(optarg, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (duration == LONG_MIN || duration == LONG_MAX) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The duration of test (%s) is overflow\n\n&quot;</span>,</span><br><span class="line">                        optarg);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (procs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The duration of test must be &gt; 0\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;Unknown option -%c\n\n&quot;</span>, optopt);</span><br><span class="line">            ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">           <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;Option -%c requires an argument\n\n&quot;</span>, optopt);</span><br><span class="line">           ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;processes:  %ld\n&quot;</span>, procs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;duration:   %lds\n&quot;</span>, duration);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n-----------------------------Start Testing----------------------&quot;</span></span><br><span class="line">           <span class="string">&quot;--------\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

</div></div>



<div class="note info">
            <p>注意：传递给getopt_long的第三个参数对应了命令行参数的缩写形式，如-h, -v, -c等。</p><p>如果字符后面带有冒号”:”，则说明该参数后跟一个值，如-c xxxxxx</p><p>如果开头有冒号”:”，则当一个选项缺少参数时，返回”:”，否则，返回”?”</p>
          </div>



<p><strong>效果如下</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">^_^$ make</span><br><span class="line">gcc <span class="string">&quot;-g&quot;</span> -c multi-process.c -o multi-process.o</span><br><span class="line">gcc  -o <span class="built_in">test</span> multi-process.o</span><br><span class="line"></span><br><span class="line">^_^$ ./<span class="built_in">test</span></span><br><span class="line">processes:  1</span><br><span class="line">duration:   10s</span><br><span class="line"></span><br><span class="line">-----------------------------Start Testing------------------------------</span><br><span class="line"></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>



<p><strong>选项或参数错误时</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ./test -p</span><br><span class="line">Option -p requires an argument</span><br><span class="line"></span><br><span class="line">Usage: ./test [options]</span><br><span class="line"></span><br><span class="line">  Options:</span><br><span class="line">    -p/--proc         Number of processes (default: 1)</span><br><span class="line">    -d/--duration     Duration of test (unit: s, default: 10)</span><br><span class="line">    -h/--help         Show the help info</span><br><span class="line"></span><br><span class="line">  Example:</span><br><span class="line">    ./test -p 4 -d 30</span><br></pre></td></tr></table></figure>



<h1 id="增加多进程的支持"><a href="#增加多进程的支持" class="headerlink" title="增加多进程的支持"></a>增加多进程的支持</h1><p>主进程<code>fork</code>出n个子进程后<code>wait</code>子进程，子进程则通过<code>sigaction</code>和<code>alarm</code>设置一个定时器，然后进行业务测试。</p>
<p>为了简洁，已经把选项参数处理的部分独立出去了。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>      <span class="comment">// printf, fprintf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span>   <span class="comment">// wait</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>  <span class="comment">// getpid, wait</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span>     <span class="comment">// sigaction, SIGLARM</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>     <span class="comment">// LONG_MIN, LONG_MAX, ULLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>     <span class="comment">// getpid</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>     <span class="comment">// memset</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;multi-process.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> isStop = <span class="number">0</span>;             <span class="comment">// 用于标记测试终止</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">param_st</span> &#123;</span>   <span class="comment">// 自定义测试参数</span></span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">&#125; Param;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal_child</span><span class="params">(<span class="keyword">int</span> sigNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigNum == SIGALRM) &#123;</span><br><span class="line">        isStop = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实际业务测试函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTest</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    Param *pa = (Param *)param;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; ULLONG_MAX &amp;&amp; !isStop; ++i) &#123;</span><br><span class="line">        <span class="comment">/* DO YOUR WORK */</span></span><br><span class="line">        <span class="comment">/* DO YOUR WORK */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;process [pid = %6u] result: %llu\n&quot;</span>, getpid(), i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> proc_index = <span class="number">0</span>;</span><br><span class="line">    Options opt;</span><br><span class="line">    <span class="keyword">int</span> isParent = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> wstatus = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act_child</span>;</span></span><br><span class="line"></span><br><span class="line">    rv = process_options(argc, argv, &amp;opt);</span><br><span class="line">    <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n-----------------------------Start Testing----------------------&quot;</span></span><br><span class="line">           <span class="string">&quot;--------\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* COMMON INIT */</span></span><br><span class="line">    <span class="comment">/* COMMON INIT */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(isParent &amp;&amp; i &lt; opt.procs) &#123;</span><br><span class="line">        pid =  fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>) &#123;         <span class="comment">/* error */</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed %d\n&quot;</span>, pid);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;     <span class="comment">/* child */</span></span><br><span class="line">            isParent = <span class="number">0</span>;</span><br><span class="line">            proc_index = i;     <span class="comment">// 记录进程索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;                  <span class="comment">/* parent */</span></span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isParent) &#123;</span><br><span class="line">        <span class="comment">/* PARENT INIT */</span></span><br><span class="line">        <span class="comment">/* PARENT INIT */</span></span><br><span class="line">        <span class="keyword">for</span>(i =<span class="number">0</span> ; i &lt; opt.procs; ++i) &#123;</span><br><span class="line">            pid = wait(&amp;wstatus);                       <span class="comment">// 等待子进程结束</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process [pid = %6d] exit\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* CHILD INIT */</span></span><br><span class="line">        Param param;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;param, <span class="number">0</span>, <span class="keyword">sizeof</span>(Param));</span><br><span class="line">        param.index = proc_index;</span><br><span class="line">        <span class="comment">/* CHILD INIT */</span></span><br><span class="line"></span><br><span class="line">        act_child.sa_handler = handle_signal_child;</span><br><span class="line">        sigemptyset(&amp;act_child.sa_mask);</span><br><span class="line">        act_child.sa_flags = SA_RESETHAND;</span><br><span class="line">        <span class="comment">/* 用于测试时间到时，通知子进程结束测试 */</span></span><br><span class="line">        rv = sigaction(SIGALRM, &amp;act_child, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;sigaction() failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//signal(SIGALRM, handle_signal_child);</span></span><br><span class="line">        alarm(opt.duration);                            <span class="comment">// 设置测试时长</span></span><br><span class="line">        doTest(&amp;param);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">/* child finished work */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></div>



<p><strong>效果如下</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ./test -p 4 -d 2</span><br><span class="line">processes:  4</span><br><span class="line">duration:   2s</span><br><span class="line"></span><br><span class="line">-----------------------------Start Testing------------------------------</span><br><span class="line"></span><br><span class="line">process [pid =  11942] result: 446930553</span><br><span class="line">process [pid =  11942] exit</span><br><span class="line">process [pid =  11939] result: 434385097</span><br><span class="line">process [pid =  11939] exit</span><br><span class="line">process [pid =  11940] result: 442246977</span><br><span class="line">process [pid =  11940] exit</span><br><span class="line">process [pid =  11941] result: 442418811</span><br><span class="line">process [pid =  11941] exit</span><br></pre></td></tr></table></figure>



<p>这样已经可以实现简单的多进程测试，简单起见，示例代码里只是简单地进行了计数操作。读者如果想要进行自己特定的测试，只要在Param中增加需要的测试参数，接着在<code>/* CHILD INIT */</code>处进行参数初始化，然后在<code>/* DO YOUR WORK */</code>处添加实际的测试逻辑即可。</p>
<h1 id="增加实时的结果统计及最终的结果汇总"><a href="#增加实时的结果统计及最终的结果汇总" class="headerlink" title="增加实时的结果统计及最终的结果汇总"></a>增加实时的结果统计及最终的结果汇总</h1><p>为了使测试程序更加人性化，使其可以实时统计测试结果，结束时自动计算总的结果。这就需要引入父子进程间通信，我们选用共享内存的方式来实现。为了避免进程间同步对测试带来的影响，在共享内存中为每个子进程开辟了一个空间，每个子进程根据索引在自己的空间里写数据，由父进程进行结果的汇总。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>      <span class="comment">// printf, fprintf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span>   <span class="comment">// wait</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>  <span class="comment">// getpid, wait</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span>    <span class="comment">// shmget, shmat, shmctl, shmdt</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span>    <span class="comment">// shmget, shmat, shmctl, shmdt</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span>     <span class="comment">// sigaction, SIGLARM</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>     <span class="comment">// LONG_MIN, LONG_MAX, ULLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span>      <span class="comment">// errno</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>     <span class="comment">// getpid</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>     <span class="comment">// memset</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;multi-process.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">param_st</span> &#123;</span>   <span class="comment">// 自定义测试参数</span></span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">&#125; Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">result_st</span> &#123;</span>   <span class="comment">// 自定义测试结果</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> count;</span><br><span class="line">&#125; Result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> isStop = <span class="number">0</span>;             <span class="comment">// 用于标记测试终止</span></span><br><span class="line">Options opt;                <span class="comment">// 命令行选项</span></span><br><span class="line"><span class="keyword">int</span> shmid;                  <span class="comment">// 共享内存id</span></span><br><span class="line">Result *shm = <span class="literal">NULL</span>;         <span class="comment">// 共享内存地址，用于存放测试结果</span></span><br><span class="line">Result res_total;</span><br><span class="line">Result res_last;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal_child</span><span class="params">(<span class="keyword">int</span> sigNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigNum == SIGALRM) &#123;</span><br><span class="line">        isStop = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal_parent</span><span class="params">(<span class="keyword">int</span> sigNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigNum == SIGALRM) &#123;</span><br><span class="line">        <span class="comment">/* DO REAL-TIME STATISTICS */</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;res_total, <span class="number">0</span>, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; opt.procs; ++i) &#123;</span><br><span class="line">            res_total.count += shm[i].count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;total count %12llu,  average %12.0lf/s\n&quot;</span>,</span><br><span class="line">                res_total.count, (res_total.count - res_last.count)</span><br><span class="line">                / (<span class="keyword">double</span>)opt.interval);</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;res_last, &amp;res_total, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        <span class="comment">/* DO REAL-TIME STATISTICS */</span></span><br><span class="line">        alarm(opt.interval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实际业务测试函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTest</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    Param *pa = (Param *)param;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; ULLONG_MAX &amp;&amp; !isStop; ++i) &#123;</span><br><span class="line">        <span class="comment">/* DO YOUR WORK */</span></span><br><span class="line">        ++shm[pa-&gt;index].count;</span><br><span class="line">        <span class="comment">/* DO YOUR WORK */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> proc_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> isParent = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> wstatus = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act_child</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act_parent</span>;</span></span><br><span class="line"></span><br><span class="line">    rv = process_options(argc, argv, &amp;opt);</span><br><span class="line">    <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n-----------------------------Start Testing-------------&quot;</span></span><br><span class="line">            <span class="string">&quot;-----------------\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* COMMON INIT */</span></span><br><span class="line">    shmid = shmget(IPC_PRIVATE, <span class="keyword">sizeof</span>(<span class="keyword">sizeof</span>(Result) * opt.procs), <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == shmid) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;shmget() failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;shmid = %d\n&quot;</span>, shmid);</span><br><span class="line">    shm = (Result*)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">void</span> *) <span class="number">-1</span> == shm) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;shmat() failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(shm, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">sizeof</span>(Result) * opt.procs));</span><br><span class="line">    <span class="comment">/* COMMON INIT */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(isParent &amp;&amp; i &lt; opt.procs) &#123;</span><br><span class="line">        pid =  fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>) &#123;         <span class="comment">/* error */</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed %d\n&quot;</span>, pid);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;     <span class="comment">/* child */</span></span><br><span class="line">            isParent = <span class="number">0</span>;</span><br><span class="line">            proc_index = i;     <span class="comment">// 记录进程索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;                  <span class="comment">/* parent */</span></span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isParent) &#123;</span><br><span class="line">        <span class="comment">/* PARENT INIT */</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;act_parent, <span class="number">0</span>, <span class="keyword">sizeof</span>(act_parent));</span><br><span class="line">        act_parent.sa_handler = handle_signal_parent;</span><br><span class="line">        <span class="comment">/* 使wait被中断时可以自动恢复 */</span></span><br><span class="line">        act_parent.sa_flags = SA_RESTART;</span><br><span class="line">        rv = sigaction(SIGALRM, &amp;act_parent, <span class="literal">NULL</span>);     <span class="comment">// 用于定时统计结果</span></span><br><span class="line">        <span class="comment">//signal(SIGALRM, handle_signal_parent);</span></span><br><span class="line">        <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;sigaction() failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;res_last, <span class="number">0</span>, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        alarm(opt.interval);</span><br><span class="line">        <span class="comment">/* PARENT INIT */</span></span><br><span class="line">        <span class="comment">/* DO FINAL STATISTICS */</span></span><br><span class="line">        Result <span class="keyword">final</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;<span class="keyword">final</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        <span class="keyword">for</span>(i =<span class="number">0</span> ; i &lt; opt.procs; ++i) &#123;</span><br><span class="line">            pid = wait(&amp;wstatus);                       <span class="comment">// 等待子进程结束</span></span><br><span class="line">            alarm(<span class="number">0</span>);                                   <span class="comment">// 终止定时器</span></span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;wait() failed, errno=%d\n&quot;</span>, errno);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;process [pid = %6d] exit\n&quot;</span>, pid);</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;process [pid = %6u] count %12llu in %lus,  &quot;</span></span><br><span class="line">                    <span class="string">&quot;average %12.0lf/s\n&quot;</span>, pid, shm[i].count, opt.duration, </span><br><span class="line">                    shm[i].count / (<span class="keyword">double</span>)opt.duration);</span><br><span class="line">            <span class="keyword">final</span>.count += shm[i].count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;total count %12llu in %lus,  average %12.0lf/s\n&quot;</span>,</span><br><span class="line">               <span class="keyword">final</span>.count, opt.duration, <span class="keyword">final</span>.count / (<span class="keyword">double</span>)opt.duration);</span><br><span class="line">        <span class="comment">/* DO FINAL STATISTICS */</span></span><br><span class="line">        shmdt((<span class="keyword">void</span>*)shm);</span><br><span class="line">        <span class="comment">/* 子进程退出之后自动detach了, 所以这里不需要通过IPC_STAT进行判断 */</span></span><br><span class="line">        shmctl(shmid, IPC_RMID, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* CHILD INIT */</span></span><br><span class="line">        Param param;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;param, <span class="number">0</span>, <span class="keyword">sizeof</span>(Param));</span><br><span class="line">        param.index = proc_index;</span><br><span class="line">        <span class="comment">/* CHILD INIT */</span></span><br><span class="line"></span><br><span class="line">        act_child.sa_handler = handle_signal_child;</span><br><span class="line">        sigemptyset(&amp;act_child.sa_mask);</span><br><span class="line">        <span class="comment">//sigaddset(&amp;act_child.sa_mask, SIGQUIT);</span></span><br><span class="line">        <span class="comment">//sigaddset(&amp;act_child.sa_mask, SIGTERM);</span></span><br><span class="line">        act_child.sa_flags = SA_RESETHAND;</span><br><span class="line">        <span class="comment">/* 用于测试时间到时，通知子进程结束测试 */</span></span><br><span class="line">        rv = sigaction(SIGALRM, &amp;act_child, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;sigaction() failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//signal(SIGALRM, handle_signal_child);</span></span><br><span class="line">        alarm(opt.duration);                            <span class="comment">// 设置测试时长</span></span><br><span class="line">        doTest(&amp;param);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">/* child finished work */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></div>



<p><strong>测试效果如下</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ./test -p 4 -d 8 -i 1</span><br><span class="line">processes:  4</span><br><span class="line">duration:   8s</span><br><span class="line">interval:   1s</span><br><span class="line"></span><br><span class="line">-----------------------------Start Testing------------------------------</span><br><span class="line"></span><br><span class="line">shmid = 2654220</span><br><span class="line">total count    344235932,  average    344235932/s</span><br><span class="line">total count    679573681,  average    335337749/s</span><br><span class="line">total count   1026283924,  average    346710243/s</span><br><span class="line">total count   1368302354,  average    342018430/s</span><br><span class="line">total count   1708471662,  average    340169308/s</span><br><span class="line">total count   2057211138,  average    348739476/s</span><br><span class="line">total count   2398403059,  average    341191921/s</span><br><span class="line">process [pid =  25124] exit</span><br><span class="line">process [pid =  25124] count    688504473 in 8s,  average     86063059/s</span><br><span class="line">process [pid =  25123] exit</span><br><span class="line">process [pid =  25123] count    682379115 in 8s,  average     85297389/s</span><br><span class="line">process [pid =  25125] exit</span><br><span class="line">process [pid =  25125] count    682467102 in 8s,  average     85308388/s</span><br><span class="line">process [pid =  25126] exit</span><br><span class="line">process [pid =  25126] count    688159459 in 8s,  average     86019932/s</span><br><span class="line">total count   2741510149 in 8s,  average    342688769/s</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>这里需要特别提一下<code>wait()</code>和<code>sigaction()</code>系统调用，默认情况下<code>wait()</code>会阻塞直到有任意一个子进程改变了其状态，或者有一个信号处理函数中断了<code>wait()</code>调用。所以我们程序中的<code>wait()</code>调用就会被自己的<code>SIGALRM</code>信号中断，返回<code>-1</code>同时<code>errno</code>为<code>EINTR</code>。这样我们就需要在<code>wait()</code>外面加一层循环来处理<code>wait()</code>被信号中断的情况。</p><p>通过在<code>sigaction()</code>时增加<code>SA_RESTART</code>标志，被中断的系统调用可以自动重开，也就省去了那个外层循环。另外，<code>signal()</code>封装了<code>sigaction()</code>，它里面默认就是设置了<code>SA_RESTART</code>，不过除非你有确切的理由，不然不建议使用<code>signal()</code>了。</p>
          </div>

<h1 id="增加SIGINT和SIGQUIT信号捕获"><a href="#增加SIGINT和SIGQUIT信号捕获" class="headerlink" title="增加SIGINT和SIGQUIT信号捕获"></a>增加SIGINT和SIGQUIT信号捕获</h1><p>截止目前，我们已经完成了多进程的测试及结果统计。但其实还有一个潜在的问题，在实际测试中，我们经常会在测试还没完成时就手动<code>^C</code>终止程序执行。这样我们在程序中申请的共享内存就会得不到释放，造成内存泄漏。所以需要增加对<code>SIGINT</code>和<code>SIGQUIT</code>信号的处理函数，在里面做清理工作，释放共享内存。</p>
<div class="note default">
            <p>如果已经不小心造成了共享内存的泄漏，可以通过如下命令手动进行删除。<code>ipcrm shm &lt;id&gt;</code>，如果是显式指定key的话也可以通过<code>ipcrm -M &lt;key&gt;</code>来进行删除。</p>
          </div>

<div class="note info">
            <p>今天，突然想到了，其实有一种更加简单的方法，即在<code>shmat()</code>之后立即进行<code>shmctl(shmid, IPC_RMID, 0);</code>。这样不仅简单，而且中间的空窗期也更短，cool！这样我们再也不用担心，<code>^C</code>造成内存泄漏了哈。</p>
          </div>

<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="meta">@@ -88,12 +88,14 @@</span> int main(int argc, char *argv[]) &#123;</span><br><span class="line">         fprintf(stderr, &quot;shmget() failed\n&quot;);</span><br><span class="line">         return -1;</span><br><span class="line">     &#125;</span><br><span class="line">     fprintf(stderr, &quot;shmid = %d\n&quot;, shmid);</span><br><span class="line">     shm = (Result*)shmat(shmid, 0, 0);</span><br><span class="line">     if ((void *) -1 == shm) &#123;</span><br><span class="line">         fprintf(stderr, &quot;shmat() failed\n&quot;);</span><br><span class="line">         return -1;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="addition">+    /* 这里直接进行IPC_RMID操作，进程退出后会自动detach了, 从而释放共享内存 */</span></span><br><span class="line"><span class="addition">+    shmctl(shmid, IPC_RMID, 0);</span></span><br><span class="line">     memset(shm, 0, sizeof(sizeof(Result) * opt.procs));</span><br><span class="line">     /* COMMON INIT */</span><br><span class="line"></span><br><span class="line"><span class="meta">@@ -156,10 +135,6 @@</span> int main(int argc, char *argv[]) &#123;</span><br><span class="line">         fprintf(stderr, &quot;total count %12llu in %lus,  average %12.0lf/s\n&quot;,</span><br><span class="line">                final.count, opt.duration, final.count / (double)opt.duration);</span><br><span class="line">         /* DO FINAL STATISTICS */</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-        shmdt((void*)shm);</span></span><br><span class="line"><span class="deletion">-        /* 子进程退出之后自动detach了, 所以这里不需要通过IPC_STAT进行判断 */</span></span><br><span class="line"><span class="deletion">-        shmctl(shmid, IPC_RMID, 0);</span></span><br><span class="line">     &#125;</span><br><span class="line">     else &#123;</span><br><span class="line">         /* CHILD INIT */</span><br></pre></td></tr></table></figure>



<h1 id="封装错误判断函数"><a href="#封装错误判断函数" class="headerlink" title="封装错误判断函数"></a>封装错误判断函数</h1><p>为了使代码看起来更加简洁，避免每个函数调用后面跟着一个<code>if()&#123;&#125;</code>判断块，我们对错误判断及日志打印函数进行了一个简单的封装。封装的函数如下：</p>
<p>其中<code>mylog()</code>单纯打印日志，<code>fail()</code>打印日志后退出进程，<code>fail_if()</code>先判断条件，如果成立打印日志退出，<code>fail_clean_if()</code>也是先判断条件，条件成立则打印日志，执行传入的清理函数。然后退出进程。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>      <span class="comment">// stderr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span>     <span class="comment">// va_start, vfprintf, va_end</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>     <span class="comment">// exit</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail_if</span><span class="params">(<span class="keyword">bool</span> condition, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        va_list args;</span><br><span class="line">        va_start(args, fmt);</span><br><span class="line">        <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">        va_end(args);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mylog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail_clean_if</span><span class="params">(<span class="keyword">bool</span> condition, cleanup clean, <span class="keyword">void</span> *param, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        va_list args;</span><br><span class="line">        va_start(args, fmt);</span><br><span class="line">        <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">        va_end(args);</span><br><span class="line">        clean(param);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>



<h1 id="添加实际测试用例"><a href="#添加实际测试用例" class="headerlink" title="添加实际测试用例"></a>添加实际测试用例</h1><p>接下来我们来添加实际有意义的测试用例，这里以OpenSSL引擎的性能测试为例来进行说明。为了我们的代码更清晰，已经将具体测试相关的代码独立为一个源文件。<code>common.c</code>封装错误函数，<code>opt.c</code>处理命令行选项，<code>work.c</code>处理具体测试，<code>multi-process.c</code>则负责测试的主控。完整的代码如下：</p>
<ul>
<li><code>common.h</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADER_COMMON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADER_COMMON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span>    <span class="comment">// bool, true, false</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*cleanup)</span> <span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail_if</span><span class="params">(<span class="keyword">bool</span> condition, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mylog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail_clean_if</span><span class="params">(<span class="keyword">bool</span> condition, cleanup clean, <span class="keyword">void</span> *param, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HEADER_COMMON_H */</span></span></span><br></pre></td></tr></table></figure>



</div></div>

<ul>
<li><code>common.c</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>      <span class="comment">// stderr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span>     <span class="comment">// va_start, vfprintf, va_end</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>     <span class="comment">// exit</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail_if</span><span class="params">(<span class="keyword">bool</span> condition, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        va_list args;</span><br><span class="line">        va_start(args, fmt);</span><br><span class="line">        <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">        va_end(args);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mylog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail_clean_if</span><span class="params">(<span class="keyword">bool</span> condition, cleanup clean, <span class="keyword">void</span> *param, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        va_list args;</span><br><span class="line">        va_start(args, fmt);</span><br><span class="line">        <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">        va_end(args);</span><br><span class="line">        clean(param);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><code>opt.h</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADER_OPT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADER_OPT_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">test</span>&#123;</span></span><br><span class="line">    hash, sign, verify, enc, dec</span><br><span class="line">&#125; Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">options_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> procs;                 <span class="comment">// 进程数</span></span><br><span class="line">    <span class="keyword">long</span> duration;              <span class="comment">// 测试时间</span></span><br><span class="line">    <span class="keyword">long</span> interval;              <span class="comment">// 统计间隔</span></span><br><span class="line">    Test test;                  <span class="comment">// 测试类型</span></span><br><span class="line">    <span class="keyword">long</span> len;                   <span class="comment">// 摘要原文长度</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *key;            <span class="comment">// 密钥文件路径</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cert;           <span class="comment">// 证书文件路径</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *loglevel;       <span class="comment">// 日志等级</span></span><br><span class="line">&#125; Options;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理参数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process_options</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], Options *opt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HEADER_OPT_H */</span></span></span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><code>opt.c</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>     <span class="comment">// LONG_MIN, LONG_MAX, ULLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>     <span class="comment">// memset</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>     <span class="comment">// strtol, abort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span>     <span class="comment">// geropt_long</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span>     <span class="comment">// mylog</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowHelpInfo</span><span class="params">(<span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    mylog(<span class="string">&quot;Usage: %s [options]\n\n&quot;</span>, name);</span><br><span class="line">    mylog(<span class="string">&quot;  Options:\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -p/--proc         Number of processes (default: 1)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -d/--duration     Duration of test (unit: s, default: 10)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -i/--interval     Interval of statisics (unit: s, default: 1)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -t/--test         Test case (hash|sign|verify|enc|dec, default: hash)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -l/--len          Hash data len (unit: byte, default: 1024)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -k/--key          PEM Key file path (default: ./key.pem)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -c/--cert         PEM Cert file path (default: ./cert.pem)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -o/--loglevel     Engine log level (0-9, default: 0)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -h/--help         Show the help info\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;  Example:\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    %s -p 1 -d 30 -i 1 -t sign -k key.pem -c cert.pem\n&quot;</span>, name);</span><br><span class="line">    mylog(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理参数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process_options</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], Options *opt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> option_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> procs = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> duration = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">long</span> interval = <span class="number">1</span>;</span><br><span class="line">    Test test = hash;</span><br><span class="line">    <span class="keyword">long</span> len = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *key = <span class="string">&quot;./key.pem&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cert = <span class="string">&quot;./cert.pem&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *loglevel = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  定义命令行参数列表，option结构的含义如下（详见 man 3 getopt）：</span></span><br><span class="line"><span class="comment">     *  struct option &#123;</span></span><br><span class="line"><span class="comment">     *      const char *name;       // 参数的完整名称，对应命令中的 --xxx</span></span><br><span class="line"><span class="comment">     *      int  has_arg;           // 该参数是否带有一个值，如 –config xxx.conf</span></span><br><span class="line"><span class="comment">     *      int *flag;              // 一般设置为NULL</span></span><br><span class="line"><span class="comment">     *      int  val;               // 解析到该参数后getopt_long函数的返回值，</span></span><br><span class="line"><span class="comment">     *                      // 为了方便维护，一般对应getopt_long调用时第三个参数</span></span><br><span class="line"><span class="comment">     *  &#125;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">arg_options</span>[] =</span></span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">&quot;proc&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;p&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;duration&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;d&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;interval&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;i&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;test&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;t&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;len&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;l&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;key&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;k&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;cert&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;log&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;g&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;help&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="string">&#x27;h&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  注意：传递给getopt_long的第三个参数对应了命令行参数的缩写形式，如-h等，</span></span><br><span class="line"><span class="comment">     *  如果字符后面带有冒号&quot;:&quot;，则说明该参数后跟一个值，如-c xxxxxx</span></span><br><span class="line"><span class="comment">     *  如果开头有冒号&quot;:&quot;，则当一个选项缺少参数时，返回&quot;:&quot;，否则，返回&quot;?&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt_long(argc, argv, <span class="string">&quot;:p:d:i:t:l:k:c:g:h&quot;</span>, arg_options, &amp;option_index)</span><br><span class="line">            ) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//fprintf(stderr,&quot;option is -%c, optarv is %s\n&quot;, c, optarg);</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">            procs = strtol(optarg, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (procs == LONG_MIN || procs == LONG_MAX) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The number of processes (%s) is overflow\n\n&quot;</span>, optarg);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (procs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The number of processes must be &gt; 0\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            duration = strtol(optarg, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (duration == LONG_MIN || duration == LONG_MAX) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The duration of test (%s) is overflow\n\n&quot;</span>, optarg);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (duration &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The duration of test must be &gt; 0\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">            interval = strtol(optarg, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (interval == LONG_MIN || interval == LONG_MAX) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The interval of statistics (%s) is overflow\n\n&quot;</span>,</span><br><span class="line">                      optarg);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (interval &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The interval of statistics must be &gt; 0\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(!strcasecmp(<span class="string">&quot;hash&quot;</span>, optarg)) &#123;</span><br><span class="line">                test = hash;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!strcasecmp(<span class="string">&quot;sign&quot;</span>, optarg)) &#123;</span><br><span class="line">                test = sign;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!strcasecmp(<span class="string">&quot;verify&quot;</span>, optarg)) &#123;</span><br><span class="line">                test = verify;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!strcasecmp(<span class="string">&quot;enc&quot;</span>, optarg)) &#123;</span><br><span class="line">                test = enc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!strcasecmp(<span class="string">&quot;dec&quot;</span>, optarg)) &#123;</span><br><span class="line">                test = dec;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                mylog(<span class="string">&quot;Unknown test case type\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">            len = strtol(optarg, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (len == LONG_MIN || len == LONG_MAX) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The len of hash data (%s) is overflow\n\n&quot;</span>,</span><br><span class="line">                      optarg);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The len of hash data must be &gt; 0\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>:</span><br><span class="line">            key = optarg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">            cert = optarg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">            loglevel = optarg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            mylog(<span class="string">&quot;Unknown option -%c\n\n&quot;</span>, optopt);</span><br><span class="line">            ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">            mylog(<span class="string">&quot;Option -%c requires an argument\n\n&quot;</span>, optopt);</span><br><span class="line">            ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mylog(<span class="string">&quot;processes:  %ld\n&quot;</span>, procs);</span><br><span class="line">    mylog(<span class="string">&quot;duration:   %lds\n&quot;</span>, duration);</span><br><span class="line">    mylog(<span class="string">&quot;interval:   %lds\n&quot;</span>, interval);</span><br><span class="line">    mylog(<span class="string">&quot;test:       #%d\n&quot;</span>, test);</span><br><span class="line">    mylog(<span class="string">&quot;len:        %ld bytes\n&quot;</span>, len);</span><br><span class="line">    mylog(<span class="string">&quot;key:        %s\n&quot;</span>, key);</span><br><span class="line">    mylog(<span class="string">&quot;cert:       %s\n&quot;</span>, cert);</span><br><span class="line">    mylog(<span class="string">&quot;loglevel:   %s\n&quot;</span>, loglevel);</span><br><span class="line">    <span class="built_in">memset</span>(opt, <span class="number">0</span>, <span class="keyword">sizeof</span>(Options));</span><br><span class="line">    opt-&gt;procs = procs;</span><br><span class="line">    opt-&gt;duration = duration;</span><br><span class="line">    opt-&gt;interval = interval;</span><br><span class="line">    opt-&gt;test = test;</span><br><span class="line">    opt-&gt;len = len;</span><br><span class="line">    opt-&gt;key = key;</span><br><span class="line">    opt-&gt;cert = cert;</span><br><span class="line">    opt-&gt;loglevel = loglevel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><code>work.h</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADER_WORK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADER_WORK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义测试参数 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hash_param_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> data_len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> md[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> md_len;</span><br><span class="line">    EVP_MD_CTX *ctx;</span><br><span class="line">&#125; HashParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sign_param_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">size_t</span> data_len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sig[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">size_t</span> sig_len;</span><br><span class="line">    EVP_PKEY_CTX *ctx;</span><br><span class="line">    BIO *in;</span><br><span class="line">&#125; SignParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> SignParam VerifyParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">enc_param_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">size_t</span> data_len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> enc[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">size_t</span> enc_len;</span><br><span class="line">    EVP_PKEY_CTX *ctx;</span><br><span class="line">    BIO *in;</span><br><span class="line">&#125; EncParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> EncParam DecParam;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义测试结果 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">result_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> count;</span><br><span class="line">&#125; Result;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*init_fn)</span> <span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*work_fn)</span> <span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*clean_fn)</span> <span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> init_fn test_init;</span><br><span class="line"><span class="keyword">extern</span> work_fn test_work;</span><br><span class="line"><span class="keyword">extern</span> clean_fn test_clean;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">global_init</span><span class="params">(Options *opt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">global_clean</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HEADER_WORK_H */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><code>work.c</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;work.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/engine.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/pem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* so_path = <span class="string">&quot;/usr/local/ssl/lib/myengine.so&quot;</span>;</span><br><span class="line"></span><br><span class="line">init_fn test_init = <span class="literal">NULL</span>;</span><br><span class="line">work_fn test_work = <span class="literal">NULL</span>;</span><br><span class="line">clean_fn test_clean = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hash_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hash_work</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hash_clean</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sign_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sign_work</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sign_clean</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify_work</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify_clean</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encrypt_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encrypt_work</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encrypt_clean</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrypt_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrypt_work</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrypt_clean</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">global_init</span><span class="params">(Options *opt)</span> </span>&#123;</span><br><span class="line">    ENGINE *e = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (opt-&gt;test == hash) &#123;</span><br><span class="line">        test_init = hash_init;</span><br><span class="line">        test_work = hash_work;</span><br><span class="line">        test_clean = hash_clean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (opt-&gt;test == sign) &#123;</span><br><span class="line">        test_init = sign_init;</span><br><span class="line">        test_work = sign_work;</span><br><span class="line">        test_clean = sign_clean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (opt-&gt;test == verify) &#123;</span><br><span class="line">        test_init = verify_init;</span><br><span class="line">        test_work = verify_work;</span><br><span class="line">        test_clean = verify_clean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (opt-&gt;test == enc) &#123;</span><br><span class="line">        test_init = encrypt_init;</span><br><span class="line">        test_work = encrypt_work;</span><br><span class="line">        test_clean = encrypt_clean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (opt-&gt;test == dec) &#123;</span><br><span class="line">        test_init = decrypt_init;</span><br><span class="line">        test_work = decrypt_work;</span><br><span class="line">        test_clean = decrypt_clean;</span><br><span class="line">    &#125;</span><br><span class="line">    OpenSSL_add_all_algorithms();</span><br><span class="line">    <span class="comment">/* ENGINE INIT */</span></span><br><span class="line">    ENGINE_load_dynamic();</span><br><span class="line">    <span class="keyword">if</span> (!(e = ENGINE_by_id(<span class="string">&quot;dynamic&quot;</span>))) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_by_id(\&quot;dynamic\&quot;) fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ENGINE_ctrl_cmd_string(e, <span class="string">&quot;SO_PATH&quot;</span>, so_path, <span class="number">0</span>)) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_ctrl_cmd_string(\&quot;SO_PATH\&quot;) fail, so_path = %s\n&quot;</span>, </span><br><span class="line">             so_path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ENGINE_ctrl_cmd_string(e, <span class="string">&quot;LIST_ADD&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_ctrl_cmd_string(\&quot;LIST_ADD\&quot;) fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ENGINE_ctrl_cmd_string(e, <span class="string">&quot;LOAD&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_ctrl_cmd_string(\&quot;LOAD\&quot;) fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ENGINE_init(e)) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_init() fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ENGINE_ctrl_cmd_string( e, <span class="string">&quot;ENGINE_SET_LOGLEVEL&quot;</span>, opt-&gt;loglevel, <span class="number">0</span>)) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_ctrl_cmd_string(\&quot;ENGINE_SET_LOGLEVEL\&quot;) fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_set_default() fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ENGINE_free(e);</span><br><span class="line">    <span class="comment">/* ENGINE INIT */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">global_clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EVP_cleanup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hash_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span> </span>&#123;</span><br><span class="line">    HashParam *p;</span><br><span class="line">    p = OPENSSL_malloc(<span class="keyword">sizeof</span>(HashParam));</span><br><span class="line">    fail_if(!p, <span class="string">&quot;OPENSSL_malloc() fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(HashParam));</span><br><span class="line"></span><br><span class="line">    p-&gt;ctx = EVP_MD_CTX_create();</span><br><span class="line">    fail_clean_if(!p-&gt;ctx, hash_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;EVP_MD_CTX_create() fail\n&quot;</span>);</span><br><span class="line">    EVP_MD_CTX_init(p-&gt;ctx);</span><br><span class="line"></span><br><span class="line">    p-&gt;data = OPENSSL_malloc(opt-&gt;len);</span><br><span class="line">    fail_clean_if(!p-&gt;data, hash_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;OPENSSL_malloc() fail\n&quot;</span>);</span><br><span class="line">    fail_clean_if(RAND_bytes(p-&gt;data, <span class="keyword">sizeof</span>(opt-&gt;len)) &lt;= <span class="number">0</span>, hash_clean, (<span class="keyword">void</span> *)p,</span><br><span class="line">                  <span class="string">&quot;RAND_bytes() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;data_len = opt-&gt;len;</span><br><span class="line"></span><br><span class="line">    p-&gt;index = proc_index;</span><br><span class="line"></span><br><span class="line">    *param = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hash_work</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    HashParam *p = (HashParam *)param;</span><br><span class="line">    <span class="keyword">const</span> EVP_MD *md = EVP_get_digestbyname(<span class="string">&quot;SHASH&quot;</span>);</span><br><span class="line">    fail_clean_if(!md, hash_clean, param, </span><br><span class="line">                  <span class="string">&quot;EVP_get_digestbyname(\&quot;SHASH\&quot;) fail\n&quot;</span>);</span><br><span class="line">    fail_clean_if(!EVP_DigestInit_ex(p-&gt;ctx, md, <span class="literal">NULL</span>), </span><br><span class="line">                  hash_clean, param, <span class="string">&quot;EVP_DigestInit_ex() fail\n&quot;</span>);</span><br><span class="line">    fail_clean_if(!EVP_DigestUpdate(p-&gt;ctx, p-&gt;data, p-&gt;data_len),</span><br><span class="line">                  hash_clean, param, <span class="string">&quot;EVP_DigestUpdate() fail\n&quot;</span>);</span><br><span class="line">    fail_clean_if(!EVP_DigestFinal_ex(p-&gt;ctx, p-&gt;md, &amp;p-&gt;md_len),</span><br><span class="line">                  hash_clean, param, <span class="string">&quot;EVP_DigestFinal_ex() fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hash_clean</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    HashParam *p = (HashParam *)param;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;data)</span><br><span class="line">        OPENSSL_free(p-&gt;data);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ctx)</span><br><span class="line">        EVP_MD_CTX_destroy(p-&gt;ctx);</span><br><span class="line">    OPENSSL_free(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sign_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span> </span>&#123;</span><br><span class="line">    SignParam *p;</span><br><span class="line">    EVP_PKEY *pkey;</span><br><span class="line">    p = OPENSSL_malloc(<span class="keyword">sizeof</span>(SignParam));</span><br><span class="line">    fail_if(!p, <span class="string">&quot;OPENSSL_malloc() fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(SignParam));</span><br><span class="line"></span><br><span class="line">    p-&gt;in = BIO_new_file(opt-&gt;key, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fail_clean_if(!p-&gt;in, sign_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;BIO_new_file(%s) fail\n&quot;</span>, opt-&gt;key);</span><br><span class="line">    pkey = PEM_read_bio_PrivateKey(p-&gt;in, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    fail_clean_if(!pkey, sign_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;PEM_read_bio_PrivateKey() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;ctx = EVP_PKEY_CTX_new(pkey, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;ctx) &#123;</span><br><span class="line">        EVP_PKEY_free(pkey);</span><br><span class="line">        fail_clean_if(<span class="number">1</span>, sign_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;EVP_PKEY_CTX_new() fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_sign_init(p-&gt;ctx), sign_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_sign_init() fail\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fail_clean_if(RAND_bytes(p-&gt;data, <span class="keyword">sizeof</span>(p-&gt;data)) &lt;= <span class="number">0</span>, sign_clean, (<span class="keyword">void</span> *)p,</span><br><span class="line">                  <span class="string">&quot;RAND_bytes() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;data_len = <span class="keyword">sizeof</span>(p-&gt;data);</span><br><span class="line">    p-&gt;sig_len = <span class="keyword">sizeof</span>(p-&gt;sig);</span><br><span class="line"></span><br><span class="line">    p-&gt;index = proc_index;</span><br><span class="line">    *param = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sign_work</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    SignParam *p = (SignParam *)param;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_sign(p-&gt;ctx, p-&gt;sig, &amp;p-&gt;sig_len, p-&gt;data, </span><br><span class="line">                                 p-&gt;data_len), sign_clean, param,</span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_sign() fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sign_clean</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    SignParam *p = (SignParam *)param;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ctx)</span><br><span class="line">        EVP_PKEY_CTX_free(p-&gt;ctx);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;in)</span><br><span class="line">        BIO_free(p-&gt;in);</span><br><span class="line">    OPENSSL_free(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span> </span>&#123;</span><br><span class="line">    VerifyParam *p;</span><br><span class="line">    EVP_PKEY *pkey;</span><br><span class="line">    X509 *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">size_t</span> data_len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sig[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">size_t</span> sig_len;</span><br><span class="line">    <span class="comment">/* 先签名一次，获取数据 */</span></span><br><span class="line">    SignParam *sp;</span><br><span class="line">    sign_init(opt, (<span class="keyword">void</span> **)&amp;sp, (<span class="keyword">long</span>)<span class="number">0</span>);</span><br><span class="line">    sign_work(sp);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, sp-&gt;data, sp-&gt;data_len);</span><br><span class="line">    data_len = sp-&gt;data_len;</span><br><span class="line">    <span class="built_in">memcpy</span>(sig, sp-&gt;sig, sp-&gt;sig_len);</span><br><span class="line">    sig_len = sp-&gt;sig_len;</span><br><span class="line">    sign_clean(sp);</span><br><span class="line"></span><br><span class="line">    p = OPENSSL_malloc(<span class="keyword">sizeof</span>(VerifyParam));</span><br><span class="line">    fail_if(!p, <span class="string">&quot;OPENSSL_malloc() fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(VerifyParam));</span><br><span class="line">    </span><br><span class="line">    p-&gt;in = BIO_new_file(opt-&gt;cert, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fail_clean_if(!p-&gt;in, verify_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;BIO_new_file(%s) fail\n&quot;</span>, opt-&gt;cert);</span><br><span class="line">    x = PEM_read_bio_X509(p-&gt;in, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    fail_clean_if(!x, verify_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;PEM_read_bio_X509() fail\n&quot;</span>);</span><br><span class="line">    pkey = X509_get_pubkey(x);</span><br><span class="line">    X509_free(x);</span><br><span class="line">    fail_clean_if(!pkey, verify_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;X509_get_pubkey() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;ctx = EVP_PKEY_CTX_new(pkey, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;ctx) &#123;</span><br><span class="line">        EVP_PKEY_free(pkey);</span><br><span class="line">        fail_clean_if(<span class="number">1</span>, verify_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;EVP_PKEY_CTX_new() fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_verify_init(p-&gt;ctx), verify_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_verify_init() fail\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(p-&gt;data, data, data_len);</span><br><span class="line">    p-&gt;data_len = data_len;</span><br><span class="line">    <span class="built_in">memcpy</span>(p-&gt;sig, sig, sig_len);</span><br><span class="line">    p-&gt;sig_len = sig_len;</span><br><span class="line"></span><br><span class="line">    p-&gt;index = proc_index;</span><br><span class="line">    *param = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify_work</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    VerifyParam *p = (VerifyParam *)param;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_verify(p-&gt;ctx, p-&gt;sig, p-&gt;sig_len, p-&gt;data, </span><br><span class="line">                                 p-&gt;data_len), verify_clean, param,</span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_verify() fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify_clean</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    VerifyParam *p = (VerifyParam *)param;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ctx)</span><br><span class="line">        EVP_PKEY_CTX_free(p-&gt;ctx);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;in)</span><br><span class="line">        BIO_free(p-&gt;in);</span><br><span class="line">    OPENSSL_free(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encrypt_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span> </span>&#123;</span><br><span class="line">    EncParam *p;</span><br><span class="line">    EVP_PKEY *pkey;</span><br><span class="line">    X509 *x;</span><br><span class="line">    p = OPENSSL_malloc(<span class="keyword">sizeof</span>(EncParam));</span><br><span class="line">    fail_if(!p, <span class="string">&quot;OPENSSL_malloc() fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(EncParam));</span><br><span class="line"></span><br><span class="line">    p-&gt;in = BIO_new_file(opt-&gt;cert, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fail_clean_if(!p-&gt;in, encrypt_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;BIO_new_file(%s) fail\n&quot;</span>, opt-&gt;cert);</span><br><span class="line">    x = PEM_read_bio_X509(p-&gt;in, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    fail_clean_if(!x, encrypt_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;PEM_read_bio_X509() fail\n&quot;</span>);</span><br><span class="line">    pkey = X509_get_pubkey(x);</span><br><span class="line">    X509_free(x);</span><br><span class="line">    fail_clean_if(!pkey, encrypt_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;X509_get_pubkey() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;ctx = EVP_PKEY_CTX_new(pkey, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;ctx) &#123;</span><br><span class="line">        EVP_PKEY_free(pkey);</span><br><span class="line">        fail_clean_if(<span class="number">1</span>, encrypt_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;EVP_PKEY_CTX_new() fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_encrypt_init(p-&gt;ctx), encrypt_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_encrypt_init() fail\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fail_clean_if(RAND_bytes(p-&gt;data, <span class="keyword">sizeof</span>(p-&gt;data)) &lt;= <span class="number">0</span>, encrypt_clean, (<span class="keyword">void</span> *)p,</span><br><span class="line">                  <span class="string">&quot;RAND_bytes() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;data_len = <span class="keyword">sizeof</span>(p-&gt;data);</span><br><span class="line">    p-&gt;enc_len = <span class="keyword">sizeof</span>(p-&gt;enc);</span><br><span class="line"></span><br><span class="line">    p-&gt;index = proc_index;</span><br><span class="line">    *param = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encrypt_work</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    EncParam *p = (EncParam *)param;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_encrypt(p-&gt;ctx, p-&gt;enc, &amp;p-&gt;enc_len, p-&gt;data, </span><br><span class="line">                                 p-&gt;data_len), encrypt_clean, param,</span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_encrypt() fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encrypt_clean</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    EncParam *p = (EncParam *)param;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ctx)</span><br><span class="line">        EVP_PKEY_CTX_free(p-&gt;ctx);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;in)</span><br><span class="line">        BIO_free(p-&gt;in);</span><br><span class="line">    OPENSSL_free(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrypt_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span> </span>&#123;</span><br><span class="line">    DecParam *p;</span><br><span class="line">    EVP_PKEY *pkey;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">size_t</span> data_len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> enc[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">size_t</span> enc_len;</span><br><span class="line">    <span class="comment">/* 先加密一次，获取数据 */</span></span><br><span class="line">    EncParam *ep;</span><br><span class="line">    encrypt_init(opt, (<span class="keyword">void</span> **)&amp;ep, (<span class="keyword">long</span>)<span class="number">0</span>);</span><br><span class="line">    encrypt_work(ep);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, ep-&gt;data, ep-&gt;data_len);</span><br><span class="line">    data_len = ep-&gt;data_len;</span><br><span class="line">    <span class="built_in">memcpy</span>(enc, ep-&gt;enc, ep-&gt;enc_len);</span><br><span class="line">    enc_len = ep-&gt;enc_len;</span><br><span class="line">    encrypt_clean(ep);</span><br><span class="line"></span><br><span class="line">    p = OPENSSL_malloc(<span class="keyword">sizeof</span>(DecParam));</span><br><span class="line">    fail_if(!p, <span class="string">&quot;OPENSSL_malloc() fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(DecParam));</span><br><span class="line">    </span><br><span class="line">    p-&gt;in = BIO_new_file(opt-&gt;key, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fail_clean_if(!p-&gt;in, decrypt_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;BIO_new_file(%s) fail\n&quot;</span>, opt-&gt;key);</span><br><span class="line">    pkey = PEM_read_bio_PrivateKey(p-&gt;in, <span class="literal">NULL</span>, <span class="literal">NULL</span>, PEM_AUTO_KEYPASS);</span><br><span class="line">    fail_clean_if(!pkey, decrypt_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;PEM_read_bio_PrivateKey() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;ctx = EVP_PKEY_CTX_new(pkey, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;ctx) &#123;</span><br><span class="line">        EVP_PKEY_free(pkey);</span><br><span class="line">        fail_clean_if(<span class="number">1</span>, decrypt_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;EVP_PKEY_CTX_new() fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_decrypt_init(p-&gt;ctx), decrypt_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_decrypt_init() fail\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(p-&gt;data, data, data_len);</span><br><span class="line">    p-&gt;data_len = data_len;</span><br><span class="line">    <span class="built_in">memcpy</span>(p-&gt;enc, enc, enc_len);</span><br><span class="line">    p-&gt;enc_len = enc_len;</span><br><span class="line"></span><br><span class="line">    p-&gt;index = proc_index;</span><br><span class="line">    *param = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrypt_work</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    DecParam *p = (DecParam *)param;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_decrypt(p-&gt;ctx, p-&gt;data, &amp;p-&gt;data_len, p-&gt;enc, </span><br><span class="line">                                 p-&gt;enc_len), decrypt_clean, param,</span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_decrypt() fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrypt_clean</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    DecParam *p = (DecParam *)param;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ctx)</span><br><span class="line">        EVP_PKEY_CTX_free(p-&gt;ctx);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;in)</span><br><span class="line">        BIO_free(p-&gt;in);</span><br><span class="line">    OPENSSL_free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><code>multi-process.c</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span>   <span class="comment">// wait</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>  <span class="comment">// getpid, wait</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span>    <span class="comment">// shmget, shmat, shmctl, shmdt</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span>    <span class="comment">// shmget, shmat, shmctl, shmdt</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span>     <span class="comment">// sigaction, SIGLARM</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>     <span class="comment">// LONG_MIN, LONG_MAX, ULLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span>      <span class="comment">// errno</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>     <span class="comment">// getpid</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>     <span class="comment">// memset</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;work.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> isStop = <span class="number">0</span>;             <span class="comment">// 用于标记测试终止</span></span><br><span class="line">Options opt;                <span class="comment">// 命令行选项</span></span><br><span class="line"><span class="keyword">int</span> shmid;                  <span class="comment">// 共享内存id</span></span><br><span class="line">Result *shm = <span class="literal">NULL</span>;         <span class="comment">// 共享内存地址，用于存放测试结果</span></span><br><span class="line">Result res_total;</span><br><span class="line">Result res_last;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal_child</span><span class="params">(<span class="keyword">int</span> sigNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigNum == SIGALRM) &#123;</span><br><span class="line">        isStop = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal_parent</span><span class="params">(<span class="keyword">int</span> sigNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigNum == SIGALRM) &#123;</span><br><span class="line">        <span class="comment">/* DO REAL-TIME STATISTICS */</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;res_total, <span class="number">0</span>, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; opt.procs; ++i) &#123;</span><br><span class="line">            res_total.count += shm[i].count;</span><br><span class="line">        &#125;</span><br><span class="line">        mylog(<span class="string">&quot;total count %12llu,  average %12.0lf/s\n&quot;</span>,</span><br><span class="line">                res_total.count, (res_total.count - res_last.count)</span><br><span class="line">                / (<span class="keyword">double</span>)opt.interval);</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;res_last, &amp;res_total, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        <span class="comment">/* DO REAL-TIME STATISTICS */</span></span><br><span class="line">        alarm(opt.interval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行测试主循环函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTest</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    HashParam *pa = (HashParam *)param;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; ULLONG_MAX &amp;&amp; !isStop; ++i) &#123;</span><br><span class="line">        <span class="comment">/* DO YOUR WORK */</span></span><br><span class="line">        test_work(param);</span><br><span class="line">        ++shm[pa-&gt;index].count;</span><br><span class="line">        <span class="comment">/* DO YOUR WORK */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> proc_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> isParent = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> wstatus = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act_child</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act_parent</span>;</span></span><br><span class="line"></span><br><span class="line">    rv = process_options(argc, argv, &amp;opt);</span><br><span class="line">    <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mylog(<span class="string">&quot;\n-----------------------------Start Testing-----------------------&quot;</span></span><br><span class="line">          <span class="string">&quot;-------\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* COMMON INIT */</span></span><br><span class="line">    shmid = shmget(IPC_PRIVATE, <span class="keyword">sizeof</span>(<span class="keyword">sizeof</span>(Result) * opt.procs), <span class="number">0666</span>);</span><br><span class="line">    fail_if(<span class="number">-1</span> == shmid, <span class="string">&quot;shmget() failed\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;shmid = %d\n&quot;</span>, shmid);</span><br><span class="line">    shm = (Result*)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    fail_if((<span class="keyword">void</span> *) <span class="number">-1</span> == shm, <span class="string">&quot;shmat() failed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里直接进行IPC_RMID操作，进程退出之后会自动detach了, 从而释放共享内存 */</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(shm, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">sizeof</span>(Result) * opt.procs));</span><br><span class="line"></span><br><span class="line">    global_init(&amp;opt);</span><br><span class="line">    <span class="comment">/* COMMON INIT */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(isParent &amp;&amp; i &lt; opt.procs) &#123;</span><br><span class="line">        pid =  fork();</span><br><span class="line">        fail_if(<span class="number">-1</span> == pid, <span class="string">&quot;fork failed %d\n&quot;</span>, pid);    <span class="comment">/* error */</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;                                  <span class="comment">/* child */</span></span><br><span class="line">            isParent = <span class="number">0</span>;</span><br><span class="line">            proc_index = i;                             <span class="comment">// 记录进程索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;                                          <span class="comment">/* parent */</span></span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isParent) &#123;</span><br><span class="line">        <span class="comment">/* PARENT INIT */</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;act_parent, <span class="number">0</span>, <span class="keyword">sizeof</span>(act_parent));</span><br><span class="line">        act_parent.sa_handler = handle_signal_parent;</span><br><span class="line">        <span class="comment">/* 使wait被中断时可以自动恢复 */</span></span><br><span class="line">        act_parent.sa_flags = SA_RESTART;</span><br><span class="line">        rv = sigaction(SIGALRM, &amp;act_parent, <span class="literal">NULL</span>);     <span class="comment">// 用于定时统计结果</span></span><br><span class="line">        fail_if(rv, <span class="string">&quot;sigaction() failed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;res_last, <span class="number">0</span>, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        alarm(opt.interval);</span><br><span class="line">        <span class="comment">/* PARENT INIT */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* DO FINAL STATISTICS */</span></span><br><span class="line">        Result <span class="keyword">final</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;<span class="keyword">final</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        <span class="keyword">for</span>(i =<span class="number">0</span> ; i &lt; opt.procs; ++i) &#123;</span><br><span class="line">            pid = wait(&amp;wstatus);                       <span class="comment">// 等待子进程结束</span></span><br><span class="line">            alarm(<span class="number">0</span>);                                   <span class="comment">// 终止定时器</span></span><br><span class="line">            fail_if(<span class="number">-1</span> == pid, <span class="string">&quot;wait() failed, errno=%d\n&quot;</span>, errno);</span><br><span class="line">            mylog(<span class="string">&quot;process [pid = %6d] exit\n&quot;</span>, pid);</span><br><span class="line">            mylog(<span class="string">&quot;process [pid = %6u] count %12llu in %lus,&quot;</span></span><br><span class="line">                  <span class="string">&quot;  average %12.0lf/s\n&quot;</span>, pid, shm[i].count, opt.duration, </span><br><span class="line">                  shm[i].count / (<span class="keyword">double</span>)opt.duration);</span><br><span class="line">            <span class="keyword">final</span>.count += shm[i].count;</span><br><span class="line">        &#125;</span><br><span class="line">        mylog(<span class="string">&quot;total count %12llu in %lus,  average %12.0lf/s\n&quot;</span>, </span><br><span class="line">               <span class="keyword">final</span>.count, opt.duration, <span class="keyword">final</span>.count / (<span class="keyword">double</span>)opt.duration);</span><br><span class="line">        <span class="comment">/* DO FINAL STATISTICS */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* PARENT CLEANUP */</span></span><br><span class="line">        global_clean();</span><br><span class="line">        <span class="comment">/* PARENT CLEANUP */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* CHILD INIT */</span></span><br><span class="line">        <span class="keyword">void</span> *param;</span><br><span class="line">        test_init(&amp;opt, &amp;param, proc_index);</span><br><span class="line">        <span class="comment">/* CHILD INIT */</span></span><br><span class="line"></span><br><span class="line">        act_child.sa_handler = handle_signal_child;</span><br><span class="line">        sigemptyset(&amp;act_child.sa_mask);</span><br><span class="line">        act_child.sa_flags = SA_RESETHAND;</span><br><span class="line">        <span class="comment">/* 用于测试时间到时，通知子进程结束测试 */</span></span><br><span class="line">        rv = sigaction(SIGALRM, &amp;act_child, <span class="literal">NULL</span>);</span><br><span class="line">        fail_if(rv, <span class="string">&quot;sigaction() failed\n&quot;</span>);</span><br><span class="line">        alarm(opt.duration);                            <span class="comment">// 设置测试时长</span></span><br><span class="line">        doTest(param);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CHILD CLEANUP */</span></span><br><span class="line">        test_clean(param);</span><br><span class="line">        global_clean();</span><br><span class="line">        <span class="comment">/* CHILD CLEANUP */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">/* child finished work */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></div>




<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，一个多进程的测试程序就算完成了。读者可以根据自身测试需要，按如下步骤修改以进行自定义的测试。</p>
<ol>
<li>在<code>opt.c</code>和<code>opt.h</code>中，添加需要的命令行选项</li>
<li>在<code>work.c</code>和<code>work.h</code>中，<code>global_init()</code>和<code>global_clean()</code>内进行全局的初始化及全局的清理工作</li>
<li>在<code>work.c</code>和<code>work.h</code>中，添加自定义的测试函数，以及相应的测试参数和测试结果</li>
<li>主控<code>multi-process.c</code>通过<code>test_init()</code>、<code>test_work()</code>、<code>test_clean()</code>调用测试相关的初始化、执行及清理工作</li>
<li>主控<code>multi-process.c</code>中，修改测试结果的更新与统计操作。</li>
</ol>
<p>主控<code>multi-process.c</code>中：</p>
<ul>
<li><code>COMMON INIT</code>、<code>PARENT INIT</code>和<code>CHILD INIT</code>代码块处分别进行公共的初始化工作和父子进程特定的初始化工作。</li>
<li><code>PARENT CLEANUP</code>和<code>CHILD CLEANUP</code>代码块处则分别进行对应的清理工作。</li>
<li><code>DO YOUR WORK</code>处执行具体的测试，<code>DO REAL-TIME STATISTICS</code>和<code>DO FINAL STATISTICS</code>处进行测试结果的统计。</li>
</ul>
<p>当然本文还有一些不足之处，比如当前是用的OpenSSL1.0.2接口，没有兼容不同版本的OpenSSL。还有代码风格的问题，在函数命名和注释方式上不统一。但是考虑到这个是测试程序，就不计较这么多了（^。^）</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Unix环境编程</category>
      </categories>
      <tags>
        <tag>共享内存</tag>
        <tag>多进程</tag>
        <tag>信号</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核是如何启动的</title>
    <url>/posts/615fc0b5/</url>
    <content><![CDATA[<div class="note primary">
            <p>本文介绍Linux内核的引导启动以及初始化流程，从你按下电源开始到你最终进行终端登录，这期间到底发生了什么？</p>
          </div>

<span id="more"></span>

<div class="note default no-icon">
            <p>注：本文讲述的内容基于Linux 0.11，相关内核源码可以从<a href="(http://oldlinux.org)">这里</a>下载。</p>
          </div>





<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>再阅读本文之前，建议先对CPU保护模式、分段分页机制、GDT/LDT/IDT等概念有最基本的了解。这里仅做简单介绍：</p>
<ul>
<li>32位保护模式：支持多任务、支持4GB物理内存、支持虚拟内存、支持分段和分页机制、支持特权级。具体提供了哪些保护机制可以参考<a href="https://pdos.csail.mit.edu/6.828/2004/readings/i386/s06_02.htm">80386 Protection Mechanisms</a></li>
<li>分段分页机制：保护模式下提供了虚拟内存机制，描述符中保存了段的基值、限长以及一些其他的保护参数。每个进程都使用独立的虚拟地址，通过段描述符的基址可以得到线性地址，再根据分页机制的页目录、页表可以转化为实际的物理地址。</li>
<li>GDT：全局描述符表，存放内核的数据段、代码段描述符以及各个任务的局部表和状态段描述符。GDT地址可以通过gdtr寄存器定位。</li>
<li>IDT：中断描述符表，指出发生中断时需要调用的代码信息，跟中断向量表有些类似，但是包含更多的信息。IDT地址可以通过idtr寄存器定位。</li>
<li>LDT：任务的局部描述符表，第0项不用、第1第2项分别为任务的代码段和数据堆栈段描述符。LDT地址可以通过ldtr寄存器定位。</li>
<li>TSS：任务状态段，主要保存两类信息。一类是任务切换时更新的动态信息：如通用寄存器、段寄存器、EFLAGS、EIP、前一个执行任务的TSS选择符。一类是静态信息级：任务的LDT选择符、页目录基地址寄存器CR3（PDBR）、0～2特权级的堆栈指针、调试跟踪位、I/O比特位图基地址。TSS地址可以通过tr寄存器定位。</li>
<li>描述符表项：8个字节，包括段的最大长度限制（16位）、段的线形基址（32位）、段的特权级、段是否在内存、读写权限以及其他一些保护模式运行的标志。</li>
<li>段选择符：2个字节，位0～1表示请求的特权级，Linux只用了两级，0表示系统级3表示用户级，位2用于全局(0)或局部(1)描述符表，位3～15是描述符表项的索引。</li>
<li>中断描述符表项：8个字节，称为门描述符，0～1和6～7字节是处理程序所在段的段内偏移量，2～3字节是处理程序所在段的段选择符，4～5B是一些标志。包含3种门描述符：中断门DPL为0、关中断，陷阱门DPL为0、开中断，系统门(其实也是陷阱门)不过DPL为3、开中断。</li>
<li>页表项：4个字节，低0～11位存放一些标志，如位0是否在内存中、位1读写标志位、位2普通用户还是超级用户、位6是否脏页，高12～31位是页框地址。</li>
</ul>
<h1 id="磁盘引导-bootsect-s"><a href="#磁盘引导-bootsect-s" class="headerlink" title="磁盘引导(bootsect.s)"></a>磁盘引导(bootsect.s)</h1><ol>
<li><p>当计算机上电启动后，x86的CPU将自动<strong>进入实模式</strong>，并从0xffff0地址处开始执行程序，这里通常是ROM-BIOS的地址，BIOS将执行硬件系统检测，并在物理地址0处建立中断向量表，即将BIOS提供的中断例程的入口地址登记在中断向量表中。</p>
<p>8086CPU的内存地址空间分配</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0</span>                    <span class="number">0x9ffff</span> <span class="number">0xa0000</span>     <span class="number">0xbffff</span> <span class="number">0xc0000</span>  <span class="number">0xfffff</span></span><br><span class="line">|中断向量表 主储存器地址空间RAM   |     显存地址空间     | 各类ROM地址空间 |</span><br></pre></td></tr></table></figure></li>
<li><p>随后BIOS将启动盘的第一个扇区（引导块，Linux0.11对应bootsect.s代码）读入内存0x7c00处，然后跳转到那里继续执行</p>
</li>
<li><p>从这里起，内核便开始接手CPU的控制权了。引导块的大小毕竟有限，所以它干的事情很简单，就是将引导块自己移到内存0x90000处，然后将内核程序剩余的部分读到内存中。其中setup.s对应的4个扇区读到了0x90200处，即紧跟在引导块之后。内核主体部分system则读到0x10000处，此时内存的布局如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0</span>         <span class="number">0x7c00</span>      <span class="number">0x10000</span>            <span class="number">0x90000</span> <span class="number">0x90200</span>      <span class="number">0xa0000</span></span><br><span class="line">|中断向量表| |引导块|     |system        |    |引导块  |setup.s|   ｜    </span><br></pre></td></tr></table></figure></li>
<li><p>读完之后，便段间跳转到0x90200处，开始执行setup.s的代码</p>
</li>
</ol>
<h1 id="系统设置-setup-s"><a href="#系统设置-setup-s" class="headerlink" title="系统设置(setup.s)"></a>系统设置(setup.s)</h1><ol>
<li><p>setup.s程序的主要任务是利用ROM BIOS中断获取系统的信息，放到内存中合适的位置（0x90000开始），以提供后面的保护模式下的操作系统使用。因为保护模式下，操作系统将自己设置中断描述符表以处理中断，而不再使用实模式下的中断向量表。</p>
</li>
<li><p>读取的系统信息包括显示相关的、内存信息、硬盘信息、根文件系统设备号等。这些信息将被内核相关程序使用。</p>
</li>
<li><p>接下来就要为进入保护模式做准备了。<strong>关中断</strong>后，将system模块从0x10000～0x8ffff（512KB）整体移到0x00000处。</p>
<p>这里有<span class="label primary">两个问题值得思考</span>：为什么前面bootsect.s中不直接将system读到0x00000处？为什么这里要关中断？</p>
<p>第一个问题是因为我们从磁盘读system模块的时候还是需要用到BIOS的中断，所以不能覆盖位于0x0的中断向量表。</p>
<p>第二个问题则是由于我们的system模块即将覆盖中断向量表，所以如果实模式发生了中断的话，得到的将是无效的中断向量，系统会崩溃。同样地，进入保护模式之后，在没有完成初始化之前，中断描述符项可能是无效的。</p>
</li>
<li><p>然后就是加载中断描述符表寄存器(idtr)和全局描述符表寄存器(gdtr)，然后开启A20地址线，对两个中断控制芯片8259A进行编程，设置其中断号为0x20-0x2f。</p>
<p>临时idt表基址0，限长0，临时gdt表基址512+gdt，限长2048，即256项。</p>
</li>
<li><p>最后通过<code>lmsw</code>指令设置CPU的机器状态字（也称控制寄存器CR0），从而<strong>进入到保护模式</strong>，并跳转到代码段开头即system模块最开头的head.s继续执行。（保护模式下段寄存器的值不再表示段的基址，而是表示段选择符。）</p>
</li>
</ol>
<p>此时内存的布局如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0</span>                             <span class="number">0x90000</span> <span class="number">0x90200</span></span><br><span class="line">|head.s|main.c|kernel|mm|lib|...|系统参数｜setup.s|临时gdt|...|</span><br><span class="line">\----------system-----------/</span><br></pre></td></tr></table></figure>

<p>system被移到了0x0开始处，0x90000处则存放了系统信息(之前的引导块bootsect.s已经被覆盖)。临时gdt中第0项不用，第1项是系统代码段描述符、第2项是系统数据段描述符，两者的基址都是0。</p>
<h1 id="启动程序-head-s"><a href="#启动程序-head-s" class="headerlink" title="启动程序(head.s)"></a>启动程序(head.s)</h1><p>从head.s开始，内核已经完全处于保护模式下运行了。不过在开始执行C代码前，还需要用汇编完成一些任务，主要包括：</p>
<ol>
<li>重新设置各个段寄存器为对应的段选择符（代码段0x08，数据段0x10）</li>
<li>设置正式中断描述符表idt，256项，初始化每个门描述符都指向一个只报错误的哑中断程序</li>
<li>设置正式全局描述符表gdt，256项。全局表第0项NULL，第1项系统代码段描述符、第2项是系统数据段描述符、第3项系统段不用，后面是留给各个任务的TSS描述符和LDT描述符。每个局部描述符表LDT含有三个描述符，第0个不用、第1个是任务代码段、第2个是任务数据/堆栈段。</li>
<li>然后设置堆栈段位内核数据段(0x10)，堆栈指针esp指向<code>user_stack</code>数组尾部，保留了4KB空间作为堆栈使用。（此前bootsect.s中临时使用的栈顶位位置在0x9000:0xff00。）</li>
<li>检查A20地址线是否真的开启</li>
<li>测试机器是否含有数学协处理器芯片，并设置控制寄存器CR0中相应标志位。</li>
<li>接下来是分页机制的相关设置，将从0x0开始的前5页内存清零，设置第一页为页目录，其余4页为页表，然后将页目录中的前4项以及所有页表项指向对应的物理内存地址，置最后3位标志，表示该页存在且用户可读写。</li>
<li>设置页目录基址寄存器cr3的值，指向页目录表</li>
<li>现在可以启动分页机制了，方法就是通过置控制寄存器cr0的第31位。</li>
<li>最后通过<code>ret</code>指令将事先压栈的main函数入口地址弹出，开始运行main函数。</li>
</ol>
<div class="note default no-icon">
            <p>注：Linux 0.11中，所以进程都使用同一个页目录表，但都有自己的页表。最多支持64个进程，每个进程的虚拟地址空间范围64MB，逻辑地址乘以任务号即可转换得到线性地址，合在一起正好是4GB。不过在Linux 0.99版之后，每个进程都有自己的页目录，可以单独享用4GB的虚拟地址了。</p>
          </div>

<p>此时内存布局如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0</span>                       <span class="number">0x5000</span></span><br><span class="line">|页目录(<span class="number">4</span>K)|pg0|pg1|pg2|pg3|软盘缓冲区(<span class="number">1</span>K)|head.s部分|idt(<span class="number">2</span>K)|gdt(<span class="number">2</span>K)|main.c|</span><br></pre></td></tr></table></figure>



<h1 id="内核初始化-main-c"><a href="#内核初始化-main-c" class="headerlink" title="内核初始化(main.c)"></a>内核初始化(main.c)</h1><p>该程序代码不长，但包括了内核初始化的所有工作，主要的初始化流程如下（此时还处于关中断的状态）：</p>
<ol>
<li><p>首先设置根文件系统设备号及内存全局变量</p>
<p>利用setup.s程序获取的系统参数设置系统的根文件系统设备号以及一些内存全局变量。这些内存全局变量指明了主内存的开始地址、系统的内存容量和作为高速缓冲区内存的末端地址。</p>
<p>Linux 0.11内核默认最多支持16MB物理内存，其分布如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  内核模块 /    高速缓冲区          \ 虚拟盘        主内存区</span><br><span class="line">|        |    ｜显存和BIOS ROM|    |      |                      |</span><br><span class="line"><span class="number">0</span>        end   <span class="number">640</span>K          <span class="number">1</span>MB  <span class="number">4</span>MB    <span class="number">4.5</span>MB                  <span class="number">16</span>MB</span><br></pre></td></tr></table></figure>

<p>高速缓冲区要扣除显存和BIOS ROM部分，如果定义了虚拟盘(RAMDISK)，则主内存适当减少。内核程序可以自由访问高速缓冲区中的数据，而主内存则由mm模块通过分页机制进行管理分配。</p>
</li>
<li><p>接着是系统各个部分的初始化：</p>
<p>内存、陷阱门、块设备、字符设备、tty、开机启动时间、调度程序（加载了任务0的tr和ldtr、时钟中断门和系统调用门）、缓冲区、硬盘、软驱。</p>
<ul>
<li>ramdisk虚拟盘：确定rd处理函数、内存起始地址和长度，对整个虚拟盘清零。</li>
<li>mem内存：初始化mem_map，主内存页为0，其余为USED。</li>
<li>trap陷阱门：设置陷阱门和系统门。（选择符0x0008表示系统级，全局表，第2项，即内核代码段cs。）</li>
<li>blk块设备：初始化请求队列</li>
<li>tty字符设备：包括rs_init和con_init。rs_init设置串口rs1和rs2中断门，初始化串口rs1和rs2（rs232），允许主8259A芯片的IRQ3和IRQ4。con_init初始化控制台中断，读取setup.s保存的信息，确定当前显示器类型并设置所有相关参数。设置键盘中断陷阱门，复位键盘。</li>
<li>time时间：从CMOS读取时间，初始化启动时间startup_time</li>
<li>sched调度：设置GDT中task0的tss和ldt描述符（init_task已经静态设置好），清任务数组及其在GDT中的描述符表项，清标志寄存器NT位（iret时不进行任务切换），将任务0的TSS加载到任务寄存器tr，将GDT中任务0的ldt描述符的选择符加载到ldtr（仅显式加载这一次，后续任务CPU根据TSS中的LDT项自动加载）。初始化8253定时器，设置定时器中断门，设置系统调用系统门。</li>
<li>buffer高速缓冲区：初始化高速缓冲区，前面缓冲区低端是缓冲头结构，高端是缓冲块（每个1KB），第一个缓冲头指向最后一个缓冲块。空闲链表头指向第一个缓冲区头，第一个缓冲区头和最后一个相连形成环链。初始化hash表为空。</li>
<li>hd硬盘：设置硬盘请求处理函数、中断门，允许硬盘控制器发送中断请求信号。</li>
<li>floppy软驱：设置软盘请求处理函数、中断门，允许软盘控制器发送中断请求信号。</li>
</ul>
</li>
<li><p>OK，所有初始化工作完毕，<strong>开中断</strong>。（从setup.s中移动system模块前关中断一直到这里为止）</p>
</li>
<li><p>接下来要变魔术了，<code>move_to_user_mode()</code>完成两个重要的历史任务：一是<strong>启动第一个任务（进程0）</strong>，二是<strong>将特权级切换到用户态</strong>（此前一直是工作在内核态）</p>
<p>我们来看下这段关键的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define move_to_user_mode() \</span><br><span class="line">__asm__ (&quot;movl %%esp,%%eax\n\t&quot; \</span><br><span class="line">    &quot;pushl $0x17\n\t&quot; \</span><br><span class="line">    &quot;pushl %%eax\n\t&quot; \</span><br><span class="line">    &quot;pushfl\n\t&quot; \</span><br><span class="line">    &quot;pushl $0x0f\n\t&quot; \</span><br><span class="line">    &quot;pushl $1f\n\t&quot; \</span><br><span class="line">    &quot;iret\n&quot; \</span><br><span class="line">    &quot;1:\tmovl $0x17,%%eax\n\t&quot; \</span><br><span class="line">    &quot;movw %%ax,%%ds\n\t&quot; \</span><br><span class="line">    &quot;movw %%ax,%%es\n\t&quot; \</span><br><span class="line">    &quot;movw %%ax,%%fs\n\t&quot; \</span><br><span class="line">    &quot;movw %%ax,%%gs&quot; \</span><br><span class="line">    :::&quot;ax&quot;)</span><br></pre></td></tr></table></figure>

<p>前面几条指令是手动模拟中断过程的堆栈情况，我们来逐条解释一下：</p>
<ol>
<li>保存堆栈指针esp到eax</li>
<li>将task0堆栈段选择符(0x17)入栈（此前ss是0x10）</li>
<li>将eax中的堆栈指针值入栈</li>
<li>将标志寄存器入栈</li>
<li>将task0代码段选择符(0x0f)入栈（此前cs是0x08）</li>
<li>将标号1的偏移地址入栈</li>
<li>接下来执行<code>iret</code>，这是一个标志性的时刻。偏移地址、代码段选择符、标志寄存器出栈，接下来跳到task0中执行了。由于任务0的描述符特权级是3（即用户态），所以之前入栈的堆栈指针和堆栈段选择符也被弹出，也即恢复之前内核堆栈。这样就完成了任务0的人工启动，它是所有进程的祖先，但是它比较特殊，它的数据段和代码段直接映射内核代码和数据空间，也即从0开始，限长640KB。其内核态堆栈位于其task数据结构所在页面的末端，内核态堆栈指针是在其初始化任务数据结构中人工设置的。而它的用户态堆栈就是最前面两条指令设置的，esp仍然指向原来的位置，但是ss已经变成0x17，即用户态局部表中的数据段。</li>
<li>接下来4个指令都是设置段寄存器，指向局部表的数据段。其中0x17是task0的数据/堆栈段选择符，00010111最后两位表示特权级为3，位2表示局部表，高15位表示索引，局部表的第2项是数据段和堆栈段描述符（0不用，1是代码段）。类似地，0x0f是代码段选择符。</li>
</ol>
</li>
<li><p>任务0自己的事情已经安顿好了，接下来自然就是开始造孩子了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!fork()) &#123;      <span class="comment">/* we count on this going ok */</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(;;) pause();</span><br></pre></td></tr></table></figure>

<p>这是main函数的最后几行代码，fork了一个子进程（即<strong>进程1</strong>）执行<code>init()</code>，进程0则循环执行<code>pause()</code>。每当系统没有其他可执行的进程时就会执行进程0。</p>
<span class="label primary">值得一提的是</span>，为了确保fork创建的新进程没有进程0的多余信息，要求进程0在创建第一个新进程之前不要使用用户态堆栈，即要求进程0不能调用函数，所以这里`fork()`和`pause()`是采用gcc函数内嵌的形式来执行的。</li>
<li><p>最后我们来看下进程1执行的<code>init()</code>函数</p>
<ol>
<li>它首先执行<code>setup()</code>函数，主要是初始化硬盘分区，最后执行<code>mount_root()</code>安装根文件系统：初始化超级块数组，读取根设备上的超级块和根i节点结构信息，设置根i节点引用次数，并作为进程1的当前工作目录pwd和根目录root的i节点。根据逻辑块位图统计空闲块数并显示，根据i节点位图统计空闲i节点数并显示。</li>
<li>读写打开终端控制台<code>/dev/tty0</code>，文件句柄为0，并复制产生句柄1和2</li>
<li>接下来fork出进程2，用<code>/bin/sh</code>程序执行<code>/etc/rc</code>脚本</li>
<li>如果进程2执行失败或执行结束，则进入一个大的死循环：创建新进程、关闭遗留句柄、创建一个会话并设置进程组号、句柄0/1/2都读写打开终端控制台<code>/dev/tty0</code>、最后<code>execve()</code>执行<code>/bin/sh</code>程序。此时用户便可以开始操作终端了。</li>
</ol>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>《Linux 内核完全注释— 赵炯》</li>
<li>《汇编语言—王爽》</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内核</tag>
      </tags>
  </entry>
</search>

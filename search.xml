<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>UNIX环境高级编程APUE练习3.2-不用fcntl实现dup2的功能</title>
    <url>/posts/2485f370/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>编写与<code>dup2</code>功能相同的函数，要求不调用<code>fcntl</code>函数，并且要有正确的出错处理。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>不能用<code>fcntl</code>，能够返回一个文件描述符的只有<code>open</code>和<code>dup</code>。而<code>open</code>会创建一个新的文件表项，返回的fd指向新的文件表项，与<code>dup2</code>的表现不符。<code>dup</code>基本能满足要求，但是返回的是最小的可用fd，需要进一步操作满足要求。另外需要自己添加错误处理，以及处理oldfd与newfd相等的情况等。具体地，</p>
<span id="more"></span>

<ol>
<li>当dup返回出错时，直接返回出错</li>
<li>当dup返回值等于newfd时，直接返回</li>
<li>当dup返回值小于newfd时，记录返回值，循环调用dup直到返回值等于newfd。关闭前面记录的所有fd，返回newfd</li>
<li>当dup返回值大于newfd时，关闭返回值的fd。如果oldfd等于newfd，直接返回newfd;如果不相等，关掉newfd，然后再dup（因为不是原子的，返回值需要再判断）</li>
</ol>
<h2 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h2><ol>
<li>oldfd的出错处理可以直接交给dup</li>
<li>newfd的出错处理，需要判断是否超出文件描述符范围(<code>RLIMIT_NOFILE</code> in getrlimit)</li>
<li>对于dup返回EMFILE的情况，newfd如果没超过进程可打开的最大文件数，则不影响</li>
<li>另外还有一个判断顺序问题，是先判断参数是否合法还是oldfd==newfd, 这个可以根据dup2函数实测来确定</li>
</ol>
<h2 id="4-测试用例"><a href="#4-测试用例" class="headerlink" title="4 测试用例"></a>4 测试用例</h2><h3 id="进程打开的文件数没满的情况下"><a href="#进程打开的文件数没满的情况下" class="headerlink" title="进程打开的文件数没满的情况下"></a>进程打开的文件数没满的情况下</h3><ol>
<li>都超出范围，相同（MAX+1，MAX+1）</li>
<li>未打开描述符，相同 (100, 100)</li>
<li>newfd超出范围 (1, MAX+1)</li>
<li>newfd正好没超出 (1, MAX)</li>
<li>oldfd和newfd相同 (2, 2)</li>
</ol>
<h3 id="进程打开的文件数满的情况下"><a href="#进程打开的文件数满的情况下" class="headerlink" title="进程打开的文件数满的情况下"></a>进程打开的文件数满的情况下</h3><ol>
<li>newfd正好超出范围 (1, MAX+1)</li>
<li>newfd正好没超出 (1, MAX)</li>
<li>oldfd和newfd相同 (2, 2)</li>
</ol>
<h2 id="5-开始撸码实测"><a href="#5-开始撸码实测" class="headerlink" title="5 开始撸码实测"></a>5 开始撸码实测</h2><h3 id="5-1-先验证dup2的判断顺序问题"><a href="#5-1-先验证dup2的判断顺序问题" class="headerlink" title="5.1 先验证dup2的判断顺序问题"></a>5.1 先验证dup2的判断顺序问题</h3><ul>
<li>测试源码</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">old_rlim</span>=</span>&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    getrlimit(RLIMIT_NOFILE, &amp;old_rlim);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NOFILE limits: soft=%lld; hard=%lld\n&quot;</span>,</span><br><span class="line">                   (<span class="keyword">long</span> <span class="keyword">long</span>) old_rlim.rlim_cur, (<span class="keyword">long</span> <span class="keyword">long</span>) old_rlim.rlim_max);</span><br><span class="line"></span><br><span class="line">    r = dup2(<span class="number">10000</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2(10000, 10000) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2(10000, 10000) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2(100, 100) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2(100, 100) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2(1, 10000) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2(1, 10000) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2(1, 100) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2(1, 100) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>MAC OSX下运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ./a.out</span><br><span class="line">NOFILE limits: soft=7168; hard=9223372036854775807</span><br><span class="line">dup2(10000, 10000) fail: : Bad file descriptor</span><br><span class="line">dup2(100, 100) fail: : Bad file descriptor</span><br><span class="line">dup2(1, 10000) fail: : Bad file descriptor</span><br><span class="line">dup2(1, 100) success return 100</span><br></pre></td></tr></table></figure>

<p>可见是参数出错判断是先于oldfd == newfd判断的</p>
<h3 id="5-2-测试进程打开的最大文件数到上限时，dup2是否能成功"><a href="#5-2-测试进程打开的最大文件数到上限时，dup2是否能成功" class="headerlink" title="5.2 测试进程打开的最大文件数到上限时，dup2是否能成功"></a>5.2 测试进程打开的最大文件数到上限时，dup2是否能成功</h3><ul>
<li>测试源码</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> max_fd = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">old_rlim</span>=</span>&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    getrlimit(RLIMIT_NOFILE, &amp;old_rlim);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NOFILE limits: soft=%lld; hard=%lld\n&quot;</span>,</span><br><span class="line">                   (<span class="keyword">long</span> <span class="keyword">long</span>) old_rlim.rlim_cur, (<span class="keyword">long</span> <span class="keyword">long</span>) old_rlim.rlim_max);</span><br><span class="line">    <span class="keyword">while</span>((r = dup(<span class="number">0</span>))!= <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        max_fd = r;</span><br><span class="line">    &#125;</span><br><span class="line">    perror(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max fd is %d\n&quot;</span>, max_fd);</span><br><span class="line"></span><br><span class="line">    r = dup2(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2(1, 10000) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2(1, 10000) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2(1, 100) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2(1, 100) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>MAC OSX下运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ./a.out</span><br><span class="line">NOFILE limits: soft=7168; hard=9223372036854775807</span><br><span class="line">Too many open files</span><br><span class="line">max fd is 7167</span><br><span class="line">dup2(1, 7168) fail: : Bad file descriptor</span><br><span class="line">dup2(1, 7167) success return 7167</span><br></pre></td></tr></table></figure>

<p>可见在进程打开文件数达到上限时，dup2替换已经打开的文件是可以的</p>
<h3 id="5-3-实现dup2的功能"><a href="#5-3-实现dup2的功能" class="headerlink" title="5.3 实现dup2的功能"></a>5.3 实现dup2的功能</h3><ul>
<li>源码</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*dup实现dup2的功能*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2_</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">7168</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">old_rlim</span>=</span>&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    getrlimit(RLIMIT_NOFILE, &amp;old_rlim);</span><br><span class="line">    <span class="keyword">if</span> (newfd &lt; <span class="number">0</span> || newfd &gt; old_rlim.rlim_cur - <span class="number">1</span>) &#123;</span><br><span class="line">        errno = EBADF;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        ret = dup(oldfd);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno != EMFILE) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno == EMFILE) &#123;</span><br><span class="line">            <span class="keyword">if</span>(oldfd == newfd) &#123;</span><br><span class="line">                <span class="keyword">return</span> newfd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;close(newfd)\n&quot;</span>);</span><br><span class="line">            close(newfd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(oldfd == newfd) &#123;</span><br><span class="line">                close(ret);</span><br><span class="line">                <span class="keyword">return</span> newfd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ret == newfd) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ret &lt; newfd) &#123;</span><br><span class="line">                <span class="built_in">stack</span>[count++] = ret;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                close(ret);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;close(newfd)\n&quot;</span>);</span><br><span class="line">                close(newfd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(count) &#123;</span><br><span class="line">        close(<span class="built_in">stack</span>[--count]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r, max_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">old_rlim</span>=</span>&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    getrlimit(RLIMIT_NOFILE, &amp;old_rlim);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NOFILE limits: soft=%lld; hard=%lld\n&quot;</span>,</span><br><span class="line">                   (<span class="keyword">long</span> <span class="keyword">long</span>) old_rlim.rlim_cur, (<span class="keyword">long</span> <span class="keyword">long</span>) old_rlim.rlim_max);</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">7168</span>, <span class="number">7168</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(7168, 7168) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(7168, 7168) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(100, 100) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(100, 100) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">1</span>, <span class="number">7168</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(1, 7168) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(1, 7168) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">1</span>, <span class="number">7167</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(1, 7167) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(1, 7167) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(2, 2) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(2, 2) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((r = dup(<span class="number">0</span>))!= <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        max_fd = r;</span><br><span class="line">    &#125;</span><br><span class="line">    perror(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max fd is %d\n&quot;</span>, max_fd);</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">1</span>, <span class="number">7168</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(1, 7168) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(1, 7168) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">1</span>, <span class="number">7167</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(1, 7167) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(1, 7167) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(2, 2) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(2, 2) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>MAC OSX下的运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NOFILE limits: soft=7168; hard=9223372036854775807</span><br><span class="line">dup2_(7168, 7168) fail: : Bad file descriptor</span><br><span class="line">dup2_(100, 100) fail: : Bad file descriptor</span><br><span class="line">dup2_(1, 7168) fail: : Bad file descriptor</span><br><span class="line">dup2_(1, 7167) success return 7167</span><br><span class="line">dup2_(2, 2) success return 2</span><br><span class="line">Too many open files</span><br><span class="line">max fd is 7167</span><br><span class="line">dup2_(1, 7168) fail: : Bad file descriptor</span><br><span class="line">close(newfd)</span><br><span class="line">dup2_(1, 7167) success return 7167</span><br><span class="line">close(newfd)</span><br><span class="line">dup2_(1, 100) success return 100</span><br><span class="line">dup2_(2, 2) success return 2</span><br></pre></td></tr></table></figure>

<p>结果都符合预期</p>
]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>UNIX</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Hexo-NexT Tag 插件的使用</title>
    <url>/posts/29bfe8c9/</url>
    <content><![CDATA[<p><code>Tag Plugin</code> 是一种使 Hexo 支持特殊样式内容的方法。例如，我们无法在标准 Markdown 中显示具有自定义尺寸的图像。然后我们可以使用标签插件来解决它。 Hexo 有很多可以帮助用户的标签。 Hexo 还具有主题接口，使主题能够创建自己的标签。</p>
<span id="more"></span>

<h2 id="文本居中引用-Centered-Quote"><a href="#文本居中引用-Centered-Quote" class="headerlink" title="文本居中引用 - Centered Quote"></a>文本居中引用 - Centered Quote</h2><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% cq %&#125;因为我渺小的心灵里，容不下一个谜，一点悬而未决的东西&#123;% endcq %&#125;</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>因为我渺小的心灵里，容不下一个谜，一点悬而未决的东西</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>



<h2 id="提示块-Note"><a href="#提示块-Note" class="headerlink" title="提示块 - Note"></a>提示块 - Note</h2><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<div class="note default">
            <p>default 提示块标签</p>
          </div>

<div class="note primary">
            <p>primary 提示块标签</p>
          </div>

<div class="note success">
            <p>success 提示块标签</p>
          </div>

<div class="note info">
            <p>info 提示块标签</p>
          </div>

<div class="note warning">
            <p>warning 提示块标签</p>
          </div>

<div class="note danger">
            <p>danger 提示块标签</p>
          </div>



<p>可在主题配置文件中修改风格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Note tag (bs-callout)</span><br><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: flat</span><br><span class="line">  icons: true</span><br><span class="line">  # 圆角</span><br><span class="line">  border_radius: 3</span><br><span class="line">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span><br><span class="line">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span><br><span class="line">  light_bg_offset: 0</span><br></pre></td></tr></table></figure>



<h2 id="标签-Label"><a href="#标签-Label" class="headerlink" title="标签 - Label"></a>标签 - Label</h2><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% label default@默认 %&#125; &#123;% label primary@主要 %&#125; &#123;% label info@信息 %&#125; &#123;% label warning@警告 %&#125; &#123;% label danger@危险 %&#125; </span><br><span class="line">&#123;% label success@成功%&#125;</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<span class="label default">默认</span> <span class="label primary">主要</span> <span class="label info">信息</span> <span class="label warning">警告</span> <span class="label danger">危险</span> 
<span class="label success">成功</span>

<h2 id="选项卡-Tabs"><a href="#选项卡-Tabs" class="headerlink" title="选项卡 - Tabs"></a>选项卡 - Tabs</h2><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% tabs tab, 2 %&#125; 名字为tab，默认显示第1个选项卡，如果是-1则隐藏</span><br><span class="line">&lt;!-- tab 魏国--&gt;</span><br><span class="line">**曹操**</span><br><span class="line"></span><br><span class="line">司马懿 郭嘉 荀彧 荀攸 程昱 杨修 </span><br><span class="line"></span><br><span class="line">典韦 许褚 夏侯渊 夏侯惇 曹仁 于禁 张辽 徐晃</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab 蜀国--&gt;</span><br><span class="line">**刘备**</span><br><span class="line"></span><br><span class="line">诸葛亮 庞统 徐庶 姜维 法正 马良</span><br><span class="line"></span><br><span class="line">关羽 张飞 赵云 马超 黄忠 魏延 关兴 张苞</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab 吴国 --&gt;</span><br><span class="line">**孙权**</span><br><span class="line"></span><br><span class="line">周瑜 张昭 鲁肃 诸葛瑾 陆逊</span><br><span class="line"></span><br><span class="line">甘宁 太史慈 吕蒙 韩当 黄盖 程普  </span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab"><a href="#tab-1">魏国</a></li><li class="tab active"><a href="#tab-2">蜀国</a></li><li class="tab"><a href="#tab-3">吴国</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-1"><p><strong>曹操</strong></p>
<p>司马懿 郭嘉 荀彧 荀攸 程昱 杨修 </p>
<p>典韦 许褚 夏侯渊 夏侯惇 曹仁 于禁 张辽 徐晃</p></div><div class="tab-pane active" id="tab-2"><p><strong>刘备</strong></p>
<p>诸葛亮 庞统 徐庶 姜维 法正 马良</p>
<p>关羽 张飞 赵云 马超 黄忠 魏延 关兴 张苞</p></div><div class="tab-pane" id="tab-3"><p><strong>孙权</strong></p>
<p>周瑜 张昭 鲁肃 诸葛瑾 陆逊</p>
<p>甘宁 太史慈 吕蒙 韩当 黄盖 程普  </p></div></div></div>



<p>可在主题配置文件中修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Tabs tag</span><br><span class="line">tabs:</span><br><span class="line">  transition:</span><br><span class="line">    tabs: true</span><br><span class="line">    labels: true</span><br><span class="line">  border_radius: 3</span><br></pre></td></tr></table></figure>

<h2 id="按钮-Button"><a href="#按钮-Button" class="headerlink" title="按钮 - Button"></a>按钮 - Button</h2><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% button url, text, icon [class], [title] %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>url</code>: 本地或外部url</li>
<li><code>text</code>: 显示的文本，文本和图标至少指定一个</li>
<li><code>icon</code>: 显示的图标， FontAwesome 图标名称（开头没有’fa-‘）</li>
<li><code>[class]</code>: FontAwesome 类，可以取如下值<code>fa-fw | fa-lg | fa-2x | fa-3x | fa-4x | fa-5X</code></li>
<li><code>title</code>: 鼠标悬停时的提示信息</li>
</ul>
<p>注意：最好添加 <code>&lt;div&gt;</code> 标签，测试时没加 div，下面显示不完全，加上非常美观。</p>
<p>一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&#123;% button https://catbro666.github.io/ ,首页,home fa-fw,这是我的博客首页%&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<div><a class="btn" href="https://catbro666.github.io/ " title="这是我的博客首页">
            <i class="fa fa-home fa-fw"></i>首页
          </a></div>

<p>多个按钮的时候可以套两层div。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;text-center&quot;&gt;&lt;div&gt;&#123;% button https://catbro666.github.io/ ,首页,home fa-fw,这是我的博客首页%&#125;&#123;% button https://catbro666.github.io/archives ,归档, archive fa-lg&#125;&lt;/div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<div class="text-center"><div><a class="btn" href="https://catbro666.github.io/ " title="这是我的博客首页">
            <i class="fa fa-home fa-fw"></i>首页
          </a><a class="btn" href="https://catbro666.github.io/archives ">
            <i class="fa fa-archive fa-lg}</div></div>"></i>归档
          </a>]]></content>
      <categories>
        <category>工具向</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux TC 流量控制介绍</title>
    <url>/posts/357ad3ec/</url>
    <content><![CDATA[<div class="note primary">
            <p>前段时间在做一些测试的时候接触到了Linux tc，因为需要对数据包添加延迟，用到了tc中的netem。添加简单的延迟非常简单，像这样一条命令就搞定了：<code>$ tc qdisc add dev eth0 root netem delay 1s</code>，你甚至不需要完全理解命令中参数的含义。但是当你想做一些更加特殊的限制的时候，（比如只对某个特定的ip端口添加延迟、或者只对入站的流量添加延迟），事情就变得有些棘手了，简单的百度貌似已经满足不了要求了。你不得不了解TC中的一些基本概念，以及tc[2]命令中相关参数的含义。</p><p>本文正是带你了解这些TC中的基本概念，并通过一个实际例子，将这些概念与tc命令联系起来。</p>
          </div>

<span id="more"></span>



<h2 id="示例命令"><a href="#示例命令" class="headerlink" title="示例命令"></a>示例命令</h2><p>考虑到这是一个科普向的介绍，这里只举了一个最简单的例子，但是基本上包含了重要的概念。本文的期望是，让读者在阅读后可以完全理解下面的例子，并且知道如何根据自身的需求编写自己的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tc qdisc add dev eth0 root handle 1: prio bands 4</span><br><span class="line">sudo tc qdisc add dev eth0 parent 1:4 handle 40: netem loss 10% delay 40ms</span><br><span class="line">sudo tc filter add dev eth0 protocol ip parent 1:0 prio 4 u32 match ip dst 192.168.190.7 match ip dport 36000 0xffff flowid 1:4</span><br></pre></td></tr></table></figure>



<h2 id="TC基本概念"><a href="#TC基本概念" class="headerlink" title="TC基本概念"></a>TC基本概念</h2><h3 id="QDISCS"><a href="#QDISCS" class="headerlink" title="QDISCS"></a>QDISCS</h3><p>全称是queueing discipline，我们姑且称其为排队规则吧。它是协议栈和网络接口之间的一个缓冲层。你可以在qdisc上对数据包做一些你想做的操作，比如分类、整形、调度等。</p>
<p>qdisc分为无类（classless）qdisc和有类（classful）qdisc。无类qdisc不再内部细分类，有类qdisc可进一步包含多个分类，每个class上可以进一步包含子qdisc，子qdisc也可以是有类qdisc，这样就形成了树状的分层结构。</p>
<h3 id="CLASSES"><a href="#CLASSES" class="headerlink" title="CLASSES"></a>CLASSES</h3><p>有类qdisc可以有多个子类（class），有些qdisc预定义了子类（如prio），有些则需要用户添加类。一个类上又可以附加其他类。最末端没有子类的类称为叶子类，它上面附加了一个qdisc。当创建一个class的时候，默认会附加一个fifo qdisc，它只是一个简单的队列，不对数据包进行任何的操作。当在这个类上增加子类的时候，这个默认的qdisc被移除。你可以将这个默认的fifo qdisc替换成其他任意你想用的qdisc。</p>
<h3 id="FILTERS"><a href="#FILTERS" class="headerlink" title="FILTERS"></a>FILTERS</h3><p>过滤器，用于有类qdisc中，决定将包入队到哪个类中。每当一个包到达有子类的类时，就需要进行分类。其中一种分类的方法就是使用过滤器（另外两个是ToS和skb-&gt;priority）。所有附加到类上的过滤器会被依次调用，直到其中一个返回裁决。一个filter包含了一些条件，当一个包到达该节点时，会根据包的特征判断是否匹配。</p>
<p>以上3个是TC中最基本的3个概念，任何复杂的流量控制都是通过这个三元组递归实现的。</p>
<h2 id="层级结构"><a href="#层级结构" class="headerlink" title="层级结构"></a>层级结构</h2><p>每个接口有一个egress ‘root qdisc’，默认是pfifo_fast。每个qdisc和class都分配一个句柄handle，句柄用于在后续的配置语句中进行引用。除了egress qdisc，一个接口也可以有一个ingress qdisc，负责管制入站的流量。但是ingress qdisc相比classful qdisc其可能性是非常有限。（所以才有所谓的控发不控收，对入站流量进行控制通常需要借助ifb[6]或者imq）。</p>
<p>这些qdisc的handles有两个部分组成，一个major数和一个minor数：<code>&lt;major&gt;:&lt;minor&gt;</code>。习惯上将root qdisc命名为<code>1:</code>，等价于<code>1:0</code>。一个qdisc的minor数总是0。</p>
<p>子类需要跟它们的parent有相同的major数。major数在一个egress或ingress内必须是唯一的，minor数在一个qdisc和它的class中必须是唯一的。</p>
<p>一个典型的层级结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">          1:   root qdisc</span><br><span class="line">           |</span><br><span class="line">          1:1    child class</span><br><span class="line">        /  |  \</span><br><span class="line">       /   |   \</span><br><span class="line">      /    |    \</span><br><span class="line">      /    |    \</span><br><span class="line">   1:10  1:11  1:12   child classes</span><br><span class="line">    |      |     | </span><br><span class="line">    |     11:    |    leaf class</span><br><span class="line">    |            | </span><br><span class="line">    10:         12:   qdisc</span><br><span class="line">   /   \       /   \</span><br><span class="line">10:1  10:2   12:1  12:2   leaf classes</span><br></pre></td></tr></table></figure>



<p>内核只跟root qdisc进行通信，每当包需要入队或者出队的时候，都需要从root节点开始，最终到达叶子节点，从而决定入队到哪里，或者从哪里出队。</p>
<p>比如当一个包入队时，它可能会经过如下路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1: -&gt; 1:1 -&gt; 1:12 -&gt; 12: -&gt; 12:2</span><br></pre></td></tr></table></figure>

<p>当然也可能直接走如下路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1: -&gt; 12:2</span><br></pre></td></tr></table></figure>

<p>这种情况，就是root qdisc上的过滤器决定把包直接送到<code>12:2</code>。</p>
<span class="label warning">注意：</span>入队和出队时虽然节点的拓扑图是一样的，但是每个节点表示的含义却有所不同[4]。入队时是根据过滤器和包的特征决定走哪条路径，而出队时则取决于qdisc本身的调度算法，比如FIFO、优先级队列、SFQ的顺序调度等。



<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>前面已经提到了过滤器用于将包分类到子类，那么具体是如何对包进行分类的呢？tc支持很多类型的分类器，它们根据数据包相关的不同信息来作出决策。其中最常用的就是<strong>u32分类器</strong>，它根据数据包中的字段做出决策（例如源IP地址等）。还有比如<strong>fw分类器</strong>，根据防火墙如何标记数据包来做出决策，你可以使用iptables标记目标数据包，然后通过fw分类器进行过滤。另外还有诸如<strong>route分类器</strong>、<strong>cgroup分类器</strong>、<strong>bpf分类器</strong>等，篇幅原因不再赘述。下面仅介绍最常见的u32分类器。</p>
<h3 id="公共参数"><a href="#公共参数" class="headerlink" title="公共参数"></a>公共参数</h3><p>分类器一般接收以下几个公共的参数：</p>
<ul>
<li><p>protocol</p>
<p>分类器接受的协议，通常你只接受IP流量。必须。</p>
</li>
<li><p>parent</p>
<p>分类器附加到哪个handle上。这个handle必须是一个已经存在的类。必须。</p>
</li>
<li><p>prio|perf</p>
<p>分类器的优先级。<strong>数字越小</strong>的越先进行匹配尝试。</p>
</li>
<li><p>handle</p>
<p>这个handle对于不同的过滤器表示不同的含义。</p>
</li>
</ul>
<h3 id="u32分类器-3"><a href="#u32分类器-3" class="headerlink" title="u32分类器[3]"></a>u32分类器[3]</h3><p>u32过滤器最简单的格式是设置一组选择器对包进行匹配，匹配的包分到特定的子类中，或者执行一个action。u32分类器提供了多种不同的选择器，可以大致分成特殊选择器和通用选择器两类。</p>
<h3 id="特殊选择器"><a href="#特殊选择器" class="headerlink" title="特殊选择器"></a>特殊选择器</h3><p>常用的有ip选择器和tcp选择器。特殊选择器简化了一些常用字段的设置，可以匹配包头中的各种字段，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tc filter add dev eth0 protocol ip parent 1:0 prio 10 u32 \</span><br><span class="line">	match ip src 192.168.8.0/24 flowid 1:4</span><br></pre></td></tr></table></figure>

<p>上例匹配ip源地址在192.168.8.0/24子网的包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tc filter add dev eth0 protocol ip parent 1:0 prio 10 u32 \</span><br><span class="line">        match ip protocol 0x6 0xff \</span><br><span class="line">        match tcp dport 53 0xffff \</span><br><span class="line">        flowid 1:2</span><br></pre></td></tr></table></figure>

<p>上例匹配TCP协议（0x6）、且目的端口为53的包。</p>
<h3 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h3><p>特殊选择器总是可以改写成对应的通用选择器，通用选择器可以匹配 IP（或上层）头中的几乎任何位，不过相比特殊选择器较难编写和阅读。其语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match [ u32 | u16 | u8 ] PATTERN MASK at [OFFSET | nexthdr+OFFSET]</span><br></pre></td></tr></table></figure>

<p>其中u32|u16|u8指定pattern的长度，分别为4个字节、2个字节、1个字节。PATTERN表示匹配的包的pattern，MASK告诉过滤器匹配哪些位，at表示从包的指定偏移处开始匹配。</p>
<p>来看一个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tc filter add dev eth0 protocol ip parent 1:0 pref 10 u32 \</span><br><span class="line">	match u32 00100000 00ff0000 at 0 flowid 1:10</span><br></pre></td></tr></table></figure>

<p>选择器会匹配IP头第二个字节为0x10的包，<code>at 0</code>表示从头开始匹配，mask为<code>00ff0000</code>所以只匹配第二个字节，pattern为<code>00100000</code>即第二个字节为0x10。</p>
<p>再来看另一个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tc filter add dev eth0 protocol ip parent 1:0 pref 10 u32 \</span><br><span class="line">	match u32 00000016 0000ffff at nexthdr+0 flowid 1:10</span><br></pre></td></tr></table></figure>

<p><code>nexthdr</code>选项表示封装在IP包里的下一个头，即上层协议的头。<code>at nexthdr+0</code>表示从下一个头第一个字节开始匹配。因为mask为<code>0000ffff</code>，所以匹配发生在头的第三和第四个字节。在TCP和UDP协议中这两个字节是包的目的端口。数字是由大段格式给出的，所以pattern <code>00000016</code>转换成十进制是22。即该选择器会匹配目的端口为22的包。</p>
<h2 id="示例解析"><a href="#示例解析" class="headerlink" title="示例解析"></a>示例解析</h2><p>好了，现在我们可以回过头来看最初的那个示例了，看看这些命令到底是什么意思。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tc qdisc add dev eth0 root handle 1: prio bands 4</span><br><span class="line">sudo tc qdisc add dev eth0 parent 1:4 handle 40: netem loss 10% delay 40ms</span><br><span class="line">sudo tc filter add dev eth0 protocol ip parent 1:0 prio 4 u32 match ip dst 192.168.190.7 match ip dport 36000 0xffff flowid 1:4</span><br></pre></td></tr></table></figure>

<p>我们一行行来看，第一行在设备eth0上添加了一个root qdisc，句柄为1:，qdisc类型为prio，bands数为4。</p>
<p>prio是一个有类的qdisc。它的作用跟默认的qdisc pfifo_fast类似。pfifo_fast有三个所谓的band，不同band的流量具有不同的优先级。每个band内，则应用FIFO规则。</p>
<p>prio qdisc，默认会创建3个子类，包含纯FIFO qdisc，默认根据ToS位进行分类。你可以使用过滤器来对流量进行分类，你也可以在子类上附加其他qdisc替换默认的FIFO。</p>
<p>接下来看第二个命令，<code>parent 1:4</code>表示在子类1:4上，<code>handle 40:</code>表示句柄为40:，<code>netem</code>表示添加一个netem qdisc，<code>loss 10% delay 40ms</code>则是netem的参数，表示丢包10%、延迟40ms。netem[5]是一个用于提供网络仿真功能的无类qdisc，可以模拟延迟、丢包、包重复、包失序等各种情况。</p>
<p>第三个命令则是添加了一个过滤器，<code>parent 1:0</code>表示在根节点上添加该过滤器，<code>prio 4</code>是过滤器的优先级，如果有很多过滤器会根据优先级的值按顺序进行尝试。<code>u32</code>表示使用u32分类器。<code>match ip dst 192.168.190.7</code>表示匹配ip地址为192.168.190.7的包，<code>match ip dport 36000 0xffff</code>表示匹配目的端口为36000的包，多个选择器之间是“与”的关系，<code>flowid 1:4</code>表示将匹配的包分类到<code>1:4</code>子类中。</p>
<p>所以最终的效果是，发往192.168.190.7且目的端口为36000的包，会分类到1:4子类，添加40ms的延迟，且有10%的丢包率。其他包则还是默认的行为，即根据ToS字段分类到1:1、1:2或1:3子类中，然后根据优先级依次发送。</p>
<p>画出该例子的分层结构图，大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">          1:     root qdisc (prio)</span><br><span class="line">         / | \ \</span><br><span class="line">       /   |  \  \</span><br><span class="line">       /   |   \   \</span><br><span class="line">     1:1  1:2  1:3  1:4      classes</span><br><span class="line">      |    |    |    |</span><br><span class="line">                     40:     qdiscs</span><br><span class="line">   pfifo pfifo pfifo netem</span><br><span class="line">band  0    1    2    3</span><br></pre></td></tr></table></figure>



<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本文只介绍了tc的基本概念和简单用法。prio qdisc只对包做了一个分类，并没有进行整形。实际上，你也可以使用更复杂的带整形的qdisc，比如CBQ、HTB等，也可以增加更多的层级。你还可以在叶子节点上添加SFQ qdisc以实现会话级的带宽公平性。相信理解了TC的这些基本概念，再根据自身需求使用其他qdisc也不是什么难事了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><p><a href="https://lartc.org/howto/">lartc</a></p>
</li>
<li><p><a href="https://man7.org/linux/man-pages/man8/tc.8.html">tc(8)</a></p>
</li>
<li><p><a href="https://man7.org/linux/man-pages/man8/tc-u32.8.html">tc-u32(8)</a></p>
</li>
<li><p><a href="https://blog.csdn.net/dog250/article/details/40681809">数据包的分类和调度</a></p>
</li>
<li><p><a href="https://wiki.linuxfoundation.org/networking/netem">netem</a></p>
</li>
<li><p><a href="https://wiki.linuxfoundation.org/networking/ifb">ifb</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具向</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>TC</tag>
        <tag>流量控制</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua中如何实现类似gdb的断点调试--01最小实现</title>
    <url>/posts/f9a188a7/</url>
    <content><![CDATA[<div class="note primary">
            <p>说到Lua代码调试，最常用的方法应该就是加一堆print进行打印。print大法虽好，但其缺点也是显而易见的。比如效率低下，需要修改原有函数内部代码，在每个需要的地方添加print语句，运行一次只能获取一次信息，下次换个地方又得重新添加print语句。而且有时候，事先并不知道该去哪打印、或者打印什么内容，需要通过运行中获取的信息才能确定。</p><p>当print大法无法满足我们的需求时，就需要类似断点调试这样更高级的调试功能。本文将从零开始编写一个Lua调试器，实现类似gdb的断点调试功能。</p><p>本文代码已开源至<a href="https://github.com/catbro666/lua-debugger">Github</a>，欢迎watch/star😘。</p>
          </div>

<span id="more"></span>



<h2 id="定义模块及接口"><a href="#定义模块及接口" class="headerlink" title="定义模块及接口"></a>定义模块及接口</h2><p>首先，我们来定义模块及接口，创建一个名为<code>luadebug.lua</code>的模块，该模块是基于标准库中的debug库。为了实现最基本的断点调试功能，我们的模块提供了两个接口<code>setbreakpoint</code>和<code>removebreakpoint</code>，分别用于设置断点和删除断点。断点信息通过一个函数和一个行号指定，返回断点的id。后续可以通过这个id来删除相应断点。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env lua</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">debug</span> = <span class="built_in">require</span> <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 省略...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setbreakpoint</span><span class="params">(func, line)</span></span></span><br><span class="line">    <span class="comment">-- 省略...</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">removebreakpoint</span><span class="params">(id)</span></span></span><br><span class="line">    <span class="comment">-- 省略...</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    setbreakpoint = setbreakpoint,</span><br><span class="line">    removebreakpoint = removebreakpoint,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="维护状态的数据结构"><a href="#维护状态的数据结构" class="headerlink" title="维护状态的数据结构"></a>维护状态的数据结构</h2><p>接着，来定义维护状态的数据结构，表<code>status</code>维护了所有断点相关信息，其中的<code>bpnum</code>元素表示当前总共有多少断点，<code>bpid</code>表示当前的断点id，这个值是不断递增的，<code>bptable</code>则是保存所有断点信息的表。表<code>bptable</code>的键是断点的id，值也是一个表，保存了断点的所在的函数和行号。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 省略...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 记录断点状态</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">status</span> = &#123;&#125;</span><br><span class="line"><span class="built_in">status</span>.bpnum = <span class="number">0</span>        <span class="comment">-- 当前总断点数</span></span><br><span class="line"><span class="built_in">status</span>.bpid = <span class="number">0</span>         <span class="comment">-- 当前断点id</span></span><br><span class="line"><span class="built_in">status</span>.bptable = &#123;&#125;     <span class="comment">-- 保存断点信息的表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 省略...</span></span><br></pre></td></tr></table></figure>



<h2 id="设置断点接口"><a href="#设置断点接口" class="headerlink" title="设置断点接口"></a>设置断点接口</h2><p>接下来来定义我们的<code>setbreakpoint</code>接口。设置断点时，首先检查参数有效性，再更新断点id和断点数，然后将参数中传入的函数<code>func</code>和行号<code>line</code>保存到表<code>bptable</code>中下一个断点id的位置。如果只有一个断点（从无到有），那么还需要调用<code>debug.sethook</code>设置钩子。这是实现断点调试的核心函数之一，它使得我们有机会停在断点处。因为是最小实现，简单起见这里只设置了<code>line</code>事件。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置断点</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setbreakpoint</span><span class="params">(func, line)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(func) ~= <span class="string">&quot;function&quot;</span> <span class="keyword">or</span> <span class="built_in">type</span>(line) ~= <span class="string">&quot;number&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>                      <span class="comment">--&gt; nil表示无效断点</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">status</span>.bpid = <span class="built_in">status</span>.bpid + <span class="number">1</span></span><br><span class="line">    <span class="built_in">status</span>.bpnum = <span class="built_in">status</span>.bpnum + <span class="number">1</span></span><br><span class="line">    <span class="built_in">status</span>.bptable[<span class="built_in">status</span>.bpid] = &#123;func = func, line = line&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">status</span>.bpnum == <span class="number">1</span> <span class="keyword">then</span>           <span class="comment">-- 第一个断点</span></span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">sethook</span>(linehook, <span class="string">&quot;l&quot;</span>)    <span class="comment">-- 设置钩子</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">status</span>.bpid                  <span class="comment">--&gt; 返回断点id</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>在钩子函数中，通过<code>debug.getinfo</code>获取到闭包信息，注意这里的层次为2，因为<code>debug.getinfo()</code>函数本身的层次是0，钩子函数层次是1，断点所在的函数层次即为2。然后遍历断点表，与获取的闭包信息进行比较，如果函数和行号都匹配，说明命中断点。我们打印一行提示信息，然后调用<code>debug.debug()</code>进入交互调试模式，<code>debug.debug</code>是实现断点调试的另一个核心函数，它使得我们可以在断点处输入任意代码执行。交互调试模式一直持续，直到用户输入<code>cont</code>为止。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 钩子函数</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">linehook</span> <span class="params">(event, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> info = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>, <span class="string">&quot;nfS&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">status</span>.bptable) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> v.func == info.func <span class="keyword">and</span> v.line == line <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> prompt = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;(%s)%s %s:%d\n&quot;</span>,</span><br><span class="line">                info.namewhat, info.name, info.short_src, line)</span><br><span class="line">            <span class="built_in">io</span>.<span class="built_in">write</span>(prompt)</span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">debug</span>()</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="删除断点接口"><a href="#删除断点接口" class="headerlink" title="删除断点接口"></a>删除断点接口</h2><p>删除断点比较简单，首先检查id参数是否有效，如果无效直接返回，如果有效则将断点表中相应id位置的值置为nil即可，然后更新断点数，如果已经没有断点了，则清除钩子。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除断点</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">removebreakpoint</span><span class="params">(id)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">status</span>.bptable[id] == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">status</span>.bptable[id] = <span class="literal">nil</span></span><br><span class="line">    <span class="built_in">status</span>.bpnum = <span class="built_in">status</span>.bpnum - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">status</span>.bpnum == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">sethook</span>()                 <span class="comment">-- 清除钩子</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>至此我们的模块就编写好了，下面对这个模块进行测试。</p>
<h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><p>我们编写一个如下的测试脚本<code>test.lua</code>，定义了两个函数foo和bar，然后分别在两个函数中设置了一个断点（注意：注释和空行不是有效的断点行），然后多次调用函数并先后删除断点：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line"></span><br><span class="line">g = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> u = <span class="number">2</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">3</span></span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line">    u = u + <span class="number">1</span></span><br><span class="line">    g = g + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span> <span class="params">(n)</span></span></span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(foo, <span class="number">11</span>)      <span class="comment">-- 设置断点1</span></span><br><span class="line"><span class="keyword">local</span> id2 = setbp(bar, <span class="number">16</span>)      <span class="comment">-- 设置断点2</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">10</span>)</span><br><span class="line">bar(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">rmbp(id1)                       <span class="comment">-- 删除断点1</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">20</span>)</span><br><span class="line">bar(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">rmbp(id2)                       <span class="comment">-- 删除断点2</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">30</span>)</span><br><span class="line">bar(<span class="number">30</span>)</span><br></pre></td></tr></table></figure>



<h2 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h2><p>然后我们运行测试脚本，可以看到程序停在了foo函数的断点1处。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua test.lua</span><br><span class="line">(<span class="built_in">local</span>)foo test.lua:11</span><br><span class="line">lua_debug&gt; </span><br></pre></td></tr></table></figure>

<p>我们可以在这里打印调用栈信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua test.lua</span><br><span class="line">(<span class="built_in">local</span>)foo test.lua:11</span><br><span class="line">lua_debug&gt; <span class="built_in">print</span>(debug.traceback())</span><br><span class="line">stack traceback:</span><br><span class="line">	(debug <span class="built_in">command</span>):1: <span class="keyword">in</span> main chunk</span><br><span class="line">	[C]: <span class="keyword">in</span> <span class="keyword">function</span> <span class="string">&#x27;debug.debug&#x27;</span></span><br><span class="line">	./luadebug.lua:20: <span class="keyword">in</span> hook <span class="string">&#x27;?&#x27;</span></span><br><span class="line">	test.lua:11: <span class="keyword">in</span> <span class="built_in">local</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">	test.lua:22: <span class="keyword">in</span> main chunk</span><br><span class="line">	[C]: <span class="keyword">in</span> ?</span><br><span class="line">lua_debug&gt; </span><br></pre></td></tr></table></figure>

<p>可以看到foo函数在第4层（第1层是执行我们调试命令的main chunk，第2层是<code>debug.debug</code>函数，第3层是hook函数）。我们打印foo函数中第一个局部变量（即固定参数n）的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; <span class="built_in">print</span>(debug.getlocal(4, 1))</span><br><span class="line">n	10</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>然后打印第二个局部变量（即a）的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; <span class="built_in">print</span>(debug.getlocal(4, 2))</span><br><span class="line">a	4</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>然后我们输入<code>cont</code>继续代码的执行，碰到了bar函数的断点2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">(<span class="built_in">local</span>)bar test.lua:16</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>我们打印bar函数的参数n的值，可以看到也是10</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; <span class="built_in">print</span>(debug.getlocal(4, 1))</span><br><span class="line">n	10</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>然后我们输入<code>cont</code>继续执行代码，因为断点1已经被移除，所以再次停在了bar函数的断点2处</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">(<span class="built_in">local</span>)bar test.lua:16</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>我们再来打印下参数n的值，此时参数n的值是20</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; <span class="built_in">print</span>(debug.getlocal(4, 1))</span><br><span class="line">n	20</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>我们再次输入<code>cont</code>，因为断点2也被移除了，所以第三次调用<code>foo</code>函数和<code>bar</code>函数就没有再碰到断点，程序运行结束</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>这样一个最简单的Lua断点调试器就完成了。虽然还比较简陋，但是已经能够应付一些简单的调试了。🎉</p>
]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua中如何实现类似gdb的断点调试--02通用变量打印</title>
    <url>/posts/f6e9079c/</url>
    <content><![CDATA[<div class="note primary">
            <p>在前一篇<a href="../f9a188a7/">01最小实现</a>中，我们实现了Lua断点调试的的一个最小实现。我们编写了一个模块，提供了两个基本的接口：设置断点和删除断点。</p><p>虽然我们已经支持在断点进行变量的打印，但是需要自己指定层数以及变量索引，使用起来不是很方便。要进行upvalue打印的话，操作会更加麻烦。为了提升调试的方便性，我们决定封装一个通用的变量打印函数，可以通过变量名查找到对应变量的值进行打印。支持局部变量、upvalue以及全局的<code>_ENV</code>中的变量。</p><span id="more"></span><p>本文代码已开源至<a href="https://github.com/catbro666/lua-debugger">Github</a>，欢迎watch/star😘。</p>
          </div>

<h2 id="局部变量中查找"><a href="#局部变量中查找" class="headerlink" title="局部变量中查找"></a>局部变量中查找</h2><p>因为函数比较长，我们分几部分进行说明，该函数有三个参数：<code>name</code>为要查找的变量的名字，<code>level</code>指示在哪个层级的函数中查找，<code>isenv</code>是个标记我们稍后再提。层级的默认值为1， <span class="label warning">注意</span>将层级加上1，是为了将层次修正为包含<code>_getvavalue</code>函数自己。</p>
<p>然后遍历局部变量表，比较变量名字是不是等于<code>name</code>，如果匹配的话记录其值，并且标记一下我们已经找到。<span class="label warning">注意</span>我们找到之后并没有立马跳出循环，因为可能具有多个同名的局部变量，我们应该获取索引最大的那个。</p>
<p>循环结束之后，如果已经在局部变量中找到了<code>name</code>，就返回<code>&quot;local&quot;</code>和变量的值。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">_getvarvalue</span> <span class="params">(name, level, isenv)</span></span></span><br><span class="line">    <span class="keyword">local</span> value</span><br><span class="line">    <span class="keyword">local</span> found = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 加1将层次纠正为包括_getvarvalue自己</span></span><br><span class="line">    level = (level <span class="keyword">or</span> <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">    <span class="comment">-- 尝试局部变量</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> n, v = <span class="built_in">debug</span>.<span class="built_in">getlocal</span>(level, i)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> n == name <span class="keyword">then</span></span><br><span class="line">            value = v</span><br><span class="line">            found = <span class="literal">true</span></span><br><span class="line">            <span class="comment">-- 这里不跳出，获取具有最大索引的那个局部变量</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> found <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">&quot;local&quot;</span>, value <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="上值中查找"><a href="#上值中查找" class="headerlink" title="上值中查找"></a>上值中查找</h2><p>如果在局部变量中没有找到，我们再尝试到upvalue中进行查找。首先通过<code>getbug.getinfo</code>获取到第level层的函数，然后遍历其上值，如果找到匹配的变量就返回<code>&quot;upvalue&quot;</code>和变量值。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">_getvarvalue</span> <span class="params">(name, level, isenv)</span></span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 尝试非局部变量</span></span><br><span class="line">    <span class="keyword">local</span> func = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(level, <span class="string">&quot;f&quot;</span>).func</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> n, v = <span class="built_in">debug</span>.<span class="built_in">getupvalue</span>(func, i)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> n == name <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">&quot;upvalue&quot;</span>, v <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="ENV表中查找"><a href="#ENV表中查找" class="headerlink" title="_ENV表中查找"></a>_ENV表中查找</h2><p>如果在普通的上值中还是没有找到，我们就去<code>_ENV</code>表中查找。<code>isenv</code>标志表示当前<code>name</code>是否就是<code>&quot;_ENV&quot;</code>，是用来防止无限循环调用的，第一次调用的时候肯定不是。然后将<code>&quot;_ENV&quot;</code>作为<code>name</code>递归调用<code>_getvarvalue</code>。因为多了一次函数调用，第二次调用的时候level又会自动加1。接下来还是先后在局部变量和上值中查找，找到了就返回类型和变量值。没有找到的话，返回<code>&quot;noenv&quot;</code>。</p>
<p>然后返回到外层的<code>_getvarvalue</code>，判断第二个返回值是否为真，如果是说明找到了<code>_ENV</code>表，就从<code>_ENV</code>表中获取名为name的值，否则直接返回<code>&quot;noenv&quot;</code>。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">_getvarvalue</span> <span class="params">(name, level, isenv)</span></span></span><br><span class="line">	<span class="comment">-- 省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> isenv <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">&quot;noenv&quot;</span> <span class="keyword">end</span>	<span class="comment">-- 避免无限循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 没找到，从环境中获取</span></span><br><span class="line">    <span class="keyword">local</span> _, env = _getvarvalue(<span class="string">&quot;_ENV&quot;</span>, level, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> env <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;global&quot;</span>, env[name]</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;noenv&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="包装函数"><a href="#包装函数" class="headerlink" title="包装函数"></a>包装函数</h2><p><code>_getvarvalue</code>函数已经定义好了，我们再定义一个包装函数<code>printvarvalue</code>。如果第二个返回值为真，表示找到了变量，就打印变量类型及结果，否则提示未找到。</p>
<span class="label warning">注意到</span>我们这里将`level`层次数加了4，目的是跟`_getvarvalue`函数中类似，也是为了修正层次数以包含`printvarvalue`函数自身以及其上层的`debug mainchunk`、`debug.debug`以及钩子函数。这样当`level`参数为1时就表示断点所在的函数。同样地，如果level不指定默认为1，即断点所在函数。2表示断点所在函数上一层，以此类推。当然如果你有特殊需求，你也可以指定层次为0，查看hook函数的情况。

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 包装 _getvarvalue, 打印结果</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">printvarvalue</span> <span class="params">(name, level)</span></span></span><br><span class="line">    <span class="comment">-- level默认值1</span></span><br><span class="line">    <span class="comment">-- 加4，将层次纠正为包含 printvarvalue, debug mainchunk, debug.debug和hook</span></span><br><span class="line">    level = (level <span class="keyword">or</span> <span class="number">1</span>) + <span class="number">4</span></span><br><span class="line">    <span class="keyword">local</span> where, value = _getvarvalue(name, level)</span><br><span class="line">    <span class="keyword">if</span> value <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(where, value)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(name, <span class="string">&quot;not found&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>最后将<code>printvarvalue</code>函数作为模块的函数输出。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    setbreakpoint = setbreakpoint,</span><br><span class="line">    removebreakpoint = removebreakpoint,</span><br><span class="line">    printvarvalue = printvarvalue,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><p>OK，调试库我们已经改好了，接下来将我们之前的测试脚本<code>test.lua</code>稍做修改。在开头添加如下一行：</p>
<p><code>pv = luadebug.printvarvalue</code></p>
<p>为了方便在断点内部调用，我们将其写到全局变量里了。然后调整下断点的行号，换一下断点删除的顺序，其他内容保持不变。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> luadebug = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = luadebug.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = luadebug.removebreakpoint</span><br><span class="line">pv = luadebug.printvarvalue		<span class="comment">-- 增加这一行</span></span><br><span class="line"></span><br><span class="line">g = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> u = <span class="number">2</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">3</span></span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line">    u = u + <span class="number">1</span></span><br><span class="line">    g = g + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span> <span class="params">(n)</span></span></span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(foo, <span class="number">12</span>)		<span class="comment">-- 行号调整</span></span><br><span class="line"><span class="keyword">local</span> id2 = setbp(bar, <span class="number">17</span>)		<span class="comment">-- 行号调整</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">10</span>)</span><br><span class="line">bar(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">rmbp(id2)						<span class="comment">-- 先删除断点2</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">20</span>)</span><br><span class="line">bar(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">rmbp(id1)						<span class="comment">-- 再删除断点1</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">30</span>)</span><br><span class="line">bar(<span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<h2 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h2><p>接下来，让我们来测试一把。可以看到无论是局部变量、upvalue、还是全局<code>_ENV</code>表中的变量，都可以很方便地获取值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua test.lua</span><br><span class="line">(<span class="built_in">local</span>)foo test.lua:12</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="built_in">local</span>	4</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;u&quot;</span>)</span><br><span class="line">upvalue	2</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">global	1</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">x	not found</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>第二次停到foo函数断点处，<code>u</code>和<code>g</code>都已经加1。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">(<span class="built_in">local</span>)bar test.lua:17</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">(<span class="built_in">local</span>)foo test.lua:12</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="built_in">local</span>	4</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;u&quot;</span>)</span><br><span class="line">upvalue	3</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">global	2</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>我们尝试显式指定层数，结果一样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; pv(<span class="string">&quot;a&quot;</span>, 1)</span><br><span class="line"><span class="built_in">local</span>	4</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;u&quot;</span>, 1)</span><br><span class="line">upvalue	3</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;g&quot;</span>, 1)</span><br><span class="line">global	2</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>我们再尝试打印上一层的变量（即main chunk），结果都符合预期。变量a是foo里的局部变量应该找不到，变量u在main chunk中是局部变量，全局变量g则没啥区别。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; pv(<span class="string">&quot;a&quot;</span>, 2)</span><br><span class="line">a	not found</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;u&quot;</span>, 2)</span><br><span class="line"><span class="built_in">local</span>	3</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;g&quot;</span>, 2)</span><br><span class="line">global	2</span><br></pre></td></tr></table></figure>

<p>OK，大功告成！</p>
]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua中如何实现类似gdb的断点调试--03通用变量修改及调用栈回溯</title>
    <url>/posts/a05a2f5f/</url>
    <content><![CDATA[<div class="note primary">
            <p>在前面两篇<a href="../f9a188a7/">01最小实现</a>及<a href="../f6e9079c">02通用变量打印</a>中，我们已经实现了设置断点、删除断点及通用变量打印接口。</p><p>本篇将继续新增两个辅助的调试接口：调用栈回溯打印接口、通用变量设置接口。前者打印调用栈的回溯信息，后者可以方便地修改变量的值，支持局部变量、upvalue以及全局的<code>_ENV</code>中的变量。</p><span id="more"></span><p>本文代码已开源至<a href="https://github.com/catbro666/lua-debugger">Github</a>，欢迎watch/star😘。</p>
          </div>

<h2 id="调用栈打印函数"><a href="#调用栈打印函数" class="headerlink" title="调用栈打印函数"></a>调用栈打印函数</h2><p>我们首先来实现调用栈回溯打印接口<code>printtraceback()</code>，这个接口比较简单，只是简单地包装了一下<code>debug.traceback()</code>，对层级进行了一个修正，就不多介绍了。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 打印调用栈的一个回溯</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">printtraceback</span><span class="params">(level)</span></span></span><br><span class="line">    <span class="comment">-- 层次的默认值为1</span></span><br><span class="line">    <span class="comment">-- 加上4是为了修正层次数以包含printtraceback, debug mainchunk, debug.debug, hook</span></span><br><span class="line">    level = (level <span class="keyword">or</span> <span class="number">1</span>) + <span class="number">4</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">debug</span>.<span class="built_in">traceback</span>(<span class="literal">nil</span>, level))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="通用变量值修改函数"><a href="#通用变量值修改函数" class="headerlink" title="通用变量值修改函数"></a>通用变量值修改函数</h2><p>接着来实现通用的变量值修改函数<code>_setvarvalue()</code>，这个函数的结构跟<code>_getvarvalue()</code>类似，依次在局部变量、上值和<code>_ENV</code>表中查找，只不过找到之后会修改相应的值。函数有三个参数，<code>name</code>为要修改的变量的名字，<code>value</code>是修改的目标值，<code>level</code>指示在哪个层级的函数中查找，我们同样分成几部分来看。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">_setvarvalue</span> <span class="params">(name, value, level)</span></span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="局部变量中查找"><a href="#局部变量中查找" class="headerlink" title="局部变量中查找"></a>局部变量中查找</h2><p>同样地，先处理层级，层级的默认值为1， 将层级加上1是为了将层次修正为包含<code>_setvavalue</code>函数自己。</p>
<p>然后遍历局部变量表，查找是否有名字为<code>name</code>的变量，如果找到的话记录其索引。<span class="label warning">注意</span>我们找到之后并没有立马跳出循环，因为可能具有多个同名的局部变量，我们应该获取索引最大的那个。</p>
<p>循环结束之后，如果已经在局部变量中找到了<code>name</code>，就修改该变量的值为<code>value</code>，然后返回<code>&quot;local&quot;</code>，指示修改的是局部变量。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">_setvarvalue</span> <span class="params">(name, value, level)</span></span></span><br><span class="line">    <span class="keyword">local</span> index</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 加1是为了将层次修正了包含_setvarvalue自身</span></span><br><span class="line">    level = (level <span class="keyword">or</span> <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">    <span class="comment">-- 在局部变量中查找</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> n, v = <span class="built_in">debug</span>.<span class="built_in">getlocal</span>(level, i)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> n == name <span class="keyword">then</span></span><br><span class="line">            index = i</span><br><span class="line">            <span class="comment">-- 只更新索引值，并不退出循环</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> index <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">setlocal</span>(level, index, value)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;local&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="上值中查找"><a href="#上值中查找" class="headerlink" title="上值中查找"></a>上值中查找</h2><p>如果在局部变量中没有找到，我们再尝试到upvalue中进行查找。首先通过<code>getbug.getinfo</code>获取到第level层的函数，然后遍历其上值，如果找到匹配的变量就修改其值为<code>value</code>，然后返回<code>&quot;upvalue&quot;</code>以指示修改的是上值。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">_setvarvalue</span> <span class="params">(name, value, level)</span></span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">local</span> func = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(level, <span class="string">&quot;f&quot;</span>).func</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> n, v = <span class="built_in">debug</span>.<span class="built_in">getupvalue</span>(func, i)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> n == name <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">setupvalue</span>(func, i, value)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;upvalue&quot;</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="ENV表中查找"><a href="#ENV表中查找" class="headerlink" title="_ENV表中查找"></a>_ENV表中查找</h2><p>如果在普通的上值中还是没有找到，我们就去<code>_ENV</code>表中查找。首先调用<code>_getvarvalue</code>获取到<code>_ENV</code>表，注意这里的<code>isenv</code>标志为<code>true</code>。如果如果找到了<code>_ENV</code>表且表中存在名为<code>name</code>的变量，就修改其值为<code>value</code>，然后返回<code>&quot;global&quot;</code>以指示是修改的<code>_ENV</code>表中的值。如果没有<code>_ENV</code>表或表中不存在要找的变量，就返回<code>nil</code>。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">_setvarvalue</span> <span class="params">(name, value, level)</span></span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">local</span> _, env = _getvarvalue(<span class="string">&quot;_ENV&quot;</span>, level, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> env <span class="keyword">and</span> env[name] <span class="keyword">then</span></span><br><span class="line">        env[name] = value</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;global&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="包装函数"><a href="#包装函数" class="headerlink" title="包装函数"></a>包装函数</h2><p>接下来我们同样再定义一个包装函数，对层次数<code>level</code>进行修正以包含<code>setvarvalue</code>函数自身以及其上层的<code>debug mainchunk</code>、<code>debug.debug</code>以及钩子函数。</p>
<p>然后对返回值进行检查，如果返回值为真，说明修改变量值成功，就打印变量类型，否则提示未找到。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setvarvalue</span> <span class="params">(name, value, level)</span></span></span><br><span class="line">    <span class="comment">-- level 默认值为1</span></span><br><span class="line">    <span class="comment">-- 加4是为了将层次纠正为包含 settvarvalue, debug mainchunk, debug.debug和hook</span></span><br><span class="line">    level = (level <span class="keyword">or</span> <span class="number">1</span>) + <span class="number">4</span></span><br><span class="line">    <span class="keyword">local</span> where = _setvarvalue(name, value, level)</span><br><span class="line">    <span class="keyword">if</span> where <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(where, name)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(name, <span class="string">&quot;not found&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>接口定义好了，让我们把这两个接口也添加到返回到表中。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line">    printtraceback = printtraceback,</span><br><span class="line">    setvarvalue = setvarvalue,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><p>接下来编写一个测试脚本<code>test.lua</code>以对我们新添加的接口进行测试。脚本很简单，就不多做解释了。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line">pv = ldb.printvarvalue</span><br><span class="line">sv = ldb.setvarvalue</span><br><span class="line">ptb = ldb.printtraceback</span><br><span class="line"></span><br><span class="line">g = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> u = <span class="number">2</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">3</span></span><br><span class="line">    u = u</span><br><span class="line">    g = g</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(foo, <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">foo(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">rmbp(id1)</span><br></pre></td></tr></table></figure>



<h2 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h2><p>我们运行测试脚本，首先调用堆栈打印函数，默认是打印从断点所在函数开始的堆栈。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua test.lua</span><br><span class="line">(<span class="built_in">local</span>)foo test.lua:14</span><br><span class="line">lua_debug&gt; ptb()</span><br><span class="line">stack traceback:</span><br><span class="line">	test.lua:14: <span class="keyword">in</span> <span class="built_in">local</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">	test.lua:21: <span class="keyword">in</span> main chunk</span><br><span class="line">	[C]: <span class="keyword">in</span> ?</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>我们显式指定层数试一下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; ptb(2)</span><br><span class="line">stack traceback:</span><br><span class="line">	test.lua:21: <span class="keyword">in</span> main chunk</span><br><span class="line">	[C]: <span class="keyword">in</span> ?</span><br><span class="line">lua_debug&gt; ptb(0)</span><br><span class="line">stack traceback:</span><br><span class="line">	./luadebug.lua:20: <span class="keyword">in</span> hook <span class="string">&#x27;?&#x27;</span></span><br><span class="line">	test.lua:14: <span class="keyword">in</span> <span class="built_in">local</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">	test.lua:21: <span class="keyword">in</span> main chunk</span><br><span class="line">	[C]: <span class="keyword">in</span> ?</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>没有问题，层数为2的时候少打印了一层，为0的时候则多打了一层。</p>
<p>我们再来测试下变量值修改函数，先看来变量原来的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; pv(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="built_in">local</span>	3</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;u&quot;</span>)</span><br><span class="line">upvalue	2</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">global	1</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>然后修改变量的值，我们把这三个变量值都改成了6</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; sv(<span class="string">&quot;a&quot;</span>, 6)</span><br><span class="line"><span class="built_in">local</span>	a</span><br><span class="line">lua_debug&gt; sv(<span class="string">&quot;u&quot;</span>, 6)</span><br><span class="line">upvalue	u</span><br><span class="line">lua_debug&gt; sv(<span class="string">&quot;g&quot;</span>, 6)</span><br><span class="line">global	g</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>然后再打印下值检查下结果，可以看到都修改成功了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; pv(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="built_in">local</span>	6</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;u&quot;</span>)</span><br><span class="line">upvalue	6</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">global	6</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>我们再试试显式指定层级为2，将变量值再改为8</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; sv(<span class="string">&quot;a&quot;</span>, 8, 2)</span><br><span class="line">a	not found</span><br><span class="line">lua_debug&gt; sv(<span class="string">&quot;u&quot;</span>, 8, 2)</span><br><span class="line"><span class="built_in">local</span>	u</span><br><span class="line">lua_debug&gt; sv(<span class="string">&quot;g&quot;</span>, 8, 2)</span><br><span class="line">global	g</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="built_in">local</span>	6</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;u&quot;</span>)</span><br><span class="line">upvalue	8</span><br><span class="line">lua_debug&gt; pv(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">global	8</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>变量a因为是函数foo的局部变量，所以外层看不到。变量u在main chunk中是属于局部变量，而变量g则还是全局变量。修改之后变量a的结果没有变，其他两个都改成了8。</p>
<p>Well done！</p>
]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua中如何实现类似gdb的断点调试--04优化钩子事件处理</title>
    <url>/posts/c1ecd715/</url>
    <content><![CDATA[<div class="note primary">
            <p>在第一篇的<a href="../f9a188a7/">01最小实现</a>中，我们实现了一个断点调试的最小实现，在设置钩子函数时只加了line事件，显然这会对性能有很大的影响。而后来两篇<a href="../f6e9079c">02通用变量打印</a>和<a href="../a05a2f5f">03通用变量修改及调用栈回溯</a>则是提供了一些辅助的调试接口，并没有对钩子函数进行修改。</p><p>我们本篇将在钩子中引入call和return事件的处理，尝试对性能进行优化。</p><span id="more"></span><p>源码已经上传<a href="https://github.com/catbro666/lua-debugger">Github</a>，欢迎watch/star😘。</p>
          </div>



<h2 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h2><p>当前的实现因为只加了line事件，执行每一行代码都会执行钩子函数去查看是否有断点，这是没有必要的。我们可以在call事件时检查当前函数是否有断点，只有当有断点的时候才加入line事件。那我们什么时候去掉line事件呢？是不是遇到return事件就去掉呢？</p>
<h3 id="考虑如下场景"><a href="#考虑如下场景" class="headerlink" title="考虑如下场景"></a>考虑如下场景</h3><p>考虑如下场景：假设f1调用f2，f2又调用f3。f1中有断点，f2没有断点，f3有断点。如果遇到return就去掉line事件，那么从f2返回到f1之后，就无法再停到f1后面的断点上了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b             b</span><br><span class="line">f1 --&gt; f2 --&gt; f3</span><br><span class="line">   &lt;--    &lt;--</span><br></pre></td></tr></table></figure>

<h3 id="正确的做法"><a href="#正确的做法" class="headerlink" title="正确的做法"></a>正确的做法</h3><p>所以正确的做法应该是：call事件时，根据被调函数是否有断点，决定是否加line事件；return事件时，则根据主调函数是否有断点，决定是否加line事件。那么return时如何获取到主调函数的信息呢？我们就需要在call的时候保存函数的相关信息，组成一个链表。call的时候在尾部增加一个节点，return的时候则去掉一个节点。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>首先，在status数据结构中增加3个成员，<code>stackinfos</code>相当于我们前面提到的链表（只不过这里以数组的形式实现），维护了调用栈中每个函数的信息，记录其中是否有断点，<code>stackdepth</code>记录了链表的长度，或者说栈的深度。<code>funcinfos</code>用于缓存一些函数调试信息，不用每次都调用<code>debug.getinfo</code>去获取。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">status</span>.stackinfos = &#123;&#125;  <span class="comment">-- table for saving stack infos</span></span><br><span class="line"><span class="built_in">status</span>.stackdepth = <span class="number">0</span>   <span class="comment">-- the depth of stack</span></span><br><span class="line"><span class="built_in">status</span>.funcinfos = &#123;&#125;   <span class="comment">-- table for caching func infos</span></span><br></pre></td></tr></table></figure>



<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>我们本篇最主要的改动是钩子函数，除了line事件，我们还增加了call（或tail call）事件和return（或tail return）事件的处理。为了代码的简洁，用局部变量s来表示<code>status</code>。接下来我们分别来看这三个部分。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span> <span class="params">(event, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail call&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">elseif</span> event == <span class="string">&quot;return&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail return&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">elseif</span> event == <span class="string">&quot;line&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="call事件"><a href="#call事件" class="headerlink" title="call事件"></a>call事件</h2><p>如果是call事件（或tail call事件），那么先获取当前函数，查看是否在断点表中有断点。</p>
<p>如果有则在<code>s.stackinfos</code>表尾部插入一个元素，其中<code>hasbreak</code>字段为<code>true</code>指示该函数有断点。注意，这里我们对<code>tail call</code>进行了一个优化，直接覆盖上一层的节点，在递归尾调用时可以防止空间无限膨胀。（Lua5.1上因为没有tail call就无能为力了：）。然后重新设置钩子函数的事件，将call、return和line事件全加上了。</p>
<p>如果当前函数没有断点，同样在<code>s.stackinfos</code>表尾部插入一个节点，不过其中<code>hasbreak</code>字段为<code>false</code>指示该层没有断点。在设置的钩子事件中，则只保留了<code>cr</code>，将line事件移除了。这样就只有断点所在的函数内才会触发line事件，可以大幅提升性能。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span> <span class="params">(event, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail call&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> func = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>, <span class="string">&quot;f&quot;</span>).func</span><br><span class="line">        <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">pairs</span>(s.bptable) <span class="keyword">do</span></span><br><span class="line">            <span class="comment">-- 当前函数中有断点</span></span><br><span class="line">            <span class="keyword">if</span> v.func == func <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">then</span></span><br><span class="line">                    s.stackdepth = s.stackdepth + <span class="number">1</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                s.stackinfos[s.stackdepth] =</span><br><span class="line">                    &#123;func = func, hasbreak = <span class="literal">true</span>&#125;</span><br><span class="line">                <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;crl&quot;</span>)  <span class="comment">-- 添加&quot;line&quot;事件</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">-- 当前函数中没有断点</span></span><br><span class="line">        <span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">then</span></span><br><span class="line">            s.stackdepth = s.stackdepth + <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        s.stackinfos[s.stackdepth] = &#123;func = func, hasbreak = <span class="literal">false</span>&#125;</span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;cr&quot;</span>)   <span class="comment">-- 移除&quot;line&quot;事件</span></span><br><span class="line">    <span class="keyword">elseif</span> event == <span class="string">&quot;return&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail return&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="return事件"><a href="#return事件" class="headerlink" title="return事件"></a>return事件</h2><p>接下来，我们来看return事件的处理。它首先删除<code>s.stackinfos</code>表尾部的节点，然后检查前一个节点的函数是否有断点，如果有则恢复line事件，否则移除line事件。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span> <span class="params">(event, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail call&quot;</span> <span class="keyword">then</span></span><br><span class="line">    	<span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">elseif</span> event == <span class="string">&quot;return&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail return&quot;</span> <span class="keyword">then</span></span><br><span class="line">        s.stackinfos[s.stackdepth] = <span class="literal">nil</span></span><br><span class="line">        s.stackdepth = s.stackdepth - <span class="number">1</span></span><br><span class="line">        <span class="comment">-- 如果上一层的函数有断点</span></span><br><span class="line">        <span class="keyword">if</span> s.stackdepth &gt; <span class="number">0</span> <span class="keyword">and</span> s.stackinfos[s.stackdepth].hasbreak <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;crl&quot;</span>)  <span class="comment">-- 恢复&quot;line&quot;事件</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;cr&quot;</span>)   <span class="comment">-- 移除&quot;line&quot;事件</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> event == <span class="string">&quot;line&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="line事件"><a href="#line事件" class="headerlink" title="line事件"></a>line事件</h2><p>最后一部分是line事件的处理，跟之前没有太大的变化。它遍历断点表，如果匹配到断点则打印提示信息，然后进入用户交互模式。不过这里也做了一个小优化，将<code>debug.getinfo</code>获取的函数信息缓存到了<code>status.funcinfos</code>中，下一次就可以直接从缓存中获取到该函数的信息。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span> <span class="params">(event, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail call&quot;</span> <span class="keyword">then</span></span><br><span class="line">    	<span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">elseif</span> event == <span class="string">&quot;line&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">pairs</span>(s.bptable) <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> v.func == s.stackinfos[s.stackdepth].func</span><br><span class="line">                <span class="keyword">and</span> v.line == line <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> s.funcinfos[v.func] <span class="keyword">then</span></span><br><span class="line">                    s.funcinfos[v.func] = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>, <span class="string">&quot;nS&quot;</span>)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">local</span> info = s.funcinfos[v.func]</span><br><span class="line">                <span class="keyword">local</span> prompt = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s (%s)%s %s:%d\n&quot;</span>,</span><br><span class="line">                    info.what, info.namewhat, info.name, info.short_src, line)</span><br><span class="line">                <span class="built_in">io</span>.<span class="built_in">write</span>(prompt)</span><br><span class="line">                <span class="built_in">debug</span>.<span class="built_in">debug</span>()</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="初始事件设置"><a href="#初始事件设置" class="headerlink" title="初始事件设置"></a>初始事件设置</h2><p>hook函数已经修改好了，我们再调整一下<code>setbreakpoint</code>函数中第一次设置钩子时的行为。初始只设置call事件。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setbreakpoint</span><span class="params">(func, line)</span></span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">if</span> s.bpnum == <span class="number">1</span> <span class="keyword">then</span>                <span class="comment">-- 只有一个断点</span></span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;c&quot;</span>)        <span class="comment">-- 设置call事件</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> s.bpid</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>我们假设代码执行的总行数为<code>L</code>，断点数<code>N=n*b</code>，其中<code>n</code>为有断点的函数个数，<code>b</code>为平均每个函数的断点数，断点所在函数平均行数为<code>l</code>，断点所在函数平均调用次数为<code>c</code>，总的函数调用次数<code>C</code>。</p>
<p>那么优化前复杂度为<code>O(L*N)</code>，优化后的复杂度为<code>O(C*N+c*l*N)</code></p>
<p>一般情况下<code>(C+c*I) &lt;&lt; L</code>，因为右边<code>L</code>代码执行总行数可以分成有断点的函数执行总行数+没有断点的函数执行总行数，而左边的<code>c*I</code>就是有断点的函数执行总行数，<code>C</code>为函数调用总次数。正常情况下函数调用总次数肯定是远远小于没有断点的函数执行的总行数的，有断点的函数执行总行数也是远远小于没有断点的函数执行总行数的。</p>
<h2 id="测试断点是否正常"><a href="#测试断点是否正常" class="headerlink" title="测试断点是否正常"></a>测试断点是否正常</h2><p>我们编写如下测试脚本，来测试下之前提到的那种场景：f1调用f2，f2又调用f3，f1中加了两个断点，在调用f2前后各有一个，f2没有断点，f3有断点。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line">pv = ldb.printvarvalue</span><br><span class="line">sv = ldb.setvarvalue</span><br><span class="line">ptb = ldb.printtraceback</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">f3</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line">    f3()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line">    f2()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- f3中加断点</span></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(f3, <span class="number">9</span>)</span><br><span class="line"><span class="comment">-- f2不加断点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- f1中在调用f2前后各加一个断点</span></span><br><span class="line"><span class="keyword">local</span> id2 = setbp(f1, <span class="number">16</span>)</span><br><span class="line"><span class="keyword">local</span> id3 = setbp(f1, <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line">f1()</span><br><span class="line"></span><br><span class="line">rmbp(id1)</span><br><span class="line">rmbp(id2)</span><br><span class="line">rmbp(id3)</span><br></pre></td></tr></table></figure>

<p>然后来运行测试脚本验证一下。首先停在了f1函数第16行（调用f2之前），然后<code>cont</code>继续执行，停在了函数f3的断点处，再次<code>cont</code>继续，函数停在了f1函数第17行（调用f2之后）。可见断点能正常工作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua test.lua</span><br><span class="line">Lua (<span class="built_in">local</span>)f1 test.lua:16</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (upvalue)f3 test.lua:9</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)f1 test.lua:17</span><br><span class="line">lua_debug&gt; cont</span><br></pre></td></tr></table></figure>



<h2 id="测试tail-call优化"><a href="#测试tail-call优化" class="headerlink" title="测试tail call优化"></a>测试tail call优化</h2><p>我们再来测试下tail call的优化，编写如下测试脚本。我们定义了一个尾调用递归的函数foo，然后再其他函数上随便加了一个断点（为了设置hook）。然后我们foo函数一直递归调用。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line">pv = ldb.printvarvalue</span><br><span class="line">sv = ldb.setvarvalue</span><br><span class="line">ptb = ldb.printtraceback</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> foo(n<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- add a break in bar</span></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(bar, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">foo(<span class="number">100000000000</span>)</span><br><span class="line"></span><br><span class="line">rmbp(id1)</span><br></pre></td></tr></table></figure>

<h3 id="Lua5-1测试"><a href="#Lua5-1测试" class="headerlink" title="Lua5.1测试"></a>Lua5.1测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua5.1 test2.lua</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用Lua5.1运行上面的测试脚本，内存占用一直在飙升，我只测试了一小会，就已经飙到8G了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/c1ecd715/lua5.1-call.jpg" alt="lua5.1-call" loading="lazy"></p>
<h3 id="Lua5-3测试"><a href="#Lua5-3测试" class="headerlink" title="Lua5.3测试"></a>Lua5.3测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua5.3 test2.lua</span><br></pre></td></tr></table></figure>

<p>用Lua5.3运行上面的测试脚本，因为有尾调用的优化，内存占用一直保持在720KB。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/c1ecd715/lua5.3-tail-call.jpg" alt="lua5.3-tail-call" loading="lazy"></p>
<p>细心的同学可能已经发现了，我们的hook函数中call事件和line都需要对整个断点表进行遍历，这其中其实是存在着一些冗余的。因为篇幅原因，我们放到下回分解。</p>
]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua中如何实现类似gdb的断点调试--05优化断点信息数据结构</title>
    <url>/posts/2e777dd3/</url>
    <content><![CDATA[<div class="note primary">
            <p>在上一篇<a href="../c1ecd715/">04优化钩子事件处理</a>中，我们在钩子函数中引入了call和return事件的处理，对性能进行了优化。</p><p>细心的同学可能已经发现了，我们的hook函数中call事件和line都需要对整个断点表进行遍历，这其中其实是存在着一些冗余的。因为call事件只关心函数是否有断点，而line事件则只关心本函数内有哪些断点。所以我们可以想办法优化一下断点信息的数据结构，进一步提升性能。</p><span id="more"></span><p>源码已经上传<a href="https://github.com/catbro666/lua-debugger">Github</a>，欢迎watch/star😘。</p>
          </div>



<h2 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h2><p>原来的断点表<code>status.bptable</code>是以断点id为键的数组，我们需要通过断点id来快速删除断点，所以<code>status.bptable</code>表还是保留。</p>
<p>但是在钩子函数中，我们并不关心断点的id，相反我们关心断点属于哪个函数。只有当程序执行到有断点的函数时，我们才需要处理line事件。所以，很自然地可以想到，我们应该新增一个以函数为键的断点表。我们把这个新表定义如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">status</span>.funcbpt = &#123;&#125;     <span class="comment">-- 以函数为键的断点表</span></span><br></pre></td></tr></table></figure>

<p>那么新表的值应该是什么呢？因为一个函数中可能有多个断点，而在line事件中我们又需要比较当前行是否是断点行，所以我们把新表<code>status.funcbpt</code>的值也设计成一个表，该表的键是断点行号，值为断点id。因为断点行号并不连续，所以<code>status.funcbpt[func]</code>表不是一个序列，为了快速获取断点个数，我们在表中额外加了一个特殊的<code>num</code>字段保存该函数中的断点个数。</p>
<p>这样我们就可以在call事件中快速地判断当前函数是否有断点，在line事件中快速地判断当前行是否是断点行。</p>
<p>另外，之所以将断点id作为<code>status.funcbpt[func]</code>表的值，则是为了保留从<code>status.funcbpt</code>访问<code>status.bptable</code>中对应断点的能力（<code>status.bptable</code>表中元素因为包含了<code>func</code>和<code>line</code>字段，所以也可以访问到<code>status.funcbpt</code>对应断点）。</p>
<p>这么说可能不直观，我们来看个例子。</p>
<p>假设我们的<code>bptable</code>表中func函数添加了两个断点如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">bptable[<span class="number">1</span>] = &#123;func = func, line = <span class="number">10</span>&#125;</span><br><span class="line">bptable[<span class="number">2</span>] = &#123;func = func, line = <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>

<p>对应的在<code>funcbpt</code>表中的操作如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">funcbpt[func] = &#123;&#125;          <span class="comment">-- 构造表</span></span><br><span class="line">funcbpt[func][<span class="number">10</span>] = <span class="number">1</span>	    <span class="comment">-- 函数func，行号10，断点id为1</span></span><br><span class="line">funcbpt[func].num = <span class="number">1</span>       <span class="comment">-- 该函数第一个断点</span></span><br><span class="line">funcbpt[func][<span class="number">20</span>] = <span class="number">2</span>       <span class="comment">-- 函数func，行号20，断点id为2</span></span><br><span class="line">funcbpt[func].num = funcbpt[func].num + <span class="number">1</span>	<span class="comment">-- 断点个数+1</span></span><br></pre></td></tr></table></figure>



<p>OK，理清楚了<code>status.funcbpt</code>的数据结构设计，实现起来就简单了。</p>
<h2 id="添加断点"><a href="#添加断点" class="headerlink" title="添加断点"></a>添加断点</h2><p>我们先从设置断点函数入手修改代码。新增的代码已经用中括号括起来了，有两个部分。其中前面的部分先根据函数和行号检查是否已经设置过同一个断点了，如果是的话，直接返回之前设置的断点id。</p>
<p>后面的部分，在断点保存到<code>s.bptable</code>表之后，也要保存到我们新增的表<code>s.funcbpt</code>表中，行号line作为键，新断点id作为值。如果设置的是该函数的第一个断点，需要先进行表的初始化构造，所以操作稍有不同。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setbreakpoint</span><span class="params">(func, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(func) ~= <span class="string">&quot;function&quot;</span> <span class="keyword">or</span> <span class="built_in">type</span>(line) ~= <span class="string">&quot;number&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="string">[[ 新增代码开始 ]]</span></span><br><span class="line">    <span class="comment">-- 已经设置了相同的断点</span></span><br><span class="line">    <span class="keyword">if</span> s.funcbpt[func] <span class="keyword">and</span> s.funcbpt[func][line] <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> s.funcbpt[func][line]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="string">[[ 新增代码结束 ]]</span></span><br><span class="line">    s.bpid = s.bpid + <span class="number">1</span></span><br><span class="line">    s.bpnum = s.bpnum + <span class="number">1</span></span><br><span class="line">    s.bptable[s.bpid] = &#123;func = func, line = line&#125;</span><br><span class="line">    <span class="string">[[ 新增代码开始 ]]</span></span><br><span class="line">    <span class="keyword">if</span> s.funcbpt[func] <span class="keyword">then</span>             <span class="comment">-- 该函数已经有断点了</span></span><br><span class="line">        s.funcbpt[func].num = s.funcbpt[func].num + <span class="number">1</span></span><br><span class="line">        s.funcbpt[func][line] = s.bpid</span><br><span class="line">    <span class="keyword">else</span>                                <span class="comment">-- 该函数第一个断点</span></span><br><span class="line">        s.funcbpt[func] = &#123;&#125;</span><br><span class="line">        s.funcbpt[func].num = <span class="number">1</span></span><br><span class="line">        s.funcbpt[func][line] = s.bpid</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">     <span class="string">[[ 新增代码结束 ]]</span></span><br><span class="line">    <span class="keyword">if</span> s.bpnum == <span class="number">1</span> <span class="keyword">then</span>                <span class="comment">-- 全局第一个断点</span></span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;c&quot;</span>)        <span class="comment">-- 设置钩子&quot;call&quot;事件</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> s.bpid                       <span class="comment">--&gt; 返回断点id</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h2><p>相应地，在删除断点的时候，我们也需要把<code>s.funcbpt</code>表中对应的断点删除。首先根据断点id，从<code>s.bptable</code>表中获取到断点的函数和行号，从而找到<code>s.funcbpt</code>表中对应的断点。现将断点个数减1，然后将对应断点删除（防止后续line事件找到该断点）。如果该函数已经没有断点了，那么将<code>s.funcbpt[func]</code>表本身也删除（防止后续call事件以为该函数还有断点）。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">removebreakpoint</span><span class="params">(id)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> s.bptable[id] == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="string">[[ 新增代码开始 ]]</span></span><br><span class="line">    <span class="keyword">local</span> func = s.bptable[id].func</span><br><span class="line">    <span class="keyword">local</span> line = s.bptable[id].line</span><br><span class="line">    s.funcbpt[func].num = s.funcbpt[func].num - <span class="number">1</span></span><br><span class="line">    s.funcbpt[func][line] = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> s.funcbpt[func].num == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        s.funcbpt[func] = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="string">[[ 新增代码结束 ]]</span></span><br><span class="line">    s.bptable[id] = <span class="literal">nil</span></span><br><span class="line">    s.bpnum = s.bpnum - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> s.bpnum == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">sethook</span>()                 <span class="comment">-- 移除钩子</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>然后来修改钩子函数的处理，钩子的函数的修改主要有两处，分别是call事件和line事件。我们先来看call事件的修改：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> local function hook (event, line)</span><br><span class="line">     local s = status</span><br><span class="line">     if event == &quot;call&quot; or event == &quot;tail call&quot; then</span><br><span class="line">         local func = debug.getinfo(2, &quot;f&quot;).func</span><br><span class="line"><span class="deletion">-        for _, v in pairs(s.bptable) do</span></span><br><span class="line"><span class="deletion">-            -- found breakpoint in current function</span></span><br><span class="line"><span class="deletion">-            if v.func == func then</span></span><br><span class="line"><span class="deletion">-                if event == &quot;call&quot; then</span></span><br><span class="line"><span class="deletion">-                    s.stackdepth = s.stackdepth + 1</span></span><br><span class="line"><span class="deletion">-                end</span></span><br><span class="line"><span class="deletion">-                s.stackinfos[s.stackdepth] =</span></span><br><span class="line"><span class="deletion">-                    &#123;func = func, hasbreak = true&#125;</span></span><br><span class="line"><span class="deletion">-                debug.sethook(hook, &quot;crl&quot;)     -- 添加&quot;line&quot;事件</span></span><br><span class="line"><span class="deletion">-                return</span></span><br><span class="line"><span class="deletion">-            end</span></span><br><span class="line"><span class="deletion">-        end</span></span><br><span class="line"><span class="deletion">-        -- 没有断点</span></span><br><span class="line"><span class="deletion">-        if event == &quot;call&quot; then</span></span><br><span class="line"><span class="addition">+        if event == &quot;call&quot; then     -- 对于尾调用,直接覆盖</span></span><br><span class="line">             s.stackdepth = s.stackdepth + 1</span><br><span class="line">         end</span><br><span class="line"><span class="deletion">-        s.stackinfos[s.stackdepth] = &#123;func = func, hasbreak = false&#125;</span></span><br><span class="line"><span class="deletion">-        debug.sethook(hook, &quot;cr&quot;)   -- 去掉&quot;line&quot;事件</span></span><br><span class="line"><span class="addition">+        -- found breakpoint in current function</span></span><br><span class="line"><span class="addition">+        if s.funcbpt[func] then</span></span><br><span class="line"><span class="addition">+            s.stackinfos[s.stackdepth] = &#123;func = func, hasbreak = true&#125;</span></span><br><span class="line"><span class="addition">+            debug.sethook(hook, &quot;crl&quot;) -- 添加&quot;line&quot;事件</span></span><br><span class="line"><span class="addition">+        else        -- no breakpoints found</span></span><br><span class="line"><span class="addition">+            s.stackinfos[s.stackdepth] = &#123;func = func, hasbreak = false&#125;</span></span><br><span class="line"><span class="addition">+            debug.sethook(hook, &quot;cr&quot;)   -- 去掉&quot;line&quot;事件</span></span><br><span class="line"><span class="addition">+        end</span></span><br><span class="line">     elseif event == &quot;return&quot; or event == &quot;tail return&quot; then</span><br></pre></td></tr></table></figure>

<p>主要的改动就是从原本的遍历<code>s.bptable</code>表来查找是否有断点，改成了直接通过检查<code>s.funcbpt[func]</code>是否不为<code>nil</code>来判断是否有断点。这里直接从遍历一个表，优化成了一个查表操作。</p>
<p>第二处是line事件的修改，下面是修改前的代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">   <span class="comment">-- 省略</span></span><br><span class="line">   <span class="keyword">elseif</span> event == <span class="string">&quot;line&quot;</span> <span class="keyword">then</span></span><br><span class="line">       <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">pairs</span>(s.bptable) <span class="keyword">do</span></span><br><span class="line">           <span class="keyword">if</span> v.func == s.stackinfos[s.stackdepth].func</span><br><span class="line">               <span class="keyword">and</span> v.line == line <span class="keyword">then</span></span><br><span class="line">               <span class="keyword">if</span> <span class="keyword">not</span> s.funcinfos[v.func] <span class="keyword">then</span></span><br><span class="line">                   s.funcinfos[v.func] = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>, <span class="string">&quot;nS&quot;</span>)</span><br><span class="line">               <span class="keyword">end</span></span><br><span class="line">               <span class="keyword">local</span> info = s.funcinfos[v.func]</span><br><span class="line">               <span class="keyword">local</span> prompt = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s (%s)%s %s:%d\n&quot;</span>,</span><br><span class="line">                   info.what, info.namewhat, info.name, info.short_src, line)</span><br><span class="line">               <span class="built_in">io</span>.<span class="built_in">write</span>(prompt)</span><br><span class="line">               <span class="built_in">debug</span>.<span class="built_in">debug</span>()</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 省略</span></span><br></pre></td></tr></table></figure>

<p>下面是修改后的代码，除了增加了一些局部变量简化代码之外，也是将原本的遍历<code>s.bptable</code>表来判断当前行是否是断点行，改成了直接通过检查<code>s.funcbpt[curfunc][line]</code>是否不为<code>nil</code>来判断当前行是否是断点行。这里也将遍历一个表的动作，优化成了一个查表操作。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">elseif</span> event == <span class="string">&quot;line&quot;</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">local</span> curfunc = s.stackinfos[s.stackdepth].func</span><br><span class="line">    <span class="keyword">local</span> funcbp = s.funcbpt[curfunc]</span><br><span class="line">    <span class="built_in">assert</span>(funcbp)</span><br><span class="line">    <span class="keyword">if</span> funcbp[line] <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s.funcinfos[curfunc] <span class="keyword">then</span></span><br><span class="line">            s.funcinfos[curfunc] = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>, <span class="string">&quot;nS&quot;</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">local</span> info = s.funcinfos[curfunc]</span><br><span class="line">        <span class="keyword">local</span> prompt = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s (%s)%s %s:%d\n&quot;</span>,</span><br><span class="line">            info.what, info.namewhat, info.name, info.short_src, line)</span><br><span class="line">        <span class="built_in">io</span>.<span class="built_in">write</span>(prompt)</span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">debug</span>()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>我们仍然假设代码执行的总行数为<code>L</code>，断点数<code>N=n*b</code>，其中<code>n</code>为有断点的函数个数，<code>b</code>为平均每个函数的断点数，断点所在函数平均行数为<code>l</code>，断点所在函数平均调用次数为<code>c</code>，总的函数调用次数<code>C</code>。</p>
<p>完全没优化前复杂度为<code>O(L*N)</code>，上一篇的事件处理优化后的复杂度为<code>O(C*N+c*l*N)</code>，而本篇的数据结构优化之后复杂度进一步缩小为<code>O(C+c*l)</code>。</p>
<h2 id="测试多函数多断点"><a href="#测试多函数多断点" class="headerlink" title="测试多函数多断点"></a>测试多函数多断点</h2><p>先来测试一下修改之后断点功能是否正常，编写一个测试脚本如下。我们对foo函数和bar函数分别添加了两个断点，其中foo函数第一个断点添加了两次用于测试重复添加的情况。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line">pv = ldb.printvarvalue</span><br><span class="line">sv = ldb.setvarvalue</span><br><span class="line">ptb = ldb.printtraceback</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span> <span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> b = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(foo, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">assert</span>(id1 == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">local</span> id1 = setbp(foo, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">assert</span>(id1 == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">local</span> id2 = setbp(foo, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id3 = setbp(bar, <span class="number">13</span>)</span><br><span class="line"><span class="keyword">local</span> id4 = setbp(bar, <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line">rmbp(id1)</span><br><span class="line">rmbp(id2)</span><br><span class="line">rmbp(id3)</span><br><span class="line">rmbp(id4)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>

<p>运行脚本，4个断点情况都能正常跑到。删除断点后再调用foo和bar函数，不再碰到断点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua test.lua</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:9</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:10</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)bar test.lua:13</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)bar test.lua:14</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">$</span><br></pre></td></tr></table></figure>



<h2 id="性能比对"><a href="#性能比对" class="headerlink" title="性能比对"></a>性能比对</h2><p>我们再来做个简单的测试，看看我们优化的效果。编写如下测试脚本，foo函数模拟较长的程序，然后在另一个函数上加个断点（为了设置hook）。我们分别使用优化前的<code>luadebug.lua</code>和优化后的<code>luadebug.lua</code>进行测试。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">10000000</span> <span class="keyword">do</span></span><br><span class="line">        a = a + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span> <span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(bar, <span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<h3 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h3><p>使用优化前的实现，运行这个脚本用了40s</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ time lua test2.lua</span><br><span class="line">lua test2.lua  39.54s user 0.16s system 99% cpu 39.957 total</span><br></pre></td></tr></table></figure>

<h3 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h3><p>使用优化后的实现，则只花了0.109s，相差了接近400倍，可见我们的优化效果还是很明显的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ time lua test2.lua</span><br><span class="line">lua test2.lua  0.10s user 0.00s system 97% cpu 0.109 total</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua中如何实现类似gdb的断点调试—06断点行号检查与自动修正</title>
    <url>/posts/fa52978d/</url>
    <content><![CDATA[<div class="note primary">
            <p>前面两篇我们对性能做了一个优化，接下来继续来丰富调试器的特性。</p><p>我们前面提到过，函数内并不是所有行都是有效行，空行和注释行就不是有效行。我们之前在添加断点的时候，并没有对行号进行检查，任何行号都能成功添加断点。所以如果添加的断点行号是无效的，那么永远也不会断到那里。但是钩子里并不知道它是无效的，call事件仍然会以为函数有断点从而启动line事件，造成CPU的浪费。</p><p>所以本篇，我们将对断点的行号进行检查，对于不在函数范围内的行号直接添加断点失败；在函数范围内的行号则自动修正为下一个有效的行号；另外支持不指定行号，默认为函数的第一个有效行。</p><span id="more"></span><p>源码已经上传<a href="https://github.com/catbro666/lua-debugger">Github</a>，欢迎watch/star😘。</p>
          </div>



<h2 id="添加断点"><a href="#添加断点" class="headerlink" title="添加断点"></a>添加断点</h2><p>因为是断点行号相关的检查，所以修改主要集中在添加断点的函数中。首先因为支持了不指定行号，所以修改了参数检查的地方允许为空。其次，因为要检查行号是否有效，我们就需要先获取到函数的信息。考虑到在钩子函数中也需要获取函数信息，我们就把相关的操作封装成了一个单独的函数<code>getfuncinfo()</code>。获取到函数信息之后，就可以验证行号是否有效了，同样我们将这个验证行号的操作也封装成了一个单独的函数<code>verifyfuncline</code>。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setbreakpoint</span><span class="params">(func, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(func) ~= <span class="string">&quot;function&quot;</span> <span class="keyword">or</span> ( line <span class="keyword">and</span> <span class="built_in">type</span>(line) ~= <span class="string">&quot;number&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;invalid parameter\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- get func info</span></span><br><span class="line">    <span class="keyword">local</span> info = getfuncinfo(func)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> info <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;unable to get func info\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- verify the line</span></span><br><span class="line">    line = verifyfuncline(info, line)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;invalid line\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="获取函数信息"><a href="#获取函数信息" class="headerlink" title="获取函数信息"></a>获取函数信息</h2><p><code>getfuncinfo</code>函数的代码如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">getfuncinfo</span> <span class="params">(func, level)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">local</span> info = s.funcinfos[func]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> info <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> level <span class="keyword">then</span></span><br><span class="line">            s.funcinfos[func] = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(level + <span class="number">1</span>, <span class="string">&quot;nSL&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s.funcinfos[func] = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(func, <span class="string">&quot;SL&quot;</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        info = s.funcinfos[func]</span><br><span class="line">        info.sortedlines = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k, _ <span class="keyword">in</span> <span class="built_in">pairs</span>(info.activelines) <span class="keyword">do</span></span><br><span class="line">           <span class="built_in">table</span>.<span class="built_in">insert</span>(info.sortedlines, k)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">sort</span>(info.sortedlines)</span><br><span class="line">    <span class="keyword">elseif</span> level <span class="keyword">then</span>	<span class="comment">-- name和namewhat需要实时获取</span></span><br><span class="line">         <span class="keyword">local</span> nameinfo = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(level + <span class="number">1</span>, <span class="string">&quot;n&quot;</span>)</span><br><span class="line">         info.name = nameinfo.name</span><br><span class="line">         info.namewhat = nameinfo.namewhat</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> info</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>该函数有两个参数，第一个参数就是函数，第二个可选的参数level用于指定在调用栈中的层数，第二个参数只有在钩子函数中时才会指定，返回值就是函数信息。如果在调用<code>debug.getinfo</code>的时候传递函数作为参数，那么是获取不到函数的名字信息的，<code>name</code>和<code>namewhat</code>字段都为空。因为函数可能是任意名字，Lua需要通过查找调用该函数的代码，知道它是怎么被调用的，从而确定函数的名字。所以只有当指定调用栈的层数时才能获取到名字信息。</p>
<p>我们接着看代码的主体部分：</p>
<p>首先尝试去<code>s.funcinfos</code>表中查找是否有缓存的函数信息。如果没有那就只能调用<code>debug.getinfo</code>去获取了，这里分为两种情况，如果指定了<code>level</code>参数，那么就以层数（这里+1同样是为了修正层数，我们在前面多次提到过）作为参数调用，此时第二个参数设置为了<code>&quot;nSL&quot;</code>，比之前多了<code>&quot;L&quot;</code>用于获取有效行号；如果没有指定<code>level</code>参数，则以函数作为参数调用。获取到函数信息之后，为了方便我们后面的行号检查，我们对有效的行号进行了排序，<code>info.sortedlines</code>数组就是排序后的有效行号，然后就返回函数信息<code>info</code>了。</p>
<p>如果缓存中已经有函数信息了，如果本次调用又指定了<code>level</code>参数，那么我们就更新下name信息。调用<code>debug.getinfo</code>获取到信息之后设置到原有的<code>info</code>表中。完成之后同样是返回函数信息<code>info</code>。</p>
<h2 id="检查及修正函数行号"><a href="#检查及修正函数行号" class="headerlink" title="检查及修正函数行号"></a>检查及修正函数行号</h2><p><code>verifyfuncline</code>函数的代码如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">verifyfuncline</span> <span class="params">(info, line)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> info.sortedlines[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> line &lt; info.linedefined <span class="keyword">or</span> line &gt; info.lastlinedefined <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(info.sortedlines) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> v &gt;= line <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>)   <span class="comment">-- impossible to reach here</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>该函数有两个参数，其中第二个行号是可选的。如果没有指定行号，那么直接返回函数的第一个有效行号。如果指定了行号，但是范围超出了函数定义的范围，那么返回<code>nil</code>。如果行号落在函数范围内，那么就遍历已经排好序的有效行号数组，返回碰到的第一个大于等于指定行号的值。</p>
<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>接下来看下钩子函数的修改，因为我们已经封装了<code>getfuncinfo</code>函数，所以钩子函数中也改成用它来获取函数信息。不过这里在调用的时候指定了<code>level</code>从而可以获取到函数名字信息。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span> <span class="params">(event, line)</span></span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">elseif</span> event == <span class="string">&quot;line&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> curfunc = s.stackinfos[s.stackdepth].func</span><br><span class="line">        <span class="keyword">local</span> funcbp = s.funcbpt[curfunc]</span><br><span class="line">        <span class="built_in">assert</span>(funcbp)</span><br><span class="line">        <span class="keyword">if</span> funcbp[line] <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> info = getfuncinfo(curfunc, <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">local</span> prompt = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s (%s)%s %s:%d\n&quot;</span>,</span><br><span class="line">                info.what, info.namewhat, info.name, info.short_src, line)</span><br><span class="line">            <span class="built_in">io</span>.<span class="built_in">write</span>(prompt)</span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">debug</span>()</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>OK，代码修改完了，我们进行测试。</p>
<h2 id="测试有效行排序"><a href="#测试有效行排序" class="headerlink" title="测试有效行排序"></a>测试有效行排序</h2><p>首先测试一下，有效行号排序那块的逻辑。我们编写了一个如下的测试脚本：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">debug</span> = <span class="built_in">require</span> <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">sortlines</span><span class="params">(func)</span></span></span><br><span class="line">    <span class="keyword">local</span> info = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(func, <span class="string">&quot;nSL&quot;</span>)</span><br><span class="line">    info.sortedlines = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(info.activelines) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(k, v)</span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(info.sortedlines, k)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">sort</span>(info.sortedlines)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(info.sortedlines) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(k, v)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">sortlines(foo)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line">sortlines(bar)</span><br></pre></td></tr></table></figure>

<p>我们定义了两个函数foo和bar，其中foo函数的范围为第3行到第9行，有4个有效行4、6、8、9。而bar函数则为特殊的单行函数。</p>
<p>运行脚本，输出如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua sortlines.lua</span><br><span class="line">foo</span><br><span class="line">4	<span class="literal">true</span></span><br><span class="line">9	<span class="literal">true</span></span><br><span class="line">6	<span class="literal">true</span></span><br><span class="line">8	<span class="literal">true</span></span><br><span class="line">1	4</span><br><span class="line">2	6</span><br><span class="line">3	8</span><br><span class="line">4	9</span><br><span class="line">bar</span><br><span class="line">11	<span class="literal">true</span></span><br><span class="line">1	11</span><br></pre></td></tr></table></figure>

<p>foo函数4个有效行没排之前是4、9、6、8，排序之后变成4、6、8、9。bar函数唯一的有效行就是它开始定义的那行。</p>
<h2 id="测试行号检查和自动修正"><a href="#测试行号检查和自动修正" class="headerlink" title="测试行号检查和自动修正"></a>测试行号检查和自动修正</h2><p>编写测试脚本如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(foo)</span><br><span class="line"><span class="built_in">assert</span>(id1 == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">local</span> id2 = setbp(foo, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">assert</span>(id2 == id1)</span><br><span class="line"><span class="keyword">local</span> id3 = setbp(foo, <span class="number">6</span>)</span><br><span class="line"><span class="built_in">assert</span>(id3 == id1)</span><br><span class="line"><span class="keyword">local</span> id4 = setbp(foo, <span class="number">7</span>)</span><br><span class="line"><span class="built_in">assert</span>(id4 == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">local</span> id5 = setbp(foo, <span class="number">8</span>)</span><br><span class="line"><span class="built_in">assert</span>(id5 == id4)</span><br><span class="line"><span class="keyword">local</span> id6 = setbp(foo, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">assert</span>(id6 == <span class="number">3</span>)</span><br><span class="line"><span class="keyword">local</span> id7 = setbp(foo, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">assert</span>(<span class="keyword">not</span> id7)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">rmbp(id1)</span><br><span class="line">rmbp(id4)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">rmbp(id6)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>我们在foo函数上添加了好几个断点，第一个断点行号省略，第二个断点加在了第5行，也就是函数开始定义的行，第三个断点加在了第6行，这是函数第一个有效行。预期前三次添加断点应该都返回同一个断点id，断在第6行。接下来添加的两个断点，第7行不是有效行，第8行是有效行，预期返回同一个断点id，断在第8行。然后在第9行添加了一个断点，因为不是有效行，预期断在第10行。最后一个在第100行设置了一个断点，因为超出了函数的范围，预期设置断点失败返回<code>nil</code>。</p>
<p>设置好断点，先调用一次foo函数，然后删除两个断点，在调用一次foo函数，最后将剩余那个断点删除，再调用一次foo函数。</p>
<p>我们了运行下测试脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua test.lua</span><br><span class="line">invalid line</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:6</span><br><span class="line">lua_debug&gt; </span><br></pre></td></tr></table></figure>

<p>断点的设置都符合预期，最后一个因为行号超出了范围，打了一行错误日志<code>invalid line</code>，程序停在了第6行处。然后我们输入两个<code>cont</code>，程序停在了最后一个断点处。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:6</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:8</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:10</span><br><span class="line">lua_debug&gt; </span><br></pre></td></tr></table></figure>

<p>我们再次输入<code>cont</code>，foo函数运行结束，此时因为前两个断点已经被删除，第二次调用foo函数应该直接停在断点3处，也就是第10行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:6</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:8</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:10</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:10</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>我们再次输入<code>cont</code>，因为最后一个断点也被删除了，所以最后一个执行foo函数没有再碰到断点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua test.lua</span><br><span class="line">invalid line</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:6</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:8</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:10</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:10</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">$</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua中如何实现类似gdb的断点调试—07支持通过函数名称添加断点</title>
    <url>/posts/acdf52b7/</url>
    <content><![CDATA[<div class="note primary">
            <p>我们之前已经支持了通过函数来添加断点，并且已经支持了行号的检查和自动修正。但是通过函数来添加断点有一些限制，如果在当前的位置无法访问目标函数，那我们就无法对其添加断点。</p><p>于是，本篇我们将扩展断点设置的接口，支持通过函数名称添加断点，以突破这个限制。</p><span id="more"></span><p>源码已经上传<a href="https://github.com/catbro666/lua-debugger">Github</a>，欢迎watch/star😘。</p>
          </div>



<h2 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h2><p>由于Lua是动态类型语言，变量可以是任何值。而函数在Lua语言中又是第一类值，与其他值一样使用，可以被存放在变量中、作为参数或返回值传递。所以一个函数的名字是不确定的，它可能是任意名字，取决于函数调用时候的变量的名称。</p>
<p>通过下面这个简单的例子，就可以看出来</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">setbp(foo, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> bar = foo</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>

<p>我们在foo函数中添加了一个断点，将foo函数赋值给局部变量bar，然后分别用foo和bar调用函数。运行这个脚本结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua namenotstable.lua</span><br><span class="line">Lua (<span class="built_in">local</span>)foo namenotstable.lua:6</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)bar namenotstable.lua:6</span><br><span class="line">lua_debug&gt; cont</span><br></pre></td></tr></table></figure>

<p>调用<code>foo()</code>和<code>bar()</code>都会碰到断点，函数名称分别为<code>foo</code>和<code>bar</code>。</p>
<p>所以通过函数名称添加的断点并不是确定的，函数名称和函数之间并不是一一映射的关系，而可能是m对n的关系。就算已经匹配到了一个与断点设置的函数名称一致的函数，我们也不能简单地将函数名称断点转换成相应的函数断点，而是仍然需要维护函数名称断点。</p>
<p>因此，我们需要增加一个维护函数名称断点的数据结构—-新的断点表<code>status.namebpt</code>。类似之前在<a href="../2e777dd3/">05优化断点信息数据结构</a>中添加的<code>status.funcbpt</code>表，只是表的键由之前的函数变成了函数名称。<code>status.namebpt</code>表的值同样是一个表，该表的键是断点行号，值为断点id。同样地，为了快速获取断点个数，我们在表中额外加了一个特殊的<code>num</code>字段保存该函数名称中的断点个数。</p>
<p>通过下面的例子来直观地看一下，假设我们的<code>bptable</code>表中添加了两个断点如下（<code>name</code>字段用来保存函数名称）：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">bptable[<span class="number">1</span>] = &#123;name = <span class="string">&quot;foo&quot;</span>, line = <span class="number">10</span>&#125;</span><br><span class="line">bptable[<span class="number">2</span>] = &#123;name = <span class="string">&quot;foo&quot;</span>, line = <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>

<p>对应的在<code>namebpt</code>表中的操作如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">namebpt[<span class="string">&quot;foo&quot;</span>] = &#123;&#125;          <span class="comment">-- 构造表</span></span><br><span class="line">namebpt[<span class="string">&quot;foo&quot;</span>][<span class="number">10</span>] = <span class="number">1</span>	     <span class="comment">-- 函数名foo，行号10，断点id为1</span></span><br><span class="line">namebpt[<span class="string">&quot;foo&quot;</span>].num = <span class="number">1</span>       <span class="comment">-- 该函数第一个断点</span></span><br><span class="line">namebpt[<span class="string">&quot;foo&quot;</span>][<span class="number">20</span>] = <span class="number">2</span>       <span class="comment">-- 函数名foo，行号20，断点id为2</span></span><br><span class="line">namebpt[<span class="string">&quot;foo&quot;</span>].num = namebpt[<span class="string">&quot;foo&quot;</span>].num + <span class="number">1</span>	<span class="comment">-- 断点个数+1</span></span><br></pre></td></tr></table></figure>

<p>OK，分析完了，接下来开始修改相应的代码实现。</p>
<h2 id="添加断点"><a href="#添加断点" class="headerlink" title="添加断点"></a>添加断点</h2><p>按照惯例，我们先修改设置断点函数。因为支持了通过函数名称设置断点，第一个参数需要支持string类型。为了简洁及代码重用，我们将之前通过函数设置断点的操作封装成了<code>setfuncbp</code>函数，另外将通过函数名称设置断点的操作封装成了<code>setnamebp</code>函数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setbreakpoint</span><span class="params">(where, line)</span></span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">type</span>(where) ~= <span class="string">&quot;function&quot;</span> <span class="keyword">and</span> <span class="built_in">type</span>(where) ~= <span class="string">&quot;string&quot;</span>)</span><br><span class="line">        <span class="keyword">or</span> ( line <span class="keyword">and</span> <span class="built_in">type</span>(line) ~= <span class="string">&quot;number&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;invalid parameter\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(where) == <span class="string">&quot;function&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> setfuncbp(where, line)</span><br><span class="line">    <span class="keyword">else</span>            <span class="comment">-- &quot;string&quot;</span></span><br><span class="line">        <span class="keyword">return</span> setnamebp(where, line)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>接下来，来看下<code>setnamebp</code>函数的实现：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setnamebp</span><span class="params">(name, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">local</span> namebp = s.namebpt[name]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line <span class="keyword">then</span>                    <span class="comment">-- 如果没有指定行号</span></span><br><span class="line">        line = <span class="number">0</span>                        <span class="comment">-- 用一个特殊值0来表示第一个有效行</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 是否已经添加了相同的断点</span></span><br><span class="line">    <span class="keyword">if</span> namebp <span class="keyword">and</span> namebp[line] <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> namebp[line]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    s.bpid = s.bpid + <span class="number">1</span></span><br><span class="line">    s.bpnum = s.bpnum + <span class="number">1</span></span><br><span class="line">    s.bptable[s.bpid] = &#123;name = name, line = line&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> namebp <span class="keyword">then</span>                  <span class="comment">-- 该函数名称的第一个断点</span></span><br><span class="line">        s.namebpt[name] = &#123;&#125;</span><br><span class="line">        namebp = s.namebpt[name]</span><br><span class="line">        namebp.num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    namebp.num = namebp.num + <span class="number">1</span></span><br><span class="line">    namebp[line] = s.bpid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s.bpnum == <span class="number">1</span> <span class="keyword">then</span>                <span class="comment">-- 第一个全局断点</span></span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;c&quot;</span>)        <span class="comment">-- 设置钩子函数的&quot;call&quot;事件</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> s.bpid                       <span class="comment">--&gt; 返回断点id</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>因为我们支持不指定行号，但我们并不确定函数的第一个有效行是什么。为了方便地记录断点，又不至于与实际的断点行冲突，我们用了一个特殊值0来表示这种情况。</p>
<p>后续的逻辑与<code>setfuncbp</code>函数基本一致，如果已经添加了相同的断点，则返回之前的断点id。然后分别在<code>bptable</code>表和<code>namebp</code>表中添加断点。这里不再赘述。</p>
<h2 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h2><p>删除断点函数的改动不大。主要是要区分删除的是哪类断点，这个可以通过<code>s.bptable</code>表中<code>id</code>所对应的断点信息来判断。如果有func则说明是通过函数添加的断点，否则则是通过函数名称添加的断点。根据情况删除<code>s.funcbpt</code>或者<code>s.namebpt</code>表中的断点，最后删除<code>s.bptable</code>表中的断点。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">removebreakpoint</span><span class="params">(id)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> s.bptable[id] == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> func = s.bptable[id].func</span><br><span class="line">    <span class="keyword">local</span> name = s.bptable[id].name</span><br><span class="line">    <span class="keyword">local</span> line = s.bptable[id].line</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> dstbp = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">then</span></span><br><span class="line">        dstbp = s.funcbpt[func]</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dstbp = s.namebpt[name]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> dstbp <span class="keyword">and</span> dstbp[line] <span class="keyword">then</span></span><br><span class="line">        dstbp.num = dstbp.num - <span class="number">1</span></span><br><span class="line">        dstbp[line] = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> dstbp.num == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            dstbp = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    s.bptable[id] = <span class="literal">nil</span></span><br><span class="line">    s.bpnum = s.bpnum - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> s.bpnum == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">debug</span>.<span class="built_in">sethook</span>()                 <span class="comment">-- 移除钩子</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="获取函数信息"><a href="#获取函数信息" class="headerlink" title="获取函数信息"></a>获取函数信息</h2><p>正如前面提到过的，因为函数名称信息是不确定的，所以我们修改了<code>getfuncinfo</code>函数实现，不再缓存函数名称信息，而只缓存确定的函数信息。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">getfuncinfo</span> <span class="params">(func)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">local</span> info = s.funcinfos[func]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> info <span class="keyword">then</span></span><br><span class="line">        info = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(func, <span class="string">&quot;SL&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (info.activelines) <span class="keyword">then</span></span><br><span class="line">            info.sortedlines = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> k, _ <span class="keyword">in</span> <span class="built_in">pairs</span>(info.activelines) <span class="keyword">do</span></span><br><span class="line">               <span class="built_in">table</span>.<span class="built_in">insert</span>(info.sortedlines, k)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="built_in">table</span>.<span class="built_in">sort</span>(info.sortedlines)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        s.funcinfos[func] = info</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> info</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>钩子函数的改动主要是在call事件。函数名称每次都根据调用栈实时获取。首先在函数断点表<code>s.funcbpt</code>中查找当前函数是否有断点，如果没有则再去函数名称断点表<code>s.namebpt</code>中查找。需要检查断点行号是否在当前函数的定义范围之内，只有当行号在范围之内才认为匹配。如果没有指定行号的话（默认为第一个有效行），则总是认为匹配。另外，在调用栈信息表中，分别将确定的函数信息<code>funcinfo</code>和调用栈相关信息<code>stackinfo</code>分别保存，以供return事件和line事件时使用。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span> <span class="params">(event, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail call&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> stackinfo = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>, <span class="string">&quot;nf&quot;</span>)</span><br><span class="line">        <span class="keyword">local</span> func = stackinfo.func</span><br><span class="line">        <span class="keyword">local</span> name = stackinfo.name</span><br><span class="line">        <span class="keyword">local</span> funcinfo = getfuncinfo(func)</span><br><span class="line">        <span class="keyword">local</span> hasbreak = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> s.funcbpt[func] <span class="keyword">then</span></span><br><span class="line">            hasbreak = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasbreak <span class="keyword">and</span> s.namebpt[name] <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> <span class="built_in">min</span> = funcinfo.linedefined</span><br><span class="line">            <span class="keyword">local</span> <span class="built_in">max</span> = funcinfo.lastlinedefined</span><br><span class="line">            <span class="keyword">for</span> k, _ <span class="keyword">in</span> <span class="built_in">pairs</span>(s.namebpt[name]) <span class="keyword">do</span></span><br><span class="line">                <span class="keyword">if</span> k ~= <span class="string">&quot;num&quot;</span> <span class="keyword">and</span> ((k &gt;= <span class="built_in">min</span> <span class="keyword">and</span> k &lt;= <span class="built_in">max</span>) <span class="keyword">or</span> k == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                    hasbreak = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">then</span>     <span class="comment">-- for tail call, just overwrite</span></span><br><span class="line">            s.stackdepth = s.stackdepth + <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        s.stackinfos[s.stackdepth] =</span><br><span class="line">            &#123;stackinfo = stackinfo, funcinfo = funcinfo, hasbreak = hasbreak&#125;</span><br><span class="line">        <span class="comment">-- found breakpoint in current function</span></span><br><span class="line">        <span class="keyword">if</span> hasbreak <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;crl&quot;</span>)	<span class="comment">-- add &quot;line&quot; event</span></span><br><span class="line">        <span class="keyword">else</span>        <span class="comment">-- no breakpoints found</span></span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">sethook</span>(hook, <span class="string">&quot;cr&quot;</span>)   <span class="comment">-- remove &quot;line&quot; event temporarily</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> event == <span class="string">&quot;return&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail return&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>line事件也需要做相应的修改</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span> <span class="params">(event, line)</span></span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">elseif</span> event == <span class="string">&quot;line&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> sinfo = s.stackinfos[s.stackdepth].stackinfo</span><br><span class="line">        <span class="keyword">local</span> finfo = s.stackinfos[s.stackdepth].funcinfo</span><br><span class="line">        <span class="keyword">local</span> func = sinfo.func</span><br><span class="line">        <span class="keyword">local</span> name = sinfo.name</span><br><span class="line">        <span class="keyword">local</span> funcbp = s.funcbpt[func]</span><br><span class="line">        <span class="keyword">local</span> namebp = s.namebpt[name]</span><br><span class="line">        <span class="keyword">if</span> (funcbp <span class="keyword">and</span> funcbp[line]) <span class="keyword">or</span> (namebp <span class="keyword">and</span> namebp[line])</span><br><span class="line">            <span class="keyword">or</span> (namebp <span class="keyword">and</span> namebp[<span class="number">0</span>] <span class="keyword">and</span> line == finfo.sortedlines[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> prompt = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s (%s)%s %s:%d\n&quot;</span>,</span><br><span class="line">                finfo.what, sinfo.namewhat, name, finfo.short_src, line)</span><br><span class="line">            <span class="built_in">io</span>.<span class="built_in">write</span>(prompt)</span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">debug</span>()</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在判断当前行是否有断点时，除了查看<code>funcbpt</code>表，还需要查看<code>namebpt</code>表，对于函数名称断点没有指定行号的情况，判断当前行是不是第一个有效行。打印提示信息时，则从<code>stackinfos</code>表中保存的信息中获取。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>代码修改好了，我们来测试下通过函数名称添加断点的功能。编写如下测试脚本：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">pee</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(foo)</span><br><span class="line"><span class="keyword">local</span> id2 = setbp(foo, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id3 = setbp(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> id4 = setbp(<span class="string">&quot;bar&quot;</span>, <span class="number">11</span>)</span><br><span class="line"><span class="keyword">local</span> id5 = setbp(<span class="string">&quot;bar&quot;</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id6 = setbp(pee)</span><br><span class="line"><span class="keyword">local</span> id7 = setbp(<span class="string">&quot;pee&quot;</span>, <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">bar()</span><br><span class="line">pee()</span><br><span class="line"></span><br><span class="line">rmbp(id1)</span><br><span class="line">rmbp(id3)</span><br><span class="line">rmbp(id6)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">bar()</span><br><span class="line">pee()</span><br><span class="line"></span><br><span class="line">rmbp(id2)</span><br><span class="line">rmbp(id4)</span><br><span class="line">rmbp(id7)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">bar()</span><br><span class="line">pee()</span><br></pre></td></tr></table></figure>

<p>我们添加了三个函数，其中foo函数以函数作为参数添加断点，bar函数以函数名称作为参数添加断点，pee函数分别用函数和函数名添加了一个断点。添加完断点，先分别调用一次，预期每个函数都会碰到两个断点。接着三个函数各删除一个断点，再各调用一次，预期每个函数都会碰到一个断点。最后三个函数再各删除一个断点，再各调用一次，预期不碰到断点。</p>
<p>运行测试脚本，结果符合预期。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua test.lua</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:6</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:7</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)bar test.lua:10</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)bar test.lua:11</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)pee test.lua:14</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)pee test.lua:15		<span class="comment"># 第一次调用，每个函数碰到两个断点</span></span><br><span class="line">lua_debug&gt; cont					</span><br><span class="line">Lua (<span class="built_in">local</span>)foo test.lua:7</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)bar test.lua:11</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (<span class="built_in">local</span>)pee test.lua:15		<span class="comment"># 第二次调用，每个函数碰到一个断点</span></span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">$								<span class="comment"># 第三次调用，不再碰到断点</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX环境高级编程APUE练习4.6-实现类似cp(1)的程序，保留文件中的空洞</title>
    <url>/posts/aa99fc97/</url>
    <content><![CDATA[<h2 id="1-题面"><a href="#1-题面" class="headerlink" title="1 题面"></a>1 题面</h2><p>编写类似<code>cp(1)</code>的程序，它复制包含空洞的文件，但是不将字节0写到输出文件中去。</p>
<h2 id="2-基本思路"><a href="#2-基本思路" class="headerlink" title="2 基本思路"></a>2 基本思路</h2><ul>
<li>首先要搞清楚空洞的性质以判断一个文件是否有空洞，以及空洞的位置</li>
<li>知道了空洞的位置之后，读到源文件中的空洞部分时，在目标文件中<code>lseek</code>相应的长度</li>
</ul>
<span id="more"></span>

<h2 id="3-创建空洞文件，同时探索空洞性质"><a href="#3-创建空洞文件，同时探索空洞性质" class="headerlink" title="3 创建空洞文件，同时探索空洞性质"></a>3 创建空洞文件，同时探索空洞性质</h2><p>交替<code>lseek</code>和<code>write</code>，逐渐增大间隔长度。比较文件的大小和实际占用的block数目</p>
<ul>
<li>测试源码</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> holesize[]=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>, <span class="number">4096</span>, <span class="number">8192</span>, <span class="number">16384</span>, <span class="number">32</span>*<span class="number">1024</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> filesize = <span class="number">64</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, fd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">32</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">32</span>*<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">1</span>, <span class="number">32</span>*<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">for</span> (; i&lt; <span class="keyword">sizeof</span>(holesize)/ <span class="keyword">sizeof</span>(<span class="keyword">int</span>); ++i) &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(filename, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(filename, <span class="string">&quot;%s%d&quot;</span>, <span class="string">&quot;holesize&quot;</span>, holesize[i]);</span><br><span class="line">        fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;open file fail\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; filesize) &#123;</span><br><span class="line">            ret = lseek(fd, holesize[i], SEEK_CUR);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;lseek fail\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> remain = holesize[i];</span><br><span class="line">            <span class="keyword">while</span>(remain) &#123;</span><br><span class="line">                ret = write(fd, buf, remain);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;write fail\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                remain -= ret;</span><br><span class="line">            &#125;</span><br><span class="line">            count += holesize[i] * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>MAC OSX 10.1.4.6测试结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ll -s</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize1</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize1024</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize128</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize16</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize16384</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize2</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize2048</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize256</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize32</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize32768</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize4</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize4096</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize512</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize64</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize8</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize8192</span><br></pre></td></tr></table></figure>

<p>Mac OSX上创建不了空洞文件，因为默认的文件系统是HFS +，不支持稀疏文件</p>
<ul>
<li>Ubuntu18 4.15.0-60-generic测试结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ll -s</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize1</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize1024</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize128</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize16</span><br><span class="line">32 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize16384</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize2</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize2048</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize256</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize32</span><br><span class="line">32 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize32768</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize4</span><br><span class="line">32 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize4096</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize512</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize64</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize8</span><br><span class="line">32 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize8192</span><br></pre></td></tr></table></figure>

<p>4KB以上才实际创建空洞。<br>因为在linux的文件系统中，磁盘分配的最小物理单元为簇。(即使文件大小不足以占用满一簇，该簇空余的磁盘存储仍旧是该文件的)</p>
<p>所以可以根据这个性质，判断文件是否是空洞文件。有空洞的文件，用文件大小计算的block数至少比实际占用的block数大1个簇的block数</p>
<h2 id="如何可移植地获取簇的大小"><a href="#如何可移植地获取簇的大小" class="headerlink" title="如何可移植地获取簇的大小"></a>如何可移植地获取簇的大小</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pagesize = sysconf(_SC_PAGESIZE);</span><br></pre></td></tr></table></figure>

<h2 id="初步实现功能"><a href="#初步实现功能" class="headerlink" title="初步实现功能"></a>初步实现功能</h2><ul>
<li>源码</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_cp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1 = <span class="number">-1</span>, fd2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> rev = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *start_pos = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">long</span> pagesize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> blocks, blksize, size;</span><br><span class="line">    <span class="keyword">int</span> read_num, write_num, remain_num, current_pos = <span class="number">0</span>, last_zero = <span class="number">-1</span>, last_nonzero = <span class="number">-1</span>, have_holes = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    fd1 = open(from, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fd1)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open file1 faild&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fstat(fd1, &amp;st) !=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat: &quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SC_PAGESIZE</span></span><br><span class="line">        pagesize = sysconf(_SC_PAGESIZE);</span><br><span class="line">        <span class="keyword">if</span> (pagesize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EINVAL) &#123;</span><br><span class="line">                    <span class="built_in">fputs</span>(<span class="string">&quot; (not supported)\n&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">                    pagesize = st.st_blksize;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    perror(<span class="string">&quot;sysconf error&quot;</span>);</span><br><span class="line">                    <span class="keyword">goto</span> err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">&quot; (no limit)\n&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">                pagesize = st.st_blksize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pagesize: %ld\n&quot;</span>, pagesize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        pagesize = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        blocks = st.st_blocks;</span><br><span class="line">        blksize = st.st_blksize;</span><br><span class="line">        size = st.st_size;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st.st_blocks: %lld\n&quot;</span>, blocks);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st.st_blksize: %lld\n&quot;</span>, blksize);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st.st_size: %lld\n&quot;</span>, size);</span><br><span class="line">        <span class="comment">/*块大小512，在不同平台上可能不兼容*/</span></span><br><span class="line">        <span class="keyword">if</span>(S_ISREG(st.st_mode) &amp;&amp; (size / pagesize + (size%pagesize?<span class="number">1</span>:<span class="number">0</span>)) * pagesize &gt; <span class="number">512</span> * blocks) &#123;</span><br><span class="line">            have_holes = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s is a sparse-block file!\n&quot;</span>, from);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            have_holes = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s is not a sparse-block file!\n&quot;</span>, from);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fd2 = open(to, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">-1</span> == fd2) &#123;</span><br><span class="line">        perror (<span class="string">&quot;open file2 faild&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer = <span class="built_in">malloc</span>(pagesize);</span><br><span class="line">    <span class="keyword">if</span>(buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror (<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, pagesize);</span><br><span class="line">    <span class="keyword">while</span>((read_num = read(fd1, buffer, pagesize)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 源文件有空洞 */</span></span><br><span class="line">        <span class="keyword">if</span>(have_holes)&#123;</span><br><span class="line">            last_zero = <span class="number">-1</span>;</span><br><span class="line">            last_nonzero = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(current_pos = <span class="number">0</span>; current_pos &lt; read_num; current_pos++)&#123;</span><br><span class="line">                <span class="comment">/* 逐字节判断，效率较低*/</span></span><br><span class="line">                <span class="keyword">if</span>(buffer[current_pos] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(last_nonzero &gt; last_zero)&#123;</span><br><span class="line">                        remain_num = last_nonzero - last_zero;</span><br><span class="line">                        start_pos = buffer + last_zero + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">while</span>(remain_num)&#123;</span><br><span class="line">                            write_num = write(fd2, start_pos, remain_num);</span><br><span class="line">                            <span class="keyword">if</span> ( <span class="number">-1</span> == write_num)&#123;</span><br><span class="line">                                perror( <span class="string">&quot;write file2 error&quot;</span>);</span><br><span class="line">                                <span class="keyword">goto</span> err;</span><br><span class="line">                            &#125;</span><br><span class="line">                            remain_num -= write_num;</span><br><span class="line">                            start_pos += write_num;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    last_zero = current_pos;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(last_zero &gt; last_nonzero)&#123;</span><br><span class="line">                        remain_num = last_zero - last_nonzero;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="number">-1</span> == lseek(fd2, remain_num, SEEK_CUR))&#123;</span><br><span class="line">                            perror(<span class="string">&quot;lseek file2 fail&quot;</span>);</span><br><span class="line">                            <span class="keyword">goto</span> err;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    last_nonzero = current_pos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 处理最后剩余数据*/</span></span><br><span class="line">            remain_num = (last_nonzero &gt; last_zero)?(last_nonzero - last_zero):(last_zero - last_nonzero);</span><br><span class="line">            start_pos = buffer + current_pos - remain_num;</span><br><span class="line">            <span class="keyword">if</span>(last_nonzero &gt; last_zero)&#123;</span><br><span class="line">                <span class="keyword">while</span>(remain_num)&#123;</span><br><span class="line">                    write_num = write(fd2, start_pos, remain_num);</span><br><span class="line">                    <span class="keyword">if</span> ( <span class="number">-1</span> == write_num)&#123;</span><br><span class="line">                        perror( <span class="string">&quot;write file2 error&quot;</span>);</span><br><span class="line">                        <span class="keyword">goto</span> err;</span><br><span class="line">                    &#125;</span><br><span class="line">                        remain_num -= write_num;</span><br><span class="line">                        start_pos += write_num;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">-1</span> == lseek(fd2, remain_num, SEEK_CUR))&#123;</span><br><span class="line">                    perror(<span class="string">&quot;lseek file2 fail&quot;</span>);</span><br><span class="line">                    <span class="keyword">goto</span> err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 源文件无空洞 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            remain_num = read_num;</span><br><span class="line">            start_pos = buffer;</span><br><span class="line">            <span class="keyword">while</span>(remain_num)&#123;</span><br><span class="line">                write_num = write(fd2, start_pos, remain_num);</span><br><span class="line">                <span class="keyword">if</span> ( <span class="number">-1</span> == write_num)&#123;</span><br><span class="line">                    perror( <span class="string">&quot;write file2 error&quot;</span>);</span><br><span class="line">                    <span class="keyword">goto</span> err;</span><br><span class="line">                &#125;</span><br><span class="line">                remain_num -= write_num;</span><br><span class="line">                start_pos += write_num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == read_num) &#123;</span><br><span class="line">        perror(<span class="string">&quot;read file1 error&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    rev = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span>(buffer) <span class="built_in">free</span>(buffer);</span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s file1 file2\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    my_cp(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>测试结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ./my_cp holesize2048 holesize2048.cp</span><br><span class="line">pagesize: 4096</span><br><span class="line">st.st_blocks: 128</span><br><span class="line">st.st_blksize: 4096</span><br><span class="line">st.st_size: 65536</span><br><span class="line">holesize2048 is not a sparse-block file!</span><br><span class="line">chen@ubuntu18:~/study/apue.3e/exercises/4</span><br><span class="line">^_^$ ./my_cp holesize4096 holesize4096.cp</span><br><span class="line">pagesize: 4096</span><br><span class="line">st.st_blocks: 72</span><br><span class="line">st.st_blksize: 4096</span><br><span class="line">st.st_size: 65536</span><br><span class="line">holesize4096 is a sparse-block file!</span><br><span class="line"></span><br><span class="line">^_^$ ll -s</span><br><span class="line">total 1708</span><br><span class="line">64 -rw-r--r-- 1 chen chen  65536 1月   6 17:27 holesize2048</span><br><span class="line">64 -rw-r--r-- 1 chen chen  65536 1月   6 17:27 holesize2048.cp</span><br><span class="line">36 -rw-r--r-- 1 chen chen  65536 1月   6 17:27 holesize4096</span><br><span class="line">32 -rw-r--r-- 1 chen chen  65536 1月   6 17:27 holesize4096.cp</span><br></pre></td></tr></table></figure>

<p>空洞文件可以正常拷贝</p>
<h2 id="尝试优化程序"><a href="#尝试优化程序" class="headerlink" title="尝试优化程序"></a>尝试优化程序</h2><p>上面的程序仅在判断文件是否含有空洞时利用的空洞的最小限制。而在实际读写时并没有利用该性质。</p>
<p>这样较短的0字节也会当成是空洞，导致系统调用次数的增加，性能的降低</p>
<p>要优化性能，必须进一步探究空洞的性质。在什么样的情况下才创建空洞(不实际占用磁盘空间的块)？</p>
<ul>
<li>测试程序源码</li>
</ul>
<p>此程序创建了3个文件：</p>
<pre><code>- 文件1先`write`了1K的非零数据，然后`lseek` 7K-1字节。循环2次。
- 文件2先`write`了1K的非零数据，然后`lseek` 7K字节。循环2次
- 文件3先`write`了1K的非零数据，然后`lseek` 7K+1字节。循环2次
</code></pre>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> holesize[]=&#123;<span class="number">4096</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> filesize = <span class="number">64</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, fd1 = <span class="number">0</span>, fd2 = <span class="number">0</span>, fd3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> filename1[<span class="number">32</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> filename2[<span class="number">32</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> filename3[<span class="number">32</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">32</span>*<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">1</span>, <span class="number">32</span>*<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">for</span> (; i&lt; <span class="keyword">sizeof</span>(holesize)/ <span class="keyword">sizeof</span>(<span class="keyword">int</span>); ++i) &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(filename1, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">        <span class="built_in">memset</span>(filename2, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">        <span class="built_in">memset</span>(filename3, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(filename1, <span class="string">&quot;%s%d-1&quot;</span>, <span class="string">&quot;holesize&quot;</span>, holesize[i]);</span><br><span class="line">        <span class="built_in">sprintf</span>(filename2, <span class="string">&quot;%s%d-2&quot;</span>, <span class="string">&quot;holesize&quot;</span>, holesize[i]);</span><br><span class="line">        <span class="built_in">sprintf</span>(filename3, <span class="string">&quot;%s%d-3&quot;</span>, <span class="string">&quot;holesize&quot;</span>, holesize[i]);</span><br><span class="line">        fd1 = open(filename1, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">        fd2 = open(filename2, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">        fd3 = open(filename3, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">        <span class="keyword">if</span>(fd1 &lt; <span class="number">0</span> || fd2 &lt; <span class="number">0</span> || fd3 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;open file fail\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> remain = holesize[i] * <span class="number">1</span> / <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">while</span>(remain) &#123;</span><br><span class="line">                ret = write(fd1, buf, remain);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;write fail\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                remain -= ret;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = lseek(fd1, holesize[i] * <span class="number">7</span> / <span class="number">4</span> - <span class="number">1</span>, SEEK_CUR);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;lseek fail\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> remain = holesize[i] * <span class="number">1</span> / <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">while</span>(remain) &#123;</span><br><span class="line">                ret = write(fd2, buf, remain);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;write fail\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                remain -= ret;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = lseek(fd2, holesize[i] * <span class="number">7</span> / <span class="number">4</span>, SEEK_CUR);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;lseek fail\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> remain = holesize[i] * <span class="number">1</span> / <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">while</span>(remain) &#123;</span><br><span class="line">                ret = write(fd3, buf, remain);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;write fail\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                remain -= ret;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = lseek(fd3, holesize[i] * <span class="number">7</span> / <span class="number">4</span> + <span class="number">1</span>, SEEK_CUR);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;lseek fail\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd1);</span><br><span class="line">        close(fd2);</span><br><span class="line">        close(fd3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>测试结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ll -s</span><br><span class="line">12 -rw-r--r-- 1 chen chen  9215 1月   6 15:07 holesize4096-1</span><br><span class="line"> 8 -rw-r--r-- 1 chen chen  9216 1月   6 15:07 holesize4096-2</span><br><span class="line"> 8 -rw-r--r-- 1 chen chen  9217 1月   6 15:07 holesize4096-3</span><br></pre></td></tr></table></figure>

<p>可见空洞必须从一页的起始位置开始计算,并且等于或超过pagesize，才不占用实际磁盘空间</p>
<h2 id="优化后程序"><a href="#优化后程序" class="headerlink" title="优化后程序"></a>优化后程序</h2><ul>
<li>源码</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read_ex</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbyte)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> read_remain = nbyte;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *read_start = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf;</span><br><span class="line">    <span class="keyword">ssize_t</span> read_num = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> total_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(read_remain) &#123;</span><br><span class="line">        read_num = read(fd, read_start, read_remain);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == read_num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == read_num)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            read_remain -= read_num;</span><br><span class="line">            read_start += read_num;</span><br><span class="line">            total_num += read_num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write_ex</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbyte)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> write_remain = nbyte;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *write_start = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf;</span><br><span class="line">    <span class="keyword">ssize_t</span> write_num = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> total_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(write_remain) &#123;</span><br><span class="line">        write_num = write(fd, write_start, write_remain);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == write_num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            write_remain -= write_num;</span><br><span class="line">            write_start += write_num;</span><br><span class="line">            total_num += write_num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total_num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_cp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1 = <span class="number">-1</span>, fd2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> rev = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer = <span class="literal">NULL</span>, *buffer_zero = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">long</span> pagesize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> blocks, blksize, size;</span><br><span class="line">    <span class="keyword">int</span> read_num, write_num, write_remain, have_holes = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    fd1 = open(from, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fd1)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open file1 faild&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fstat(fd1, &amp;st) !=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat: &quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SC_PAGESIZE</span></span><br><span class="line">        pagesize = sysconf(_SC_PAGESIZE);</span><br><span class="line">        <span class="keyword">if</span> (pagesize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EINVAL) &#123;</span><br><span class="line">                    <span class="built_in">fputs</span>(<span class="string">&quot; (not supported)\n&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">                    pagesize = st.st_blksize;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    perror(<span class="string">&quot;sysconf error&quot;</span>);</span><br><span class="line">                    <span class="keyword">goto</span> err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">&quot; (no limit)\n&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">                pagesize = st.st_blksize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pagesize: %ld\n&quot;</span>, pagesize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        pagesize = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        blocks = st.st_blocks;</span><br><span class="line">        blksize = st.st_blksize;</span><br><span class="line">        size = st.st_size;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st.st_blocks: %lld\n&quot;</span>, blocks);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st.st_blksize: %lld\n&quot;</span>, blksize);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st.st_size: %lld\n&quot;</span>, size);</span><br><span class="line">        <span class="comment">/*块大小512，在不同平台上可能不兼容*/</span></span><br><span class="line">        <span class="keyword">if</span>(S_ISREG(st.st_mode) &amp;&amp; (size / pagesize + (size%pagesize?<span class="number">1</span>:<span class="number">0</span>)) * pagesize &gt; <span class="number">512</span> * blocks) &#123;</span><br><span class="line">            have_holes = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s is a sparse-block file!\n&quot;</span>, from);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            have_holes = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s is not a sparse-block file!\n&quot;</span>, from);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer = <span class="built_in">malloc</span>(pagesize);</span><br><span class="line">    buffer_zero = <span class="built_in">malloc</span>(pagesize);</span><br><span class="line">    <span class="keyword">if</span>(buffer == <span class="literal">NULL</span> || buffer_zero == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror (<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, pagesize);</span><br><span class="line">    <span class="built_in">memset</span>(buffer_zero, <span class="string">&#x27;\0&#x27;</span>, pagesize);</span><br><span class="line"></span><br><span class="line">    fd2 = open(to, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fd2) &#123;</span><br><span class="line">        perror (<span class="string">&quot;open file2 faild&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((read_num = read_ex(fd1, buffer, pagesize)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 读取到空洞 */</span></span><br><span class="line">        <span class="keyword">if</span>(have_holes &amp;&amp; !<span class="built_in">memcmp</span>(buffer_zero, buffer, read_num))&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">-1</span> == lseek(fd2, read_num, SEEK_CUR))&#123;</span><br><span class="line">                perror(<span class="string">&quot;lseek file2 fail&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 非空洞 */</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            write_num = write_ex(fd2, buffer, read_num);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">-1</span> == write_num)&#123;</span><br><span class="line">                perror( <span class="string">&quot;write file2 error&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == read_num)&#123;</span><br><span class="line">        perror(<span class="string">&quot;read file1 error&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    rev = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span>(buffer) <span class="built_in">free</span>(buffer);</span><br><span class="line">    <span class="keyword">if</span>(buffer_zero) <span class="built_in">free</span>(buffer_zero);</span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s file1 file2\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    my_cp(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>对比测试</li>
</ul>
<p>构造一个文件，除了开头一个空洞，其余数据为0x00,0x01的100000次重复</p>
<p>用优化前的程序拷贝该文件10000次，大约2000s</p>
<p>用优化后的程序拷贝该文件10000次，大约30s</p>
]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>UNIX</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现Lua--实现TAILCALL指令</title>
    <url>/posts/74970c0e/</url>
    <content><![CDATA[<div class="note primary">
            <p>最近在看《自己动手实现Lua—虚拟机、编译器和标准库》。这是本挺不错的书，通过学习此书能够对Lua语言有比较深刻的理解，此外还可以对如何自己实现一门脚本语言有直观的认识。对于想学习Lua的同学，安利一下这本书。</p><p>废话不多说，书中留了一个作业，让读者自己实现<code>TAILCALL</code>指令，实现尾调用的优化。本文就算是交作业吧。</p>
          </div>

<span id="more"></span>

<h1 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h1><p>尾调用，被调函数可以重用主调函数的调用帧，可以有效缓解调用栈溢出。</p>
<p>不过尾调用的条件非常苛刻，必须是直接返回函数调用。下面的是一个尾调用的例子，<code>TAILCALL</code>指令后面肯定紧跟着<code>RETURN</code>指令，并且<code>RETURN</code>指令的操作数A跟<code>TAILCALL</code>相同，<code>RETURN</code>指令的操作数B肯定是0。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ luac -l -</span><br><span class="line"><span class="built_in">return</span> f(a)</span><br><span class="line">^D</span><br><span class="line">main &lt;stdin:0,0&gt; (5 instructions at 0x7fa2b9d00070)</span><br><span class="line">0+ params, 2 slots, 1 upvalue, 0 locals, 2 constants, 0 <span class="built_in">functions</span></span><br><span class="line">	1	[1]	GETTABUP 	0 0 -1	; _ENV <span class="string">&quot;f&quot;</span></span><br><span class="line">	2	[1]	GETTABUP 	1 0 -2	; _ENV <span class="string">&quot;a&quot;</span></span><br><span class="line">	3	[1]	TAILCALL 	0 2 0</span><br><span class="line">	4	[1]	RETURN   	0 0</span><br><span class="line">	5	[1]	RETURN   	0 1</span><br></pre></td></tr></table></figure>



<p>下面几个例子，都不是尾调用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ luac -l -</span><br><span class="line"><span class="built_in">return</span> (f(a))</span><br><span class="line">^D</span><br><span class="line">main &lt;stdin:0,0&gt; (5 instructions at 0x7fb5a34035e0)</span><br><span class="line">0+ params, 2 slots, 1 upvalue, 0 locals, 2 constants, 0 <span class="built_in">functions</span></span><br><span class="line">	1	[1]	GETTABUP 	0 0 -1	; _ENV <span class="string">&quot;f&quot;</span></span><br><span class="line">	2	[1]	GETTABUP 	1 0 -2	; _ENV <span class="string">&quot;a&quot;</span></span><br><span class="line">	3	[1]	CALL     	0 2 2</span><br><span class="line">	4	[1]	RETURN   	0 2</span><br><span class="line">	5	[1]	RETURN   	0 1</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ luac -l -</span><br><span class="line"><span class="built_in">return</span> f(a)+1</span><br><span class="line">^D</span><br><span class="line">main &lt;stdin:0,0&gt; (6 instructions at 0x7f98c3d00070)</span><br><span class="line">0+ params, 2 slots, 1 upvalue, 0 locals, 3 constants, 0 <span class="built_in">functions</span></span><br><span class="line">	1	[1]	GETTABUP 	0 0 -1	; _ENV <span class="string">&quot;f&quot;</span></span><br><span class="line">	2	[1]	GETTABUP 	1 0 -2	; _ENV <span class="string">&quot;a&quot;</span></span><br><span class="line">	3	[1]	CALL     	0 2 2</span><br><span class="line">	4	[1]	ADD      	0 0 -3	; - 1</span><br><span class="line">	5	[1]	RETURN   	0 2</span><br><span class="line">	6	[1]	RETURN   	0 1</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ luac -l -</span><br><span class="line"><span class="built_in">return</span> &#123;f(a)&#125;</span><br><span class="line">^D</span><br><span class="line">main &lt;stdin:0,0&gt; (7 instructions at 0x7fb1b95006f0)</span><br><span class="line">0+ params, 3 slots, 1 upvalue, 0 locals, 2 constants, 0 <span class="built_in">functions</span></span><br><span class="line">	1	[1]	NEWTABLE 	0 0 0</span><br><span class="line">	2	[1]	GETTABUP 	1 0 -1	; _ENV <span class="string">&quot;f&quot;</span></span><br><span class="line">	3	[1]	GETTABUP 	2 0 -2	; _ENV <span class="string">&quot;a&quot;</span></span><br><span class="line">	4	[1]	CALL     	1 2 0</span><br><span class="line">	5	[1]	SETLIST  	0 0 1	; 1</span><br><span class="line">	6	[1]	RETURN   	0 2</span><br><span class="line">	7	[1]	RETURN   	0 1</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ luac -l -</span><br><span class="line"><span class="built_in">return</span> 1, f(a)</span><br><span class="line">^D</span><br><span class="line">main &lt;stdin:0,0&gt; (6 instructions at 0x7f8f9c500070)</span><br><span class="line">0+ params, 3 slots, 1 upvalue, 0 locals, 3 constants, 0 <span class="built_in">functions</span></span><br><span class="line">	1	[1]	LOADK    	0 -1	; 1</span><br><span class="line">	2	[1]	GETTABUP 	1 0 -2	; _ENV <span class="string">&quot;f&quot;</span></span><br><span class="line">	3	[1]	GETTABUP 	2 0 -3	; _ENV <span class="string">&quot;a&quot;</span></span><br><span class="line">	4	[1]	CALL     	1 2 0</span><br><span class="line">	5	[1]	RETURN   	0 0</span><br><span class="line">	6	[1]	RETURN   	0 1</span><br></pre></td></tr></table></figure>



<h1 id="CALL指令"><a href="#CALL指令" class="headerlink" title="CALL指令"></a>CALL指令</h1><p>我们先来看看普通的<code>CALL</code>指令的操作流程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1))</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">call</span><span class="params">(i Instruction, vm LuaVM)</span></span> &#123;</span><br><span class="line">    a, b, c := i.ABC()</span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// println(&quot;:::&quot;+ vm.StackToString())</span></span><br><span class="line">    nArgs := _pushFuncAndArgs(a, b, vm)</span><br><span class="line">    vm.Call(nArgs, c<span class="number">-1</span>)</span><br><span class="line">    _popResults(a, c, vm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先将位于寄存器中的函数和参数推入栈顶，然后调用<code>Call()</code>方法执行函数，最后将栈上的返回值出栈并放入指定寄存器中。</p>
<p><code>_pushFuncAndArgs()</code>和<code>_popResults()</code>分别要处理操作数B和操作数C为0的特殊情况。操作数B为0的情况，部分参数已经在栈上了（由前面的<code>CALL</code>指令或<code>VARARG</code>指令留在栈上）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">pushFuncAndArgs</span><span class="params">(a, b <span class="keyword">int</span>, vm LuaVM)</span> <span class="params">(nArgs <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b &gt;= <span class="number">1</span> &#123;</span><br><span class="line">        vm.CheckStack(b)</span><br><span class="line">        <span class="keyword">for</span> i := a; i &lt; a+b; i++ &#123;</span><br><span class="line">            vm.PushValue(i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _fixStack(a, vm)</span><br><span class="line">        <span class="keyword">return</span> vm.GetTop() - vm.RegisterCount() - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而操作数C为0的情况，则不需要将返回值从栈上弹出。直接将返回值留在栈上，供后面的指令使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">popResults</span><span class="params">(a, c <span class="keyword">int</span>, vm LuaVM)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// no results</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> c &gt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := a + c - <span class="number">2</span>; i &gt;= a; i-- &#123;</span><br><span class="line">            vm.Replace(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// leave results on stack</span></span><br><span class="line">        vm.CheckStack(<span class="number">1</span>)</span><br><span class="line">        vm.PushInteger(<span class="keyword">int64</span>(a))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们来看下<code>Call()</code>方法做了什么。它首先根据索引找到要调用的函数的值，检查它是否是闭包类型，如果不是直接报错。然后通过<code>callLuaClosure()</code>调用该函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [-(nargs+1), +nresults, e]</span></span><br><span class="line"><span class="comment">// http://www.lua.org/manual/5.3/manual.html#lua_call</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *luaState)</span> <span class="title">Call</span><span class="params">(nArgs, nResults <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    val := self.stack.get(-(nArgs + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">if</span> c, ok := val.(*closure); ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;call %s&lt;%d,%d&gt;\n&quot;</span>, c.proto.Source,</span><br><span class="line">            c.proto.LineDefined, c.proto.LastLineDefined)</span><br><span class="line">        self.callLuaClosure(nArgs, nResults, c)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;not function!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>callLuaClosure()</code>稍微有点复杂，来看下代码。首先从闭包的函数原型中获取到各种信息，如寄存器个数、固定参数个数、是否是vararg。接着创建一个新的调用帧，并将闭包与调用帧关联。然后将函数和参数值全部从主调帧栈顶弹出，并将固定参数压入被调帧栈顶，如果是vararg且参数个数大于固定参数个数，还要将vararg参数记录下来。</p>
<p>到这新帧就准备就绪了，将新帧推入调用栈顶，然后调用<code>runLuaClosure()</code>开始执行被调函数的指令。执行结束之后，被调帧的任务结束，将其弹出调用栈顶。</p>
<p>此时，返回值还留在被调帧的栈顶，需要移到主调帧栈顶。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *luaState)</span> <span class="title">callLuaClosure</span><span class="params">(nArgs, nResults <span class="keyword">int</span>, c *closure)</span></span> &#123;</span><br><span class="line">    nRegs := <span class="keyword">int</span>(c.proto.MaxStackSize)</span><br><span class="line">    nParams := <span class="keyword">int</span>(c.proto.NumParams)</span><br><span class="line">    isVararg := c.proto.IsVararg == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// create new lua stack</span></span><br><span class="line">    newStack := newLuaStack(nRegs + <span class="number">20</span>)</span><br><span class="line">    newStack.closure = c</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass args, pop func</span></span><br><span class="line">    funcAndArgs := self.stack.popN(nArgs + <span class="number">1</span>)</span><br><span class="line">    newStack.pushN(funcAndArgs[<span class="number">1</span>:], nParams)</span><br><span class="line">    newStack.top = nRegs</span><br><span class="line">    <span class="keyword">if</span> nArgs &gt; nParams &amp;&amp; isVararg &#123;</span><br><span class="line">        newStack.varargs = funcAndArgs[nParams+<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run closure</span></span><br><span class="line">    self.pushLuaStack(newStack)</span><br><span class="line">    self.runLuaClosure()</span><br><span class="line">    self.popLuaStack()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return results, nResults == c - 1</span></span><br><span class="line">    <span class="keyword">if</span> nResults != <span class="number">0</span> &#123;</span><br><span class="line">        results := newStack.popN(newStack.top - nRegs)</span><br><span class="line">        self.stack.check(<span class="built_in">len</span>(results))</span><br><span class="line">        self.stack.pushN(results, nResults)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现TAILCALL指令"><a href="#实现TAILCALL指令" class="headerlink" title="实现TAILCALL指令"></a>实现TAILCALL指令</h1><p>知道了<code>CALL</code>指令的流程，我们就可以着手实现<code>TAILCALL</code>指令了。其操作数A和操作数B的含义跟<code>CALL</code>指令完全一致，操作数C没用，相当于固定为0。所以<code>_pushFuncAndArgs()</code>和<code>_popResults()</code>函数可以重用，主要是修改中间的调用流程。我们首先给LuaVM新增一个接口<code>TailCall()</code>。</p>
<p>在<code>api/lua_vm.go</code>文件中添加如下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LuaVM <span class="keyword">interface</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    TailCall(nArgs <span class="keyword">int</span>)	<span class="comment">// add this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>因为<code>TAILCALL</code>指令后面紧跟着<code>RETURN</code>指令，且<code>RETURN</code>指令的操作数B为0，操作数A跟<code>TAILCALL</code>指令一样。所以<code>_popResults()</code>之后，我们啥都不用干，直接把返回值保留在栈上即可。</p>
<p>在<code>vm/inst_call.go</code>文件中修改<code>tailCall()</code>如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// return R(A)(R(A+1), ... ,R(A+B-1))</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tailCall</span><span class="params">(i Instruction, vm LuaVM)</span></span> &#123;</span><br><span class="line">    a, b, _ := i.ABC()</span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    nArgs := _pushFuncAndArgs(a, b, vm)</span><br><span class="line">    vm.TailCall(nArgs)</span><br><span class="line">    _popResults(a, <span class="number">0</span>, vm)</span><br><span class="line">    <span class="comment">// no need to _return() as ‘b’ of the following ‘RETURN’ is 0, </span></span><br><span class="line">    <span class="comment">// ‘a’ of ‘RETURN’ is same ‘as’ a of ‘TAILCALL’</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>state/api_call.go</code>文件中添加<code>TailCall()</code>代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [-(nargs+1), +nresults, e]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *luaState)</span> <span class="title">TailCall</span><span class="params">(nArgs <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    val := self.stack.get(-(nArgs + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">if</span> c, ok := val.(*closure); ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;tailcall %s&lt;%d,%d&gt;\n&quot;</span>, c.proto.Source,</span><br><span class="line">            c.proto.LineDefined, c.proto.LastLineDefined)</span><br><span class="line">        self.tailCallLuaClosure(nArgs, c)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;not function!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>tailCallLuaClosure()</code>中实现主要逻辑。在<code>state/api_call.go</code>文件中添加<code>tailCallLuaClosure()</code>代码如下。</p>
<p>首先同样是从闭包中获取函数原型的信息。因为当前帧在<code>TAILCALL</code>之后肯定跟着<code>RETURN</code>，所以保存参数之后可以直接清理掉当前帧的栈，然后直接给被调函数重用。将被调函数的信息设置到当前帧，先检查栈空间是否够，然后将当前帧关联到新的闭包，然后将固定参数推入栈顶，修改栈顶指针指向最后一个寄存器。如果是vararg且参数个数大于固定参数个数，还要将vararg参数记录下来。</p>
<p>一切就绪之后，就可以调用<code>runLuaClosure()</code>开始执行闭包的指令了。执行完毕后返回值保留在栈顶。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *luaState)</span> <span class="title">tailCallLuaClosure</span><span class="params">(nArgs <span class="keyword">int</span>, c *closure)</span></span> &#123;</span><br><span class="line">    nRegs := <span class="keyword">int</span>(c.proto.MaxStackSize)</span><br><span class="line">    nParams := <span class="keyword">int</span>(c.proto.NumParams)</span><br><span class="line">    isVararg := c.proto.IsVararg == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// store args</span></span><br><span class="line">    args := self.stack.popN(nArgs)</span><br><span class="line">    <span class="comment">// clean the stack</span></span><br><span class="line">    self.SetTop(<span class="number">0</span>)    </span><br><span class="line">    <span class="comment">// check if stack space is enough</span></span><br><span class="line">    self.stack.check(nRegs + <span class="number">20</span>)</span><br><span class="line">    <span class="comment">// substitue the closure to new one</span></span><br><span class="line">    self.stack.closure = c</span><br><span class="line">    <span class="comment">// push fixed args</span></span><br><span class="line">    self.stack.pushN(args[<span class="number">1</span>:], nParams)</span><br><span class="line">    self.stack.top = nRegs</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// store varargs</span></span><br><span class="line">    <span class="keyword">if</span> nArgs &gt; nParams &amp;&amp; isVararg &#123;</span><br><span class="line">        self.stack.varargs = args[nParams+<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run closure</span></span><br><span class="line">    self.runLuaClosure()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><p>我们重新编译Go代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$LUAGO</span>/go</span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="variable">$PWD</span>/ch08</span><br><span class="line"><span class="built_in">export</span> GOBIN=<span class="variable">$PWD</span>/ch08/bin</span><br><span class="line">go install luago</span><br></pre></td></tr></table></figure>

<p>然后来编写Lua脚本，我们编写了一个求和的函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(n, s, fun)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    s = s + n</span><br><span class="line">    <span class="keyword">return</span> fun(n<span class="number">-1</span>, s, fun)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">assert</span><span class="params">(v)</span></span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> v <span class="keyword">then</span> fail() <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v1 = sum(<span class="number">0</span>, <span class="number">0</span>, sum)</span><br><span class="line"><span class="built_in">assert</span>(v1 == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v2 = sum(<span class="number">1</span>, <span class="number">0</span>, sum)</span><br><span class="line"><span class="built_in">assert</span>(v2 == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v3 = sum(<span class="number">3</span>, <span class="number">0</span>, sum)</span><br><span class="line"><span class="built_in">assert</span>(v3 == <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v4 = sum(<span class="number">10</span>, <span class="number">0</span>, sum)</span><br><span class="line"><span class="built_in">assert</span>(v4 == <span class="number">55</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v5 = sum(<span class="number">10000</span>, <span class="number">0</span>, sum)</span><br><span class="line"><span class="built_in">assert</span>(v5 == <span class="number">50005000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v6 = sum(<span class="number">1000000</span>, <span class="number">0</span>, sum)</span><br><span class="line"><span class="built_in">assert</span>(v6 == <span class="number">500000500000</span>)</span><br></pre></td></tr></table></figure>

<p>先来看看<code>sum()</code>函数会被编译成什么指令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ luac -l -</span><br><span class="line"><span class="built_in">local</span> <span class="keyword">function</span> sum(n, s, fun)</span><br><span class="line">    <span class="keyword">if</span> n == 0 <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> s</span><br><span class="line">    end</span><br><span class="line">    s = s + n</span><br><span class="line">    <span class="built_in">return</span> fun(n-1, s, fun)</span><br><span class="line">end</span><br><span class="line">^D</span><br><span class="line">main &lt;stdin:0,0&gt; (2 instructions at 0x7fe071d00070)</span><br><span class="line">0+ params, 2 slots, 1 upvalue, 1 <span class="built_in">local</span>, 0 constants, 1 <span class="keyword">function</span></span><br><span class="line">	1	[7]	CLOSURE  	0 0	; 0x7fe071e00110</span><br><span class="line">	2	[7]	RETURN   	0 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> &lt;stdin:1,7&gt; (11 instructions at 0x7fe071e00110)</span><br><span class="line">3 params, 7 slots, 0 upvalues, 3 locals, 2 constants, 0 <span class="built_in">functions</span></span><br><span class="line">	1	[2]	EQ       	0 0 -1	; - 0</span><br><span class="line">	2	[2]	JMP      	0 1	; to 4</span><br><span class="line">	3	[3]	RETURN   	1 2</span><br><span class="line">	4	[5]	ADD      	1 1 0</span><br><span class="line">	5	[6]	MOVE     	3 2</span><br><span class="line">	6	[6]	SUB      	4 0 -2	; - 1</span><br><span class="line">	7	[6]	MOVE     	5 1</span><br><span class="line">	8	[6]	MOVE     	6 2</span><br><span class="line">	9	[6]	TAILCALL 	3 4 0</span><br><span class="line">	10	[6]	RETURN   	3 0</span><br><span class="line">	11	[7]	RETURN   	0 1</span><br></pre></td></tr></table></figure>

<p>可以看到的确是被编译成了<code>TAILCALL</code>，后面紧跟<code>RETURN</code>指令，且<code>RETURN</code>指令的操作数A与<code>TAILCALL</code>相同，操作数B为0。</p>
<p>我们编译Lua脚本，然后用我们的虚拟机进行执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">luac ../lua/ch08/tailcall.lua</span><br><span class="line">./ch08/bin/luago  luac.out</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;0,0&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;9,11&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;9,11&gt;</span><br><span class="line">panic: GETTABUP</span><br></pre></td></tr></table></figure>

<p>哦哦，执行失败了，残念！</p>
<p>于是加日志进行问题排查，把指令执行时的栈打出来</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开</div></div><div class="fold">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">call @../lua/ch08/tailcall.lua&lt;0,0&gt;</span><br><span class="line">CLOSURE  	0 0	[nil][nil][nil][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">CLOSURE  	1 1	[<span class="keyword">function</span>][nil][nil][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	2 0	[<span class="keyword">function</span>][<span class="keyword">function</span>][nil][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">LOADK    	3 -1	[<span class="keyword">function</span>][<span class="keyword">function</span>][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">LOADK    	4 -1	[<span class="keyword">function</span>][<span class="keyword">function</span>][<span class="keyword">function</span>][0][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	5 0	[<span class="keyword">function</span>][<span class="keyword">function</span>][<span class="keyword">function</span>][0][0][nil][nil]</span><br><span class="line"></span><br><span class="line">CALL     	2 4 2	[<span class="keyword">function</span>][<span class="keyword">function</span>][<span class="keyword">function</span>][0][0][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">EQ       	0 0 -1	[0][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">RETURN   	1 2	[0][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">RETURN   	after 	[0][0][<span class="keyword">function</span>][nil][nil][nil][nil][0]</span><br><span class="line"></span><br><span class="line">CALL     	after 	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][0][0][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	3 1	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][0][0][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">EQ       	1 2 -1	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][<span class="keyword">function</span>][0][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">JMP      	0 1	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][<span class="keyword">function</span>][0][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">LOADBOOL 	4 1 0	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][<span class="keyword">function</span>][0][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">CALL     	3 2 1	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][<span class="keyword">function</span>][<span class="literal">true</span>][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;9,11&gt;</span><br><span class="line">TEST     	0 1	[<span class="literal">true</span>][nil]</span><br><span class="line"></span><br><span class="line">JMP      	0 2	[<span class="literal">true</span>][nil]</span><br><span class="line"></span><br><span class="line">RETURN   	0 1	[<span class="literal">true</span>][nil]</span><br><span class="line"></span><br><span class="line">RETURN   	after 	[<span class="literal">true</span>][nil]</span><br><span class="line"></span><br><span class="line">CALL     	after 	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][<span class="keyword">function</span>][<span class="literal">true</span>][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	3 0	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][<span class="keyword">function</span>][<span class="literal">true</span>][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">LOADK    	4 -2	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][<span class="keyword">function</span>][<span class="literal">true</span>][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">LOADK    	5 -1	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][<span class="keyword">function</span>][1][<span class="keyword">function</span>][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	6 0	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][<span class="keyword">function</span>][1][0][nil]</span><br><span class="line"></span><br><span class="line">CALL     	3 4 2	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][<span class="keyword">function</span>][1][0][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">EQ       	0 0 -1	[1][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">JMP      	0 1	[1][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">ADD      	1 1 0	[1][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	3 2	[1][1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">SUB      	4 0 -2	[1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	5 1	[1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][0][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	6 2	[1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][0][1][nil]</span><br><span class="line"></span><br><span class="line">TAILCALL 	3 4 0	[1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][0][1][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">RETURN   	3 0	[1][<span class="keyword">function</span>][nil][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">RETURN   	after 	[1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">TAILCALL 	after 	[1][<span class="keyword">function</span>][nil][nil][nil][nil][4]</span><br><span class="line"></span><br><span class="line">RETURN   	0 1	[1][<span class="keyword">function</span>][nil][nil][nil][nil][4]</span><br><span class="line"></span><br><span class="line">RETURN   	after 	[1][<span class="keyword">function</span>][nil][nil][nil][nil][4]</span><br><span class="line"></span><br><span class="line">CALL     	after 	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][nil][1][0][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">MOVE     	4 1	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][nil][1][0][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">EQ       	1 3 -2	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][nil][<span class="keyword">function</span>][0][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">LOADBOOL 	5 0 1	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][nil][<span class="keyword">function</span>][0][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">CALL     	4 2 1	[<span class="keyword">function</span>][<span class="keyword">function</span>][0][nil][<span class="keyword">function</span>][<span class="literal">false</span>][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;9,11&gt;</span><br><span class="line">TEST     	0 1	[<span class="literal">false</span>][nil]</span><br><span class="line"></span><br><span class="line">GETTABUP 	1 0 -1	[<span class="literal">false</span>][nil]</span><br><span class="line"></span><br><span class="line">panic: GETTABUP</span><br></pre></td></tr></table></figure>

</div></div>

<p>我们发现在<code>TAILCALL</code>开始执行之后立马调用了<code>RETURN</code>，问题就是出在这里，我们虽然替换了当前帧的闭包为被调函数的闭包，但是忘了更新pc。于是修改<code>tailCallLuaClosure()</code>初始化pc为0。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *luaState)</span> <span class="title">tailCallLuaClosure</span><span class="params">(nArgs <span class="keyword">int</span>, c *closure)</span></span> &#123;</span><br><span class="line">    <span class="comment">// substitue the closure to new one</span></span><br><span class="line">    self.stack.closure = c</span><br><span class="line">    self.stack.pc = <span class="number">0</span> <span class="comment">// add this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新编译之后测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go install luago</span><br><span class="line">$ ./ch08/bin/luago  luac.out</span><br><span class="line">...	<span class="comment"># 省略前面的日志</span></span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">EQ       	0 0 -1	[1][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">JMP      	0 1	[1][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">ADD      	1 1 0	[1][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	3 2	[1][1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">SUB      	4 0 -2	[1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	5 1	[1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][0][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE     	6 2	[1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][0][1][nil]</span><br><span class="line"></span><br><span class="line">TAILCALL 	3 4 0	[1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][0][1][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">EQ       	0 0 -1	[1][<span class="keyword">function</span>][nil][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">JMP      	0 1	[1][<span class="keyword">function</span>][nil][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">ADD      	1 1 0	[1][<span class="keyword">function</span>][nil][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">panic: arithmetic error!</span><br></pre></td></tr></table></figure>

<p>哦哦，又执行失败了🤷‍♂️！查看打印的栈信息，<code>TAILCALL</code>指令执行之前栈的情况是正常的，三个参数都已经推入栈顶<code>[0][1][function]</code>，但是执行<code>EQ</code>指令前栈中却少了一个参数，只有<code>[1][function]</code>。于是检查代码，原来是数组索引搞错了，Go的起始索引是0，跟Lua搞混了🤷‍♂️。。。</p>
<p>修改<code>tailCallLuaClosure()</code>如下之后</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *luaState)</span> <span class="title">tailCallLuaClosure</span><span class="params">(nArgs <span class="keyword">int</span>, c *closure)</span></span> &#123;</span><br><span class="line">    nRegs := <span class="keyword">int</span>(c.proto.MaxStackSize)</span><br><span class="line">    nParams := <span class="keyword">int</span>(c.proto.NumParams)</span><br><span class="line">    isVararg := c.proto.IsVararg == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// store args</span></span><br><span class="line">    args := self.stack.popN(nArgs)</span><br><span class="line">    <span class="comment">// clean the stack</span></span><br><span class="line">    self.SetTop(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// check if stack space is enough</span></span><br><span class="line">    self.stack.check(nRegs + <span class="number">20</span>)</span><br><span class="line">    <span class="comment">// substitue the closure to new one</span></span><br><span class="line">    self.stack.closure = c</span><br><span class="line">    self.stack.pc = <span class="number">0</span></span><br><span class="line">    <span class="comment">// push fixed args</span></span><br><span class="line">    self.stack.pushN(args, nParams)</span><br><span class="line">    self.stack.top = nRegs</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store varargs</span></span><br><span class="line">    <span class="keyword">if</span> nArgs &gt; nParams &amp;&amp; isVararg &#123;</span><br><span class="line">        self.stack.varargs = args[nParams:]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run closure</span></span><br><span class="line">    self.runLuaClosure()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新编译，然后继续执行，程序进入了死循环。。。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开</div></div><div class="fold">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go install luago</span><br><span class="line">$ ./ch08/bin/luago  luac.out</span><br><span class="line">...	<span class="comment"># 程序停不下来了。。。</span></span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">EQ          0 0 -1  [1][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">JMP         0 1 [1][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">ADD         1 1 0   [1][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE        3 2 [1][1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">SUB         4 0 -2  [1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE        5 1 [1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][0][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE        6 2 [1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][0][1][nil]</span><br><span class="line"></span><br><span class="line">TAILCALL    3 4 0   [1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][0][1][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">EQ          0 0 -1  [0][1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">RETURN      1 2 [0][1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">RETURN      after   [0][1][<span class="keyword">function</span>][nil][nil][nil][nil][1]</span><br><span class="line"></span><br><span class="line">TAILCALL    after   [0][1][<span class="keyword">function</span>][nil][nil][nil][nil][1][4]</span><br><span class="line"></span><br><span class="line">ADD         1 1 0   [0][1][<span class="keyword">function</span>][nil][nil][nil][nil][1][4]</span><br><span class="line"></span><br><span class="line">MOVE        3 2 [0][1][<span class="keyword">function</span>][nil][nil][nil][nil][1][4]</span><br><span class="line"></span><br><span class="line">SUB         4 0 -2  [0][1][<span class="keyword">function</span>][<span class="keyword">function</span>][nil][nil][nil][1][4]</span><br><span class="line"></span><br><span class="line">MOVE        5 1 [0][1][<span class="keyword">function</span>][<span class="keyword">function</span>][-1][nil][nil][1][4]</span><br><span class="line"></span><br><span class="line">MOVE        6 2 [0][1][<span class="keyword">function</span>][<span class="keyword">function</span>][-1][1][nil][1][4]</span><br><span class="line"></span><br><span class="line">TAILCALL    3 4 0   [0][1][<span class="keyword">function</span>][<span class="keyword">function</span>][-1][1][<span class="keyword">function</span>][1][4]</span><br><span class="line">EQ          0 0 -1  [-1][1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">JMP         0 1 [-1][1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">ADD         1 1 0   [-1][1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE        3 2 [-1][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">SUB         4 0 -2  [-1][0][<span class="keyword">function</span>][<span class="keyword">function</span>][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE        5 1 [-1][0][<span class="keyword">function</span>][<span class="keyword">function</span>][-2][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE        6 2 [-1][0][<span class="keyword">function</span>][<span class="keyword">function</span>][-2][0][nil]</span><br><span class="line"></span><br><span class="line">TAILCALL    3 4 0   [-1][0][<span class="keyword">function</span>][<span class="keyword">function</span>][-2][0][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">EQ          0 0 -1  [-2][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">JMP         0 1 [-2][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">ADD         1 1 0   [-2][0][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE        3 2 [-2][-2][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">SUB         4 0 -2  [-2][-2][<span class="keyword">function</span>][<span class="keyword">function</span>][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE        5 1 [-2][-2][<span class="keyword">function</span>][<span class="keyword">function</span>][-3][nil][nil]</span><br><span class="line"></span><br><span class="line">MOVE        6 2 [-2][-2][<span class="keyword">function</span>][<span class="keyword">function</span>][-3][-2][nil]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

</div></div>

<p>观察到在<code>TAILCALL</code>结束之后，又继续执行<code>RETURN</code>指令后面的<code>ADD</code>指令了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TAILCALL    3 4 0   [1][1][<span class="keyword">function</span>][<span class="keyword">function</span>][0][1][<span class="keyword">function</span>]</span><br><span class="line"></span><br><span class="line">EQ          0 0 -1  [0][1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">RETURN      1 2 [0][1][<span class="keyword">function</span>][nil][nil][nil][nil]</span><br><span class="line"></span><br><span class="line">RETURN      after   [0][1][<span class="keyword">function</span>][nil][nil][nil][nil][1]</span><br><span class="line"></span><br><span class="line">TAILCALL    after   [0][1][<span class="keyword">function</span>][nil][nil][nil][nil][1][4]</span><br><span class="line"></span><br><span class="line">ADD         1 1 0   [0][1][<span class="keyword">function</span>][nil][nil][nil][nil][1][4]</span><br></pre></td></tr></table></figure>

<p>正常在执行第3条指令<code>RETURN</code>之后就应该返回上层了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> &lt;../lua/ch08/tailcall.lua:1,7&gt; (11 instructions at 0x7fd783c03070)</span><br><span class="line">3 params, 7 slots, 0 upvalues, 3 locals, 2 constants, 0 <span class="built_in">functions</span></span><br><span class="line">	1	[2]	EQ       	0 0 -1	; - 0</span><br><span class="line">	2	[2]	JMP      	0 1	; to 4</span><br><span class="line">	3	[3]	RETURN   	1 2</span><br><span class="line">	4	[5]	ADD      	1 1 0</span><br><span class="line">	5	[6]	MOVE     	3 2</span><br><span class="line">	6	[6]	SUB      	4 0 -2	; - 1</span><br><span class="line">	7	[6]	MOVE     	5 1</span><br><span class="line">	8	[6]	MOVE     	6 2</span><br><span class="line">	9	[6]	TAILCALL 	3 4 0</span><br><span class="line">	10	[6]	RETURN   	3 0</span><br><span class="line">	11	[7]	RETURN   	0 1</span><br></pre></td></tr></table></figure>



<p>猛然想到，之前把<code>RETURN</code>语句给略过了，虽然在返回值的处理上是没有问题，但是外层帧依赖<code>RETURN</code>指令来结束</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *luaState)</span> <span class="title">runLuaClosure</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> inst.Opcode() == vm.OP_RETURN &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们修改<code>runLuaClosure()</code>，使<code>TAILCALL</code>指令执行之后也结束。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *luaState)</span> <span class="title">runLuaClosure</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">if</span> inst.Opcode() == vm.OP_RETURN || inst.Opcode() == vm.OP_TAILCALL &#123;</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个地方需要修改，因为我们省略了<code>RETURN</code>指令，所以<code>tailCall()</code>里的<code>_popResults()</code>也就不需要了，否则栈上会多出一个值。<code>_popResults()</code>会推一个整数值（即a）到栈顶指示返回值起始的寄存器位置，相应的在<code>RETURN</code>指令的时候会把这个整数值弹出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// return R(A)(R(A+1), ... ,R(A+B-1))</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tailCall</span><span class="params">(i Instruction, vm LuaVM)</span></span> &#123;</span><br><span class="line">    a, b, _ := i.ABC()</span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// todo: optimize tail call!</span></span><br><span class="line">    nArgs := _pushFuncAndArgs(a, b, vm)</span><br><span class="line">    vm.TailCall(nArgs)</span><br><span class="line">    <span class="comment">// _popResults(a, 0, vm)</span></span><br><span class="line">    <span class="comment">// no need to _return() as ‘b’ of the following ‘RETURN’ is 0, </span></span><br><span class="line">    <span class="comment">// ‘a’ of ‘RETURN’ is same ‘as’ a of ‘TAILCALL’</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>重新编译执行，这回终于大功告成了！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go install luago</span><br><span class="line">$ ./ch08/bin/luago  luac.out</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;0,0&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;9,11&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;9,11&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;9,11&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;9,11&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;9,11&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;1,7&gt;</span><br><span class="line">call @../lua/ch08/tailcall.lua&lt;9,11&gt;</span><br></pre></td></tr></table></figure>



<p>我们再来试试可变参数的情况，修改Lua脚本如下</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(n, s, fun, ...)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> args = &#123;...&#125;</span><br><span class="line">    <span class="keyword">if</span> args[n] <span class="keyword">then</span></span><br><span class="line">        s = s + args[n]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> fun(n<span class="number">-1</span>, s, fun, ...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">assert</span><span class="params">(v)</span></span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> v <span class="keyword">then</span> fail() <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v1 = sum(<span class="number">0</span>, <span class="number">0</span>, sum)</span><br><span class="line"><span class="built_in">assert</span>(v1 == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v2 = sum(<span class="number">1</span>, <span class="number">0</span>, sum, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">assert</span>(v2 == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v3 = sum(<span class="number">3</span>, <span class="number">0</span>, sum, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">assert</span>(v3 == <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v4 = sum(<span class="number">3</span>, <span class="number">0</span>, sum, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">assert</span>(v4 == <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> v3 = sum(<span class="number">3</span>, <span class="number">0</span>, sum, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">assert</span>(v3 == <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>编译Lua脚本，执行测试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ luac ../lua/ch08/tailcall2.lua</span><br><span class="line">$ ./ch08/bin/luago  luac.out</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;0,0&gt;</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;1,10&gt;</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;12,14&gt;</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;1,10&gt;</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;12,14&gt;</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;1,10&gt;</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;12,14&gt;</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;1,10&gt;</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;12,14&gt;</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;1,10&gt;</span><br><span class="line">call @../lua/ch08/tailcall2.lua&lt;12,14&gt;</span><br></pre></td></tr></table></figure>

<p>也没有问题✌️</p>
]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua中如何实现类似gdb的断点调试—08支持通过包名称添加断点</title>
    <url>/posts/5c25711/</url>
    <content><![CDATA[<div class="note primary">
            <p>在前一篇中我们支持了通过函数名称来添加断点，我们同时也提到了在Lua中一个函数的名称的并不是确定的。准确的说，Lua中的函数并没有名称，所谓名称其实是保存这个函数值的变量的名称。</p><p>于是通过函数名称添加断点就造成了一定的不确定性，因为函数被调用时并不一定是以这个名字被调用的。另外，多个不同的函数也可能以相同的名字进行调用。</p><p>所以为了解决这个问题，本篇我们将继续扩展断点的设置接口，支持通过包名来添加断点。因为包名相对更具确定性，配合行号可以进行精确定位。</p>
          </div>

<span id="more"></span>

<p>源码已经上传<a href="https://github.com/catbro666/lua-debugger">Github</a>，欢迎watch/star😘。</p>
<h2 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h2><h3 id="为何选用包名的方式"><a href="#为何选用包名的方式" class="headerlink" title="为何选用包名的方式"></a>为何选用包名的方式</h3><p>其实一开始的想法并不是通过包名来添加断点，而是通过源文件名。但是源文件名同样存在重复的可能，我们只能考虑使用类似后缀匹配这种模糊的方式进行查找。这样的话，每个call事件中都需要对通过源文件名设置的断点表进行遍历。</p>
<p>使用绝对路径虽然可以解决重复的问题，但是使用上不方便，在添加断点的时候也不一定知道源文件的具体位置，况且<code>short_src</code>也不一定是绝对路径。</p>
<p>所以出于性能及易用性的考虑，采用了通过包名来设置断点的方式，这样就可以利用Lua本身的包名搜索机制，使用搜索包路径的方法<code>package.searchpackage()</code>将包名转成路径。而这个路径就是<code>debug.getinfo</code>获取到的调试信息中的<code>short_src</code>。</p>
<p>下面是一个例子：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">package</span>.searchpath( <span class="string">&quot;foo.bar.baz&quot;</span>, <span class="built_in">package</span>.<span class="built_in">path</span> )</span><br><span class="line"><span class="comment">--&gt; (e.g.) &quot;/usr/share/lua/5.3/foo/bar/baz.lua&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="断点的保存解析和查找"><a href="#断点的保存解析和查找" class="headerlink" title="断点的保存解析和查找"></a>断点的保存解析和查找</h3><p>跟上一篇中通过函数名称添加的断点不同的是，通过包名添加的断点都是确定的，所以最终都可以将其转换为函数的断点。但是只有当执行过该函数之后，我们才能获取到该函数的相关信息，进行断点的转换，所以在此之前我们需要将它们临时存放在一个表中，跟之前的<code>status.funcbpt</code>、<code>status.namebpt</code>类似，我们把这个表定义为<code>status.srcbpt</code>。</p>
<p>当执行到该函数之后，我们就可以将<code>status.srcbpt</code>中对应的断点转移到<code>status.funcbpt</code>表中，后续就可以通过普通函数断点的方式进行处理了。</p>
<p>为了提升性能，我们可以将之前执行过的函数的信息保存下来，后续再（通过包名方式）在相同的函数中添加断点时，就可以快速地确定其所在函数，直接在添加断点的时候就转换为普通函数断点了，而不需要推迟到后面进行查找比对转换了。之前我们已经有了一个保存函数信息的表<code>status.funcinfos</code>，但是那个表是以函数作为键，而这里我们需要通过源文件路径进行查找，所以需要新的数据结构。</p>
<h3 id="解决断点歧义"><a href="#解决断点歧义" class="headerlink" title="解决断点歧义"></a>解决断点歧义</h3><p>通过包名添加断点存在着一种歧义的情况：当断点落在函数定义的范围之内时，它是表示对mainchunk中的函数声明添加断点，还是表示在该子函数执行时添加断点。（本质上是因为mainchunk的有效行和子函数有效行存在重叠）</p>
<p>所以为了优雅地解决这个歧义问题，我们使用行号的正负表示是在mainchunk中还是在子函数中添加断点。如果行号是正数，表示子函数，跟前几篇中的情况保持一致；如果行号是负数，则表示在mainchunk中添加断点。</p>
<p>好了，解决了最关键的几个问题，我们就可以开始着手写代码了</p>
<h2 id="添加断点"><a href="#添加断点" class="headerlink" title="添加断点"></a>添加断点</h2><p>同样依照惯例，我们先修改设置断点函数。它的改动较大，因为函数名称和包名称都是通过字符串参数指定，所以需要一个区分手段，我们这里采用了一个跟在名称后面的特殊字符来进行区分。如果后面跟的是<code>@</code>，表示是函数名称，如果后面跟的是<code>:</code>，表示是包名。</p>
<p>先来看通过包名添加断点的情况，首先查找标记符号<code>:</code>，如果找到则前面部分表示包名，后面部分表示行号。切分之后，检查包名是否为空，再检查行号是否合法。如果没有指定行号，那么默认设置为-1，也就是mainchunk的第一行。接下来调用<code>package.searchpath()</code>将包名转化为路径，如果找到了指定的包，再通过<code>setsrcbp()</code>函数来设置断点。<code>setsrcbp()</code>我们稍后介绍。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setbreakpoint</span><span class="params">(where, line)</span></span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(where) == <span class="string">&quot;function&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> setfuncbp(where, line)</span><br><span class="line">    <span class="keyword">else</span>            <span class="comment">-- &quot;string&quot;</span></span><br><span class="line">        <span class="keyword">local</span> i = <span class="built_in">string</span>.<span class="built_in">find</span>(where, <span class="string">&quot;:&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">then</span>   <span class="comment">-- package name</span></span><br><span class="line">            <span class="keyword">local</span> packname = <span class="built_in">string</span>.<span class="built_in">sub</span>(where, <span class="number">1</span>, i<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">local</span> line = <span class="built_in">string</span>.<span class="built_in">sub</span>(where, i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> packname == <span class="string">&quot;&quot;</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;no package name specified!\n&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> line ~= <span class="string">&quot;&quot;</span> <span class="keyword">then</span></span><br><span class="line">                line = <span class="built_in">tonumber</span>(line)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> line <span class="keyword">then</span></span><br><span class="line">                    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;no valid line number specified!\n&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                line = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">local</span> <span class="built_in">path</span>, err = <span class="built_in">package</span>.searchpath(packname, <span class="built_in">package</span>.<span class="built_in">path</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">path</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">io</span>.<span class="built_in">write</span>(err)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">return</span> setsrcbp(<span class="built_in">path</span>, line)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>通过函数名称添加断点的情况也是类似，不过省了路径转换的步骤。首先查找标记符号<code>@</code>，然后切分函数名和行号，检查函数名是否为空，检查行号是否合法，都ok之后再交给<code>setnamebp()</code>进行后面的工作。<code>setnamebp()</code>函数我们在上一篇已经介绍过了。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setbreakpoint</span><span class="params">(where, line)</span></span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">local</span> i = <span class="built_in">string</span>.<span class="built_in">find</span>(where, <span class="string">&quot;@&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">then</span>   <span class="comment">-- function name</span></span><br><span class="line">                <span class="keyword">local</span> funcname = <span class="built_in">string</span>.<span class="built_in">sub</span>(where, <span class="number">1</span>, i<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">local</span> line = <span class="built_in">string</span>.<span class="built_in">sub</span>(where, i+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> funcname == <span class="string">&quot;&quot;</span> <span class="keyword">then</span></span><br><span class="line">                    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;no function name specified!\n&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">if</span> line ~= <span class="string">&quot;&quot;</span> <span class="keyword">then</span></span><br><span class="line">                    line = <span class="built_in">tonumber</span>(line)</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> line <span class="keyword">then</span></span><br><span class="line">                        <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;no valid line number specified!\n&quot;</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    line = <span class="literal">nil</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">return</span> setnamebp(funcname, line)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>下面我们来看<code>setsrcbp()</code>函数的实现，这个函数跟<code>setnamebp()</code>大体上类似，开头部分稍有不同。首先会通过<code>lookforfunc()</code>查看断点是否位于已知函数中，如果是的话返回该函数，然后直接调用<code>setfuncbp()</code>函数作为函数断点处理。<code>lookforfunc()</code>我们稍晚一点再介绍。后面的流程跟<code>setnamebp()</code>并无二致就不再赘述。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setsrcbp</span><span class="params">(src, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 检查断点是否位于已知函数中</span></span><br><span class="line">    <span class="keyword">local</span> func = lookforfunc(src, line)</span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> setfuncbp(func, line)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> srcbp = s.srcbpt[src]</span><br><span class="line">    <span class="comment">-- 检查相同的断点是否已经设置</span></span><br><span class="line">    <span class="keyword">if</span> srcbp <span class="keyword">and</span> srcbp[line] <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> srcbp[line]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>钩子函数的改动都是在call事件中。首先，在获取到当前函数及其信息之后，调用<code>solvesrcbp()</code>处理<code>status.srcbpt</code>表中还未转换的断点，如果发现有位于当前函数中的断点，那么就进行相应的断点转换。接下来，如果当前函数不是C函数，就调用<code>setsrcfunc()</code>函数保存函数信息。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hook</span> <span class="params">(event, line)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">&quot;call&quot;</span> <span class="keyword">or</span> event == <span class="string">&quot;tail call&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> stackinfo = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>, <span class="string">&quot;nf&quot;</span>)</span><br><span class="line">        <span class="keyword">local</span> func = stackinfo.func</span><br><span class="line">        <span class="keyword">local</span> name = stackinfo.name</span><br><span class="line">        <span class="keyword">local</span> funcinfo = getfuncinfo(func)</span><br><span class="line">        <span class="keyword">local</span> hasbreak = <span class="literal">false</span></span><br><span class="line">        <span class="comment">-- 处理通过包名添加的还未转换的断点</span></span><br><span class="line">        solvesrcbp(funcinfo, func)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> funcinfo.what ~= <span class="string">&quot;C&quot;</span> <span class="keyword">then</span></span><br><span class="line">            setsrcfunc(funcinfo, func)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> s.funcbpt[func] <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> id = s.funcbpt[func]</span><br><span class="line">            <span class="keyword">if</span> s.bptable[id] <span class="keyword">and</span> <span class="keyword">not</span> s.bptable[id].src <span class="keyword">then</span></span><br><span class="line">                s.bptable[id].src = funcinfo.short_src</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            hasbreak = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="断点转换"><a href="#断点转换" class="headerlink" title="断点转换"></a>断点转换</h2><p>接下来看下<code>solvesrcbp()</code>函数的实现，如果当前源文件中存在未转换的断点，那么遍历这些断点，调用<code>verifyfuncline()</code>判断断点是否在当前函数中，如果是的话就调用<code>modsrcbp()</code>函数进行实际的转换操作。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">solvesrcbp</span> <span class="params">(info, func)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">local</span> srcbp = s.srcbpt[info.short_src]</span><br><span class="line">    <span class="keyword">if</span> srcbp <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(srcbp) <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> k ~= <span class="string">&quot;num&quot;</span> <span class="keyword">then</span></span><br><span class="line">                line = verifyfuncline(info, k)</span><br><span class="line">                <span class="keyword">if</span> line <span class="keyword">then</span></span><br><span class="line">                    modsrcbp(info.short_src, func, k, line)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p><code>modsrcbp()</code>函数的实现如下，它有4个参数第一个<code>src</code>是源文件路径、第二个<code>func</code>是函数、第三个<code>oline</code>是设置断点时的行号、第四个<code>nline</code>是<code>verifyfuncline()</code>进行修正后的行号。</p>
<p>该函数首先以<code>src</code>和<code>oline</code>为索引将断点从<code>status.srcbpt</code>表中移除，然后设置到<code>status.funcbpt</code>表中。如果同一个断点已经设置过了，那么将新添加的断点删除，然后返回旧的断点id。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">modsrcbp</span><span class="params">(src, func, oline, nline)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">local</span> srcbp = s.srcbpt[src]</span><br><span class="line">    <span class="keyword">local</span> id = srcbp[oline]</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 从srcbpt中移除</span></span><br><span class="line">    srcbp.num = srcbp.num - <span class="number">1</span></span><br><span class="line">    srcbp[oline] = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> srcbp.num == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        srcbp = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 设置funcbpt</span></span><br><span class="line">    <span class="keyword">local</span> funcbp = s.funcbpt[func]</span><br><span class="line">    <span class="comment">-- 检查是否已经设置了相同的断点</span></span><br><span class="line">    <span class="keyword">if</span> funcbp <span class="keyword">and</span> funcbp[nline] <span class="keyword">then</span></span><br><span class="line">        s.bptable[id] = <span class="literal">nil</span>      <span class="comment">-- 如果已经设置了，删除新加的断点</span></span><br><span class="line">        s.bpnum = s.bpnum - <span class="number">1</span></span><br><span class="line">        <span class="built_in">assert</span>(s.bpnum &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> funcbp[nline]     <span class="comment">-- 返回旧的断点id</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>如果还未添加过这个断点，那么就在<code>status.funcbpt</code>中添加该断点，然后将断点所在的函数和修正后的行号更新到<code>s.bptable</code>表中。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">modsrcbp</span><span class="params">(src, func, oline, nline)</span></span></span><br><span class="line">    <span class="comment">-- 省略</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> funcbp <span class="keyword">then</span>            <span class="comment">-- 该函数的第一个断点</span></span><br><span class="line">        s.funcbpt[func] = &#123;&#125;</span><br><span class="line">        funcbp = s.funcbpt[func]</span><br><span class="line">        funcbp.num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    funcbp.num = funcbp.num + <span class="number">1</span></span><br><span class="line">    funcbp[nline] = id</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 更新bptable中字段</span></span><br><span class="line">    s.bptable[id].func = func</span><br><span class="line">    s.bptable[id].line = nline</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="行号扩展"><a href="#行号扩展" class="headerlink" title="行号扩展"></a>行号扩展</h2><p>因为我们对行号进行了扩展了，使用负数来表示mainchunk中的断点，所以<code>verifyfuncline()</code>也需要进行相应的扩展。对于行号是负数的情况，如果不是mainchunk函数，直接返回nil，否则对行号取反还原为正常的行号。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">verifyfuncline</span> <span class="params">(info, line)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> info.sortedlines[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> line &lt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> info.what ~= <span class="string">&quot;main&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        line = -line</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> line &lt; info.linedefined <span class="keyword">or</span> line &gt; info.lastlinedefined <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(info.sortedlines) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> v &gt;= line <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>)   <span class="comment">-- impossible to reach here</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>这里还有一个问题，通过<code>debug.getinfo()</code>函数获取到的函数信息中，对于mainchunk的情况，<code>linedefined</code>和<code>lastlinedefined</code>字段的值都是0，于是我们的<code>getfuncinfo()</code>函数也要进行相应的调整：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">getfuncinfo</span> <span class="params">(func)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">local</span> info = s.funcinfos[func]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> info <span class="keyword">then</span></span><br><span class="line">        info = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(func, <span class="string">&quot;SL&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (info.activelines) <span class="keyword">then</span></span><br><span class="line">            info.sortedlines = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> k, _ <span class="keyword">in</span> <span class="built_in">pairs</span>(info.activelines) <span class="keyword">do</span></span><br><span class="line">               <span class="built_in">table</span>.<span class="built_in">insert</span>(info.sortedlines, k)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="built_in">table</span>.<span class="built_in">sort</span>(info.sortedlines)</span><br><span class="line">            <span class="comment">-- mainchunk需要特殊处理以使`verifyfuncline`能够正常工作</span></span><br><span class="line">            <span class="keyword">if</span> info.what == <span class="string">&quot;main&quot;</span> <span class="keyword">then</span></span><br><span class="line">                info.linedefined = <span class="number">1</span></span><br><span class="line">                info.lastlinedefined = info.sortedlines[#info.sortedlines]</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        s.funcinfos[func] = info</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> info</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>对于mainchunk函数进行特殊处理，将<code>linedefined</code>设置为1，将<code>lastlinedefined</code>设置为最后一个有效行的行号。</p>
<h2 id="缓存及查找源文件的函数"><a href="#缓存及查找源文件的函数" class="headerlink" title="缓存及查找源文件的函数"></a>缓存及查找源文件的函数</h2><p>我们在钩子函数中调用<code>setsrcfunc()</code>保存函数信息，将函数与源文件关联。在<code>setsrcbp()</code>中调用<code>lookforfunc()</code>通过源文件和行号查找对应的函数。先来看<code>setsrcfunc()</code>函数实现：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setsrcfunc</span> <span class="params">(info, func)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="built_in">status</span></span><br><span class="line">    <span class="keyword">local</span> srcfunc = s.srcfuncmap[info.short_src]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> srcfunc <span class="keyword">then</span></span><br><span class="line">        srcfunc = &#123;&#125;</span><br><span class="line">        s.srcfuncmap[info.short_src] = srcfunc</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> srcfunc[func] <span class="keyword">then</span></span><br><span class="line">        srcfunc[func] = info</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>其中<code>status.srcfuncmap</code>就是我们新增的数据结构，它是一个以源文件路径为键的表，其值也是一个表，保存位于该源文件中的函数信息，以函数为键，以函数信息为值。</p>
<p>再来看<code>lookforfunc()</code>函数的实现：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">lookforfunc</span> <span class="params">(src, line)</span></span></span><br><span class="line">    <span class="built_in">assert</span>(line)</span><br><span class="line">    <span class="keyword">local</span> srcfunc = <span class="built_in">status</span>.srcfuncmap[src]</span><br><span class="line">    <span class="keyword">if</span> srcfunc <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">for</span> func, info <span class="keyword">in</span> <span class="built_in">pairs</span>(srcfunc) <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> info.what == <span class="string">&quot;main&quot;</span> <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">if</span> line &lt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">return</span> func</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">elseif</span> line &gt;= info.linedefined</span><br><span class="line">                <span class="keyword">and</span> line &lt;= info.lastlinedefined <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">return</span> func</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p><code>lookforfunc()</code>函数中首先判断该源文件是否有缓存的函数信息，如果有则进行遍历。如果行号是负数，则只要找到mainchunk就可以返回了。否则，需要判断断点的行号是否在函数定义的范围内。找到了，就返回断点所在函数；没有找到返回<code>nil</code>。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>首先，编写一个用于测试的包<code>testlib.lua</code>，实现了两个简单的函数foo和bar。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    foo = foo,</span><br><span class="line">    bar = bar,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="测试通过函数名和包名添加断点"><a href="#测试通过函数名和包名添加断点" class="headerlink" title="测试通过函数名和包名添加断点"></a>测试通过函数名和包名添加断点</h3><p>我们通过函数名添加了两个断点，其中一个省略行号，默认为函数第一个有效行。又通过包名添加了两个有效断点id3和id4，id5虽然能添加成功，但是并不落在有效函数范围内。id6和id7都是参数错误的情况，添加断点失败。</p>
<p>设置完断点，先分别调用foo和bar函数一次，预期都在foo函数第2行第3行会碰到断点，然后在bar函数的第6行第7行碰到断点。接着分别删除foo和bar函数中的1个断点，再分别调用foo和bar函数一次，预期在foo函数的第3行和bar函数的第7行碰到断点。最后删除foo和bar函数中的另一个断点，再分别调用foo和bar函数一次，预期不再碰到断点。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> lib = <span class="built_in">require</span> <span class="string">&quot;testlib&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(<span class="string">&quot;foo@&quot;</span>)           <span class="comment">-- foo 2</span></span><br><span class="line"><span class="keyword">local</span> id2 = setbp(<span class="string">&quot;foo@3&quot;</span>)          <span class="comment">-- foo 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id3 = setbp(<span class="string">&quot;testlib:5&quot;</span>)      <span class="comment">-- bar 6</span></span><br><span class="line"><span class="keyword">local</span> id4 = setbp(<span class="string">&quot;testlib:7&quot;</span>)      <span class="comment">-- bar 7</span></span><br><span class="line"><span class="keyword">local</span> id5 = setbp(<span class="string">&quot;testlib:100&quot;</span>)    <span class="comment">-- invalid line</span></span><br><span class="line"><span class="keyword">local</span> id6 = setbp(<span class="string">&quot;:5&quot;</span>)</span><br><span class="line"><span class="built_in">assert</span>(<span class="keyword">not</span> id6)</span><br><span class="line"><span class="keyword">local</span> id7 = setbp(<span class="string">&quot;testlib:aa&quot;</span>)</span><br><span class="line"><span class="built_in">assert</span>(<span class="keyword">not</span> id7)</span><br><span class="line"></span><br><span class="line">lib.foo(<span class="number">1</span>)              <span class="comment">-- break twice</span></span><br><span class="line">lib.bar(<span class="number">1</span>)              <span class="comment">-- break twice</span></span><br><span class="line"></span><br><span class="line">rmbp(id1)</span><br><span class="line">rmbp(id3)</span><br><span class="line"></span><br><span class="line">lib.foo(<span class="number">2</span>)              <span class="comment">-- break once</span></span><br><span class="line">lib.bar(<span class="number">2</span>)              <span class="comment">-- break once</span></span><br><span class="line"></span><br><span class="line">rmbp(id2)</span><br><span class="line">rmbp(id4)</span><br><span class="line"></span><br><span class="line">lib.foo(<span class="number">3</span>)              <span class="comment">-- not break</span></span><br><span class="line">lib.bar(<span class="number">3</span>)              <span class="comment">-- not break</span></span><br></pre></td></tr></table></figure>

<p>运行测试脚本，分别在foo函数和bar函数中碰到两个断点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua setbpbysrc.lua</span><br><span class="line">no package name specified!</span><br><span class="line">no valid line number specified!</span><br><span class="line">Lua (field)foo /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:2</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (field)foo /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:3</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (field)bar /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:6</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (field)bar /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:7</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>继续执行，分别在foo函数和bar函数中碰到一个断点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (field)foo /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:3</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (field)bar /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:7</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>继续执行，没有再碰到断点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">$</span><br></pre></td></tr></table></figure>



<h3 id="测试行号扩展"><a href="#测试行号扩展" class="headerlink" title="测试行号扩展"></a>测试行号扩展</h3><p>编写如下测试脚本，在mainchunk中添加了4个断点，其中不指定行号时默认是mainchunk的第一个有效行。当require该包时，预期在mainchunk的第3行、第7行、第9行和第13行分别碰到断点。</p>
<p>接着在子函数foo中添加两个断点，调用foo函数，预期在foo函数第2行和第3行碰到断点。然后其中一个断点，再调用foo函数，预期在foo函数第3行碰到断点。最后删除剩余一个断点，再调用foo函数，预期不再碰到断点。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(<span class="string">&quot;testlib:&quot;</span>)       <span class="comment">-- main 3</span></span><br><span class="line"><span class="keyword">local</span> id2 = setbp(<span class="string">&quot;testlib:-5&quot;</span>)     <span class="comment">-- main 7</span></span><br><span class="line"><span class="keyword">local</span> id3 = setbp(<span class="string">&quot;testlib:-9&quot;</span>)     <span class="comment">-- main 9</span></span><br><span class="line"><span class="keyword">local</span> id4 = setbp(<span class="string">&quot;testlib:-13&quot;</span>)    <span class="comment">-- main 13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> lib = <span class="built_in">require</span> <span class="string">&quot;testlib&quot;</span>       <span class="comment">-- break 4 times</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id5 = setbp(<span class="string">&quot;testlib:2&quot;</span>)      <span class="comment">-- foo 2</span></span><br><span class="line"><span class="keyword">local</span> id6 = setbp(<span class="string">&quot;testlib:3&quot;</span>)      <span class="comment">-- foo 3</span></span><br><span class="line"></span><br><span class="line">lib.foo()   <span class="comment">-- break 2 times</span></span><br><span class="line"></span><br><span class="line">rmbp(id5)</span><br><span class="line"></span><br><span class="line">lib.foo()   <span class="comment">-- break 1 time</span></span><br><span class="line"></span><br><span class="line">rmbp(id6)</span><br><span class="line"></span><br><span class="line">lib.foo()   <span class="comment">-- not break</span></span><br></pre></td></tr></table></figure>



<p>运行测试脚本，首先碰到了mainchunk中的4个断点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua mainchunk.lua</span><br><span class="line">main ()nil /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:3</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">main ()nil /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:7</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">main ()nil /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:9</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">main ()nil /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:13</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>继续执行，碰到foo函数中两个断点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (field)foo /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:2</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (field)foo /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:3</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>再继续执行，碰到foo函数中一个断点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">Lua (field)foo /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:3</span><br><span class="line">lua_debug&gt;</span><br></pre></td></tr></table></figure>

<p>再cont就结束了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lua_debug&gt; cont</span><br><span class="line">$</span><br></pre></td></tr></table></figure>



<h3 id="测试断点重复及缓存源文件的函数"><a href="#测试断点重复及缓存源文件的函数" class="headerlink" title="测试断点重复及缓存源文件的函数"></a>测试断点重复及缓存源文件的函数</h3><p>编写如下测试脚本，首先我们通过函数添加一个断点，然后再通过包名添加一个断点。虽然这两个实际是同一个断点，但是刚开始的时候因为还没有缓存信息，所以第二个断点也会添加成功。接着调用 foo函数，预期在foo函数第2行碰到断点。在钩子函数call事件中会处理未转换的断点2，因为已经存在同样的断点了，所以会将断点2删除。</p>
<p>接下来我们删除断点1之后，就没有断点了，再次调用foo函数，预期不会碰到断点。</p>
<p>然后我们再通过包名添加一个断点，这里因为已经有了对应的函数信息，所以预期会直接转换成对应的函数断点。当我们再对函数添加同样的断点的时候预期返回之前的断点号。</p>
<p>调用foo函数，预期在foo函数第3行碰到断点。删除断点3，预期不再碰到断点。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ldb = <span class="built_in">require</span> <span class="string">&quot;luadebug&quot;</span></span><br><span class="line"><span class="keyword">local</span> lib = <span class="built_in">require</span> <span class="string">&quot;testlib&quot;</span></span><br><span class="line"><span class="keyword">local</span> setbp = ldb.setbreakpoint</span><br><span class="line"><span class="keyword">local</span> rmbp = ldb.removebreakpoint</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id1 = setbp(lib.foo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id2 = setbp(<span class="string">&quot;testlib:1&quot;</span>)  <span class="comment">-- foo 2</span></span><br><span class="line"></span><br><span class="line">lib.foo()   <span class="comment">-- break once</span></span><br><span class="line"></span><br><span class="line">rmbp(id1)</span><br><span class="line"></span><br><span class="line">lib.foo()   <span class="comment">-- not break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;not break&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> id3 = setbp(<span class="string">&quot;testlib:3&quot;</span>)  <span class="comment">-- foo 3</span></span><br><span class="line"><span class="built_in">assert</span>(id3 == <span class="number">3</span>)</span><br><span class="line"><span class="keyword">local</span> id4 = setbp(lib.foo, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">assert</span>(id3 == id4)</span><br><span class="line"></span><br><span class="line">lib.foo()   <span class="comment">-- break once</span></span><br><span class="line"></span><br><span class="line">rmbp(id3)</span><br><span class="line"></span><br><span class="line">lib.foo()   <span class="comment">-- not break</span></span><br></pre></td></tr></table></figure>



<p>运行测试脚本，结果符合预期。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lua srcfuncmap.lua</span><br><span class="line">Lua (field)foo /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:2</span><br><span class="line">lua_debug&gt; cont</span><br><span class="line">not <span class="built_in">break</span></span><br><span class="line">Lua (field)foo /usr/<span class="built_in">local</span>/share/lua/5.3/testlib.lua:3</span><br><span class="line">lua_debug&gt; cont</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenResty Lua钩子调用完整流程</title>
    <url>/posts/30b81f82/</url>
    <content><![CDATA[<div class="note primary">
            <p>前面一篇文章介绍了<a href="../150430f0/">Openresty Lua协程调度机制</a>，主要关心的是核心调度函数<code>run_thread()</code>内部发生的事情，而对于外部的事情我们并没有涉及。本篇作为其姊妹篇，准备补上剩余的部分。本篇将通过一个例子，完整介绍OpenResty中Lua钩子的调用流程，包括初始化阶段的工作、新连接进来时如何进入钩子、I/O等待时如何出去、事件触发时如何恢复、钩子正常执行结束时的操作、钩子内出错的情况。本文同样是基于<code>stream-lua</code>模块的代码。</p>
          </div>

<span id="more"></span>

<h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p>我们以<code>ssl_certificate_by_lua*</code>钩子为例来进行介绍，一来是因为它还涉及SSL握手，流程上更长一点。二来是因为在其上下文中是<code>YIELDABLE</code>的，支持的<code>ngx</code>接口比较完整。</p>
<p>我们将以下面两个配置为例来展开介绍。例子非常简单，第一个是正常的结束情况在<code>ssl_certificate_by_lua_block</code>里面调用了<code>ngx.sleep()</code>。第二个是出错中止的情况，多了一个<code>ngx.exit(ngx.ERROR)</code>。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="section">ssl_certificate_by_lua_block</span> &#123;</span><br><span class="line">        ngx.sleep(0.1)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> test.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> test.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="section">ssl_certificate_by_lua_block</span> &#123;</span><br><span class="line">        ngx.sleep(0.1)</span><br><span class="line">        ngx.exit(ngx.ERROR)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> test.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> test.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，分别来看一下初始化阶段和连接阶段的整体流程。后面章节会结合实际代码，来详细介绍每种情况下是如何处理的。</p>
<h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/30b81f82/openresty-lua-hook-flow-init-phase.svg" alt="openresty-lua-hook-flow-init-phase" loading="lazy"></p>
<p>初始化阶段的流程比较简单：配置解析阶段会读取配置文件中的代码块进行解析保存，然后创建Lua代码的key，这个key是用于后面将代码cache到注册表的。配置合并阶段，主要是合并配置项，然后设置<code>cert_cb</code>回调。配置后处理阶段，主要工作是初始化Lua VM，包括创建注册表项、创建全局表项<code>ngx</code>、替换coroutine接口。</p>
<h2 id="连接阶段"><a href="#连接阶段" class="headerlink" title="连接阶段"></a>连接阶段</h2><p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/30b81f82/openresty-lua-hook-flow-connect-phase.svg" alt="openresty-lua-hook-flow-connect-phase" loading="lazy"></p>
<p>连接阶段因为涉及新连接进入钩子、I/O等待时出去、事件触发时恢复、钩子正常执行结束（YIELD之后）、钩子内出错（YIELD之后）等各种情况，相对比较复杂。图中用不同颜色分别表示这几种不同的情况，每种颜色又用数字标识了其流程顺序。读者可以结合这个图，阅读后续每个阶段的代码，应该能够帮助您更好地理解。</p>
<p>另外提一下，本文没有涉及Lua代码执行过程没有碰到YIELD就直接完成或者出错的情况。因为这种情况比较简单，整个流程都是一个同步的过程。执行完成或者出错之后，<code>lua_resume()</code>返回，后续的流程就跟图中I/O等待（棕色）的情况是一样的。</p>
<h1 id="初始化阶段-1"><a href="#初始化阶段-1" class="headerlink" title="初始化阶段"></a>初始化阶段</h1><h2 id="配置项解析"><a href="#配置项解析" class="headerlink" title="配置项解析"></a>配置项解析</h2><p>解析到<code>ssl_certificate_by_lua_block</code>时会调用<code>ngx_stream_lua_ssl_cert_by_lua_block()</code>进行解析，里面会进行配置文件的词法分析，将代码块中的代码都合并到一个buffer之后，插入到参数数组的后面。然后调用<code>ngx_stream_lua_ssl_cert_by_lua()</code>。（如果是<code>by_lua_file</code>的情况会直接调用<code>ngx_stream_lua_ssl_cert_by_lua()</code>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_stream_lua_ssl_cert_by_lua_block</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> *conf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>        *rv;</span><br><span class="line">    <span class="keyword">ngx_conf_t</span>   save;</span><br><span class="line"></span><br><span class="line">    save = *cf;</span><br><span class="line">    cf-&gt;handler = ngx_stream_lua_ssl_cert_by_lua;</span><br><span class="line">    cf-&gt;handler_conf = conf;</span><br><span class="line"></span><br><span class="line">    rv = ngx_stream_lua_conf_lua_block_parse(cf, cmd);</span><br><span class="line"></span><br><span class="line">    *cf = save;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ngx_stream_lua_ssl_cert_by_lua()</code>主要工作是设置<code>lscf-&gt;srv.ssl_cert_src</code>以及创建Lua代码的key。如果是<code>by_lua_file</code>的情况，key以字符串<code>nhlf_</code>开头，后边是对文件路径计算的摘要十六进制值；而<code>by_lua_block</code>的情况，key以字符串<code>&quot;ssl_certificate_by_lua&quot;</code>开头，后边是对整个Lua代码块计算的摘要十六进制值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lscf-&gt;srv.ssl_cert_src = value[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">p = ngx_palloc(cf-&gt;pool,</span><br><span class="line">               <span class="keyword">sizeof</span>(<span class="string">&quot;ssl_certificate_by_lua&quot;</span>) +</span><br><span class="line">               NGX_STREAM_LUA_INLINE_KEY_LEN);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> NGX_CONF_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lscf-&gt;srv.ssl_cert_src_key = p;</span><br><span class="line"></span><br><span class="line">p = ngx_copy(p, <span class="string">&quot;ssl_certificate_by_lua&quot;</span>,</span><br><span class="line">             <span class="keyword">sizeof</span>(<span class="string">&quot;ssl_certificate_by_lua&quot;</span>) - <span class="number">1</span>);</span><br><span class="line">p = ngx_copy(p, NGX_STREAM_LUA_INLINE_TAG, NGX_STREAM_LUA_INLINE_TAG_LEN);</span><br><span class="line">p = ngx_stream_lua_digest_hex(p, value[<span class="number">1</span>].data, value[<span class="number">1</span>].len);</span><br><span class="line">*p = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="配置项合并"><a href="#配置项合并" class="headerlink" title="配置项合并"></a>配置项合并</h2><p>在配置合并阶段，由<code>ngx_stream_lua_merge_srv_conf()</code>把<code>cert_cb</code>回调函数<code>ngx_stream_lua_ssl_cert_handler()</code>设置到server的<code>SSL_CTX</code>上。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        <span class="comment">/* 先进行配置合并 */</span></span><br><span class="line">        <span class="keyword">if</span> (conf-&gt;srv.ssl_cert_src.len == <span class="number">0</span>) &#123;</span><br><span class="line">            conf-&gt;srv.ssl_cert_src = prev-&gt;srv.ssl_cert_src;</span><br><span class="line">            conf-&gt;srv.ssl_cert_src_key = prev-&gt;srv.ssl_cert_src_key;</span><br><span class="line">            conf-&gt;srv.ssl_cert_handler = prev-&gt;srv.ssl_cert_handler;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 如果设置了该配置 */</span></span><br><span class="line">        <span class="keyword">if</span> (conf-&gt;srv.ssl_cert_src.len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sscf-&gt;ssl.ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ngx_log_error(NGX_LOG_EMERG, cf-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                              <span class="string">&quot;no ssl configured for the server&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> NGX_CONF_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> OPENSSL_VERSION_NUMBER &gt;= 0x1000205fL</span></span><br><span class="line">            <span class="comment">/* 设置cert_cb回调 */</span></span><br><span class="line">            SSL_CTX_set_cert_cb(sscf-&gt;ssl.ctx, ngx_stream_lua_ssl_cert_handler, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置后处理-postconfiguration"><a href="#配置后处理-postconfiguration" class="headerlink" title="配置后处理 postconfiguration"></a>配置后处理 postconfiguration</h2><p>在postconfig阶段，会调用<code>ngx_stream_lua_init()</code>，它里面最关键的任务就是初始化Lua VM。（其实还会调用<code>init_by*</code>钩子，不过不在我们今天的讨论范围内。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rc = ngx_stream_lua_init_vm(&amp;lmcf-&gt;lua, <span class="literal">NULL</span>, cf-&gt;cycle, cf-&gt;pool,</span><br><span class="line">                            lmcf, cf-&gt;<span class="built_in">log</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>我们来看下<code>ngx_stream_lua_init_vm()</code>里面的实现，它先会创建Lua VM实例，然后注册其cleanup handler，如果有第三方模块的<code>preload_hooks</code>会注册之，然后会加载<code>resty.core</code>模块，最后会注入代码对全局变量的写操作加一个警告日志。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/* create new Lua VM instance */</span></span><br><span class="line">    L = ngx_stream_lua_new_state(parent_vm, cycle, lmcf, <span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* register cleanup handler for Lua VM */</span></span><br><span class="line">    cln-&gt;handler = ngx_stream_lua_cleanup_vm;</span><br><span class="line"></span><br><span class="line">    state = ngx_alloc(<span class="keyword">sizeof</span>(<span class="keyword">ngx_stream_lua_vm_state_t</span>), <span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    state-&gt;vm = L;</span><br><span class="line">    state-&gt;count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    cln-&gt;data = state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lmcf-&gt;vm_cleanup == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* this assignment will happen only once,</span></span><br><span class="line"><span class="comment">         * and also only for the main Lua VM */</span></span><br><span class="line">        lmcf-&gt;vm_cleanup = cln;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OPENRESTY_LUAJIT</span></span><br><span class="line">    <span class="comment">/* load FFI library first since cdata needs it */</span></span><br><span class="line">    luaopen_ffi(L);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lmcf-&gt;preload_hooks) &#123;</span><br><span class="line">        <span class="comment">/* 注册第三方preload_hooks */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *new_vm = L;</span><br><span class="line"></span><br><span class="line">    lua_getglobal(L, <span class="string">&quot;require&quot;</span>);</span><br><span class="line">    lua_pushstring(L, <span class="string">&quot;resty.core&quot;</span>);</span><br><span class="line"></span><br><span class="line">    rc = lua_pcall(L, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_DECLINED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OPENRESTY_LUAJIT</span></span><br><span class="line">    ngx_stream_lua_inject_global_write_guard(L, <span class="built_in">log</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NGX_OK;</span><br></pre></td></tr></table></figure>

<p>关键函数是创建Lua VM实例的<code>ngx_stream_lua_new_state()</code>，我们来一睹其芳容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建vm state*/</span></span><br><span class="line">L = luaL_newstate();</span><br><span class="line"><span class="comment">/* 打开标准库 */</span></span><br><span class="line">luaL_openlibs(L);</span><br><span class="line"><span class="comment">/* 获取package表 */</span></span><br><span class="line">lua_getglobal(L, <span class="string">&quot;package&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置package.path和package.cpath */</span></span><br><span class="line"></span><br><span class="line">lua_pop(L, <span class="number">1</span>); <span class="comment">/* remove the &quot;package&quot; table */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化registry */</span></span><br><span class="line">ngx_stream_lua_init_registry(L, <span class="built_in">log</span>);</span><br><span class="line"><span class="comment">/* 初始化globals */</span></span><br><span class="line">ngx_stream_lua_init_globals(L, cycle, lmcf, <span class="built_in">log</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> L;</span><br></pre></td></tr></table></figure>

<p>重点是最后的两个函数，它们分别初始化<code>registry</code>和<code>globals</code>。这个两个函数都不算太长，让我们来完整看下它们做了些什么。</p>
<p><code>ngx_stream_lua_init_registry()</code>创建了几个注册表项，分别用于存放协程、Lua的请求ctx、socket连接池、Lua预编译正则表达式对象cache及Lua代码cache。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ngx_stream_lua_init_registry(lua_State *L, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_log_debug0(NGX_LOG_DEBUG_STREAM, <span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="string">&quot;lua initializing lua registry&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &#123;&#123;&#123; register a table to anchor lua coroutines reliably:</span></span><br><span class="line"><span class="comment">     * &#123;([int]ref) = [cort]&#125; */</span></span><br><span class="line">    lua_pushlightuserdata(L, ngx_stream_lua_lightudata_mask(</span><br><span class="line">                          coroutines_key));</span><br><span class="line">    lua_createtable(L, <span class="number">0</span>, <span class="number">32</span> <span class="comment">/* nrec */</span>);</span><br><span class="line">    lua_rawset(L, LUA_REGISTRYINDEX);</span><br><span class="line">    <span class="comment">/* &#125;&#125;&#125; */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create the registry entry for the Lua request ctx data table */</span></span><br><span class="line">    lua_pushliteral(L, ngx_stream_lua_ctx_tables_key);</span><br><span class="line">    lua_createtable(L, <span class="number">0</span>, <span class="number">32</span> <span class="comment">/* nrec */</span>);</span><br><span class="line">    lua_rawset(L, LUA_REGISTRYINDEX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create the registry entry for the Lua socket connection pool table */</span></span><br><span class="line">    lua_pushlightuserdata(L, ngx_stream_lua_lightudata_mask(</span><br><span class="line">                          socket_pool_key));</span><br><span class="line">    lua_createtable(L, <span class="number">0</span>, <span class="number">8</span> <span class="comment">/* nrec */</span>);</span><br><span class="line">    lua_rawset(L, LUA_REGISTRYINDEX);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_PCRE)</span></span><br><span class="line">    <span class="comment">/* create the registry entry for the Lua precompiled regex object cache */</span></span><br><span class="line">    lua_pushlightuserdata(L, ngx_stream_lua_lightudata_mask(</span><br><span class="line">                          regex_cache_key));</span><br><span class="line">    lua_createtable(L, <span class="number">0</span>, <span class="number">16</span> <span class="comment">/* nrec */</span>);</span><br><span class="line">    lua_rawset(L, LUA_REGISTRYINDEX);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &#123;&#123;&#123; register table to cache user code:</span></span><br><span class="line"><span class="comment">     * &#123; [(string)cache_key] = &lt;code closure&gt; &#125; */</span></span><br><span class="line">    lua_pushlightuserdata(L, ngx_stream_lua_lightudata_mask(</span><br><span class="line">                          code_cache_key));</span><br><span class="line">    lua_createtable(L, <span class="number">0</span>, <span class="number">8</span> <span class="comment">/* nrec */</span>);</span><br><span class="line">    lua_rawset(L, LUA_REGISTRYINDEX);</span><br><span class="line">    <span class="comment">/* &#125;&#125;&#125; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ngx_stream_lua_init_globals()</code>则是创建了<code>ngx</code>表，接着把相关Lua Ngx API全部注册到全局表上了，其中就包括我们前面例子中的<code>ngx.sleep()</code>和<code>ngx.exit()</code>。然后把<code>ngx</code>表分别设为全局表项，同时也设到<code>package.loaded.ngx</code>了。注意，原生的<code>coroutine</code>接口也在这里被替换了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_stream_lua_inject_ngx_api</span><span class="params">(lua_State *L, <span class="keyword">ngx_stream_lua_main_conf_t</span> *lmcf,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lua_createtable(L, <span class="number">0</span> <span class="comment">/* narr */</span>, <span class="number">113</span> <span class="comment">/* nrec */</span>);    <span class="comment">/* ngx.* */</span></span><br><span class="line"></span><br><span class="line">    lua_pushcfunction(L, ngx_stream_lua_get_raw_phase_context);</span><br><span class="line">    lua_setfield(L, <span class="number">-2</span>, <span class="string">&quot;_phase_ctx&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ngx_stream_lua_inject_core_consts(L);</span><br><span class="line"></span><br><span class="line">    ngx_stream_lua_inject_log_api(L);</span><br><span class="line">    ngx_stream_lua_inject_output_api(L);</span><br><span class="line">    ngx_stream_lua_inject_string_api(L);</span><br><span class="line">    ngx_stream_lua_inject_control_api(<span class="built_in">log</span>, L);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ngx_stream_lua_inject_sleep_api(L);</span><br><span class="line">    ngx_stream_lua_inject_phase_api(L);</span><br><span class="line"></span><br><span class="line">    ngx_stream_lua_inject_req_api(<span class="built_in">log</span>, L);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ngx_stream_lua_inject_shdict_api(lmcf, L);</span><br><span class="line">    ngx_stream_lua_inject_socket_tcp_api(<span class="built_in">log</span>, L);</span><br><span class="line">    ngx_stream_lua_inject_socket_udp_api(<span class="built_in">log</span>, L);</span><br><span class="line">    ngx_stream_lua_inject_uthread_api(<span class="built_in">log</span>, L);</span><br><span class="line">    ngx_stream_lua_inject_timer_api(L);</span><br><span class="line">    ngx_stream_lua_inject_config_api(L);</span><br><span class="line"></span><br><span class="line">    lua_getglobal(L, <span class="string">&quot;package&quot;</span>); <span class="comment">/* ngx package */</span></span><br><span class="line">    lua_getfield(L, <span class="number">-1</span>, <span class="string">&quot;loaded&quot;</span>); <span class="comment">/* ngx package loaded */</span></span><br><span class="line">    lua_pushvalue(L, <span class="number">-3</span>); <span class="comment">/* ngx package loaded ngx */</span></span><br><span class="line">    lua_setfield(L, <span class="number">-2</span>, <span class="string">&quot;ngx&quot;</span>); <span class="comment">/* ngx package loaded */</span></span><br><span class="line">    lua_pop(L, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    lua_setglobal(L, <span class="string">&quot;ngx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ngx_stream_lua_inject_coroutine_api(<span class="built_in">log</span>, L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>初始化阶段的主要工作就是这些，简单小结一下，配置项解析阶段完成了Lua代码key的创建，配置项合并阶段完成了Lua钩子回调的设置，postconfig阶段完成了Lua虚拟机的初始化，其中包括registry和globals的初始化。当master进程fork出worker子进程之后，每个worker都将有一个自己的Lua VM实例。</p>
<h1 id="进入Lua钩子"><a href="#进入Lua钩子" class="headerlink" title="进入Lua钩子"></a>进入Lua钩子</h1><p>接下来，我们来看连接发起阶段。当监听的socket接收到连接请求之后，会调用<code>accept</code>建立连接，因为是stream子系统调用到<code>ngx_stream_init_connection</code>，又因为是ssl server会先走到<code>ngx_stream_ssl_handler</code>，里面调用<code>ngx_ssl_create_connection</code>创建连接(<code>SSL_new(ssl-&gt;ctx)</code>)，最终会调用<code>SSL_do_handshake</code>进入SSL状态机。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for ( ;; ) &#123;</span><br><span class="line">    ngx_process_events_and_timers(cycle)</span><br><span class="line">    +-- ngx_epoll_process_events()</span><br><span class="line">        |-- epoll_wait()</span><br><span class="line">        +-- ngx_event_accept()</span><br><span class="line">            |-- accept4()</span><br><span class="line">            |-- ngx_get_connection()</span><br><span class="line">            +-- ngx_stream_init_connection()</span><br><span class="line">                +-- ngx_stream_session_handler()</span><br><span class="line">                    |-- s = ngx_pcalloc(c-&gt;pool, sizeof(ngx_stream_session_t))</span><br><span class="line">                    +-- ngx_stream_core_run_phases()</span><br><span class="line">                        +-- ngx_stream_core_generic_phase()</span><br><span class="line">                            +-- ngx_stream_ssl_handler()</span><br><span class="line">                                +-- ngx_stream_ssl_init_connection()</span><br><span class="line">                                    |-- ngx_ssl_create_connection()</span><br><span class="line">                                    |   +-- SSL_new(ssl-&gt;ctx)</span><br><span class="line">                                    +-- ngx_ssl_handshake()</span><br><span class="line">                                        |-- SSL_do_handshake()</span><br><span class="line">                                        |-- sslerr = SSL_get_error();</span><br><span class="line">                       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SSL状态机的部分不是我们今天的重点，这里暂且略过。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ossl_statem_accept()</span><br><span class="line">+-- state_machine()</span><br><span class="line">    +-- read_state_machine()</span><br><span class="line">        +-- ossl_statem_server_post_process_message()</span><br></pre></td></tr></table></figure>

<p>状态机最终会调用到<code>tls_post_process_client_hello()</code>里的<code>cert_cb</code>。这个回调我们已经在配置初始化阶段设置了，在创建SSL连接的时候又会拷贝到<code>SSL</code>结构体里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tls_post_process_client_hello()</span><br><span class="line">+-- s-&gt;cert-&gt;cert_cb(); /* 即ngx_stream_lua_ssl_cert_handler */</span><br><span class="line">    |   /* 即ngx_stream_lua_ssl_cert_handler_inline */</span><br><span class="line">    +-- lscf-&gt;srv.ssl_cert_handler(r, lscf, L); </span><br><span class="line">        |-- ngx_stream_lua_cache_loadbuffer()</span><br><span class="line">        +-- ngx_stream_lua_ssl_cert_by_chunk()</span><br><span class="line">            |-- ngx_stream_lua_create_ctx()</span><br><span class="line">            |-- lua_xmove(L, co, 1);    /* 将代码闭包从L移到co上 */</span><br><span class="line">            |-- ngx_stream_lua_new_thread()</span><br><span class="line">            +-- ngx_stream_lua_run_thread() </span><br><span class="line">                |-- lua_resume()</span><br></pre></td></tr></table></figure>

<p>在<code>ngx_stream_lua_ssl_cert_handler</code>中会做一些初始化工作，如创建fake连接、fake会话、fake请求(因为还在SSL握手阶段，还没有真实的前端请求)，设置默认的返回码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fc = ngx_stream_lua_create_fake_connection(<span class="literal">NULL</span>);</span><br><span class="line">fs = ngx_stream_lua_create_fake_session(fc);</span><br><span class="line">r = ngx_stream_lua_create_fake_request(fs);</span><br><span class="line">cctx-&gt;exit_code = <span class="number">1</span>;  <span class="comment">/* successful by default */</span></span><br><span class="line">cctx-&gt;connection = c;</span><br><span class="line">cctx-&gt;request = r;</span><br><span class="line">cctx-&gt;entered_cert_handler = <span class="number">1</span>;</span><br><span class="line">cctx-&gt;done = <span class="number">0</span>;</span><br><span class="line">SSL_set_ex_data(c-&gt;ssl-&gt;connection, ngx_stream_lua_ssl_ctx_index, </span><br><span class="line">                cctx)</span><br></pre></td></tr></table></figure>



<p>然后因为是用配置指令是<code>xxx_by_lua_block</code>所以调用<code>ngx_stream_lua_ssl_cert_handler_inline</code>，它里面会加载Lua代码。如果是第一次加载会把代码块加载为一个Lua函数闭包工厂，然后保存闭包工厂到虚拟机的注册表上并生成一个闭包到栈顶；后续会直接从虚拟机注册表上查找并生成闭包到栈顶。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ngx_int_t</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_stream_lua_ssl_cert_handler_inline</span><span class="params">(<span class="keyword">ngx_stream_lua_request_t</span> *r,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">ngx_stream_lua_srv_conf_t</span> *lscf, lua_State *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        rc = ngx_stream_lua_cache_loadbuffer(r-&gt;connection-&gt;<span class="built_in">log</span>, L,</span><br><span class="line">                                         lscf-&gt;srv.ssl_cert_src.data,</span><br><span class="line">                                         lscf-&gt;srv.ssl_cert_src.len,</span><br><span class="line">                                         lscf-&gt;srv.ssl_cert_src_key,</span><br><span class="line">                                         <span class="string">&quot;=ssl_certificate_by_lua&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ngx_stream_lua_ssl_cert_by_chunk(L, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是进入<code>by_chunk()</code>准备执行Lua代码了，这里首先创建模块<code>ctx</code>，接着在虚拟机上创建一个入口线程，并把代码闭包从虚拟机栈上移到新线程的栈上，还在fake请求上挂了一个cleanup。然后就是调用<code>run_thread()</code>进入协程调度循环了。里面的事情我们已经在上一篇中讲到了，<code>lua_resume()</code>开始执行我们的Lua代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ctx = ngx_stream_lua_create_ctx(r-&gt;session);</span><br><span class="line">ctx-&gt;entered_content_phase = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 创建入口线程 */</span></span><br><span class="line">co = ngx_stream_lua_new_thread(r, L, &amp;co_ref);</span><br><span class="line"><span class="comment">/* 将代码闭包移到入口线程中 */</span></span><br><span class="line">lua_xmove(L, co, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 设置闭包的环境表为新协程的全局表 */</span></span><br><span class="line">ngx_stream_lua_get_globals_table(co);</span><br><span class="line">lua_setfenv(co, <span class="number">-2</span>);</span><br><span class="line"><span class="comment">/* 把nginx请求保存到协程全局表中 */</span></span><br><span class="line">ngx_stream_lua_set_req(co, r);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册请求的cleanup hooks */</span></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;cleanup == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    cln = ngx_stream_lua_cleanup_add(r, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (cln == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        rc = NGX_ERROR;</span><br><span class="line">        ngx_stream_lua_finalize_request(r, rc);</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cln-&gt;handler = ngx_stream_lua_request_cleanup_handler;</span><br><span class="line">    cln-&gt;data = ctx;</span><br><span class="line">    ctx-&gt;cleanup = &amp;cln-&gt;handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx-&gt;context = NGX_STREAM_LUA_CONTEXT_SSL_CERT;</span><br><span class="line">rc = ngx_stream_lua_run_thread(L, r, ctx, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h1 id="I-O等待挂起"><a href="#I-O等待挂起" class="headerlink" title="I/O等待挂起"></a>I/O等待挂起</h1><p>我们在初始化阶段已经将Lua Ngx API设置到全局表中了，所以<code>ngx.sleep()</code>会调用到对应的C函数<code>ngx_stream_lua_ngx_sleep()</code>，里面主要是设置了一个定时器，其事件的handler是<code>ngx_stream_lua_sleep_handler()</code>。挂完定时器，就直接<code>lua_yield()</code>了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">coctx-&gt;sleep.handler = ngx_stream_lua_sleep_handler;</span><br><span class="line">coctx-&gt;sleep.data = coctx;</span><br><span class="line">coctx-&gt;sleep.<span class="built_in">log</span> = r-&gt;connection-&gt;<span class="built_in">log</span>;</span><br><span class="line"></span><br><span class="line">ngx_add_timer(&amp;coctx-&gt;sleep, (<span class="keyword">ngx_msec_t</span>) delay);</span><br><span class="line"><span class="keyword">return</span> lua_yield(L, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>回到我们的主线程<code>run_thread()</code>之后，因为是I/O等待就直接返回<code>NGX_AGAIN</code>了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rv = lua_resume(orig_coctx-&gt;co, nrets);</span><br><span class="line"><span class="keyword">switch</span> (rv) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_YIELD:</span><br><span class="line">        <span class="keyword">switch</span> (ctx-&gt;co_op) &#123;</span><br><span class="line">            <span class="keyword">case</span> NGX_STREAM_LUA_USER_CORO_NOP:</span><br><span class="line">                ctx-&gt;cur_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span> NGX_AGAIN;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样又回到了我们的<code>by_chunk()</code>函数，因为返回值是<code>NGX_AGAIN</code>所以会检查先队列里面有没有posted的协程，如果有的话会去恢复协程的执行，在我们这个例子是没有的，不过它的返回值<code>rc</code>改成了<code>NGX_DONE</code>，所以<code>ngx_stream_lua_finalize_request(r, rc);</code>里啥也没干就返回了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rc = ngx_stream_lua_run_thread(L, r, ctx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rc == NGX_ERROR || rc &gt;= NGX_OK) &#123;</span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == NGX_AGAIN) &#123;</span><br><span class="line">    rc = ngx_stream_lua_content_run_posted_threads(L, r, ctx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == NGX_DONE) &#123;</span><br><span class="line">    rc = ngx_stream_lua_content_run_posted_threads(L, r, ctx, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    rc = NGX_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_stream_lua_finalize_request(r, rc);</span><br><span class="line"><span class="keyword">return</span> rc;</span><br></pre></td></tr></table></figure>

<p>这个<code>NGX_DONE</code>的返回值往回传递到<code>ngx_stream_lua_ssl_cert_handler</code>，在这里会对不同返回值做不同处理。如果是完成<code>NGX_OK</code>或出错<code>NGX_ERROR</code>的情况，就意味着钩子的工作已经结束了。我们目前的返回值是<code>NGX_DONE</code>，说明工作还没有结束，它在返回<code>-1</code>之前，挂了两个cleanup。其中<code>_done()</code>的那个是挂在fake连接的pool上的，而<code>_aborted()</code>那个是是挂在前端连接上的。所以<code>_done()</code>函数上在钩子工作结束之后调用的，而<code>_aborted()</code>是在前端连接终止的时候调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> rc = lscf-&gt;srv.ssl_cert_handler(r, lscf, L);</span><br><span class="line"><span class="comment">/* 已经处理完毕或者出错的情况 */</span></span><br><span class="line"><span class="keyword">if</span> (rc &gt;= NGX_OK || rc == NGX_ERROR) &#123;</span><br><span class="line">    cctx-&gt;done = <span class="number">1</span>;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">return</span> cctx-&gt;exit_code;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* rc == NGX_DONE */</span></span><br><span class="line"></span><br><span class="line">cln = ngx_pool_cleanup_add(fc-&gt;pool, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">cln-&gt;handler = ngx_stream_lua_ssl_cert_done;</span><br><span class="line">cln-&gt;data = cctx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cctx-&gt;cleanup == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    cln = ngx_pool_cleanup_add(c-&gt;pool, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cln-&gt;data = cctx;</span><br><span class="line">    cctx-&gt;cleanup = &amp;cln-&gt;handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*cctx-&gt;cleanup = ngx_stream_lua_ssl_cert_aborted;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p>这样就回到了OpenSSL的领地，我们看看出去的流程是怎么样的。因为上层的返回值是<code>-1</code>，这里设置状态为<code>SSL_X509_LOOKUP</code>然后返回<code>WORK_MORE_B</code>，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> rv = s-&gt;cert-&gt;cert_cb(s, s-&gt;cert-&gt;cert_cb_arg);</span><br><span class="line"><span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    s-&gt;rwstate = SSL_X509_LOOKUP;</span><br><span class="line">    <span class="keyword">return</span> WORK_MORE_B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个返回值传递到<code>read_state_machine</code>，变成了返回<code>SUB_STATE_ERROR</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> READ_STATE_POST_PROCESS:</span><br><span class="line">    st-&gt;read_state_work = post_process_message(s, st-&gt;read_state_work);</span><br><span class="line">    <span class="keyword">switch</span> (st-&gt;read_state_work) &#123;</span><br><span class="line">    <span class="keyword">case</span> WORK_ERROR:</span><br><span class="line">        check_fatal(s, SSL_F_READ_STATE_MACHINE);</span><br><span class="line">        <span class="comment">/* Fall through */</span></span><br><span class="line">    <span class="keyword">case</span> WORK_MORE_A:</span><br><span class="line">    <span class="keyword">case</span> WORK_MORE_B:</span><br><span class="line">    <span class="keyword">case</span> WORK_MORE_C:</span><br><span class="line">        <span class="keyword">return</span> SUB_STATE_ERROR;</span><br></pre></td></tr></table></figure>

<p>传递到<code>state_machine</code>，变成了返回<code>-1</code>。最终<code>ossl_statem_accept</code>及<code>SSL_do_handshake()</code>都返回这个值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (st-&gt;state == MSG_FLOW_READING) &#123;</span><br><span class="line">    ssret = read_state_machine(s);</span><br><span class="line">    <span class="keyword">if</span> (ssret == SUB_STATE_FINISHED) &#123;</span><br><span class="line">        st-&gt;state = MSG_FLOW_WRITING;</span><br><span class="line">        init_write_state_machine(s);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* NBIO or error */</span></span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看看回到nginx之后做了什么，因为返回值是-1，所以会先去获取错误类型，因为之前在<code>cert_cb()</code>返回以后已经设置了<code>s-&gt;rwstate = SSL_X509_LOOKUP;</code>所以会返回<code>SSL_ERROR_WANT_X509_LOOKUP</code>，这里将读写事件的回调设置为ssl握手的回调以便下次恢复。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n = SSL_do_handshake(c-&gt;ssl-&gt;connection);</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">sslerr = SSL_get_error(c-&gt;ssl-&gt;connection, n);</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">if</span> (sslerr == SSL_ERROR_WANT_X509_LOOKUP)</span><br><span class="line">&#123;</span><br><span class="line">    c-&gt;read-&gt;handler = ngx_ssl_handshake_handler;</span><br><span class="line">    c-&gt;write-&gt;handler = ngx_ssl_handshake_handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ngx_handle_read_event(c-&gt;read, <span class="number">0</span>) != NGX_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ngx_handle_write_event(c-&gt;write, <span class="number">0</span>) != NGX_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NGX_AGAIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后<code>NGX_AGAIN</code>的返回值一直往上传递，直到<code>ngx_stream_core_generic_phase</code>变为<code>NGX_OK</code>。然后本次的事件处理就算结束了。</p>
<h1 id="事件触发时恢复"><a href="#事件触发时恢复" class="headerlink" title="事件触发时恢复"></a>事件触发时恢复</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ngx_process_events_and_timers</span><br><span class="line">|-- ngx_event_expire_timers</span><br><span class="line">    |-- ngx_stream_lua_sleep_handler</span><br><span class="line">        |-- ngx_stream_lua_sleep_resume</span><br><span class="line">            |-- ngx_stream_lua_run_thread</span><br></pre></td></tr></table></figure>

<p>等到定时器超时的时候，会执行我们之前设置的<code>ngx_stream_lua_sleep_handler</code>，里面会设置当前协程上下文，然后调用<code>ngx_stream_lua_sleep_resume()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">coctx = ev-&gt;data;</span><br><span class="line">ctx-&gt;cur_co_ctx = coctx;</span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;entered_content_phase) &#123;</span><br><span class="line">    (<span class="keyword">void</span>) ngx_stream_lua_sleep_resume(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ngx_stream_lua_sleep_resume</code>里调用<code>ngx_stream_lua_run_thread</code>恢复协程的执行。这样就又回到了我们的Lua代码里。</p>
<h1 id="Lua钩子正常执行结束"><a href="#Lua钩子正常执行结束" class="headerlink" title="Lua钩子正常执行结束"></a>Lua钩子正常执行结束</h1><p>接下来Lua代码执行完毕，<code>lua_resume()</code>返回，因为是协程正常结束，且没有其他在posted队列里的协程了，所以<code>run_thread()</code>直接返回<code>NGX_OK</code>。因此在<code>ngx_stream_lua_finalize_request</code>里就会实际清除fake请求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rc = ngx_stream_lua_run_thread(vm, r, ctx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rc == NGX_AGAIN) &#123;</span><br><span class="line">    <span class="keyword">return</span> ngx_stream_lua_run_posted_threads(c, vm, r, ctx, nreqs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rc == NGX_DONE) &#123;</span><br><span class="line">    ngx_stream_lua_finalize_request(r, NGX_DONE);</span><br><span class="line">    <span class="keyword">return</span> ngx_stream_lua_run_posted_threads(c, vm, r, ctx, nreqs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;entered_content_phase) &#123;</span><br><span class="line">    ngx_stream_lua_finalize_request(r, rc);</span><br><span class="line">    <span class="keyword">return</span> NGX_DONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rc;</span><br></pre></td></tr></table></figure>

<p>里面会调用到之前设置的cleanup函数，清理fake请求的时候调用<code>ngx_stream_lua_request_cleanup_handler</code>清理Lua线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cln = r-&gt;cleanup;</span><br><span class="line">r-&gt;cleanup = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (cln) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cln-&gt;handler) &#123;</span><br><span class="line">        cln-&gt;handler(cln-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cln = cln-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r-&gt;connection-&gt;destroyed = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>清理fake连接的时候调用<code>ngx_stream_lua_ssl_cert_done</code>。我们来看看<code>ngx_stream_lua_ssl_cert_done</code>里面做了什么。主要是设置了完成标志，然后把前端连接的写事件加入了<code>ngx_posted_events</code>队列里。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cctx-&gt;done = <span class="number">1</span>;</span><br><span class="line">ngx_post_event(c-&gt;write, &amp;ngx_posted_events);</span><br></pre></td></tr></table></figure>

<p>定时器超时事件完成之后返回到外层，处理后续的<code>ngx_posted_events</code>队列事件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">void</span>) ngx_process_events(cycle, timer, flags);</span><br><span class="line"></span><br><span class="line">delta = ngx_current_msec - delta;</span><br><span class="line"></span><br><span class="line">ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">               <span class="string">&quot;timer delta: %M&quot;</span>, delta);</span><br><span class="line"></span><br><span class="line">ngx_event_process_posted(cycle, &amp;ngx_posted_accept_events);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">    ngx_shmtx_unlock(&amp;ngx_accept_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (delta) &#123;</span><br><span class="line">    ngx_event_expire_timers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_event_process_posted(cycle, &amp;ngx_posted_events);</span><br></pre></td></tr></table></figure>

<p>因为前端连接的写事件已经设置成<code>ngx_ssl_handshake_handler</code>，所以会再次调用到<code>ngx_ssl_handshake-SSL_do_handshake</code>，这样就再次进入了SSL状态机，又会来到<code>ngx_stream_lua_ssl_cert_handler</code>中。因为是第二次进入了，且已经设置了<code>cctx-&gt;done</code>，所以就直接返回离开码了，其中<code>cctx-&gt;exit_code</code>就是<code>ngx.exit()</code>时的参数，<code>cctx-&gt;exit_code</code>初始化时的默认值时0，但是注意到前面第一次进入<code>ngx_stream_lua_ssl_cert_handler</code>的时候已经将默认值设为1了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cctx &amp;&amp; cctx-&gt;entered_cert_handler) &#123;</span><br><span class="line">    <span class="comment">/* not the first time */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cctx-&gt;done) &#123;</span><br><span class="line">        ngx_log_debug1(NGX_LOG_DEBUG_STREAM, c-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                       <span class="string">&quot;stream lua_certificate_by_lua:&quot;</span></span><br><span class="line">                       <span class="string">&quot; cert cb exit code: %d&quot;</span>,</span><br><span class="line">                       cctx-&gt;exit_code);</span><br><span class="line"></span><br><span class="line">        dd(<span class="string">&quot;lua ssl cert done, finally&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> cctx-&gt;exit_code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，回到了<code>tls_post_process_client_hello()</code>继续后面的握手流程了。</p>
<h1 id="Lua钩子内出错的情况"><a href="#Lua钩子内出错的情况" class="headerlink" title="Lua钩子内出错的情况"></a>Lua钩子内出错的情况</h1><p>出错的流程跟正常结束类似，只不过返回值不一样。<code>ngx.exit()</code>的实现如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ngx.<span class="built_in">exit</span> = function (rc)</span><br><span class="line">    local err = get_string_buf(ERR_BUF_SIZE)</span><br><span class="line">    local errlen = get_size_ptr()</span><br><span class="line">    local r = get_request()</span><br><span class="line">    <span class="keyword">if</span> r == nil then</span><br><span class="line">        error(<span class="string">&quot;no request found&quot;</span>)</span><br><span class="line">    end</span><br><span class="line">    errlen[<span class="number">0</span>] = ERR_BUF_SIZE</span><br><span class="line">    rc = ngx_lua_ffi_exit(r, rc, err, errlen)</span><br><span class="line">    <span class="keyword">if</span> rc == <span class="number">0</span> then</span><br><span class="line">        -- print(<span class="string">&quot;yielding...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">co_yield</span>()</span><br><span class="line">    end</span><br><span class="line">    <span class="keyword">if</span> rc == FFI_DONE then</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    end</span><br><span class="line">    error(ffi_string(err, errlen[<span class="number">0</span>]), <span class="number">2</span>)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>里面会调用ffi函数<code>ngx_stream_lua_ffi_exit()</code>，在其中设置<code>ctx-&gt;exit_code</code>，然后返回<code>NGX_OK</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx-&gt;context &amp; (NGX_STREAM_LUA_CONTEXT_SSL_CERT</span><br><span class="line">                    | NGX_STREAM_LUA_CONTEXT_SSL_CLIENT_HELLO ))</span><br><span class="line">&#123;</span><br><span class="line">    ctx-&gt;exit_code = status;</span><br><span class="line">    ctx-&gt;exited = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到<code>ngx.exit()</code>函数之后，就调用原生的<code>coroutine.yield()</code>，回到我们的主线程<code>run_thread()</code>之后，因为设置了<code>ctx-&gt;exited</code>会调用<code>ngx_stream_lua_handle_exit</code>返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rv = lua_resume(orig_coctx-&gt;co, nrets);</span><br><span class="line"><span class="keyword">switch</span> (rv) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_YIELD:</span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;exited) &#123;</span><br><span class="line">            <span class="keyword">return</span> ngx_stream_lua_handle_exit(L, r, ctx);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ngx_stream_lua_handle_exit()</code>里面调用<code>ngx_stream_lua_request_cleanup</code>清理线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ctx-&gt;cur_co_ctx-&gt;co_status = NGX_STREAM_LUA_CO_DEAD;</span><br><span class="line">ngx_stream_lua_request_cleanup(ctx, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> ctx-&gt;exit_code;</span><br></pre></td></tr></table></figure>

<p>然后返回到<code>sleep_resume</code>，此时<code>rc</code>为<code>ctx-&gt;exit_code</code>，即<code>ngx.ERROR</code>，接下来跟正常结束时一样也是结束我们的请求</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rc = ngx_stream_lua_run_thread(L, r, ctx, <span class="number">0</span>);</span><br><span class="line">...;</span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;entered_content_phase) &#123;</span><br><span class="line">    ngx_stream_lua_finalize_request(r, rc);</span><br><span class="line">    <span class="keyword">return</span> NGX_DONE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rc;</span><br></pre></td></tr></table></figure>

<p>因为是fake请求，<code>ngx_stream_lua_finalize_request</code>调用<code>ngx_stream_lua_finalize_fake_request</code>，里面将<code>cctx-&gt;exit_code</code>设为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (rc == NGX_ERROR || rc &gt;= NGX_STREAM_BAD_REQUEST) &#123;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;connection-&gt;ssl) &#123;</span><br><span class="line">        ssl_conn = r-&gt;connection-&gt;ssl-&gt;connection;</span><br><span class="line">        <span class="keyword">if</span> (ssl_conn) &#123;</span><br><span class="line">            c = ngx_ssl_get_connection(ssl_conn);</span><br><span class="line">            <span class="keyword">if</span> (c &amp;&amp; c-&gt;ssl) &#123;</span><br><span class="line">                cctx = ngx_stream_lua_ssl_get_ctx(c-&gt;ssl-&gt;connection);</span><br><span class="line">                <span class="keyword">if</span> (cctx != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    cctx-&gt;exit_code = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ngx_stream_lua_close_fake_request(r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在清理fake请求的时候调用<code>ngx_stream_lua_request_cleanup_handler</code>清理Lua线程。在清理fake连接的时候会触发<code>ngx_stream_lua_ssl_cert_done</code>，跟正常完成时一样，也是设置完成标志，然后把前端连接的写事件加入了<code>ngx_posted_events</code>队列里。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cctx-&gt;done = <span class="number">1</span>;</span><br><span class="line">ngx_post_event(c-&gt;write, &amp;ngx_posted_events);</span><br></pre></td></tr></table></figure>

<p>到此定时器的事件就结束了，开始处理后续的posted队列事件。同样地，也会再次调用<code>ngx_ssl_handshake_handler</code>最终调到到<code>ngx_stream_lua_ssl_cert_handler</code>中。因为是第二次进入了，且已经设置了<code>cctx-&gt;done</code>，所以就直接返回离开码了，而本次因为是出错<code>cctx-&gt;exit_code</code>的值是0.</p>
<p>返回到OpenSSL之后，一路往上传递错误码。。。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> rv = s-&gt;cert-&gt;cert_cb(s, s-&gt;cert-&gt;cert_cb_arg);</span><br><span class="line"><span class="keyword">if</span> (rv == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">err:</span><br><span class="line"><span class="keyword">return</span> WORK_ERROR;</span><br></pre></td></tr></table></figure>

<p>最终，<code>SSL_do_handshake</code>返回错误值，结束SSL握手。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = SSL_do_handshake(c-&gt;ssl-&gt;connection);</span><br><span class="line">sslerr = SSL_get_error(c-&gt;ssl-&gt;connection, n);</span><br><span class="line">return NGX_ERROR;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们本篇是以一个定时器为例子，对于socket I/O等待其实也是类似的流程。只不过触发事件由定时器超时变成了相应的fd的读写事件，协程的恢复由定时器时的直接恢复变成了完成本次I/O任务（或者出错）之后恢复协程。</p>
]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>OpenResty</tag>
        <tag>Nginx</tag>
        <tag>钩子</tag>
      </tags>
  </entry>
  <entry>
    <title>Openresty Lua协程调度机制</title>
    <url>/posts/150430f0/</url>
    <content><![CDATA[<div class="note primary">
            <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>OpenResty（后面简称：OR）是一个基于Nginx和Lua的高性能Web平台，它内部集成大量的Lua API以及第三方模块，可以利用它快速搭建支持高并发、极具动态性和扩展性的Web应用、Web服务或动态网关。</p><p>OR最大的特点就是，将Lua协程与Nginx事件驱动模型及非阻塞I/O结合起来。使用户可以在handler中使用 <strong>同步但是依然是非阻塞</strong> 的方式编写其应用代码，而无需关心底层的协程调度以及与Nginx事件驱动模型的交互。</p><p>本文将先从总体上介绍OR的协程调度机制，然后结合源码以及Lua栈的情况来详细了解各个部分是如何实现的，包括其异常保护、协程初始化、协程的恢复和执行、协程的挂起、协程的执行结束、协程出错的情况。</p><p>本文主要关注调度函数内部的逻辑，如果想了解外部的调用流程。可以参看<a href="../30b81f82/">Openresty Lua钩子调用完整流程</a></p>
          </div>

<span id="more"></span>

<div class="note default">
            <p>注：<code>lua-nginx</code>模块与<code>stream-lua-nginx</code>模块的主体部分类似，后者实现相对简单一点。下面的讨论将基于<code>stream-lua</code>模块。</p><p>为了防止歧义，文中用到的一些术语明确一下：</p><ul><li><code>主线程</code>：表示外层调用<code>run_thread()</code>的OS线程</li><li><code>入口线程</code>：每个handler被调用时会创建一个入口线程，用于执行lua代码</li><li><code>用户线程</code>：用户在Lua代码中通过<code>ngx.thread.spawn()</code>创建的线程</li><li><code>用户协程</code>：用户在Lua代码中通过<code>coroutine.create()</code>创建的协程</li><li><code>协程</code>：泛指所有协程，包括入口线程、用户线程和用户协程</li><li><code>vm</code>：表示Lua虚拟机</li><li><code>L</code>：视出现的上下文，一般表示父协程，在创建入口线程的时候表示Lua VM</li><li><code>co</code>：一般表示新创建的协程</li><li><code>L栈： |协程表|新协程|顶|</code>：表示Lua栈结构，最右边是栈顶</li></ul>
          </div>

<h1 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h1><p>在深入了解协程调度机制之前，我们先来认识一下主要的数据结构：</p>
<ul>
<li>协程上下文：<code>ngx_stream_lua_co_ctx_t</code><ul>
<li>协程内部栈（<code>coctx-&gt;co</code>）</li>
<li>协程状态（<code>coctx-&gt;co_status</code>）</li>
<li>维护协程之间关系的数据（父协程<code>coctx-&gt;parent_co_ctx</code>、僵尸子线程<code>coctx-&gt;zombie_child_threads</code>）</li>
<li>用户相关数据（<code>coctx-&gt;data</code>）</li>
<li>在Lua的registry表中对应该线程指针的引用值（<code>co_ref</code>）</li>
<li>一些状态标记（是否是用户线程<code>is_uthread</code>、是否因创建新线程<code>thread_spawn_yielded</code>被yield)</li>
</ul>
</li>
<li>模块上下文：<code>ngx_stream_lua_ctx_t</code><ul>
<li><code>ctx-&gt;cur_co_ctx</code>（当前调度协程上下文）</li>
<li><code>ctx-&gt;co_op</code>（协程是以何种方式YIELD）</li>
</ul>
</li>
<li>核心调度函数：<code>ngx_stream_lua_run_thread()</code></li>
</ul>
<h1 id="协程调度"><a href="#协程调度" class="headerlink" title="协程调度"></a>协程调度</h1><p>首先你可能很好奇OR为什么要在C引擎层面自己实现协程的调度？或者说这么做的好处是什么？我觉得最主要的原因还是减轻开发者的负担。</p>
<h2 id="原生Lua-coroutine接口"><a href="#原生Lua-coroutine接口" class="headerlink" title="原生Lua coroutine接口"></a>原生Lua coroutine接口</h2><p>我们知道Lua是个非常轻巧的语言，它不像Go有自己的调度器。Lua原生的对协程的操作无非就是<code>coroutine.resume()</code>和<code>coroutine.yield()</code>。这两者是成对出现的，协程<code>coroutine.yield()</code>之后肯定回到父协程<code>coroutine.resume()</code>的地方，恢复子协程需要显式再次<code>coroutine.resume()</code>。如果要在Lua代码层面实现非阻塞I/O，那么父协程必须处理子协程I/O等待的情况，并在事件发生时恢复子协程的执行。如果需要同时进行多个任务，那么父协程就需要负责多个协程间的调度。因为协程的拓扑可能是一个复杂的树状结构，所以协程的调度管理将变得异常复杂。</p>
<h2 id="OpenResty实现"><a href="#OpenResty实现" class="headerlink" title="OpenResty实现"></a>OpenResty实现</h2><p>OR在C引擎层帮我们把这些事情都做了，你无须再关心所有这些，只需专心写你的业务逻辑。为了支持同步非阻塞的方式编写应用代码，OR重写了<code>coroutine</code>的接口函数，从而接管了协程的调度，并在<code>coroutine</code>基础上封装抽象出了<code>thread</code>的概念。无论是<code>coroutine</code>还是<code>thread</code>，I/O等待对于用户都是透明的，用户无需关心。两者的主要区别是，<code>coroutine</code>父子之间的协作度更高，<code>coroutine.yield()</code>和<code>coroutine.resume()</code>成对出现。在子协程执行完成（出错）或者显式<code>coroutine.yield()</code>之前，父协程一直处于等待状态。而<code>thread</code>则由调度器进行调度，子<code>thread</code>一旦开始执行就不再受父协程控制了，在需要并发请求时很有用。<code>thread</code>提供了<code>spawn()</code>、<code>wait()</code>等接口，<code>spawn()</code>执行参数中指定的函数，直到执行完毕、出错或者I/O等待时返回。<code>wait()</code>则使父协程可以同步等待子线程执行完毕、获取结果。</p>
<div class="note primary">
            <p>OR在对协程调度上，最核心的改动是其创建新协程时的行为（<code>coroutine.resume()</code>, <code>ngx.thread.spawn()</code>）。它不会直接调用<code>lua_resume()</code>，而是先<code>lua_yield()</code>回到主线程，然后由主线程再根据情况<code>lua_resume()</code>下一个协程。Lua代码域内从来不会直接调用<code>lua_resume()</code>，理解了这一点你就理解了OpenResty协程调度的精髓。</p>
          </div>

<p>所以OR中协程拓扑是一个单层的结构，它只有<strong>一个入口点</strong>。这样使得协程调度更加灵活，I/O事件的触发时回调函数也更容易实现。</p>
<p>OR调度器根据<code>lua_resume()</code>的返回值，确定协程是挂起了、结束了还是出错了。因为OR改动了创建新协程时行为，同时又抽象了thread概念，所以如果是协程挂起的情况，还需要知道是什么原因挂起，以便做相应的不同处理。是继续调度？还是返回上层？我们前面提到的<code>ctx-&gt;co_op</code>便是做这个用途。</p>
<h2 id="协程调度逻辑"><a href="#协程调度逻辑" class="headerlink" title="协程调度逻辑"></a>协程调度逻辑</h2><p>协程的调度在核心调度函数<code>ngx_stream_lua_run_thread()</code>中进行，它是创建或恢复协程的唯一入口点。最初是由配置的Lua钩子调用（图中<code>ssl_cert_handler()</code>），如果碰到了I/O等待的情况，后续则由对应的事件handler（图中的<code>sleep_handler()</code>和<code>read_handler()</code>）再次拉起。<code>run_thread()</code>里面实现了一个调度循环，循环里面先从<code>ctx-&gt;cur_co_ctx</code>获取下一个待resume的协程上下文，然后<code>lua_resume()</code>执行或恢复该协程，其返回值<code>LUA_YIELD</code>表示协程挂起，<code>0</code>表示协程执行结束，其余的表示协程出错了。其中协程挂起又分为四种不同的情况：即等待I/O、新建thread、<code>coroutine.resume()</code>和<code>coroutine.yield()</code>。根据不同的情况，决定是跳到循环前面继续恢复下一个协程，还是返回上层函数。</p>
<p>下图是协程调度主要逻辑的示意图，可以看到在Lua代码域中无论是新建、挂起或恢复协程，都是先调用<code>lua_yield()</code>回到主线程。I/O操作例如<code>ngx.tcp.receive()</code>如果碰到了I/O等待，会在内部注册epoll事件（对于sleep的情况是定时器），然后自动<code>lua_yield()</code>，当事件触发时继续未完成的I/O操作，完成之后再调用<code>run_thread()</code>恢复之前被挂起的协程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/150430f0/openresty-lua-coroutine-schedule.svg" loading="lazy"></p>
<h1 id="异常保护"><a href="#异常保护" class="headerlink" title="异常保护"></a>异常保护</h1><p>作为一个调度器，OpenResty扮演者类似操作系统内核的角色，不过它的调度对象是Lua协程。作为一个“内核”，无论其调度对象出了什么问题，都不应该使这个系统崩溃，而是应该将错误信息打印出来。</p>
<p>Openresty内部就做了一个这样的异常保护，其原理就是用<code>setjmp</code>、<code>longjmp</code>包住了<code>run_thread()</code>里面的整个协程调度逻辑。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 首先注册虚拟机的panic回调 */</span></span><br><span class="line">lua_atpanic(L, ngx_stream_lua_atpanic);</span><br><span class="line"><span class="comment">/* setjmp保存环境 */</span></span><br><span class="line">NGX_LUA_EXCEPTION_TRY &#123;</span><br><span class="line">    <span class="comment">/* 执行调度逻辑 */</span></span><br><span class="line">&#125; NGX_LUA_EXCEPTION_CATCH &#123;</span><br><span class="line">    <span class="comment">/* 出现异常时走到这里 */</span></span><br><span class="line">    dd(<span class="string">&quot;nginx execution restored&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ngx_stream_lua_atpanic()</code>的实现也非常简单，只是简单地打印崩溃日志，然后调用<code>NGX_LUA_EXCEPTION_THROW(1);</code>恢复nginx的执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_stream_lua_atpanic</span><span class="params">(lua_State *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NGX_LUA_ABORT_AT_PANIC</span></span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    u_char                  *s = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span>                   len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lua_type(L, <span class="number">-1</span>) == LUA_TSTRING) &#123;</span><br><span class="line">        s = (u_char *) lua_tolstring(L, <span class="number">-1</span>, &amp;len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        s = (u_char *) <span class="string">&quot;unknown reason&quot;</span>;</span><br><span class="line">        len = <span class="keyword">sizeof</span>(<span class="string">&quot;unknown reason&quot;</span>) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_log_stderr(<span class="number">0</span>, <span class="string">&quot;lua atpanic: Lua VM crashed, reason: %*s&quot;</span>, len, s);</span><br><span class="line">    ngx_quit = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  restore nginx execution */</span></span><br><span class="line">    NGX_LUA_EXCEPTION_THROW(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* impossible to reach here */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这几个宏定义分别如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_LUA_EXCEPTION_TRY                                                \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (setjmp(ngx_stream_lua_exception) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_LUA_EXCEPTION_CATCH                                              \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_LUA_EXCEPTION_THROW(x)                                           \</span></span><br><span class="line"><span class="meta">    longjmp(ngx_stream_lua_exception, (x))</span></span><br></pre></td></tr></table></figure>



<h1 id="协程初始化"><a href="#协程初始化" class="headerlink" title="协程初始化"></a>协程初始化</h1><h2 id="钩子的入口线程"><a href="#钩子的入口线程" class="headerlink" title="钩子的入口线程"></a>钩子的入口线程</h2><p><code>ngx_stream_lua_new_thread()</code>用于创建入口线程</p>
<p>OR中需要在Registry表中存储每个创建出来的Lua线程的reference，这个存储协程的表在Registry表中对应的key是全局变量<code>ngx_stream_lua_coroutines_key</code>的地址，因此下面这段代码就是从Registry表中查询这个储存协程的表，返回到栈顶：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 返回栈顶元素的索引，等于栈中元素的个数 */</span></span><br><span class="line">base = lua_gettop(L);</span><br><span class="line"><span class="comment">/* 将存储协程的表对应的key压栈 */</span></span><br><span class="line">lua_pushlightuserdata(L, ngx_stream_lua_lightudata_mask(</span><br><span class="line">                      coroutines_key));</span><br><span class="line"><span class="comment">/* 将key出栈，获取Registry表中key对应的元素，然后将结果入栈 */</span></span><br><span class="line">lua_rawget(L, LUA_REGISTRYINDEX);</span><br></pre></td></tr></table></figure>

<p>接下来创建一个新的协程，同时初始化其全局表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建Lua协程，返回的新lua_State跟原有的lua_State共享所有的全局对象（如表），</span></span><br><span class="line"><span class="comment">   但是有一个独立的执行栈。 协程依赖垃圾回收销毁 */</span></span><br><span class="line"><span class="comment">/* L栈： |协程表|新协程|顶| */</span></span><br><span class="line">co = lua_newthread(L);  </span><br><span class="line"><span class="comment">/* 创建该协程的全局表，设置_G field为全局表自己 */</span></span><br><span class="line"><span class="comment">/* L栈： |协程表|新协程|协程新的全局表|顶| */</span></span><br><span class="line">ngx_stream_lua_create_new_globals_table(co, <span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line"><span class="comment">/* 再创建一个新表 */</span></span><br><span class="line"><span class="comment">/* L栈： |协程表|新协程|协程新的全局表|新表|顶| */</span></span><br><span class="line">lua_createtable(co, <span class="number">0</span>, <span class="number">1</span>);  </span><br><span class="line"><span class="comment">/* 拿到全局表 */</span></span><br><span class="line"><span class="comment">/* L栈： |协程表|新协程|协程新的全局表|新表|旧全局表|顶| */</span></span><br><span class="line">ngx_stream_lua_get_globals_table(co);   </span><br><span class="line"><span class="comment">/* 新表的__index的值为栈顶的值，也即就全局表 */</span></span><br><span class="line"><span class="comment">/* L栈： |协程表|新协程|协程新的全局表|新表|顶| */</span></span><br><span class="line">lua_setfield(co, <span class="number">-2</span>, <span class="string">&quot;__index&quot;</span>);    </span><br><span class="line"><span class="comment">/* 新表出栈，将其设为索引-2处即协程新的全局表的元表 */</span></span><br><span class="line"><span class="comment">/* L栈： |协程表|新协程|协程新的全局表|顶| */</span></span><br><span class="line">lua_setmetatable(co, <span class="number">-2</span>);</span><br><span class="line"><span class="comment">/* 设置协程新的全局表到对应索引，其_G field是自己，</span></span><br><span class="line"><span class="comment">   其元表是新表，新表的__index是父协程的全局表 */</span></span><br><span class="line"><span class="comment">/* L栈： |协程表|新协程|顶| */</span></span><br><span class="line">ngx_stream_lua_set_globals_table(co);</span><br></pre></td></tr></table></figure>

<p>这一块的逻辑有点绕，我们来稍微理一下，其实就是用新建的全局表替换了旧的全局表，其中新的全局表的<code>_G</code>字段是它自己，新全局表的元表中<code>__index</code>元方法是旧的全局表。</p>
<p>此时的Lua虚拟机栈顶情况如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L-&gt;top      |   栈顶    |</span><br><span class="line">L-&gt;top - 1  |Lua_State*|    新创建的协程</span><br><span class="line">L-&gt;top -2   | Lua Table|    存储协程引用的表</span><br></pre></td></tr></table></figure>

<p>下面一步就是在Lua虚拟机中为这个新协程创建一个reference：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 为栈顶对象（即新协程），创建并返回一个协程表中的引用 */</span></span><br><span class="line"><span class="comment">/* 当前栈： |协程表|顶| */</span></span><br><span class="line">*ref = luaL_ref(L, <span class="number">-2</span>);</span><br><span class="line"><span class="keyword">if</span> (*ref == LUA_NOREF) &#123;</span><br><span class="line">    lua_settop(L, base);  <span class="comment">/* restore main thread stack */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后恢复堆栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置栈顶索引 */</span></span><br><span class="line"><span class="comment">/* 当前栈： |顶| */</span></span><br><span class="line">lua_settop(L, base);    </span><br><span class="line"><span class="keyword">return</span> co;</span><br></pre></td></tr></table></figure>

<p>以上步骤还只是创建了一个什么都不能做的Lua协程，回到<code>_by_chunk()</code>函数之后还需要把入口函数放入协程中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将lua虚拟机VM栈上的入口函数闭包移到新创建的协程栈上，</span></span><br><span class="line"><span class="comment">   这样新协程就有了虚拟机已经解析完毕的代码了。*/</span></span><br><span class="line">lua_xmove(L, co, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 拿到co全局表，放到栈顶 */</span></span><br><span class="line"><span class="comment">/* 当前栈： |入口closure|全局表|顶| */</span></span><br><span class="line">ngx_stream_lua_get_globals_table(co);</span><br><span class="line"><span class="comment">/* 将全局表设为入口closure的环境表 */</span></span><br><span class="line"><span class="comment">/* 当前栈： |入口closure|顶|*/</span></span><br><span class="line">lua_setfenv(co, <span class="number">-2</span>);</span><br></pre></td></tr></table></figure>

<p>至此，协程入口函数以及环境表已经设置好。接下来就是让它能够运行起来，让调度器能够调度它运行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将nginx请求保存到协程全局表 */</span></span><br><span class="line">ngx_stream_lua_set_req(co, r);</span><br><span class="line"></span><br><span class="line">ctx-&gt;cur_co_ctx = &amp;ctx-&gt;entry_co_ctx;</span><br><span class="line">ctx-&gt;cur_co_ctx-&gt;co = co;</span><br><span class="line">ctx-&gt;cur_co_ctx-&gt;co_ref = co_ref;</span><br></pre></td></tr></table></figure>

<p>接下来就是注册cleanup钩子，然后<code>ngx_stream_lua_run_thread()</code>。</p>
<h2 id="用户创建的uthread"><a href="#用户创建的uthread" class="headerlink" title="用户创建的uthread"></a>用户创建的uthread</h2><p>用户线程由<code>ngx.thread.spawn()</code>创建，对应的C实现是<code>ngx_stream_lua_uthread_spawn()</code>。首先它会调<code>ngx_stream_lua_coroutine_create_helper()</code>创建一个新的协程。</p>
<h3 id="创建协程"><a href="#创建协程" class="headerlink" title="创建协程"></a>创建协程</h3><p>注意协程都是在worker的虚拟机上创建的（不考虑cache off的情况的话）。但是用户协程会继承父协程的全局表，其父子关系由OR进行维护。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取虚拟机 */</span></span><br><span class="line">vm = ngx_stream_lua_get_lua_vm(r, ctx);</span><br><span class="line"><span class="comment">/* 创建新协程 */</span></span><br><span class="line">co = lua_newthread(vm);</span><br><span class="line"><span class="comment">/* 然后创建coctx，设置其co、co_status值 */</span></span><br><span class="line">coctx = ngx_stream_lua_create_co_ctx;</span><br><span class="line">coctx-&gt;co = co;</span><br><span class="line">coctx-&gt;co_status = NGX_STREAM_LUA_CO_SUSPENDED;</span><br></pre></td></tr></table></figure>

<p>此时父协程的栈如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 当前栈: |entry_func|args|顶| */</span><br></pre></td></tr></table></figure>

<p>接下来将父协程的全局表给新创建的协程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* make new coroutine share globals of the parent coroutine.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> globals don&#x27;t have to be separated! */</span></span><br><span class="line"><span class="comment">/* 拷贝父协程的全局表到栈上 */</span></span><br><span class="line"><span class="comment">/* L栈: |entry_func|args|全局表|顶| */</span></span><br><span class="line">ngx_stream_lua_get_globals_table(L);</span><br><span class="line"><span class="comment">/* 将全局表移动到新创建的协程co的栈上 */</span></span><br><span class="line"><span class="comment">/* L栈: |entry_func|args|顶| */</span></span><br><span class="line">lua_xmove(L, co, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 从新协程栈上写入其的全局表 */</span></span><br><span class="line">ngx_stream_lua_set_globals_table(co);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将新协程从进程虚拟机，移动到父协程中 */</span></span><br><span class="line"><span class="comment">/* L栈: |entry_func|args|新协程|顶| */</span></span><br><span class="line">lua_xmove(vm, L, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 入口函数拷贝到L栈顶 */</span></span><br><span class="line"><span class="comment">/* L栈: |entry_func|args|新协程|entry_func|顶|*/</span></span><br><span class="line">lua_pushvalue(L, <span class="number">1</span>); </span><br><span class="line"><span class="comment">/* 将入口函数从L移到co栈中 */</span></span><br><span class="line"><span class="comment">/* L栈: |entry_func|args|新协程|顶| */</span></span><br><span class="line"><span class="comment">/* co栈: |entry_func|顶|*/</span></span><br><span class="line">lua_xmove(L, co, <span class="number">1</span>);  </span><br></pre></td></tr></table></figure>

<p><code>create_helper</code>函数返回之后，L的栈顶是新协程，co的栈顶是入口函数。</p>
<h3 id="初始化uthread"><a href="#初始化uthread" class="headerlink" title="初始化uthread"></a>初始化uthread</h3><p><code>ngx_stream_lua_coroutine_create_helper</code>返回之后，进行uthread的初始化。</p>
<p>此时，父协程L是这样的：</p>
<ul>
<li>栈顶是新创建的协程</li>
<li>然后是参数和入口函数</li>
</ul>
<p>在此之前，先在registry表中保存一个该协程的ref。（到现在还没搞明白这个ref是干嘛用的？除了创建线程和删除线程，貌似只有检查线程是否活着的时候会查一下这个ref，只是检查状态用<code>coctx-&gt;co_status</code>不是也能做到么？8.12更新，之所以要把线程锚定到注册表上，是为了防止被当成垃圾回收。这也解释了为什么只有线程需要锚定到注册表上，而用户协程不需要。因为用户协程肯定由其父协程保留着一个引用。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* anchor the newly created coroutine into the Lua registry */</span></span><br><span class="line"><span class="comment">/* 把新创建的协程写入Lua registry表中 */</span></span><br><span class="line"><span class="comment">/* 将ngx_stream_lua_coroutines_key的地址压入栈中 */</span></span><br><span class="line">lua_pushlightuserdata(L, &amp;ngx_stream_lua_coroutines_key);</span><br><span class="line"><span class="comment">/* 从registry表中获取协程表 */</span></span><br><span class="line"><span class="comment">/* L栈: |entry_func|args|新协程|协程表|顶|*/</span></span><br><span class="line">lua_rawget(L, LUA_REGISTRYINDEX);</span><br><span class="line"><span class="comment">/* 将新协程压栈 */</span></span><br><span class="line"><span class="comment">/* L栈: |entry_func|args|新协程|协程表|新协程|顶|*/</span></span><br><span class="line">lua_pushvalue(L, <span class="number">-2</span>);</span><br><span class="line"><span class="comment">/* -2位置是注册表，为新协程创建在报表中的索引 */</span></span><br><span class="line"><span class="comment">/* L栈: |entry_func|args|新协程|协程表|顶| */</span></span><br><span class="line">coctx-&gt;co_ref = luaL_ref(L, <span class="number">-2</span>);    <span class="comment">// </span></span><br><span class="line"><span class="comment">/* 弹出协程表 */</span></span><br><span class="line"><span class="comment">/* L栈: |entry_func|args|新协程|顶| */</span></span><br><span class="line">lua_pop(L, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>接下来是初始化运行环境：</p>
<p>此时的，L的栈情况如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|entry_func|参数1|...|参数n|新协程|</span><br><span class="line">    1        2   ...  -2    -1</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 由于lua函数压栈顺序是从左到右</span></span><br><span class="line"><span class="comment">     * 因此1就是压入的第一个参数，而spawn的第一个参数就是入口函数</span></span><br><span class="line"><span class="comment">     * 把栈顶元素（即新协程）移动到1，覆盖入口函数，入口函数前面已经拷贝到新协程栈上了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* L栈: |新协程|args|顶| */</span></span><br><span class="line">    lua_replace(L, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 将参数移到新协程栈中 */</span></span><br><span class="line">    <span class="comment">/* L栈: |新协程|顶|*/</span></span><br><span class="line">    <span class="comment">/* co栈: |入口函数|args|顶| */</span></span><br><span class="line">    lua_xmove(L, coctx-&gt;co, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置状态，将父协程放入post_thread队列中，设置协程的父子关系，设置新协程为下一个调度的线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置状态 */</span></span><br><span class="line">coctx-&gt;co_status = NGX_STREAM_LUA_CO_RUNNING;</span><br><span class="line">ctx-&gt;co_op = NGX_STREAM_LUA_USER_THREAD_RESUME;</span><br><span class="line">ctx-&gt;cur_co_ctx-&gt;thread_spawn_yielded = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将父协程放入post_thread队列中 */</span></span><br><span class="line">ngx_stream_lua_post_thread(r, ctx, ctx-&gt;cur_co_ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存子线程的父协程上下文为当前协程 */</span></span><br><span class="line">coctx-&gt;parent_co_ctx = ctx-&gt;cur_co_ctx;</span><br><span class="line"><span class="comment">/* 切换当前协程为新创建的协程 */</span></span><br><span class="line">ctx-&gt;cur_co_ctx = coctx;</span><br></pre></td></tr></table></figure>

<p>最后，spawn函数的返回值是新创建的协程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将原协程的执行权切换出去，这里的参数1表示栈上留了一个值，这里是指新创建的协程</span></span><br><span class="line"><span class="comment"> * 主线程并不会取这个值，而是等到新线程spawn返回时作为返回值。</span></span><br><span class="line"><span class="comment"> * 此时L栈中是新协程，co栈中是参数和入口函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> lua_yield(L, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="用户创建的coroutine"><a href="#用户创建的coroutine" class="headerlink" title="用户创建的coroutine"></a>用户创建的coroutine</h2><p>OR替换了原生的coroutine接口，当存在<code>getfenv(0).__ngx_req</code>时（全局环境保存了nginx请求），使用重写后的coroutine接口函数。</p>
<p><code>coroutine.create()</code>创建新协程部分跟uthread是一样的，都是调用<code>ngx_stream_lua_coroutine_create_helper()</code>。Lua函数返回新协程。此时新协程栈中是入口函数。</p>
<p><code>coroutine.resume()</code>用于开始或恢复新协程，其对应的C函数是<code>ngx_http_lua_coroutine_resume()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 首先，获取到协程 */</span></span><br><span class="line"><span class="comment">/* L栈: |co|参数|,  co栈: |入口函数| */</span></span><br><span class="line">co = lua_tothread(L, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 然后设置状态和父子关系 */</span></span><br><span class="line"><span class="comment">/* 父协程为normal */</span></span><br><span class="line">p_coctx-&gt;co_status = NGX_HTTP_LUA_CO_NORMAL;</span><br><span class="line"></span><br><span class="line">coctx-&gt;parent_co_ctx = p_coctx;</span><br><span class="line"></span><br><span class="line">dd(<span class="string">&quot;set coroutine to running&quot;</span>);</span><br><span class="line"><span class="comment">/* 子协程为running */</span></span><br><span class="line">coctx-&gt;co_status = NGX_HTTP_LUA_CO_RUNNING;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置co_op告知主线程yield类型 */</span></span><br><span class="line">ctx-&gt;co_op = NGX_HTTP_LUA_USER_CORO_RESUME;</span><br><span class="line"><span class="comment">/* 设置下一个调度协程为新协程 */</span></span><br><span class="line">ctx-&gt;cur_co_ctx = coctx;</span><br></pre></td></tr></table></figure>

<p>接下来，将控制权交还给主协程，并把参数传给主线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此时L栈: |co|参数|， co栈: |入口函数| */</span></span><br><span class="line"><span class="comment">/* lua_gettop(L) - 1表示留在栈中的返回值个数，</span></span><br><span class="line"><span class="comment"> * 由主线程取用之后，在lua_resume新协程时传递 */</span></span><br><span class="line"><span class="comment">/* 减一个，表示不传底下的co */</span></span><br><span class="line"><span class="keyword">return</span> lua_yield(L, lua_gettop(L) - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h1 id="协程执行和恢复"><a href="#协程执行和恢复" class="headerlink" title="协程执行和恢复"></a>协程执行和恢复</h1><p>OR中协程的执行和恢复总是由主线程来进行，不管是<code>coroutine.resume()</code>还是<code>ngx.thread.spawn()</code>，都是先<code>lua_yield()</code>回到主线程之后，在主线程中<code>lua_resume()</code>。</p>
<p>注意到前面创建阶段，thread是<code>lua_yield(L, 1)</code>，coroutine是<code>lua_yield(L, lua_gettop(L) - 1)</code>。yield到主线程之后，我们继续看调度程序的处理。</p>
<h2 id="uthread"><a href="#uthread" class="headerlink" title="uthread"></a>uthread</h2><p>先获取参数个数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 因为入口函数和参数已经在新线程栈中了,所以从新协程中获取参数个数，-1是除掉入口函数 */</span></span><br><span class="line">nrets = lua_gettop(ctx-&gt;cur_co_ctx-&gt;co) - <span class="number">1</span>;    </span><br></pre></td></tr></table></figure>

<p>然后跳到主循环的前面，执行新线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 保存新协程coctx */</span></span><br><span class="line">orig_coctx = ctx-&gt;cur_co_ctx;</span><br><span class="line"><span class="comment">/* 执行新线程，其中nrets为参数个数 */</span></span><br><span class="line">rv = lua_resume(orig_coctx-&gt;co, nrets);</span><br></pre></td></tr></table></figure>

<p>在<code>lua_resume</code>中就会开始新线程的执行。当新线程执行完毕或因I/O中断yield之后，会恢复父协程。在恢复父协程之前，先设置参数个数为1，即之前留在栈上的新协程co。恢复父协程之后，<code>ngx.thread.spawn()</code>函数就返回了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx-&gt;cur_co_ctx-&gt;thread_spawn_yielded) &#123;</span><br><span class="line">    ctx-&gt;cur_co_ctx-&gt;thread_spawn_yielded = <span class="number">0</span>;</span><br><span class="line">    nrets = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="coroutine"><a href="#coroutine" class="headerlink" title="coroutine"></a>coroutine</h2><p>同样是先获取参数个数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取父协程 */</span></span><br><span class="line">old_co = ctx-&gt;cur_co_ctx-&gt;parent_co_ctx-&gt;co;</span><br><span class="line"><span class="comment">/* 因为参数还在父协程栈中，所以从父协程栈中获取参数个数 */</span></span><br><span class="line">nrets = lua_gettop(old_co);</span><br><span class="line"><span class="keyword">if</span> (nrets) &#123;</span><br><span class="line">    <span class="comment">/* 将参数从父协程移到子协程 */</span></span><br><span class="line">    lua_xmove(old_co, ctx-&gt;cur_co_ctx-&gt;co, nrets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时子协程栈中是参数和入口函数。</p>
<p>然后跳到主循环的前面，执行新协程，跟前面uthread时一样。</p>
<h1 id="协程挂起"><a href="#协程挂起" class="headerlink" title="协程挂起"></a>协程挂起</h1><p>协程的挂起分为两种情况：</p>
<ul>
<li>一种是内部在I/O等待时自动挂起，这种情况用户不用参与，OR会自动将相应的事件及其handler挂到事件驱动上，当事件被唤醒时继续未完成的I/O操作，完成之后由调度器恢复之前挂起的协程。</li>
<li>另一种是用户在Lua代码主动调用<code>coroutine.yield()</code>挂起。此时由调度器根据情况决定执行下一个执行的协程。</li>
</ul>
<h2 id="显式主动挂起"><a href="#显式主动挂起" class="headerlink" title="显式主动挂起"></a>显式主动挂起</h2><p>我们先来看用户主动挂起的情况，<code>coroutine.yield()</code>对应的C函数为<code>ngx_stream_lua_coroutine_yield()</code>。我们先来看看它里面干了些什么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 首先修改当前协程的状态为挂起 */</span></span><br><span class="line">coctx = ctx-&gt;cur_co_ctx;</span><br><span class="line">coctx-&gt;co_status = NGX_STREAM_LUA_CO_SUSPENDED;</span><br><span class="line"><span class="comment">/* 设置co_op */</span></span><br><span class="line">ctx-&gt;co_op = NGX_STREAM_LUA_USER_CORO_YIELD;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果不是用户线程（也即是普通coroutine），且有父协程，</span></span><br><span class="line"><span class="comment">   将其父协程状态设置为running */</span></span><br><span class="line"><span class="keyword">if</span> (!coctx-&gt;is_uthread &amp;&amp; coctx-&gt;parent_co_ctx) &#123;</span><br><span class="line">    coctx-&gt;parent_co_ctx-&gt;co_status = NGX_STREAM_LUA_CO_RUNNING;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 最后将控制权交还主线程，将所有yield参数传递给主线程 */</span></span><br><span class="line"><span class="keyword">return</span> lua_yield(L, lua_gettop(L));</span><br></pre></td></tr></table></figure>

<p>回到主线程之后，根据待挂起协程是thread还是corotine进行不同处理。</p>
<h3 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ngx_stream_lua_is_thread(ctx)) &#123;</span><br><span class="line">    <span class="comment">/* 丢弃coroutine.yield()的任何参数 */</span></span><br><span class="line">    lua_settop(ctx-&gt;cur_co_ctx-&gt;co, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 因为thread由调度器负责调度，所以将当前线程的状态改为running，为什么不在前面一起改？*/</span></span><br><span class="line">    ctx-&gt;cur_co_ctx-&gt;co_status = NGX_STREAM_LUA_CO_RUNNING;</span><br><span class="line">    <span class="comment">/* 如果已经有pending的线程，则放到队列中 */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;posted_threads) &#123;</span><br><span class="line">        ngx_stream_lua_post_thread(r, ctx, ctx-&gt;cur_co_ctx);</span><br><span class="line">        ctx-&gt;cur_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 否则，立即恢复线程 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="coroutine-1"><a href="#coroutine-1" class="headerlink" title="coroutine"></a>coroutine</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取当前栈的高度，也即coroutine.yield()的参数个数 */</span></span><br><span class="line">nrets = lua_gettop(ctx-&gt;cur_co_ctx-&gt;co);</span><br><span class="line"><span class="comment">/* 设置父协程为下一个调度的协程 */</span></span><br><span class="line">next_coctx = ctx-&gt;cur_co_ctx-&gt;parent_co_ctx;</span><br><span class="line">next_co = next_coctx-&gt;co;</span><br><span class="line"><span class="comment">/* 将参数从子协程栈中移到父协程栈中 */</span></span><br><span class="line"><span class="keyword">if</span> (nrets) &#123;</span><br><span class="line">    dd(<span class="string">&quot;moving %d return values to next co&quot;</span>, nrets);</span><br><span class="line">    lua_xmove(ctx-&gt;cur_co_ctx-&gt;co, next_co, nrets);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NGX_LUA_USE_ASSERT</span></span><br><span class="line">    ctx-&gt;cur_co_ctx-&gt;co_top -= nrets;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 如果不是wrap封装的，还要加一个true，作为第一个参数 */</span></span><br><span class="line"><span class="keyword">if</span> (!ctx-&gt;cur_co_ctx-&gt;is_wrap) &#123;</span><br><span class="line">    <span class="comment">/* prepare return values for coroutine.resume</span></span><br><span class="line"><span class="comment">     * (true plus any retvals)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lua_pushboolean(next_co, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 插入1的位置，作为第一个参数 */</span></span><br><span class="line">    lua_insert(next_co, <span class="number">1</span>);</span><br><span class="line">    nrets++; <span class="comment">/* add the true boolean value */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx-&gt;cur_co_ctx = next_coctx;</span><br><span class="line"><span class="comment">/* 回到主循环的前面，resume父协程 */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h2 id="I-O等待场景"><a href="#I-O等待场景" class="headerlink" title="I/O等待场景"></a>I/O等待场景</h2><p>I/O等待的场景有很多，不过其背后的原理都差不多：</p>
<ul>
<li>定义一个事件，设置恢复时的handler及对应协程上下文，然后<code>lua_yield()</code>回到<code>run_thread()</code>。</li>
<li>主线程将<code>ctx-&gt;cur_co_ctx</code>设为空之后，直接返回<code>NGX_AGAIN</code>，如果有<code>posted_thread</code>会继续执行，否则将控制权交还给nginx层</li>
<li>后续当事件发生时，继续未完成的操作，完成之后将保存的协程上下文设为<code>ctx-&gt;cur_co_ctx</code>，然后调用<code>ngx_stream_lua_run_thread()</code>恢复协程的执行。</li>
</ul>
<p>这里举两个典型的例子:</p>
<h3 id="ngx-sleep"><a href="#ngx-sleep" class="headerlink" title="ngx.sleep()"></a>ngx.sleep()</h3><p>它的C函数实现是<code>ngx_stream_lua_ngx_sleep()</code>，先定义设置好handler和coctx，挂上定时器，然后<code>lua_yield()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    ngx_stream_lua_cleanup_pending_operation(coctx);</span><br><span class="line">    coctx-&gt;cleanup = ngx_stream_lua_sleep_cleanup;</span><br><span class="line">    coctx-&gt;data = r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 保存恢复时的handler和协程上下文 */</span></span><br><span class="line">    coctx-&gt;sleep.handler = ngx_stream_lua_sleep_handler;</span><br><span class="line">    coctx-&gt;sleep.data = coctx;</span><br><span class="line">    coctx-&gt;sleep.<span class="built_in">log</span> = r-&gt;connection-&gt;<span class="built_in">log</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当delay为0时，放入post_event队列或添加定时器 */</span></span><br><span class="line">    <span class="keyword">if</span> (delay == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_POSTED_DELAYED_EVENTS_PATCH</span></span><br><span class="line">        dd(<span class="string">&quot;posting 0 sec sleep event to head of delayed queue&quot;</span>);</span><br><span class="line"></span><br><span class="line">        coctx-&gt;sleep.delayed = <span class="number">1</span>;</span><br><span class="line">        ngx_post_event(&amp;coctx-&gt;sleep, &amp;ngx_posted_delayed_events);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        ngx_log_error(NGX_LOG_WARN, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;ngx.sleep(0)&quot;</span></span><br><span class="line">                      <span class="string">&quot; called without delayed events patch, this will&quot;</span></span><br><span class="line">                      <span class="string">&quot; hurt performance&quot;</span>);</span><br><span class="line">        ngx_add_timer(&amp;coctx-&gt;sleep, (<span class="keyword">ngx_msec_t</span>) delay);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">/* 添加定时器 */</span></span><br><span class="line">        ngx_add_timer(&amp;coctx-&gt;sleep, (<span class="keyword">ngx_msec_t</span>) delay);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 外层函数*/</span></span><br><span class="line">    <span class="keyword">return</span> lua_yield(L, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在<code>run_thread()</code>里将当前协程上下文置为<code>NULL</code>，然后返回<code>NGX_AGAIN</code></p>
<p>在<code>by_chunk()</code>里会先检查有没有在post队列里的线程，如果没有则返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rc = ngx_stream_lua_run_thread(L, r, ctx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rc == NGX_ERROR || rc &gt;= NGX_OK) &#123;</span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == NGX_AGAIN) &#123;</span><br><span class="line">    rc = ngx_stream_lua_content_run_posted_threads(L, r, ctx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == NGX_DONE) &#123; <span class="comment">/* 这里DONE的情况只有HTTP子请求的时候会出现 */</span></span><br><span class="line">    rc = ngx_stream_lua_content_run_posted_threads(L, r, ctx, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    rc = NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当定时器超时时，它会执行<code>sleep_handler()</code>，设置<code>ctx-&gt;cur_co_ctx</code>然后执行<code>run_thread()</code>恢复协程调度。</p>
<h3 id="ngx-tcp-receive"><a href="#ngx-tcp-receive" class="headerlink" title="ngx.tcp.receive()"></a>ngx.tcp.receive()</h3><p>其对应的C函数实现是<code>ngx_stream_lua_socket_tcp_receive()</code>，里面会调<code>ngx_stream_lua_socket_tcp_receive_helper()</code>。碰到读等待的情况，也是先设置好handler和coctx，然后<code>lua_yield()</code>。我们来看下里面代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这里0表示还未进行协程切换 */</span></span><br><span class="line">u-&gt;read_waiting = <span class="number">0</span>;</span><br><span class="line">u-&gt;read_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取的主要逻辑由此函数处理 */</span></span><br><span class="line">rc = ngx_stream_lua_socket_tcp_read(r, u);</span><br><span class="line"><span class="comment">/* 不管是成功、出错或等待I/O，肯定会返回 */</span></span><br><span class="line"><span class="keyword">if</span>(rc == NGX_ERROR) &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(rc == NGX_OK) &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rc == NGX_AGAIN */</span></span><br><span class="line"><span class="comment">/* 如果是等待I/O的情况，设置事件触发时的handler、当前协程上下文 */</span></span><br><span class="line">u-&gt;read_event_handler = ngx_stream_lua_socket_read_handler;</span><br><span class="line">coctx = lctx-&gt;cur_co_ctx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置请求的写事件handler，这个是返回到Lua层前调用的handler */</span></span><br><span class="line">r-&gt;write_event_handler = ngx_stream_lua_content_wev_handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存当前协程上下文到u上 */</span></span><br><span class="line">u-&gt;read_co_ctx = coctx;</span><br><span class="line"><span class="comment">/* 表示是后续是需要协程恢复的 */</span></span><br><span class="line">u-&gt;read_waiting = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 设置准备返回值的回调 */</span></span><br><span class="line">u-&gt;read_prepare_retvals = ngx_stream_lua_socket_tcp_receive_retval_handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lua_yield(L, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>回到<code>run_thread()</code>，同样是将当前协程上下文置为<code>NULL</code>，然后返回<code>NGX_AGAIN</code>。</p>
<p>当事件被触发时，执行前面设置的<code>ngx_stream_lua_socket_read_handler()</code>，里面又会调用读取操作核心函数<code>ngx_stream_lua_socket_tcp_read()</code>。如果继续碰到等待I/O，handler直接结束，等待下一次事件。如果是完成或出错，会执行如下操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 恢复该值为0 */</span></span><br><span class="line">u-&gt;read_waiting = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 获取协程上下文 */</span></span><br><span class="line">coctx = u-&gt;read_co_ctx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置协程恢复的handler */</span></span><br><span class="line">ctx-&gt;resume_handler = ngx_stream_lua_socket_tcp_read_resume;</span><br><span class="line"><span class="comment">/* 设置下一个调度的上下文，为之前调用读取操作的协程 */</span></span><br><span class="line">ctx-&gt;cur_co_ctx = coctx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个handler就是yield之前设置的那个，它里面调用 ctx-&gt;resume_handler */</span></span><br><span class="line">r-&gt;write_event_handler(r);  </span><br></pre></td></tr></table></figure>

<p><code>r-&gt;write_event_handler(r);</code>是返回Lua层前调用的handler，里面会调用<code>resume_handler</code>。<code>ngx_stream_lua_socket_tcp_read_resume()</code>只是封装了一下，最终都是调用的<code>ngx_stream_lua_socket_tcp_resume_helper()</code>，我们看来下它的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 待恢复协程上下文 */</span></span><br><span class="line">coctx = ctx-&gt;cur_co_ctx;</span><br><span class="line"></span><br><span class="line">u = coctx-&gt;data;</span><br><span class="line">prepare_retvals = u-&gt;read_prepare_retvals;</span><br><span class="line"><span class="comment">/* 准备返回值 */</span></span><br><span class="line">nret = prepare_retvals(r, u, ctx-&gt;cur_co_ctx-&gt;co);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复协程调度，回到Lua层 */</span></span><br><span class="line">rc = ngx_stream_lua_run_thread(vm, r, ctx, nret);</span><br></pre></td></tr></table></figure>

<p>至于完成的条件，取决与不同的调用方式。如果是读取固定字节数的话，会维护一个剩余待读取的字节数<code>u-&gt;rest</code>。如果是读取一行，则读取到<code>\n</code>就结束。如果是readall，则一直读到<code>u-&gt;eof</code>为止。</p>
<h1 id="协程执行完毕"><a href="#协程执行完毕" class="headerlink" title="协程执行完毕"></a>协程执行完毕</h1><p>为了不失完整性，再说一下正常结束和出错时的情况。正常执行完毕时，会设置协程状态，然后清理它的僵尸子线程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将当前协程状态置为DEAD */</span></span><br><span class="line">ctx-&gt;cur_co_ctx-&gt;co_status = NGX_STREAM_LUA_CO_DEAD;</span><br><span class="line"><span class="comment">/* 如果子线程有僵尸线程，则清理之 */</span></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;cur_co_ctx-&gt;zombie_child_threads) &#123;</span><br><span class="line">    ngx_stream_lua_cleanup_zombie_child_uthreads(</span><br><span class="line">        r, L, ctx, ctx-&gt;cur_co_ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，根据结束的协程的类型不同执行不同的操作：</p>
<h2 id="入口线程"><a href="#入口线程" class="headerlink" title="入口线程"></a>入口线程</h2><p>此时直接删除线程即可，然后根据是否还有用户线程，选择返回<code>NGX_AGAIN</code>或<code>NGX_OK</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ngx_stream_lua_is_entry_thread(ctx)) &#123;</span><br><span class="line">    <span class="comment">/* 将虚拟机栈清空 */</span></span><br><span class="line">    lua_settop(L, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 删除当前线程，会从REGISTY表中解引用当前协程的`coctx-&gt;co_ref` */</span></span><br><span class="line">    ngx_stream_lua_del_thread(r, L, ctx, ctx-&gt;cur_co_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果还有其他用户线程，返回NGX_AGAIN */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;uthreads) &#123;</span><br><span class="line">        ctx-&gt;cur_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> NGX_AGAIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* all user threads terminated already */</span></span><br><span class="line">    <span class="keyword">goto</span> done;      <span class="comment">/* 到这就圆满结束了 return NGX_OK; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h2><p>此时如果父协程已经死了，处理方式跟入口线程一样，即删除线程，然后根据是否还有任何用户线程或入口线程，选择返回<code>NGX_AGAIN</code>或<code>NGX_OK</code>。</p>
<p>如果父协程还活着，并且已经在wait它了，直接恢复父协程。否则，加入到父协程的僵尸线程列表中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx-&gt;cur_co_ctx-&gt;is_uthread) &#123;</span><br><span class="line">    <span class="comment">/* 清空虚拟机栈 */</span></span><br><span class="line">    lua_settop(L, <span class="number">0</span>); </span><br><span class="line">    <span class="comment">/* 获取父协程 */</span></span><br><span class="line">    parent_coctx = ctx-&gt;cur_co_ctx-&gt;parent_co_ctx;</span><br><span class="line">    <span class="comment">/* 如果父协程还活着 */</span></span><br><span class="line">    <span class="keyword">if</span> (ngx_stream_lua_coroutine_alive(parent_coctx)) &#123;</span><br><span class="line">        <span class="comment">/* 并且在wait当前线程，则恢复父协程 */</span></span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;cur_co_ctx-&gt;waited_by_parent) &#123;</span><br><span class="line">            ngx_stream_lua_probe_info(<span class="string">&quot;parent already waiting&quot;</span>);</span><br><span class="line">            ctx-&gt;cur_co_ctx-&gt;waited_by_parent = <span class="number">0</span>;</span><br><span class="line">            success = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> user_co_done;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 否则将当前线程挂到父协程的僵尸子线程中 */</span></span><br><span class="line">        <span class="keyword">if</span> (ngx_stream_lua_post_zombie_thread(r, parent_coctx,</span><br><span class="line">                                              ctx-&gt;cur_co_ctx)</span><br><span class="line">            != NGX_OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 压入第一个返回值true，以备后续wait时返回 */</span></span><br><span class="line">        lua_pushboolean(ctx-&gt;cur_co_ctx-&gt;co, <span class="number">1</span>);</span><br><span class="line">        lua_insert(ctx-&gt;cur_co_ctx-&gt;co, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* 设置当前线程状态为ZOMBIE */</span></span><br><span class="line">        ctx-&gt;cur_co_ctx-&gt;co_status = NGX_STREAM_LUA_CO_ZOMBIE;</span><br><span class="line">        ctx-&gt;cur_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> NGX_AGAIN;       <span class="comment">/* 返回上层 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果父协程已经死了，直接删除当前线程</span></span><br><span class="line"><span class="comment">     * 会从REGISTY表中解引用当前协程的`coctx-&gt;co_ref` */</span></span><br><span class="line">    ngx_stream_lua_del_thread(r, L, ctx, ctx-&gt;cur_co_ctx);</span><br><span class="line">    ctx-&gt;uthreads--;</span><br><span class="line">    <span class="comment">/* 如果没有用户线程了 */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;uthreads == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 入口线程在活着，返回上层 */</span></span><br><span class="line">        <span class="keyword">if</span> (ngx_stream_lua_entry_thread_alive(ctx)) &#123;</span><br><span class="line">            ctx-&gt;cur_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> NGX_AGAIN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* all threads terminated already */</span></span><br><span class="line">        <span class="keyword">goto</span> done;  <span class="comment">/* 到这就圆满结束了 return NGX_OK; */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果还有其他用户线程，返回上层 */</span></span><br><span class="line">    ctx-&gt;cur_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> NGX_AGAIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户协程"><a href="#用户协程" class="headerlink" title="用户协程"></a>用户协程</h2><p>剩下的就是用户协程的情况，这个情况跟用户线程被父协程wait的情况是一样的。主要是将返回值移动到父协程栈中，然后跳到主循环前面恢复父协程的执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">success = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 获取返回值个数 */</span></span><br><span class="line">nrets = lua_gettop(ctx-&gt;cur_co_ctx-&gt;co);</span><br><span class="line">next_coctx = ctx-&gt;cur_co_ctx-&gt;parent_co_ctx;</span><br><span class="line">next_co = next_coctx-&gt;co;</span><br><span class="line"><span class="comment">/* 将返回值移到父协程栈中 */</span></span><br><span class="line"><span class="keyword">if</span> (nrets) &#123;</span><br><span class="line">    lua_xmove(ctx-&gt;cur_co_ctx-&gt;co, next_co, nrets);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 如果是用户线程，删除之 */</span></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;cur_co_ctx-&gt;is_uthread) &#123;</span><br><span class="line">    ngx_stream_lua_del_thread(r, L, ctx, ctx-&gt;cur_co_ctx);</span><br><span class="line">    ctx-&gt;uthreads--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 除了wrap的用户协程，加上第一个true的返回值 */</span></span><br><span class="line"><span class="keyword">if</span> (!ctx-&gt;cur_co_ctx-&gt;is_wrap) &#123;</span><br><span class="line">    <span class="comment">/* ended successfully, coroutine.resume returns true plus</span></span><br><span class="line"><span class="comment">     * any return values</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lua_pushboolean(next_co, success);</span><br><span class="line">    lua_insert(next_co, <span class="number">1</span>);</span><br><span class="line">    nrets++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置父协程的状态为RUNNING */</span></span><br><span class="line">ctx-&gt;cur_co_ctx = next_coctx;</span><br><span class="line">next_coctx-&gt;co_status = NGX_STREAM_LUA_CO_RUNNING;</span><br><span class="line"><span class="comment">/* 回到主循环前面，恢复父协程的执行 */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>



<h1 id="出错的情况"><a href="#出错的情况" class="headerlink" title="出错的情况"></a>出错的情况</h1><p>大致处理步骤是，恢复<code>cur_co_ctx</code>，获取虚拟机L栈上错误信息，获取当前协程栈中错误信息，后面的操作类似协程执行完毕时，根据不同的情况选择恢复父协程或者返回上层。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 恢复cur_co_ctx */</span></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;cur_co_ctx != orig_coctx) &#123;</span><br><span class="line">    ctx-&gt;cur_co_ctx = orig_coctx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 设置当前协程状态为DEAD */</span></span><br><span class="line">ctx-&gt;cur_co_ctx-&gt;co_status = NGX_HTTP_LUA_CO_DEAD;</span><br><span class="line"><span class="comment">/* 获取错误信息 */</span></span><br><span class="line"><span class="keyword">if</span> (orig_coctx-&gt;is_uthread</span><br><span class="line">    || orig_coctx-&gt;is_wrap</span><br><span class="line">    || ngx_http_lua_is_entry_thread(ctx))</span><br><span class="line">&#123;</span><br><span class="line">    ngx_http_lua_thread_traceback(L, orig_coctx-&gt;co, orig_coctx);</span><br><span class="line">    trace = lua_tostring(L, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lua_isstring(orig_coctx-&gt;co, <span class="number">-1</span>)) &#123;</span><br><span class="line">        msg = lua_tostring(orig_coctx-&gt;co, <span class="number">-1</span>);</span><br><span class="line">        dd(<span class="string">&quot;user custom error msg: %s&quot;</span>, msg);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg = <span class="string">&quot;unknown reason&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户线程-1"><a href="#用户线程-1" class="headerlink" title="用户线程"></a>用户线程</h2><p>跟正常结束的处理一样，除了第一个返回值是false。</p>
<p>此时如果父协程已经死了，直接删除线程，然后根据是否还有任何用户线程或入口线程，选择返回<code>NGX_AGAIN</code>或<code>NGX_OK</code>。</p>
<p>如果父协程还活着，并且已经在wait它了，直接恢复父协程。否则，加入到父协程的僵尸线程列表中。</p>
<h2 id="入口线程-1"><a href="#入口线程-1" class="headerlink" title="入口线程"></a>入口线程</h2><p><code>ngx_stream_lua_request_cleanup()</code>清理当前请求，里面会清理掉所有的用户创建的协程，然后清理入口协程自己。最后返回错误码。</p>
<h2 id="用户协程-1"><a href="#用户协程-1" class="headerlink" title="用户协程"></a>用户协程</h2><p>如果是wrap的协程，将错误传递给父协程（就好像是父协程出错了，然后父协程重新走一遍上面的出错处理流程）。</p>
<p>如果是普通协程，则恢复父协程的执行，返回false和错误信息。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://openresty-reference.readthedocs.io/en/latest/Lua_Nginx_API/">Lua-Ngx-API</a></li>
<li><a href="https://github.com/openresty/stream-lua-nginx-module">stream-lua-nginx源码</a></li>
<li><a href="https://www.lua.org/manual/5.1/manual.html">lua-5.1-manual</a></li>
<li><a href="https://www.codedump.info/post/20190501-lua-stream/">lua stream实现分析</a></li>
</ul>
]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>OpenResty</tag>
        <tag>Nginx</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章搞懂密码学基础及SSL/TLS协议</title>
    <url>/posts/e92ef4b4/</url>
    <content><![CDATA[<div class="note primary">
            <p>SSL协议是现代网络通信中重要的一环，它提供了传输层上的数据安全。为了方便大家的理解，本文将先从加密学的基础知识入手，然后展开对SSL协议原理、流程以及一些重要的特性的详解，最后会扩展介绍一下国密SSL协议的差异、安全性以及TLS 1.3的关键新特性。</p><p>限于篇幅以及个人知识水平，本文不会涉及过于细节的内容。特别地，本文将不涉及算法的具体原理，也不涉及实际代码的实现。而是试图以图表等直观的方式来了解基本的原理以及流程。</p>
          </div>

<span id="more"></span>

<h1 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h1><h2 id="古典的密码"><a href="#古典的密码" class="headerlink" title="古典的密码"></a>古典的密码</h2><p>密码学的历史可以追溯到很久以前，早在罗马共和国时期，据说凯撒就使用凯撒密码和他的将军进行通信。</p>
<h3 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h3><p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Caesar3.svg" alt="Caesar Cipher" loading="lazy"></p>
<p>凯撒密码就是一个简单地移位操作。凯撒密钥非常容易被破解，使用<strong>暴力破解</strong>的方式把密钥从0到25都尝试一遍就可以了。</p>
<h3 id="简单替换密码"><a href="#简单替换密码" class="headerlink" title="简单替换密码"></a>简单替换密码</h3><p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/simple-substitution-cipher.png" alt="Simple Substitution Cipher" loading="lazy"></p>
<p>简单替换密码，其明文字母表和密文字母表之间是一种随机的映射关系。这种方式密钥空间为<code>26! ~= 4 * 10^26</code>，这已经无法使用暴力破解方式来找到正确的密钥。但是可以使用<strong>频率分析</strong>来破译。</p>
<h3 id="Enigma密码机"><a href="#Enigma密码机" class="headerlink" title="Enigma密码机"></a>Enigma密码机</h3><p>二战时期德国使用的一系列转子机械加解密机器。尽管此机器的安全性较高，但盟军的密码学家们还是成功地破译了大量由这种机器加密的信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Enigma.jpg" alt="Enigma" loading="lazy"></p>
<p>主要弱点：</p>
<ul>
<li>将通信密码连续输入两次并加密</li>
<li>通信密码是人为选定</li>
<li>必须派发国防军密码本</li>
</ul>
<h2 id="对称密码"><a href="#对称密码" class="headerlink" title="对称密码"></a>对称密码</h2><h3 id="块密码和流密码"><a href="#块密码和流密码" class="headerlink" title="块密码和流密码"></a>块密码和流密码</h3><p>上面几种密码其实都属于对称密码的范畴，对称加密算法可以分为块密码和流密码两种：</p>
<ul>
<li>块密码（block cipher）：每次只能处理特定长度的数据块。一个块的长度就叫块长度（分组长度）</li>
<li>流密码（stream cipher）：对数据流进行连续处理的一类密码算法。一般以1比特、8比特或32比特为单位进行加密和解密。</li>
</ul>
<h3 id="AES-Advanced-Encryption-Standard"><a href="#AES-Advanced-Encryption-Standard" class="headerlink" title="AES (Advanced Encryption Standard)"></a>AES (Advanced Encryption Standard)</h3><p>AES是目前最常用的对称算法之一。对称加密算法，顾名思义，就是<strong>加密和解密使用相同的密钥</strong>。发送方使用密钥K对明文P进行加密得到密文C，然后将密文C发送给接收方，接收方使用相同的密钥K对密文进行解密，得到明文P。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/symmetric-cipher-flow.png" alt="symmetric-cipher-flow" loading="lazy"></p>
<p>AES采用的是Rijndael算法，下图是Rijndael加密中一轮的操作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/RijndaelEncrypt.png" alt="RijndaelEncrypt" loading="lazy"></p>
<p>每一轮都会进行字节替换、行位移、列混合和轮密钥异或，使得输入的位得到充分的<strong>混淆</strong>。一个块的加密会经过很多轮的操作，最终得到密文。</p>
<p>因为这4轮操作都是<strong>可逆</strong>的，解密的时候就是一个相反的过程。</p>
<h2 id="块密码的模式"><a href="#块密码的模式" class="headerlink" title="块密码的模式"></a>块密码的模式</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而块与块之间进行<strong>迭代的方法</strong>就称为分组密码的<strong>模式（mode）</strong>。</p>
<p>常用模式由：ECB、CBC、OFB、CFB、CTR等。这边限于篇幅，仅介绍ECB、CBC、CTR三种。</p>
<h4 id="ECB模式"><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h4><p>ECB是最简单的一种模式，每个块是独立进行加密的。将明文分组加密之后的结果直接成为密文分组。当最后一个明文分组的内容小于分组长度时，需要用一些特定的数据进行填充（padding）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Ecb_encryption.png" alt="Ecb_encryption" loading="lazy"></p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Ecb_decryption.png" alt="Ecb_decryption" loading="lazy"></p>
<p>ECB模式有非常显著的<strong>缺点</strong>：同样的明文块会被加密成相同的密文块；因此，它不能很好的隐藏数据模式。在某些场合，这种方法不能提供严格的数据保密性。</p>
<p>比如下面的企鹅图，用ECB模式加密之后得到中间的图，还是能很明显地看出图片的轮廓，不能很好的保护数据的机密性。而用其他模式加密之后，就得到如第三个图所示的结果，已经看不出明显的特征。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/ecb-penguin1.jpg" alt="原图" loading="lazy"> <img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/ecb-penguin2.jpeg" alt="ECB模式" loading="lazy"><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/ecb-penguin3.jpg" alt="其他模式" loading="lazy"></p>
<h4 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h4><p>CBC模式中，每个明文块先与前一个密文块进行异或，再进行加密。所以每个明文块都依赖于前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量（IV）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Cbc_encryption.png" alt="Cbc_encryption" loading="lazy"></p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Cbc_decryption.png" alt="Cbc_decryption" loading="lazy"></p>
<p>CBC是TLS1.2时代最为常用的工作模式。它没有ECB模式那个相同原文加密称相同密文的问题，但是也因此导致其并行计算能力不如ECB模式。</p>
<h4 id="CTR模式"><a href="#CTR模式" class="headerlink" title="CTR模式"></a>CTR模式</h4><p>计数器模式其实是将块加密转换成了流加密，它对一个逐次累加的计数器进行加密，然后用加密的比特序列与明文进行XOR操作得到密文。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/CTR_encryption_2.svg" alt="CTR_encryption" loading="lazy"></p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/CTR_decryption_2.svg" alt="CTR_decryption" loading="lazy"></p>
<p>计数器的作用跟CBC模式中的IV类似，保证相同的明文会加密成不同的密文。相比CBC等模式，CTR模式还有如下<strong>优点</strong>：它非常适合并行计算、错误密文中的对应比特只会影响明文中的对应比特。</p>
<h3 id="AEAD（Authenticated-Encryption-with-Associated-Data）"><a href="#AEAD（Authenticated-Encryption-with-Associated-Data）" class="headerlink" title="AEAD（Authenticated Encryption with Associated Data）"></a>AEAD（Authenticated Encryption with Associated Data）</h3><p>前面的那些模式都已经被发现存在不同程序的缺点或问题。在TLS1.3时代，只保留了AEAD类型的加密模式。AEAD在加密的同时增加了认证的功能，常用的有GCM、CCM、Ploy1305。</p>
<h4 id="GCM（Galois-Counter-Mode）"><a href="#GCM（Galois-Counter-Mode）" class="headerlink" title="GCM（Galois/Counter Mode）"></a>GCM（Galois/Counter Mode）</h4><p>GCM中的G是指的GMAC（关于MAC我们稍后会讲到），C就是指的我们前面提到的CTR计数器模式。下图右上角的部分就是上面的Counter模式加密，剩余部分则是GMAC。最终的结果包含初始计数器值、加密密文和MAC值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/GCM-Galois_Counter_Mode_with_IV.svg" alt="GCM-Galois_Counter_Mode_with_IV" loading="lazy"></p>
<h2 id="公钥密码（非对称密码）"><a href="#公钥密码（非对称密码）" class="headerlink" title="公钥密码（非对称密码）"></a>公钥密码（非对称密码）</h2><p>在使用对称加密时，一定会碰到<strong>密钥分发（密钥交换）</strong>的问题。使用预先共享密钥具有局限性，需要一种安全的方式将密钥交给对方。于是就引出了公钥密码。</p>
<h3 id="公钥密码算法（RSA、国密SM2）"><a href="#公钥密码算法（RSA、国密SM2）" class="headerlink" title="公钥密码算法（RSA、国密SM2）"></a>公钥密码算法（RSA、国密SM2）</h3><p>最常用的公钥密钥算法要数大名鼎鼎的RSA了，国密中则有SM2算法。公钥密码有两个密钥，其中一个是公开密钥，公开密钥可以散布，另一个是私有密钥，需要自己严密保管。比如Bob要发消息给Alice，Bob用Alice的公钥对消息进行加密，然后发送给Alice，Alice则用自己的私钥进行解密。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Public_key_encryption.svg" alt="Public_key_encryption" loading="lazy"></p>
<h3 id="Diffie-Hellman密钥交换"><a href="#Diffie-Hellman密钥交换" class="headerlink" title="Diffie-Hellman密钥交换"></a>Diffie-Hellman密钥交换</h3><p>另一种常用的公钥密码是DH类算法，可以用下图来形象地解释DH算法的原理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Diffie-Hellman_Key_Exchange.svg" alt="Diffie-Hellman_Key_Exchange" loading="lazy"></p>
<p>首先双方协商一个相同的底色（算法参数），然后各自生成自己私有的颜色（相当于私钥），并通过混合得到对应的公有颜色（相当于公钥）。随后双方交换各自的公有颜色，并与自己的私钥颜色混合，最终协商出一个相同的颜色（即交换的密钥）。窃听者就算得到了双方交换的这些信息，也无法生成相同的密钥，<strong>求解离散对象问题的困难度</strong>保证了DH算法的安全性。</p>
<h3 id="ECDH和ECDHE"><a href="#ECDH和ECDHE" class="headerlink" title="ECDH和ECDHE"></a>ECDH和ECDHE</h3><p><code>ECDH</code>是基于椭圆曲线的DH算法，原理上跟DH基本一样，主要是把有限域上的模幂运算替换成了椭圆曲线上的点乘运算。相比DH算法速度更快，可逆更难。</p>
<p>DH和ECDH都是使用的一个固定密钥，一旦密钥泄漏，以前所有的密文消息就都都破解了。<code>ECDHE</code>则提供了前向安全性，它每次使用一个临时的密钥，基于这个临时密钥进行密钥交换生成会话密钥。就算这个临时密钥泄漏了，也只影响本次SSL会话的消息。</p>
<h2 id="单向散列函数（Hash）"><a href="#单向散列函数（Hash）" class="headerlink" title="单向散列函数（Hash）"></a>单向散列函数（Hash）</h2><p>前面的对称密钥和公钥密码解决了信息传输的<strong>机密性</strong>问题，使我们传输的信息不被窃听。但是还没有解决<strong>完整性</strong>的问题，消息有可能在中途被“<strong>篡改</strong>”。所以就轮到单向散列函数出场了。</p>
<p><strong>单向散列函数</strong>可以根据输入的信息，计算出一个固定长度的散列值（摘要值），这个散列值可以作为消息的指纹用于检查消息的完整性。修改了原始消息的任意1个比特，最终生成的散列值可能就完全不同了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Cryptographic_Hash_Function.svg" alt="Cryptographic_Hash_Function" loading="lazy"></p>
<p>理想的散列函数具有以下几个性质：</p>
<ol>
<li>确定性：同样的消息总是产生同样的散列值</li>
<li>任何给定消息能够快速计算出散列值</li>
<li>单向性：无法通过散列值反算出消息</li>
<li><strong>弱抗碰撞性</strong>：难以找到可以生成给定散列值的消息</li>
<li><strong>强抗碰撞性</strong>：难以找到可以生成两条相同散列值的消息</li>
<li>消息的一个小的改动会导致Hash值的巨大变化</li>
</ol>
<h2 id="消息认证码（MAC）"><a href="#消息认证码（MAC）" class="headerlink" title="消息认证码（MAC）"></a>消息认证码（MAC）</h2><p>单向散列函数虽然保证了消息的<strong>完整性</strong>，但是聪明的攻击者可以将消息连同其散列值一起篡改了，而接收方却无法进行识别。所以还需要对消息进行<strong>认证</strong>，传统的认证方法有手写签名、盖章、手印、身份证、口令（其实是个共享密钥）等。在密码领域则可以通过消息认证码的方法进行认证。消息认证码相比单向散列函数，多了一个共享密钥对消息进行认证。攻击者因为没有这个密钥，所以无法伪造出MAC值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/MAC-vs-HASH.png" alt="MAC-vs-HASH" loading="lazy"></p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/HMAC-use-scene.png" alt="HMAC-use-scene" loading="lazy"></p>
<h3 id="MAC的问题"><a href="#MAC的问题" class="headerlink" title="MAC的问题"></a>MAC的问题</h3><ul>
<li>MAC跟对称密码一样需要一个共享密钥，所以也会有密钥分发的问题。</li>
<li>无法对第三方证明</li>
<li>无法防止否认</li>
</ul>
<h2 id="数字签名（RSA、ECDSA）"><a href="#数字签名（RSA、ECDSA）" class="headerlink" title="数字签名（RSA、ECDSA）"></a>数字签名（RSA、ECDSA）</h2><p>为了解决MAC的问题，又引入了数字签名。</p>
<p>数字签名同样属于公钥密码的范畴。跟之前不同的地方是，它使用私钥进行加密（该操作叫作签名），任何人都可以用公钥进行解密（该操作叫作验签）。因为公钥是公开的，所以解决了第三方证明的问题。又因为私钥只有本人具有，没有私钥的人事实上无法生成这段密文，所以也可以防止否认。所以MAC的三个问题都可以由数字签名解决。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Private_key_signing.svg" alt="Private_key_signing" loading="lazy"></p>
<p>通常配合散列函数使用，同时保证了完整性，也加快了速度。如下图所示，Alice发送消息给Bob。她先把自己的公钥发送给Bob，接着她对消息先计算一个散列值，然后用自己的私钥对这个散列值进行加密得到消息的签名值。然后她将初始的消息和签名一同发送给Bob。Bob收到之后，对消息进行同样的散列函数计算得到散列值，同时用Alice的公钥对签名数据进行解密，得到解密后散列值，然后在比较两个计算得到散列值是否一致，以验证签名的有效性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/DigitalSignature.png" alt="DigitalSignature" loading="lazy"></p>
<h2 id="数字证书、-CA"><a href="#数字证书、-CA" class="headerlink" title="数字证书、 CA"></a>数字证书、 CA</h2><p>到目前为止，我们的公钥密码、数字签名解决了机密性、完整性、可以进行认证以及防止否认等。但其实这一切都是基于一个大前提：就是<strong>公钥是属于真正的发送者</strong>。如果公钥是伪造的、那么这一切就都失效了。前面提到的数字签名只能保证对方拥有这个公钥对应的私钥，但是没法认证公钥所有者本身的身份。</p>
<p>为了解决这个问题，数字证书应运而出。它的解决方式就是让一个<strong>可信的第三方</strong>来对公钥进行签名。这个可信的第三方，我们一般称之为<strong>Certificate authorities（CA）</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Chain-of-trust-with-cert.svg" loading="lazy"></p>
<p>我们来看看实际证书是什么样子的。其中<code>Subject</code>是证书拥有者的信息，<code>Issuer</code>就是其签发者的信息，<code>Subject Public Key Info</code>是实际的公钥信息，这里用的是RSA 2048位的密钥。证书最后就是CA用自己的私钥对这个证书的签名。任何拥有CA的证书（包含公钥）的人都可以对这个证书进行验证，从而验证公钥所有者的身份。<code>Validity</code>是这个证书的有效期。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ openssl x509 -<span class="keyword">in</span> ~/sharefile/certs/rsa-user.pem -text -noout</span><br><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number:</span><br><span class="line">            a2:95:90:e8:e0:f6:3a:e4</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">        Issuer: C=CN, ST=SH, L=Shanghai, O=Awesome Software, OU=SSL Group, CN=RSA_CA_Cert/emailAddress=ssl@ca.com</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Nov  5 01:47:05 2018 GMT</span><br><span class="line">            Not After : Nov  2 01:47:05 2028 GMT</span><br><span class="line">        Subject: C=CN, ST=SH, L=Shanghai, O=Awesome Software, OU=SSL Group, CN=RSA_USER/emailAddress=rsa@site.com</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: rsaEncryption</span><br><span class="line">                Public-Key: (2048 bit)</span><br><span class="line">                Modulus:</span><br><span class="line">                    00:f4:a0:b6:57:e7:68:39:98:39:13:11:b9:61:ee:</span><br><span class="line">                    1d:5c:60:c6:53:51:ec:0e:59:53:0e:12:75:1c:5b:</span><br><span class="line">                    b1:b7:e4:dd:4d:c8:c1:b8:eb:07:32:12:a1:<span class="built_in">fc</span>:50:</span><br><span class="line">                    33:d9:63:4a:30:7f:b4:b5:e9:87:d9:71:33:65:ab:</span><br><span class="line">                    56:54:ba:34:92:06:9a:af:ff:84:8e:a3:29:af:46:</span><br><span class="line">                    61:3b:45:39:c5:a8:0a:f9:ae:fb:d4:2b:20:5a:9d:</span><br><span class="line">                    ce:00:fe:c9:87:b2:f4:d2:f8:bf:b7:2e:7a:79:5e:</span><br><span class="line">                    94:54:7d:f9:09:73:4a:ec:c7:22:01:79:4c:62:11:</span><br><span class="line">                    55:a9:d3:3b:f8:ef:3e:1d:56:e3:2f:34:ef:c6:0f:</span><br><span class="line">                    2c:94:40:01:a3:6f:1e:3b:61:bd:79:00:bf:26:f7:</span><br><span class="line">                    d6:c3:a6:22:22:50:f0:6e:aa:03:1e:ea:d9:e6:ad:</span><br><span class="line">                    4d:a9:60:4f:6d:81:80:f4:f9:a9:89:31:ab:f1:a3:</span><br><span class="line">                    9b:1a:a2:57:ed:44:30:39:<span class="built_in">fc</span>:3a:3a:c3:6e:c8:a6:</span><br><span class="line">                    db:2e:14:c1:3b:6b:5b:ca:ab:b7:0d:fb:85:39:08:</span><br><span class="line">                    bf:6b:41:c1:f6:42:b1:3f:9c:45:5c:4c:37:8e:7d:</span><br><span class="line">                    c6:18:f8:9b:87:16:80:7f:25:34:8f:14:a9:02:2e:</span><br><span class="line">                    7c:07:c9:8a:21:77:33:03:6a:9c:86:f1:73:9c:c8:</span><br><span class="line">                    2d:f1</span><br><span class="line">                Exponent: 65537 (0x10001)</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Basic Constraints:</span><br><span class="line">                CA:FALSE</span><br><span class="line">            X509v3 Key Usage:</span><br><span class="line">                Digital Signature, Non Repudiation, Key Encipherment</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">         30:cf:b2:9f:50:ea:d7:0d:e2:87:50:e6:bd:d7:b0:17:12:31:</span><br><span class="line">         b1:9f:59:16:50:60:bc:52:c0:46:7a:43:d0:34:43:48:d0:bd:</span><br><span class="line">         e1:a0:dc:75:a2:60:a0:c9:8f:ed:d4:36:14:18:75:c0:ef:c3:</span><br><span class="line">         92:fa:43:fa:34:5a:12:77:2f:03:00:eb:a6:db:d9:6b:50:ff:</span><br><span class="line">         44:56:22:c6:51:73:73:9a:4b:fd:bb:53:ff:2b:7e:97:55:d3:</span><br><span class="line">         4d:bb:bd:26:69:37:8d:71:30:41:bf:fd:48:40:<span class="built_in">fc</span>:6f:<span class="built_in">cd</span>:e2:</span><br><span class="line">         b7:4a:90:6f:a2:11:85:a7:88:d3:61:d5:03:0a:50:98:cc:0e:</span><br><span class="line">         aa:d5:83:38:b4:d5:f0:06:ff:a5:eb:d4:e6:54:14:e9:65:af:</span><br><span class="line">         36:a5:e4:3e:8b:78:18:0b:d6:7c:cc:f1:a3:da:7a:03:fd:89:</span><br><span class="line">         23:f0:e1:3e:af:7b:b1:7a:53:82:11:4a:5e:1d:84:b6:0b:cc:</span><br><span class="line">         96:b4:3a:8a:43:cf:ff:b3:3a:be:47:e0:40:c0:48:15:b4:f3:</span><br><span class="line">         2d:2b:73:b8:07:d2:21:83:3c:c4:4c:c2:31:17:4e:4c:15:da:</span><br><span class="line">         66:fd:06:9a:b7:ed:b5:9e:71:a3:40:0b:39:12:3c:7b:cb:cb:</span><br><span class="line">         a0:af:d0:c7:fe:59:41:35:04:7f:f3:f3:38:d0:d0:ac:7a:15:</span><br><span class="line">         7e:fa:ee:fd</span><br></pre></td></tr></table></figure>

<p>在实际使用中，通常会使用多级证书链，每一级证书由上一级CA签发，并由上一级CA的证书进行验签。最终的Root CA证书只能由它自己签发的，也即用自己的私钥对自己的公钥进行签名，否则就无限递归了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/CA-signing-of-digital-certificates.svg" alt="CA-signing-of-digital-certificates" loading="lazy"></p>
<p>所以数字证书实际上是一种信任链的传递，将对众多个体的身份认证转移到对少数几个CA的身份认证，可以减少遭到中间人攻击的风险。从公钥密码和证书这些出发就引出了<strong>公钥基础设置（PKI）</strong>：这是为了能够更有效地运用公钥而制定的一系列规范和规格的总称。</p>
<h2 id="混合密码系统"><a href="#混合密码系统" class="headerlink" title="混合密码系统"></a>混合密码系统</h2><p>那么有了公钥密码，是不是就不需要对称密码了呢？公钥密码虽然解决了对称密码的密钥分发问题，但是在计算速度上却远低于对称密码，相差几个数量级。下面是用<code>openssl speed</code>测试RSA1024和AES128的结果。AES128（相同块大小）的速度大概是RSA1024签名的1200倍，是验签的70倍。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ openssl speed rsa1024</span><br><span class="line">                  sign    verify    sign/s verify/s</span><br><span class="line">rsa 1024 bits 0.000103s 0.000006s   9732.8 162578.8</span><br><span class="line"></span><br><span class="line">$ openssl speed -evp aes128</span><br><span class="line"><span class="built_in">type</span>             16 bytes     64 bytes    256 bytes   1024 bytes   8192 bytes  16384 bytes</span><br><span class="line">aes-128-cbc    1075884.36k  1452740.12k  1510392.06k  1530545.83k  1537414.49k  1537114.11k</span><br></pre></td></tr></table></figure>

<p>因为对称密码和非对称密码各有优缺点，所以在实际应用中通常将两者结合起来，使用非对称密码来完成密钥交换，然后生成会话密钥作为对称密码的密钥，使用对称密码对信息进行加解密。</p>
<h2 id="随机数发生器"><a href="#随机数发生器" class="headerlink" title="随机数发生器"></a>随机数发生器</h2><p>截止目前，我们已经解决了很多问题，包括机密性、完整性、认证性、防抵赖，但其实还有一个大问题我们没有解决：即我们的<strong>会话密钥</strong>如何生成？一个安全的算法其所有的安全性应该都是基于其<strong>密钥的安全性</strong>，如果我们的密钥可以被轻易破解或预测，那我们前面构建的一切就都土崩瓦解了。所以随机数发生器就在这里起到了至关重要的作用。</p>
<p>随机数同样在<strong>防重放攻击</strong>中具有重要的作用，所谓重放攻击，就是攻击者将窃听的数据保存下来，在后面再原样发送给接收者，以达到其特定的攻击目的。防重放的常用手段有使用序号、时间戳、随机数等。</p>
<p>这里留个问题给大家思考，因为机密性和完整性的保护，攻击者既不能解密消息，又不能对消息进行篡改，那么重放有什么用呢？</p>
<p>理想的随机数发生器具有以下特性：</p>
<ul>
<li>随机性：不存在统计学偏差，是完全杂乱的数列</li>
<li>不可预测性：不能从过去的数列推测出下一个出现的数</li>
<li>不可重现性：除非将数列本身保存下来，否则不能重现相同的数列</li>
</ul>
<h2 id="密钥派生函数-key-derivation-function"><a href="#密钥派生函数-key-derivation-function" class="headerlink" title="密钥派生函数 key derivation function"></a>密钥派生函数 key derivation function</h2><p>KDF可用于将密钥材料扩展为更长的密钥或获取所需格式的密钥。TLS 1.2中是用的PRF算法，TLS 1.3中则是用的HKDF算法。</p>
<h1 id="SSL-TLS协议详解"><a href="#SSL-TLS协议详解" class="headerlink" title="SSL/TLS协议详解"></a>SSL/TLS协议详解</h1><h2 id="什么是SSL-TLS协议"><a href="#什么是SSL-TLS协议" class="headerlink" title="什么是SSL/TLS协议"></a>什么是SSL/TLS协议</h2><p>好了，有了前面的密码学基础，我们就可以正式进入TLS协议的介绍。前面介绍的基本都是独立的算法或者是几个算法结合起来的组件，而SSL/TLS协议则是基于这些底层的算法原语和组件，最终拼装而成的一个<strong>成品的密码学协议</strong>。</p>
<p>SSL全称是<code>Secure Sockets Layer</code>，安全套接字层，它是由网景公司(Netscape)设计的主要用于Web的安全传输协议，目的是为网络通信提供机密性、认证性及数据完整性保障。如今，SSL已经成为互联网保密通信的工业标准。</p>
<p>SSL最初的几个版本(SSL 1.0、SSL2.0、SSL 3.0)由网景公司设计和维护，从3.1版本开始，SSL协议由因特网工程任务小组(IETF)正式接管，并更名为TLS(Transport Layer Security)，发展至今已有TLS 1.0、TLS1.1、TLS1.2这几个版本。目前主流的还是TLS1.2，不过TLS1.3即将是大势所趋。</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Published</th>
<th>Status</th>
</tr>
</thead>
<tbody><tr>
<td>SSL 1.0</td>
<td>Unpublished</td>
<td>Unpublished</td>
</tr>
<tr>
<td>SSL 2.0</td>
<td>1995</td>
<td>Deprecated in 2011 (RFC <a href="https://datatracker.ietf.org/doc/html/rfc6176">6176</a>)</td>
</tr>
<tr>
<td>SSL 3.0</td>
<td>1996</td>
<td>Deprecated in 2015 (RFC <a href="https://datatracker.ietf.org/doc/html/rfc7568">7568</a>)</td>
</tr>
<tr>
<td>TLS 1.0</td>
<td>1999</td>
<td>Deprecated in 2020 (RFC <a href="https://datatracker.ietf.org/doc/html/rfc8996">8996</a>)[<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#cite_note-tls-deprecation-8">8]</a>[<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#cite_note-:3-9">9]</a>[<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#cite_note-:4-10">10]</a></td>
</tr>
<tr>
<td>TLS 1.1</td>
<td>2006</td>
<td>Deprecated in 2020 (RFC <a href="https://datatracker.ietf.org/doc/html/rfc8996">8996</a>)[<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#cite_note-tls-deprecation-8">8]</a>[<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#cite_note-:3-9">9]</a>[<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#cite_note-:4-10">10]</a></td>
</tr>
<tr>
<td>TLS 1.2</td>
<td>2008</td>
<td></td>
</tr>
<tr>
<td>TLS 1.3</td>
<td>2018</td>
<td></td>
</tr>
</tbody></table>
<p>SSL/TLS协议能够提供的安全目标主要包括如下几个：</p>
<div class="note info no-icon">
            <ul><li><p><strong>机密性</strong>：借助加密防止第三方窃听</p></li><li><p><strong>认证性</strong>：借助数字证书认证服务器端和客户端身份，防止身份伪造</p></li><li><p><strong>完整性</strong>：借助消息认证码(MAC)保障数据完整性，防止消息篡改</p></li><li><p><strong>防重放</strong>：防止重放攻击</p></li></ul>
          </div>



<h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><p>相信大家对TCP/IP 5层模型已经非常熟悉了，TLS协议就如其名字所说的（Transport Layer Security），用于保障传输层的安全。它位于传输层之上，应用层之下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS-layered-structure.svg" alt="TLS-layered-structure" loading="lazy"></p>
<p>SSL/TLS协议有一个高度模块化的架构，其内部又分为很多子协议：Handshake协议、Alert协议、ChangeCipherSpec协议、Application协议。它们底层都是基于Record协议，记录层协议负责识别不同的上层消息类型以及消息的分段加密认证等。</p>
<ul>
<li>Handshake协议：包括协商安全参数和算法套件、服务器身份认证(客户端身份认证可选)、密钥交换</li>
<li>Application协议：用于传输应用层数据</li>
<li>ChangeCipherSpec 协议：一条消息表明握手协议已经完成</li>
<li>Alert 协议：对握手协议中一些异常的错误提醒，分为fatal和warning两个级别，fatal类型的错误会直接中断SSL连接，而warning级别的错误一般情况下SSL连接会继续，只是会给出错误警告</li>
</ul>
<p>SSL/TLS协议被设计为一个两阶段协议，分为<strong>握手阶段</strong>和<strong>应用阶段</strong>。</p>
<p><strong>握手阶段</strong>：也称协商阶段，在这一阶段主要目标就是进行我们前面已经提到过的协商安全参数和算法套件、身份认证（基于数字证书）以及密钥交换生成后续加密通信所使用的密钥。</p>
<p><strong>应用阶段</strong>：双方使用握手阶段协商好的密钥进行安全通信。</p>
<h2 id="SSL-record"><a href="#SSL-record" class="headerlink" title="SSL record"></a>SSL record</h2><p>SSL记录层包的格式，跟其下的IP或TCP层类似，所有在SSL会话上交换的数据都按如下格式封装成帧。记录层协议负责识别不同的消息类型，也负责对消息的分段、压缩、消息认证和完整性保护、加密等工作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS-record-structure.svg" alt="TLS-record-structure" loading="lazy"></p>
<p>一个典型的记录层工作流（分组密码算法）如下：</p>
<ul>
<li>记录层接收到应用层的数据</li>
<li>将接收到的数据分块</li>
<li>使用协商的MAC key计算MAC或HMAC，并增加到记录块中</li>
<li>使用协商的Cipher Key将记录数据加密</li>
</ul>
<p>当加密的数据到了接收端，对方则进行相反的操作：解密数据、验证MAC、重组数据并交给应用层。</p>
<p>所有这些工作都由SSL层完成了，对于上层应用是完全透明的。</p>
<p>对于握手阶段的消息，payload是明文，当然就没有MAC和Padding。其他消息的payload都是密文。</p>
<p>对于<strong>流加密算法</strong>，没有后面的padding。对于<strong>块加密算法</strong>的记录，根据使用的算法在payload之前有可选的IV字段。</p>
<p>对于<strong>AEAD算法</strong>，因为认证已经包含在算法里了，所以没有后面的MAC和Padding字段。payload之前有一个外部nonce字段。</p>
<h2 id="算法套件CipherSuites"><a href="#算法套件CipherSuites" class="headerlink" title="算法套件CipherSuites"></a>算法套件CipherSuites</h2><p>在深入握手流程之前，我们先来了解一下算法套件的概念。前面在密码学基础部分我们已经了解到了各种算法，包括认证算法、密钥交换算法、对称密码算法、完整性认证的算法。</p>
<h3 id="TLS-1-2"><a href="#TLS-1-2" class="headerlink" title="TLS 1.2-"></a>TLS 1.2-</h3><p>一个<strong>算法套件</strong>是一个SSL连接中用到的这些算法类型的组合，包含如下几个部分：</p>
<ul>
<li>Key Exchange（Kx）</li>
<li>Authentication（Au）</li>
<li>Encryption（Enc）</li>
<li>Message Authentication Code（Mac）</li>
</ul>
<p>常见的算法套件类型比如<code>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256</code>，<code>TLS_RSA_WITH_AES_256_GCM_SHA384</code>、<code>TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384</code>、<code>ECC_SM2_WITH_SM4_SM3</code>（国密）、<code>ECDHE_SM2_WITH_SM4_SM3</code>（国密）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/CipherSuite1_2.png" alt="CipherSuite1_2" loading="lazy"></p>
<p>以<code>ECDHE-ECDSA-AES128-GCM-SHA256</code>为例，前面的<code>ECDHE</code>表示密钥交换算法，<code>ECDSA</code>表示身份认证算法，<code>AES128-GCM</code>表示对称加密算法，其中<code>128</code>表示块长度，<code>GCM</code>是其模式，<code>SHA256</code>表示哈希算法。对于<code>AEAD</code>因为消息认证和加密已经合并到一起了，最后的<code>SHA256</code>只表示密钥派生函数的算法，而对于传统的数据加密和认证分开的算法套件，它还表示<code>MAC</code>的算法。</p>
<p>可以通过如下命令查看每种算法套件的详细情况：<code>openssl ciphers -V | column -t | less</code>。</p>
<h3 id="TLS-1-3"><a href="#TLS-1-3" class="headerlink" title="TLS 1.3"></a>TLS 1.3</h3><p>对于TLSv1.3，因为已经将密钥交换和身份认证算法从算法套件中独立出去，算法套件只表示加密算法和密钥派生函数。之所以要独立出去，是因为支持的算法越来越多了，导致相乘之后算法套件数量庞大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/CipherSuite1_3.png" alt="CipherSuite1_3" loading="lazy"></p>
<p>可以用如下命令查看当前支持哪些TLS 1.3算法套件：<code>openssl ciphers -V | column -t | grep &#39;TLSv1.3&#39;</code>。</p>
<h2 id="SSL-handshake"><a href="#SSL-handshake" class="headerlink" title="SSL handshake"></a>SSL handshake</h2><p>终于进入核心的握手协议部分了。如前所述，SSL握手主要干以下几件事情：首先得商量双方用什么算法套件，然后根据需要认证对方的身份（基于数字证书），最后基于选择的算法套件进行密钥交换生成后续加密通信所使用的密钥。（本节描述的是TLS 1.2及以前版本的情况）</p>
<p>下图是一个完整SSL握手的建立流程:</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS-full-handshake-flow.svg" alt="TLS-full-handshake-flow" loading="lazy"></p>
<p>首先是TCP的3次握手建立TCP连接，然后客户端发起SSL握手。一次完整的SSL握手包含两次交互，第一次主要是完成算法套件的选择。第二次交互主要是完成身份认证以及密钥交换。这些都协商完成之后，SSL的安全通道就建立完成了。后续的应用数据就会在安全通道上进行加密传输。</p>
<h3 id="密钥交换流程-RSA"><a href="#密钥交换流程-RSA" class="headerlink" title="密钥交换流程-RSA"></a>密钥交换流程-RSA</h3><p>基于RSA的密钥交换流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/SSL-keyexchange-RSA.jpeg" alt="SSL-keyexchange-RSA" loading="lazy"></p>
<p>我们来模拟下协商过程：</p>
<ul>
<li><span class="label info">客户端</span>：Hi，服务端，我这边支持这些算法，这是我本次的随机数。</li>
<li><span class="label success">服务端</span>：好的，我看看，我们就选用这个算法套件吧，这是我本次的随机数，这是我的证书，你用这个证书里的公钥来加密预主密钥。</li>
<li><span class="label info">客户端</span>：稍等我验下证书，嗯，的确是服务端的证书。这是用证书中公钥加密的预主密钥。（使用两个随机数+预主密钥计算主密钥，然后生成会话密钥。。。）好了，我这边OK了。</li>
<li><span class="label success">服务端</span>：收到。（用私钥解密出预主密钥，使用两个随机数+预主密钥计算主密钥，然后生成会话密钥。。。）好了，我这边也OK了。</li>
<li><span class="label info">客户端</span>：这是加密的应用数据。。。</li>
<li><span class="label success">服务端</span>：这是加密的应用数据。。。</li>
</ul>
<p>注：上面的流程是单向认证（服务端没有验证客户端的身份），如果服务端也需要验客户端的身份，会在第一次交互中发送<code>Certificate Request</code>消息，客户端相应的在第二次交互中发送自己的<code>Certificate</code>以及<code>CertificateVerify</code>消息给服务端。</p>
<h3 id="密钥交换流程-DH"><a href="#密钥交换流程-DH" class="headerlink" title="密钥交换流程-DH"></a>密钥交换流程-DH</h3><p>基于DH的密钥交换流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/SSL-keyexchange-DH.jpeg" alt="SSL-keyexchange-DH" loading="lazy"></p>
<p>我们同样来模拟下协商过程：</p>
<ul>
<li><span class="label info">客户端</span>：Hi，服务端，我这边支持这些算法，这是我本次的随机数。</li>
<li><span class="label success">服务端</span>：好的，我看看，我们就选用这个算法套件吧，这是我本次的随机数，给你我的证书。我这边用这个DH参数，这是对应的签名。</li>
<li><span class="label info">客户端</span>：稍等我验下证书和签名，嗯，的确是服务端的证书，签名也没有问题。这是我这边的DH参数。（使用DH参数推导出预主密钥，再使用两个随机数+预主密钥计算主密钥，然后生成会话密钥。。。）好了，我这边OK了。</li>
<li><span class="label success">服务端</span>：收到。（使用DH参数推导预主密钥，再使用两个随机数+预主密钥计算主密钥，然后生成会话密钥。。。）好了，我这边也OK了。</li>
<li><span class="label info">客户端</span>：这是加密的应用数据。。。</li>
<li><span class="label success">服务端</span>：这是加密的应用数据。。。</li>
</ul>
<h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><p>通过第一次ClientHello和ServerHello的交互、以及密钥交换的过程，客户端和服务端双方，都得到了client随机数、server随机数以及预主密钥。接下来就可以通过这些来计算主密钥了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">master_secret = PRF(pre_master_secret, &quot;master secret&quot;,</span><br><span class="line">                    ClientHello.random + ServerHello.random)</span><br><span class="line">                    [0..47];</span><br></pre></td></tr></table></figure>

<p>得到主密钥之后，再将其扩展为一个安全字节序列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key_block = PRF(SecurityParameters.master_secret,</span><br><span class="line">                     &quot;key expansion&quot;,</span><br><span class="line">                     SecurityParameters.server_random +</span><br><span class="line">                     SecurityParameters.client_random);</span><br></pre></td></tr></table></figure>

<p>然后分别切分为MAC密钥、对称加密的key和IV。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client_write_MAC_key[SecurityParameters.mac_key_length]</span><br><span class="line">server_write_MAC_key[SecurityParameters.mac_key_length]</span><br><span class="line">client_write_key[SecurityParameters.enc_key_length]</span><br><span class="line">server_write_key[SecurityParameters.enc_key_length]</span><br><span class="line">client_write_IV[SecurityParameters.fixed_iv_length]</span><br><span class="line">server_write_IV[SecurityParameters.fixed_iv_length]</span><br></pre></td></tr></table></figure>

<p>画成图的话大概是下面这个样子。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS1_2-Key-Calculation.png" alt="TLS1_2-Key-Calculation" loading="lazy"></p>
<h2 id="Session重用"><a href="#Session重用" class="headerlink" title="Session重用"></a>Session重用</h2><p>SSL握手额外引入了<strong>两次交互</strong>以及<strong>CPU密集型</strong>的算法运算。每次连接都进行SSL握手时非常耗费性能的，有没有什么办法进行性能优化呢？显然提升硬件性能、软件性能都是有效的方法。其实SSL从协议层面也考虑了这个问题，它提供了“会话重用”的特性。双方在建立前一次SSL连接之后，可以将SSL会话保存下来。下一次想要在建立SSL连接的时候，可以直接恢复之前的SSL会话，从而简化SSL握手流程。Session重用的时候只需要进行一次SSL握手交互，而且不需要再进行身份认证和密钥交换，从而大幅减小了整个流程的延迟和计算开销。</p>
<p>事实上，如果浏览器要对同个站点发起多个连接，它通常就会等第一个SSL握手完成后再发起其他的连接，这样其他的连接就可以复用之前的那个Session。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS-half-handshake-flow.svg" alt="TLS-half-handshake-flow" loading="lazy"></p>
<p>Session重用有两种机制，分别为Session IDs和Session tickets。</p>
<h3 id="Session-ID"><a href="#Session-ID" class="headerlink" title="Session ID"></a>Session ID</h3><p>我们来看下使用Session ID时的Session重用流程。从前面密钥交换的流程图中可以看到，服务端在<code>Server Hello</code>消息中会发送本次会话的<code>Session ID</code>给客户端。完成握手之后，服务端会保存本次的Session。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/session_resumption_with_session_id.jpeg" alt="session_resumption_with_session_id" loading="lazy"></p>
<p>后续客户端可以通过恢复这个Session来建立SSL连接。具体做法就是在<code>ClientHello</code>消息中带上要恢复的Session ID，然后服务端会根据Session ID去查找对应的会话，如果一切都OK的话，就会根据保存的会话恢复出会话密钥等信息。如果服务端不支持会话重用、或者没找到Session ID、或者会话已经过期了，那么就退化到完整的SSL握手。</p>
<h3 id="Session-Ticket"><a href="#Session-Ticket" class="headerlink" title="Session Ticket"></a>Session Ticket</h3><p>Session ID机制它要求服务端保存每个客户端的session cache，这会在服务端造成几个问题：内存的额外开销、要求Session的保存和淘汰策略、然后对有多个服务器的站点，如何高性能地共享session cache提出了挑战。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/session_resumption_with_session_ticket.jpeg" alt="session_resumption_with_session_ticket" loading="lazy"></p>
<p>Session Ticket机制的提出就是为了解决Session ID的问题。Session Ticket不需要服务端保存每个客户端的会话。取而代之，如果客户端宣称它支持session ticket，服务端会发送给客户端一个<code>New Session Ticket</code>消息，其中包含了会话相关的加密数据，加密的密钥只有服务端知道。</p>
<p>客户端会保存这个session ticket，当需要会话恢复的时候，它会在<code>ClientHello</code>消息的<code>SessionTicket</code>扩展中带上这个session ticket。服务端在收到之后解密出其中的session数据从而恢复上次的会话。</p>
<p>所以Session Ticket机制对于服务端来说是一种无状态（stateless）的重用，不需要服务端保存session cache，当然也就没有多服务器同步的问题。</p>
<h2 id="证书的吊销（黑名单）"><a href="#证书的吊销（黑名单）" class="headerlink" title="证书的吊销（黑名单）"></a>证书的吊销（黑名单）</h2><p>我们在介绍证书的时候已经看到了证书有一个有效期，在有效期外是无法验证通过的。但是如果我们想在有效期内就让证书失效该怎么办？比如公司员工离职了、或者私钥泄漏等，总不可能把发出去的证书收回来吧。</p>
<p>所以就引入了证书的吊销，CA可以吊销某张证书，在验证证书有效性的时候进行额外的黑名单验证。黑名单的验证有如下几种机制：</p>
<h3 id="Certificate-Revocation-List-CRL"><a href="#Certificate-Revocation-List-CRL" class="headerlink" title="Certificate Revocation List (CRL)"></a>Certificate Revocation List (CRL)</h3><p>CRL，即证书吊销列表。CA机构维护一个被吊销证书的列表，里面是被吊销证书的信息。验证证书方需要下载这个列表，进行黑名单的验证。</p>
<p>CRL的缺陷也很明显：证书验证方必须下载这个列表，且下载的列表跟实际CA机构的列表之间可能不同步。如果一个证书实际已经被吊销，但是并没有在本地列表中，就可能形成安全隐患。</p>
<h3 id="Online-Certificate-Status-Protocol-OCSP"><a href="#Online-Certificate-Status-Protocol-OCSP" class="headerlink" title="Online Certificate Status Protocol (OCSP)"></a>Online Certificate Status Protocol (OCSP)</h3><p>OCSP，即在线证书状态协议。它通过在线请求的方式来进行黑名单验证，不需要下载整个 list，只需要将该证书的序列号发送给 CA 进行验证。部署 OCSP 对 CA也引入了一定的要求，CA 需要搭建的一个高性能的服务器来提供验证服务。万一服务器挂掉了，那所有的黑名单验证就会当成是通过，有一定的安全隐患。</p>
<h3 id="OCSP-Stapling"><a href="#OCSP-Stapling" class="headerlink" title="OCSP Stapling"></a>OCSP Stapling</h3><p>OCSP Stapling是OCSP标准的一个扩展，主要目标就是提升性能和安全性。证书拥有者自己定期向OCSP服务器发送请求。获取OCSP响应，这个响应是基于时间戳的，而且由CA直接签名。</p>
<p>OCSP Stapling提升整体的性能，一方面证书验证方不需要再直接请求CA的服务器去查询状态，另一方面CA的OCSP服务器的压力也减小了。</p>
<h2 id="Server-Name-Indication（SNI）"><a href="#Server-Name-Indication（SNI）" class="headerlink" title="Server Name Indication（SNI）"></a>Server Name Indication（SNI）</h2><p>当一个站点上部署了多个Server时（相当于一个IP映射了多个域名），不同的Server可能需要使用不同的证书。问题是如何在SSL握手阶段知道是访问那个host（还没到HTTP阶段，无法用请求头里的<code>HOST</code>字段），从而决定使用对应的证书呢？</p>
<p>SNI就是为了解决这个问题，具体做法是在<code>ClientHello</code>扩展中带上SNI，服务端就能从中得知需要访问哪个host，从而选择相应的证书。</p>
<h1 id="GMSSL协议差异"><a href="#GMSSL协议差异" class="headerlink" title="GMSSL协议差异"></a>GMSSL协议差异</h1><p>GMSSL修改自TLS1.1，总体上与TLS协议的差异不大。详见《GMT 0024-2014 SSL VPN技术规范》。</p>
<h2 id="协议号"><a href="#协议号" class="headerlink" title="协议号"></a>协议号</h2><p>TLSv1.0, TSLv1.1, TLSv1.2、TLSv1.3的协议号分别为<code>0x0301</code>、<code>0x0302</code>、<code>0x0303</code>、<code>0x0304</code>。</p>
<p>而国密的版本号是<code>0x0101</code>。</p>
<h2 id="算法套件"><a href="#算法套件" class="headerlink" title="算法套件"></a>算法套件</h2><p>新增了国密的SM1/2/3/4等算法，定义了多个算法套件，其中比较常用的如<code>ECC_SM4_SM3</code>和<code>ECDHE_SM4_SM3</code>。<code>ECDHE_SM4_SM3</code>要求必须双向认证。</p>
<p>其中<code>ECC_SM4_SM3</code>的密钥交换过程类似RSA的密钥交换过程，由客户端用服务端的公钥对预主密钥进行加密后发送给服务端。<code>ECDHE_SM4_SM3</code>的密钥交换过程与普通TLS的ECDHE密钥交换类似，预主密钥由客户端和服务端双方推导得出。<code>ECC_SM4_SM3</code>和<code>ECDHE_SM4_SM3</code>的身份认证是都是通过SM2的签名/验签来完成。</p>
<h2 id="双证书体系"><a href="#双证书体系" class="headerlink" title="双证书体系"></a>双证书体系</h2><h3 id="证书消息"><a href="#证书消息" class="headerlink" title="证书消息"></a>证书消息</h3><p>国密SSL采用双证书体系：一个签名证书、一个加密证书。其中签名证书用于身份认证、加密证书用于密钥交换。发送<code>Certificate</code>消息时需要同时发送两个证书，格式与标准TLS报文格式一样，第一个证书是签名证书、第二个证书是加密证书。</p>
<h3 id="ECC-SM4-SM3密钥交换"><a href="#ECC-SM4-SM3密钥交换" class="headerlink" title="ECC_SM4_SM3密钥交换"></a>ECC_SM4_SM3密钥交换</h3><p>因为采用了双证书体系，在SSL状态机上略微有点不同。<code>ECC_SM4_SM3</code>的密钥交换过程如下：服务端发送<code>Certificate</code>消息之后，还要发送一个<code>ServerKeyExchange</code>消息（这跟RSA密钥交换有所不同），<code>ServerKeyExchange</code>中包含了一个签名值，签名由服务端签名证书对应的私钥（签名私钥）进行计算，签名的内容包括了ClientHello和ServerHello中的随机数以及加密证书。</p>
<p>客户端验证证书和签名之后，使用服务端加密证书加密预主密钥，发送给服务端，服务端则由自己的加密私钥进行解密得到预主密钥。</p>
<h3 id="ECDHE-SM4-SM3密钥交换"><a href="#ECDHE-SM4-SM3密钥交换" class="headerlink" title="ECDHE_SM4_SM3密钥交换"></a>ECDHE_SM4_SM3密钥交换</h3><p><code>ECDHE_SM4_SM3</code>的密钥交换过程如下：服务端发送<code>Certificate</code>消息之后，同样发送一个<code>ServerKeyExchange</code>消息，<code>ServerKeyExchange</code>中包含了一个签名值，签名由服务端签名证书对应的私钥（签名私钥）进行计算。签名的内容跟<code>ECC_SM4_SM3</code>时有所不同，包括了ClientHello和ServerHello中的随机数以及服务端ECDH参数（曲线、公钥）。国密ECDHE的密钥推导计算方式跟TLS也有所不同，TLS只需要对方的临时公钥和自己的临时私钥参与计算，而国密需要对方的临时公钥和固定公钥（即加密证书中的公钥）及自己的临时私钥和固定私钥（即加密私钥）参与计算。所以国密<code>ECDHE</code>必须是双向认证，因为服务端在进行密钥推导的时候也需要用到客户端的加密证书。</p>
<p>客户端验证证书和签名之后，发送自己的证书给服务端，接着根据<code>ServerKeyExchange</code>中ECDH参数信息生成自己的临时密钥，然后同自己的加密密钥、服务端临时公钥和加密公钥一起进行密钥推导得到预主密钥。并将自己的临时密钥参数通过<code>ClientKeyExchange</code>消息发送给服务端，服务端同样使用自己的临时密钥、加密密钥、客户端的临时公钥和加密公钥一起进行密钥推导得到预主密钥。</p>
<p>因为是双向认证，客户端在发送<code>ClientKeyExchange</code>消息之后，还需要发送一个<code>CertificateVerify</code>消息，签名的内容为从ClientHello消息开始到目前为止的所有已经交换的握手消息。</p>
<h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><h2 id="常见攻击"><a href="#常见攻击" class="headerlink" title="常见攻击"></a>常见攻击</h2><p>有些是针对协议设计上的漏洞，有些则是针对实现的bug，经常结合降级攻击手段一起使用。因为篇幅原因，这里仅挑选两个有代表性的重协商攻击和Heartbleed着重介绍一下，对于其余攻击感兴趣的可以参考<a href="https://datatracker.ietf.org/doc/html/rfc7457">rfc7457-已知攻击总结</a></p>
<ul>
<li>重协商攻击</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/renegotiation-attack.png" loading="lazy"></p>
<p>中间人在不需要劫持、解密SSL/TLS连接的情况下，成功地将自己伪造的数据插入到用户真正数据之前。中间人如果了解APP协议（如HTTPS）的话，则会精心构造不完整的数据，让服务器的APP程序认为发生粘包，将数据暂缓不处理，继续等待后续的数据上来。例如攻击者先发送了如下的半拉子请求</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/bank/sendmoney.asp?acct=attacker&amp;amount=1000000</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">X-Ignore-This:</span><br></pre></td></tr></table></figure>

<p>后面当客户端发送过来真正的请求</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/ebanking</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>validcookie</span><br></pre></td></tr></table></figure>

<p>APP程序将请求拼接，真正的请求头被屏蔽了，但是却保留了用户的Cookie信息，从而利用用户的Cookie去访问网站内容。服务端会以为前面发送的请求是真正的客户端发送的。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/bank/sendmoney.asp?acct=attacker&amp;amount=1000000</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">X-Ignore-This</span><span class="punctuation">: </span>GET /ebanking HTTP/1.1</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>validcookie</span><br></pre></td></tr></table></figure>



<p>这个漏洞成因在于，客户端认为的首次协商却被服务器认为是重协商，以及首次协商和重协商之间缺少关联性。解决办法就是禁用重协商或者使用<a href="https://datatracker.ietf.org/doc/html/rfc5746">安全重协商</a>。安全重协商会增加一个安全重协商标志，以及确认首次协商和重协商的关联性校验，从而确保中间人的攻击行为可以被识别并拒绝，保证重协商安全。</p>
<p>我们来看看安全重协商是如何保证安全的，对于前面的ClientHello2里面不携带安全重协商表示的情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/renegotiation-attack-fix1.png" alt="renegotiation-attack-fix1" loading="lazy"></p>
<p>对于前面的ClientHello2里面携带安全重协商表示的情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/renegotiation-attack-fix2.png" alt="renegotiation-attack-fix2" loading="lazy"></p>
<p>无论哪种情况都能保证中间人无机可乘。而这个安全重协商的标识就是提供了一个新的扩展性<code>renegotiation_info</code>。因为SSLv3/TLS 1.0不支持扩展，所以提供了另一种方法，即在算法套件列表中加上<code>TLS_EMPTY_RENEGOTIATION_INFO_SCSV（0xFF）</code>，这个不是一个真正的算法套件，只是起标识作用。</p>
<p>安全重协商的流程如下：</p>
<pre><code> 1. 在连接建立第一次SSL握手期间，双方通过`renegotiation_info`扩展或`SCSV`套件通知对方自己支持安全重协商
 2. 然后在握手结束之后，client和server都分别记录`Finish`消息之中的`client_verify_data`和`server_verify_data`
 3. 重协商时client在`ClientHello`中包含`client_verify_data`，server在`ServerHello`中包含`client_verify_data`和`server_verify_data`。对于受害者，如果协商中不会携带这些数据则连接无法建立。而Finished消息由于是加密的，攻击者无法得到client_verify_data和server_verify_data的值。
</code></pre>
<ul>
<li><a href="https://heartbleed.com/">Heartbleed</a></li>
</ul>
<p>这是OpenSSL库一个实现上的bug，而不是TLS协议本身的bug。这个bug是由于TLS heartbeat扩展的实现没有进行正确的输入验证（缺少边界检查）导致的。bug的命名也从heartbeat而来。由于没有进行边界检查，导致可以读取的数据超出允许的范围。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/Simplified_Heartbleed_explanation.svg" alt="Simplified_Heartbleed_explanation" loading="lazy"></p>
<p>这个bug当前造成了非常广泛的影响，有调查显示在这个漏洞公布后几年，仍有许多网站暴露在此攻击之下。这个bug告诫我们就算协议是安全的，实现仍然可能引入安全问题。安全性就像一个木桶，整体的安全性取决于最短的那块木板。</p>
<ul>
<li>CRIME和BREACH攻击</li>
</ul>
<p>这两个攻击都是基于压缩算法，通过改变请求正文，对比被压缩后的密文长度，可以破解出某些信息。</p>
<p>CRIME通过在受害者的浏览器中运行JavaScript代码并同时监听HTTPS传输数据，能够解密会话Cookie，主要针对TLS压缩。</p>
<p>Javascript代码尝试一位一位的暴力破解Cookie的值。中间人组件能够观察到每次破解请求和响应的密文，寻找不同，一旦发现了一个，他会和执行破解的Javascript通信并继续破解下一位。</p>
<p>BREACH攻击是CRIME攻击的升级版，攻击方法和CRIME相同，不同的是BREACH利用的不是SSL/TLS压缩，而是HTTP压缩。所以要抵御BREACH攻击必须禁用HTTP压缩。</p>
<ul>
<li>BEAST攻击</li>
</ul>
<p>TLS 在 1.1版本之前，下一个记录的IV是直接使用的前一个记录的密文。BEAST攻击就是利用了这一点，攻击者控制受害者发送大量请求，利用可预测性IV猜测关键信息。解决方法就是部署TLS 1.1或者更高级的版本。</p>
<ul>
<li>RC4攻击</li>
</ul>
<p>基于RC4算法的安全性，RC4目前已经不安全，应该禁用。</p>
<ul>
<li>POODLE攻击</li>
</ul>
<p>是SSL 3.0设计上的漏洞，使用了非确定性的CBC-padding，使中间人攻击者更容易通过padding-oracle攻击获取明文数据。</p>
<ul>
<li>降级攻击（版本回退攻击）</li>
</ul>
<p>欺骗服务器使用低版本的不安全的TLS协议，常和其他攻击手段结合使用。删除后向兼容性通常是防止降低攻击的唯一方法。</p>
<h2 id="前向安全性"><a href="#前向安全性" class="headerlink" title="前向安全性"></a>前向安全性</h2><p>如果没有前向安全性，一旦私钥泄漏，不仅将来的会话会受影响，过去的会话也都会受影响。一个耐心的黑客，可以先把以前截获的数据先保存下来，一旦私钥泄露或被破解，就可以破解之前的所有密文。这就是所谓的<strong>今日截获，明日破解</strong>。</p>
<p>TLS的实现之一就是通过使用临时的DH密钥交换来生成会话密钥，<strong>一次一密</strong>保证了即使黑客花大力气破解了这一次的会话密钥，也只是这次通信被攻击，之前的历史消息不会受到影响。这我们已经在第一部分中讲到了。</p>
<p>但即使是使用了临时DH密钥交换，服务端的session管理机制也会影响到前向安全性。前面Session重用的部分我们讲到了session ticket，它的保护完全是依赖于对称加密，所以长时间有效的session ticket密钥会阻止前向安全性的实现。</p>
<p>在实践中，应该优先使用临时DH密钥交换类算法套件，session的有效期不宜设置过长，session ticket的key也应该经常更换。</p>
<h1 id="TLS-1-3新特性"><a href="#TLS-1-3新特性" class="headerlink" title="TLS 1.3新特性"></a>TLS 1.3新特性</h1><p>TLS 1.3相比TLS 1.2改动巨大，它的主要改进目标是<strong>最大兼容</strong>、<strong>强化安全</strong>、<strong>提升性能</strong>。</p>
<p>下面列举了相比TLS 1.3的<strong>主要差异</strong>：</p>
<ul>
<li>对称加密算法只保留了AEAD类算法，将密钥交换和认证算法从算法套件的概念中分离出去了</li>
<li>增加了0-RTT模式</li>
<li>移除了静态RSA和DH密钥协商（现在所有基于公钥的密钥交换都提供了前向安全性）</li>
<li>现在所有的<code>ServerHello</code>后的握手消息都是加密的</li>
<li>密钥派生函数重新设计，KDF换成了标准的<code>HKDF</code></li>
<li>握手状态机大幅重构，砍掉了多余的消息如<code>ChangeCipherSpec</code></li>
<li>使用统一的PSK模型，替代了之前的Session Resumption（包括Session ID和Session Ticket）及早期TLS版本基于PSK（rfc4279）的算法套件</li>
</ul>
<p>这里介绍几个关键的特性</p>
<h2 id="密钥交换模式"><a href="#密钥交换模式" class="headerlink" title="密钥交换模式"></a>密钥交换模式</h2><p>TLS 1.3提出了3种密钥交换模式：</p>
<ul>
<li>(EC)DHE</li>
<li>PSK-only（pre-shared symmetric key）</li>
<li>PSK with (EC)DHE 前两者的结合，具有前向安全性</li>
</ul>
<h2 id="1-RTT握手"><a href="#1-RTT握手" class="headerlink" title="1-RTT握手"></a>1-RTT握手</h2><p>如前所述，TLS 1.2的完整握手有2个RTT，第一个RTT是<code>ClientHello/ServerHello</code>，第二个RTT是<code>ServerKeyExchange/ClientKeyExchange</code>。之所以需要两个RTT是因为TLS 1.2支持多种密钥交换算法及各种不同的参数，这些都依赖第一个RTT去协商出来。TLS 1.3直接大刀阔斧，砍掉了各种自定义的group、curve，砍掉了RSA密钥交换，只剩下为数不多的几个密钥交换算法，实际应用中大部分使用<code>ECDH P-256</code>或<code>X25519</code>。所以干脆让客户端缓存服务器上一次用的是啥密钥交换算法，把<code>KeyExchange</code>直接合入第一个RTT。如果服务器发现客户端发上来的算法不对，那么再告诉它正确的，让客户端重试就好了。（这就引入了<code>HelloRetryRequest</code>消息）。这样基本没有副作用，就可以降到1-RTT了。</p>
<p>TLS 1.3的完整握手流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       Client                                           Server</span><br><span class="line"></span><br><span class="line">Key  ^ ClientHello</span><br><span class="line">Exch | + key_share*</span><br><span class="line">     | + signature_algorithms*</span><br><span class="line">     | + psk_key_exchange_modes*</span><br><span class="line">     v + pre_shared_key*       --------&gt;</span><br><span class="line">                                                  ServerHello  ^ Key</span><br><span class="line">                                                 + key_share*  | Exch</span><br><span class="line">                                            + pre_shared_key*  v</span><br><span class="line">                                        &#123;EncryptedExtensions&#125;  ^  Server</span><br><span class="line">                                        &#123;CertificateRequest*&#125;  v  Params</span><br><span class="line">                                               &#123;Certificate*&#125;  ^</span><br><span class="line">                                         &#123;CertificateVerify*&#125;  | Auth</span><br><span class="line">                                                   &#123;Finished&#125;  v</span><br><span class="line">                               &lt;--------  [Application Data*]</span><br><span class="line">     ^ &#123;Certificate*&#125;</span><br><span class="line">Auth | &#123;CertificateVerify*&#125;</span><br><span class="line">     v &#123;Finished&#125;              --------&gt;</span><br><span class="line">       [Application Data]      &lt;-------&gt;  [Application Data]</span><br><span class="line"></span><br><span class="line">              +  Indicates noteworthy extensions sent in the</span><br><span class="line">                 previously noted message.</span><br><span class="line"></span><br><span class="line">              *  Indicates optional or situation-dependent</span><br><span class="line">                 messages/extensions that are not always sent.</span><br><span class="line"></span><br><span class="line">              &#123;&#125; Indicates messages protected using keys</span><br><span class="line">                 derived from a [sender]_handshake_traffic_secret.</span><br><span class="line"></span><br><span class="line">              [] Indicates messages protected using keys</span><br><span class="line">                 derived from [sender]_application_traffic_secret_N.</span><br><span class="line"></span><br><span class="line">               Figure 1: Message Flow for Full TLS Handshake</span><br></pre></td></tr></table></figure>

<p>握手过程可以分成三个阶段：</p>
<ul>
<li>密钥交换：建立共享密钥材料，选择加密参数。此阶段后的所有信息都是加密的。</li>
<li>服务端参数：建立其他握手参数，如客户端是否需要认证、应用层协议支持</li>
<li>认证：身份认证，提供密钥确认和握手完整性</li>
</ul>
<h2 id="重用和PSK"><a href="#重用和PSK" class="headerlink" title="重用和PSK"></a>重用和PSK</h2><p>TLS的PSK可以直接在带外建立，也可以通过前一个连接的会话建立。一旦一个握手完成了之后，服务端就会给客户端发送一个PSK id，对应初始握手推导出的密钥。（对应TLS 1.2及之前版本的Session ID和Session Tickets，这两个机制在TLS 1.3中都弃用了）。</p>
<p>PSK可以单独使用，或者跟(EC)DHE密钥交换结合使用以提供前向安全性。</p>
<p>重用和PSK的握手流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       Client                                               Server</span><br><span class="line"></span><br><span class="line">Initial Handshake:</span><br><span class="line">       ClientHello</span><br><span class="line">       + key_share               --------&gt;</span><br><span class="line">                                                       ServerHello</span><br><span class="line">                                                       + key_share</span><br><span class="line">                                             &#123;EncryptedExtensions&#125;</span><br><span class="line">                                             &#123;CertificateRequest*&#125;</span><br><span class="line">                                                    &#123;Certificate*&#125;</span><br><span class="line">                                              &#123;CertificateVerify*&#125;</span><br><span class="line">                                                        &#123;Finished&#125;</span><br><span class="line">                                 &lt;--------     [Application Data*]</span><br><span class="line">       &#123;Certificate*&#125;</span><br><span class="line">       &#123;CertificateVerify*&#125;</span><br><span class="line">       &#123;Finished&#125;                --------&gt;</span><br><span class="line">                                 &lt;--------      [NewSessionTicket]</span><br><span class="line">       [Application Data]        &lt;-------&gt;      [Application Data]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Subsequent Handshake:</span><br><span class="line">       ClientHello</span><br><span class="line">       + key_share*</span><br><span class="line">       + pre_shared_key          --------&gt;</span><br><span class="line">                                                       ServerHello</span><br><span class="line">                                                  + pre_shared_key</span><br><span class="line">                                                      + key_share*</span><br><span class="line">                                             &#123;EncryptedExtensions&#125;</span><br><span class="line">                                                        &#123;Finished&#125;</span><br><span class="line">                                 &lt;--------     [Application Data*]</span><br><span class="line">       &#123;Finished&#125;                --------&gt;</span><br><span class="line">       [Application Data]        &lt;-------&gt;      [Application Data]</span><br><span class="line"></span><br><span class="line">            Figure 3: Message Flow for Resumption and PSK</span><br></pre></td></tr></table></figure>

<p>这种情况下服务端的身份通过PSK认证，所以服务端不发送<code>Certficate</code>和<code>CertificateVerify</code>消息。当客户端通过PSK提议重用的时候，也应该提供<code>key_share</code>扩展，以便服务端在拒绝重用的时候回退到全握手。</p>
<h2 id="有副作用的0-RTT握手"><a href="#有副作用的0-RTT握手" class="headerlink" title="有副作用的0-RTT握手"></a>有副作用的0-RTT握手</h2><p>当客户端和服务端共享一个PSK的时候（无论是通过外部获得还是通过前面的握手获得），TLS 1.3允许客户端在第一个flight上就发送数据（early data）。客户端使用PSK来认证服务端及加密early data。</p>
<p>0-RTT的握手流程如下，与PSK重用的1-RTT握手相比，增加<code>early_data</code>扩展以及第一个flight上的0-RTT应用数据。当接收到服务端的<code>Finished</code>消息之后，会发送一个<code>EndOfEarlyData</code>消息指示后面加密密钥的更换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client                                               Server</span><br><span class="line"></span><br><span class="line">ClientHello</span><br><span class="line">+ early_data</span><br><span class="line">+ key_share*</span><br><span class="line">+ psk_key_exchange_modes</span><br><span class="line">+ pre_shared_key</span><br><span class="line">(Application Data*)     --------&gt;</span><br><span class="line">                                                ServerHello</span><br><span class="line">                                           + pre_shared_key</span><br><span class="line">                                               + key_share*</span><br><span class="line">                                      &#123;EncryptedExtensions&#125;</span><br><span class="line">                                              + early_data*</span><br><span class="line">                                                 &#123;Finished&#125;</span><br><span class="line">                        &lt;--------       [Application Data*]</span><br><span class="line">(EndOfEarlyData)</span><br><span class="line">&#123;Finished&#125;              --------&gt;</span><br><span class="line">[Application Data]      &lt;-------&gt;        [Application Data]</span><br><span class="line"></span><br><span class="line">      +  Indicates noteworthy extensions sent in the</span><br><span class="line">         previously noted message.</span><br><span class="line"></span><br><span class="line">      *  Indicates optional or situation-dependent</span><br><span class="line">         messages/extensions that are not always sent.</span><br><span class="line"></span><br><span class="line">      () Indicates messages protected using keys</span><br><span class="line">         derived from a client_early_traffic_secret.</span><br><span class="line"></span><br><span class="line">      &#123;&#125; Indicates messages protected using keys</span><br><span class="line">         derived from a [sender]_handshake_traffic_secret.</span><br><span class="line"></span><br><span class="line">      [] Indicates messages protected using keys</span><br><span class="line">         derived from [sender]_application_traffic_secret_N.</span><br><span class="line"></span><br><span class="line">      Figure 4: Message Flow for a 0-RTT Handshake</span><br></pre></td></tr></table></figure>

<p>0-RTT的数据安全性较弱：</p>
<ul>
<li>0-RTT数据没有前向安全性，因为其加密密钥单纯是从PSK推导出来的</li>
<li>跨连接可以重放0-RTT里的应用数据（常规的TLS 1.3 1-RTT数据通过服务端随机数来防重放）</li>
</ul>
<h2 id="密钥派生过程"><a href="#密钥派生过程" class="headerlink" title="密钥派生过程"></a>密钥派生过程</h2><p>密钥派生过程用到了HKDF-Extract和HKDF-Expand函数，以及如下的函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKDF-Expand-Label(Secret, Label, Context, Length) =</span><br><span class="line">      HKDF-Expand(Secret, HkdfLabel, Length)</span><br></pre></td></tr></table></figure>

<p>其中<code>HkdfLabel</code>表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">  uint16 length = Length;</span><br><span class="line">  opaque label&lt;7..255&gt; = &quot;tls13 &quot; + Label;</span><br><span class="line">  opaque context&lt;0..255&gt; = Context;</span><br><span class="line">&#125; HkdfLabel;</span><br><span class="line"></span><br><span class="line">Derive-Secret(Secret, Label, Messages) = HKDF-Expand-Label(</span><br><span class="line">  Secret, Label, Transcript-Hash(Messages), Hash.length)</span><br></pre></td></tr></table></figure>



<p>不管是哪种密钥交换模式都给走完下面的整个流程，当没有对应的输入密钥材料（IKM），对应的位置用Hash长度的0值字符串代替。例如没有PSK的话，Early Secret就是<code>HKDF-Extract(0, 0)</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/e92ef4b4/TLS1_3-Key-Schedule.png" alt="TLS1_3-Key-Schedule" loading="lazy"></p>
<p>其中<code>exporter_secret</code>是导出密钥，用于用户自定义的其他用途。<code>resumption_master_secret</code>用于生成ticket。<code>client_early_traffic_secret</code>用于推导0-RTT的early-data密钥，<code>*_handshake_traffic_secret</code>用于推到握手消息的加密密钥，<code>*_application_traffic_secret_N</code>用于推导应用消息的加密密钥。</p>
<h1 id="常见实现"><a href="#常见实现" class="headerlink" title="常见实现"></a>常见实现</h1><p>OpenSSL：非常流行的开源实现、代码量最大、写得最烂？</p>
<p>LibreSSL：也是OpenSSL的一个fork，OpenBSD项目</p>
<p>BoringSSL：是OpenSSL的一个fork分支，主要用于Google的Chrome/Chromium、Android以及其他应用</p>
<p>JSSE（Java Secure Socket Extension）：Java实现</p>
<p>NSS：最初由网景开发的库，现在主要被浏览器和客户端软件使用，比如Firefox使用的就是NSS库（Mozilla开发）。</p>
<p>go.crypto：Go语言的实现</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://introspelliam.github.io/2018/03/20/crypto/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BBSSL-TLS%E5%AE%9E%E7%8E%B0/">深度解读SSL/TLS实现</a></li>
<li><a href="https://blog.helong.info/blog/2015/09/07/tls-protocol-analysis-and-crypto-protocol-design/#1-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%88%86%E5%B1%82%E6%8A%BD%E8%B1%A1">TLS协议分析</a></li>
<li><a href="https://juejin.cn/post/6844903624640823310#heading-5">完全吃透</a></li>
<li><a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/">Keyless SSL</a></li>
<li><a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">wiki-Transport_Layer_Security</a></li>
<li><a href="https://hpbn.co/transport-layer-security-tls/">Transport Layer Security</a></li>
<li><a href="https://www.crypto101.io/">Crypto101</a></li>
<li><a href="https://xiaoxueying.gitbooks.io/graphic-cryptology/content/index.html">graphic-cryptology</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA算法原理</a></li>
<li><a href="https://www.pediy.com/kssd/pediy06/pediy6014.htm">ECC加密算法入门</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc5246">TLS1.2-rfc5246</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc8446">TLS1.3-rfc8446</a></li>
<li><a href="https://en.wikipedia.org/wiki/OCSP_stapling">OCSP_stapling</a></li>
<li><a href="http://drops.xmd5.com/static/drops/tips-4403.html">常见HTTPS攻击方法</a></li>
</ul>
]]></content>
      <categories>
        <category>理论向</category>
      </categories>
      <tags>
        <tag>SSL/TLS</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>如何编写一个多进程性能测试程序</title>
    <url>/posts/e416d910/</url>
    <content><![CDATA[<div class="note primary">
            <p>在工作中经常碰到需要写一些多进程/多线程的测试程序，用来测试接口的性能。本文将会从零开始一点点增加代码，最终完成一个简易的多进程测试程序编写。该程序支持实时打印测试进结果和最终测试结果的统计。</p><p>同时，本文还涵盖了以下知识点，可以作为学习参考：</p><ul><li>使用<code>getopt_long()</code>处理命令行选项和参数</li><li>使用<code>fork()</code>和<code>wait()</code>处理多进程</li><li>使用<code>sigaction()</code>配合<code>alarm()</code>处理定时信号<code>SIGALRM</code></li><li>使用<code>shmget()</code>、<code>shmat()</code>、<code>shmdt()</code>、<code>shmctl()</code>等通过共享内存进行进程间通信</li><li>使用<code>sigaction()</code>捕获<code>SIGINT</code>和<code>SIGQUIT</code>信号，在程序终止前做共享内存清理工作</li></ul>
          </div>

<span id="more"></span>

<p>本文源码已开源<a href="https://github.com/catbro666/multi-process-test-demo">Github</a></p>
<h1 id="选项和参数的处理"><a href="#选项和参数的处理" class="headerlink" title="选项和参数的处理"></a>选项和参数的处理</h1><p>为了使测试程序更高的可用性，我们<code>getopt</code>来处理选项和参数。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>      <span class="comment">// printf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span>     <span class="comment">// getopt_long</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>     <span class="comment">// strtol, abort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>     <span class="comment">// LONG_MIN, LONG_MAX</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowHelpInfo</span><span class="params">(<span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [options]\n\n&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Options:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    -p/--proc         Number of processes (default: 1)\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    -d/--duration     Duration of test (unit: s, default: 10)\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    -h/--help         Show the help info\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Example:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    %s -p 4 -d 30\n&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> option_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> procs = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> duration = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  定义命令行参数列表，option结构的含义如下（详见 man 3 getopt）：</span></span><br><span class="line"><span class="comment">     *  struct option &#123;</span></span><br><span class="line"><span class="comment">     *      const char *name;       // 参数的完整名称，对应命令中的 --xxx</span></span><br><span class="line"><span class="comment">     *      int  has_arg;           // 该参数是否带有一个值，如 –-config xxx.conf</span></span><br><span class="line"><span class="comment">     *      int *flag;              // 一般设置为NULL</span></span><br><span class="line"><span class="comment">     *      int  val;               // 解析到该参数后getopt_long函数的返回值，</span></span><br><span class="line"><span class="comment">     *                      // 为了方便维护，一般对应getopt_long调用时第三个参数</span></span><br><span class="line"><span class="comment">     *  &#125;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">arg_options</span>[] =</span></span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">&quot;proc&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;p&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;duration&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;d&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;help&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="string">&#x27;h&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  注意：传递给getopt_long的第三个参数对应了命令行参数的缩写形式，如-h等，</span></span><br><span class="line"><span class="comment">     *  如果字符后面带有冒号&quot;:&quot;，则说明该参数后跟一个值，如-c xxxxxx</span></span><br><span class="line"><span class="comment">     *  如果开头有冒号&quot;:&quot;，则当一个选项缺少参数时，返回&quot;:&quot;，否则，返回&quot;?&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt_long(argc, argv, <span class="string">&quot;:p:d:h&quot;</span>, arg_options, &amp;option_index)</span><br><span class="line">            ) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//fprintf(stdout,&quot;option is -%c, optarv is %s\n&quot;, c, optarg);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">            procs = strtol(optarg, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (procs == LONG_MIN || procs == LONG_MAX) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The number of processes (%s) is overflow\n\n&quot;</span>,</span><br><span class="line">                        optarg);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (procs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The number of processes must be &gt; 0\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            duration = strtol(optarg, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (duration == LONG_MIN || duration == LONG_MAX) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The duration of test (%s) is overflow\n\n&quot;</span>,</span><br><span class="line">                        optarg);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (procs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The duration of test must be &gt; 0\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;Unknown option -%c\n\n&quot;</span>, optopt);</span><br><span class="line">            ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">           <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;Option -%c requires an argument\n\n&quot;</span>, optopt);</span><br><span class="line">           ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;processes:  %ld\n&quot;</span>, procs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;duration:   %lds\n&quot;</span>, duration);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n-----------------------------Start Testing----------------------&quot;</span></span><br><span class="line">           <span class="string">&quot;--------\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

</div></div>



<div class="note info">
            <p>注意：传递给getopt_long的第三个参数对应了命令行参数的缩写形式，如-h, -v, -c等。</p><p>如果字符后面带有冒号”:”，则说明该参数后跟一个值，如-c xxxxxx</p><p>如果开头有冒号”:”，则当一个选项缺少参数时，返回”:”，否则，返回”?”</p>
          </div>



<p><strong>效果如下</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">^_^$ make</span><br><span class="line">gcc <span class="string">&quot;-g&quot;</span> -c multi-process.c -o multi-process.o</span><br><span class="line">gcc  -o <span class="built_in">test</span> multi-process.o</span><br><span class="line"></span><br><span class="line">^_^$ ./<span class="built_in">test</span></span><br><span class="line">processes:  1</span><br><span class="line">duration:   10s</span><br><span class="line"></span><br><span class="line">-----------------------------Start Testing------------------------------</span><br><span class="line"></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>



<p><strong>选项或参数错误时</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ./test -p</span><br><span class="line">Option -p requires an argument</span><br><span class="line"></span><br><span class="line">Usage: ./test [options]</span><br><span class="line"></span><br><span class="line">  Options:</span><br><span class="line">    -p/--proc         Number of processes (default: 1)</span><br><span class="line">    -d/--duration     Duration of test (unit: s, default: 10)</span><br><span class="line">    -h/--help         Show the help info</span><br><span class="line"></span><br><span class="line">  Example:</span><br><span class="line">    ./test -p 4 -d 30</span><br></pre></td></tr></table></figure>



<h1 id="增加多进程的支持"><a href="#增加多进程的支持" class="headerlink" title="增加多进程的支持"></a>增加多进程的支持</h1><p>主进程<code>fork</code>出n个子进程后<code>wait</code>子进程，子进程则通过<code>sigaction</code>和<code>alarm</code>设置一个定时器，然后进行业务测试。</p>
<p>为了简洁，已经把选项参数处理的部分独立出去了。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>      <span class="comment">// printf, fprintf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span>   <span class="comment">// wait</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>  <span class="comment">// getpid, wait</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span>     <span class="comment">// sigaction, SIGLARM</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>     <span class="comment">// LONG_MIN, LONG_MAX, ULLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>     <span class="comment">// getpid</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>     <span class="comment">// memset</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;multi-process.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> isStop = <span class="number">0</span>;             <span class="comment">// 用于标记测试终止</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">param_st</span> &#123;</span>   <span class="comment">// 自定义测试参数</span></span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">&#125; Param;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal_child</span><span class="params">(<span class="keyword">int</span> sigNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigNum == SIGALRM) &#123;</span><br><span class="line">        isStop = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实际业务测试函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTest</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    Param *pa = (Param *)param;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; ULLONG_MAX &amp;&amp; !isStop; ++i) &#123;</span><br><span class="line">        <span class="comment">/* DO YOUR WORK */</span></span><br><span class="line">        <span class="comment">/* DO YOUR WORK */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;process [pid = %6u] result: %llu\n&quot;</span>, getpid(), i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> proc_index = <span class="number">0</span>;</span><br><span class="line">    Options opt;</span><br><span class="line">    <span class="keyword">int</span> isParent = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> wstatus = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act_child</span>;</span></span><br><span class="line"></span><br><span class="line">    rv = process_options(argc, argv, &amp;opt);</span><br><span class="line">    <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n-----------------------------Start Testing----------------------&quot;</span></span><br><span class="line">           <span class="string">&quot;--------\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* COMMON INIT */</span></span><br><span class="line">    <span class="comment">/* COMMON INIT */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(isParent &amp;&amp; i &lt; opt.procs) &#123;</span><br><span class="line">        pid =  fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>) &#123;         <span class="comment">/* error */</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed %d\n&quot;</span>, pid);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;     <span class="comment">/* child */</span></span><br><span class="line">            isParent = <span class="number">0</span>;</span><br><span class="line">            proc_index = i;     <span class="comment">// 记录进程索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;                  <span class="comment">/* parent */</span></span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isParent) &#123;</span><br><span class="line">        <span class="comment">/* PARENT INIT */</span></span><br><span class="line">        <span class="comment">/* PARENT INIT */</span></span><br><span class="line">        <span class="keyword">for</span>(i =<span class="number">0</span> ; i &lt; opt.procs; ++i) &#123;</span><br><span class="line">            pid = wait(&amp;wstatus);                       <span class="comment">// 等待子进程结束</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process [pid = %6d] exit\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* CHILD INIT */</span></span><br><span class="line">        Param param;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;param, <span class="number">0</span>, <span class="keyword">sizeof</span>(Param));</span><br><span class="line">        param.index = proc_index;</span><br><span class="line">        <span class="comment">/* CHILD INIT */</span></span><br><span class="line"></span><br><span class="line">        act_child.sa_handler = handle_signal_child;</span><br><span class="line">        sigemptyset(&amp;act_child.sa_mask);</span><br><span class="line">        act_child.sa_flags = SA_RESETHAND;</span><br><span class="line">        <span class="comment">/* 用于测试时间到时，通知子进程结束测试 */</span></span><br><span class="line">        rv = sigaction(SIGALRM, &amp;act_child, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;sigaction() failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//signal(SIGALRM, handle_signal_child);</span></span><br><span class="line">        alarm(opt.duration);                            <span class="comment">// 设置测试时长</span></span><br><span class="line">        doTest(&amp;param);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">/* child finished work */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></div>



<p><strong>效果如下</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ./test -p 4 -d 2</span><br><span class="line">processes:  4</span><br><span class="line">duration:   2s</span><br><span class="line"></span><br><span class="line">-----------------------------Start Testing------------------------------</span><br><span class="line"></span><br><span class="line">process [pid =  11942] result: 446930553</span><br><span class="line">process [pid =  11942] exit</span><br><span class="line">process [pid =  11939] result: 434385097</span><br><span class="line">process [pid =  11939] exit</span><br><span class="line">process [pid =  11940] result: 442246977</span><br><span class="line">process [pid =  11940] exit</span><br><span class="line">process [pid =  11941] result: 442418811</span><br><span class="line">process [pid =  11941] exit</span><br></pre></td></tr></table></figure>



<p>这样已经可以实现简单的多进程测试，简单起见，示例代码里只是简单地进行了计数操作。读者如果想要进行自己特定的测试，只要在Param中增加需要的测试参数，接着在<code>/* CHILD INIT */</code>处进行参数初始化，然后在<code>/* DO YOUR WORK */</code>处添加实际的测试逻辑即可。</p>
<h1 id="增加实时的结果统计及最终的结果汇总"><a href="#增加实时的结果统计及最终的结果汇总" class="headerlink" title="增加实时的结果统计及最终的结果汇总"></a>增加实时的结果统计及最终的结果汇总</h1><p>为了使测试程序更加人性化，使其可以实时统计测试结果，结束时自动计算总的结果。这就需要引入父子进程间通信，我们选用共享内存的方式来实现。为了避免进程间同步对测试带来的影响，在共享内存中为每个子进程开辟了一个空间，每个子进程根据索引在自己的空间里写数据，由父进程进行结果的汇总。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>      <span class="comment">// printf, fprintf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span>   <span class="comment">// wait</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>  <span class="comment">// getpid, wait</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span>    <span class="comment">// shmget, shmat, shmctl, shmdt</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span>    <span class="comment">// shmget, shmat, shmctl, shmdt</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span>     <span class="comment">// sigaction, SIGLARM</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>     <span class="comment">// LONG_MIN, LONG_MAX, ULLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span>      <span class="comment">// errno</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>     <span class="comment">// getpid</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>     <span class="comment">// memset</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;multi-process.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">param_st</span> &#123;</span>   <span class="comment">// 自定义测试参数</span></span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">&#125; Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">result_st</span> &#123;</span>   <span class="comment">// 自定义测试结果</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> count;</span><br><span class="line">&#125; Result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> isStop = <span class="number">0</span>;             <span class="comment">// 用于标记测试终止</span></span><br><span class="line">Options opt;                <span class="comment">// 命令行选项</span></span><br><span class="line"><span class="keyword">int</span> shmid;                  <span class="comment">// 共享内存id</span></span><br><span class="line">Result *shm = <span class="literal">NULL</span>;         <span class="comment">// 共享内存地址，用于存放测试结果</span></span><br><span class="line">Result res_total;</span><br><span class="line">Result res_last;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal_child</span><span class="params">(<span class="keyword">int</span> sigNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigNum == SIGALRM) &#123;</span><br><span class="line">        isStop = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal_parent</span><span class="params">(<span class="keyword">int</span> sigNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigNum == SIGALRM) &#123;</span><br><span class="line">        <span class="comment">/* DO REAL-TIME STATISTICS */</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;res_total, <span class="number">0</span>, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; opt.procs; ++i) &#123;</span><br><span class="line">            res_total.count += shm[i].count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;total count %12llu,  average %12.0lf/s\n&quot;</span>,</span><br><span class="line">                res_total.count, (res_total.count - res_last.count)</span><br><span class="line">                / (<span class="keyword">double</span>)opt.interval);</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;res_last, &amp;res_total, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        <span class="comment">/* DO REAL-TIME STATISTICS */</span></span><br><span class="line">        alarm(opt.interval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实际业务测试函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTest</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    Param *pa = (Param *)param;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; ULLONG_MAX &amp;&amp; !isStop; ++i) &#123;</span><br><span class="line">        <span class="comment">/* DO YOUR WORK */</span></span><br><span class="line">        ++shm[pa-&gt;index].count;</span><br><span class="line">        <span class="comment">/* DO YOUR WORK */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> proc_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> isParent = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> wstatus = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act_child</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act_parent</span>;</span></span><br><span class="line"></span><br><span class="line">    rv = process_options(argc, argv, &amp;opt);</span><br><span class="line">    <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n-----------------------------Start Testing-------------&quot;</span></span><br><span class="line">            <span class="string">&quot;-----------------\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* COMMON INIT */</span></span><br><span class="line">    shmid = shmget(IPC_PRIVATE, <span class="keyword">sizeof</span>(<span class="keyword">sizeof</span>(Result) * opt.procs), <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == shmid) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;shmget() failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;shmid = %d\n&quot;</span>, shmid);</span><br><span class="line">    shm = (Result*)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">void</span> *) <span class="number">-1</span> == shm) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;shmat() failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(shm, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">sizeof</span>(Result) * opt.procs));</span><br><span class="line">    <span class="comment">/* COMMON INIT */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(isParent &amp;&amp; i &lt; opt.procs) &#123;</span><br><span class="line">        pid =  fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>) &#123;         <span class="comment">/* error */</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed %d\n&quot;</span>, pid);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;     <span class="comment">/* child */</span></span><br><span class="line">            isParent = <span class="number">0</span>;</span><br><span class="line">            proc_index = i;     <span class="comment">// 记录进程索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;                  <span class="comment">/* parent */</span></span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isParent) &#123;</span><br><span class="line">        <span class="comment">/* PARENT INIT */</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;act_parent, <span class="number">0</span>, <span class="keyword">sizeof</span>(act_parent));</span><br><span class="line">        act_parent.sa_handler = handle_signal_parent;</span><br><span class="line">        <span class="comment">/* 使wait被中断时可以自动恢复 */</span></span><br><span class="line">        act_parent.sa_flags = SA_RESTART;</span><br><span class="line">        rv = sigaction(SIGALRM, &amp;act_parent, <span class="literal">NULL</span>);     <span class="comment">// 用于定时统计结果</span></span><br><span class="line">        <span class="comment">//signal(SIGALRM, handle_signal_parent);</span></span><br><span class="line">        <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;sigaction() failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;res_last, <span class="number">0</span>, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        alarm(opt.interval);</span><br><span class="line">        <span class="comment">/* PARENT INIT */</span></span><br><span class="line">        <span class="comment">/* DO FINAL STATISTICS */</span></span><br><span class="line">        Result <span class="keyword">final</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;<span class="keyword">final</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        <span class="keyword">for</span>(i =<span class="number">0</span> ; i &lt; opt.procs; ++i) &#123;</span><br><span class="line">            pid = wait(&amp;wstatus);                       <span class="comment">// 等待子进程结束</span></span><br><span class="line">            alarm(<span class="number">0</span>);                                   <span class="comment">// 终止定时器</span></span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;wait() failed, errno=%d\n&quot;</span>, errno);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;process [pid = %6d] exit\n&quot;</span>, pid);</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;process [pid = %6u] count %12llu in %lus,  &quot;</span></span><br><span class="line">                    <span class="string">&quot;average %12.0lf/s\n&quot;</span>, pid, shm[i].count, opt.duration, </span><br><span class="line">                    shm[i].count / (<span class="keyword">double</span>)opt.duration);</span><br><span class="line">            <span class="keyword">final</span>.count += shm[i].count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;total count %12llu in %lus,  average %12.0lf/s\n&quot;</span>,</span><br><span class="line">               <span class="keyword">final</span>.count, opt.duration, <span class="keyword">final</span>.count / (<span class="keyword">double</span>)opt.duration);</span><br><span class="line">        <span class="comment">/* DO FINAL STATISTICS */</span></span><br><span class="line">        shmdt((<span class="keyword">void</span>*)shm);</span><br><span class="line">        <span class="comment">/* 子进程退出之后自动detach了, 所以这里不需要通过IPC_STAT进行判断 */</span></span><br><span class="line">        shmctl(shmid, IPC_RMID, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* CHILD INIT */</span></span><br><span class="line">        Param param;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;param, <span class="number">0</span>, <span class="keyword">sizeof</span>(Param));</span><br><span class="line">        param.index = proc_index;</span><br><span class="line">        <span class="comment">/* CHILD INIT */</span></span><br><span class="line"></span><br><span class="line">        act_child.sa_handler = handle_signal_child;</span><br><span class="line">        sigemptyset(&amp;act_child.sa_mask);</span><br><span class="line">        <span class="comment">//sigaddset(&amp;act_child.sa_mask, SIGQUIT);</span></span><br><span class="line">        <span class="comment">//sigaddset(&amp;act_child.sa_mask, SIGTERM);</span></span><br><span class="line">        act_child.sa_flags = SA_RESETHAND;</span><br><span class="line">        <span class="comment">/* 用于测试时间到时，通知子进程结束测试 */</span></span><br><span class="line">        rv = sigaction(SIGALRM, &amp;act_child, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;sigaction() failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//signal(SIGALRM, handle_signal_child);</span></span><br><span class="line">        alarm(opt.duration);                            <span class="comment">// 设置测试时长</span></span><br><span class="line">        doTest(&amp;param);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">/* child finished work */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></div>



<p><strong>测试效果如下</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ./test -p 4 -d 8 -i 1</span><br><span class="line">processes:  4</span><br><span class="line">duration:   8s</span><br><span class="line">interval:   1s</span><br><span class="line"></span><br><span class="line">-----------------------------Start Testing------------------------------</span><br><span class="line"></span><br><span class="line">shmid = 2654220</span><br><span class="line">total count    344235932,  average    344235932/s</span><br><span class="line">total count    679573681,  average    335337749/s</span><br><span class="line">total count   1026283924,  average    346710243/s</span><br><span class="line">total count   1368302354,  average    342018430/s</span><br><span class="line">total count   1708471662,  average    340169308/s</span><br><span class="line">total count   2057211138,  average    348739476/s</span><br><span class="line">total count   2398403059,  average    341191921/s</span><br><span class="line">process [pid =  25124] exit</span><br><span class="line">process [pid =  25124] count    688504473 in 8s,  average     86063059/s</span><br><span class="line">process [pid =  25123] exit</span><br><span class="line">process [pid =  25123] count    682379115 in 8s,  average     85297389/s</span><br><span class="line">process [pid =  25125] exit</span><br><span class="line">process [pid =  25125] count    682467102 in 8s,  average     85308388/s</span><br><span class="line">process [pid =  25126] exit</span><br><span class="line">process [pid =  25126] count    688159459 in 8s,  average     86019932/s</span><br><span class="line">total count   2741510149 in 8s,  average    342688769/s</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>这里需要特别提一下<code>wait()</code>和<code>sigaction()</code>系统调用，默认情况下<code>wait()</code>会阻塞直到有任意一个子进程改变了其状态，或者有一个信号处理函数中断了<code>wait()</code>调用。所以我们程序中的<code>wait()</code>调用就会被自己的<code>SIGALRM</code>信号中断，返回<code>-1</code>同时<code>errno</code>为<code>EINTR</code>。这样我们就需要在<code>wait()</code>外面加一层循环来处理<code>wait()</code>被信号中断的情况。</p><p>通过在<code>sigaction()</code>时增加<code>SA_RESTART</code>标志，被中断的系统调用可以自动重开，也就省去了那个外层循环。另外，<code>signal()</code>封装了<code>sigaction()</code>，它里面默认就是设置了<code>SA_RESTART</code>，不过除非你有确切的理由，不然不建议使用<code>signal()</code>了。</p>
          </div>

<h1 id="增加SIGINT和SIGQUIT信号捕获"><a href="#增加SIGINT和SIGQUIT信号捕获" class="headerlink" title="增加SIGINT和SIGQUIT信号捕获"></a>增加SIGINT和SIGQUIT信号捕获</h1><p>截止目前，我们已经完成了多进程的测试及结果统计。但其实还有一个潜在的问题，在实际测试中，我们经常会在测试还没完成时就手动<code>^C</code>终止程序执行。这样我们在程序中申请的共享内存就会得不到释放，造成内存泄漏。所以需要增加对<code>SIGINT</code>和<code>SIGQUIT</code>信号的处理函数，在里面做清理工作，释放共享内存。</p>
<div class="note default">
            <p>如果已经不小心造成了共享内存的泄漏，可以通过如下命令手动进行删除。<code>ipcrm shm &lt;id&gt;</code>，如果是显式指定key的话也可以通过<code>ipcrm -M &lt;key&gt;</code>来进行删除。</p>
          </div>

<div class="note info">
            <p>今天，突然想到了，其实有一种更加简单的方法，即在<code>shmat()</code>之后立即进行<code>shmctl(shmid, IPC_RMID, 0);</code>。这样不仅简单，而且中间的空窗期也更短，cool！这样我们再也不用担心，<code>^C</code>造成内存泄漏了哈。</p>
          </div>

<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="meta">@@ -88,12 +88,14 @@</span> int main(int argc, char *argv[]) &#123;</span><br><span class="line">         fprintf(stderr, &quot;shmget() failed\n&quot;);</span><br><span class="line">         return -1;</span><br><span class="line">     &#125;</span><br><span class="line">     fprintf(stderr, &quot;shmid = %d\n&quot;, shmid);</span><br><span class="line">     shm = (Result*)shmat(shmid, 0, 0);</span><br><span class="line">     if ((void *) -1 == shm) &#123;</span><br><span class="line">         fprintf(stderr, &quot;shmat() failed\n&quot;);</span><br><span class="line">         return -1;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="addition">+    /* 这里直接进行IPC_RMID操作，进程退出后会自动detach了, 从而释放共享内存 */</span></span><br><span class="line"><span class="addition">+    shmctl(shmid, IPC_RMID, 0);</span></span><br><span class="line">     memset(shm, 0, sizeof(sizeof(Result) * opt.procs));</span><br><span class="line">     /* COMMON INIT */</span><br><span class="line"></span><br><span class="line"><span class="meta">@@ -156,10 +135,6 @@</span> int main(int argc, char *argv[]) &#123;</span><br><span class="line">         fprintf(stderr, &quot;total count %12llu in %lus,  average %12.0lf/s\n&quot;,</span><br><span class="line">                final.count, opt.duration, final.count / (double)opt.duration);</span><br><span class="line">         /* DO FINAL STATISTICS */</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-        shmdt((void*)shm);</span></span><br><span class="line"><span class="deletion">-        /* 子进程退出之后自动detach了, 所以这里不需要通过IPC_STAT进行判断 */</span></span><br><span class="line"><span class="deletion">-        shmctl(shmid, IPC_RMID, 0);</span></span><br><span class="line">     &#125;</span><br><span class="line">     else &#123;</span><br><span class="line">         /* CHILD INIT */</span><br></pre></td></tr></table></figure>



<h1 id="封装错误判断函数"><a href="#封装错误判断函数" class="headerlink" title="封装错误判断函数"></a>封装错误判断函数</h1><p>为了使代码看起来更加简洁，避免每个函数调用后面跟着一个<code>if()&#123;&#125;</code>判断块，我们对错误判断及日志打印函数进行了一个简单的封装。封装的函数如下：</p>
<p>其中<code>mylog()</code>单纯打印日志，<code>fail()</code>打印日志后退出进程，<code>fail_if()</code>先判断条件，如果成立打印日志退出，<code>fail_clean_if()</code>也是先判断条件，条件成立则打印日志，执行传入的清理函数。然后退出进程。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>      <span class="comment">// stderr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span>     <span class="comment">// va_start, vfprintf, va_end</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>     <span class="comment">// exit</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail_if</span><span class="params">(<span class="keyword">bool</span> condition, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        va_list args;</span><br><span class="line">        va_start(args, fmt);</span><br><span class="line">        <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">        va_end(args);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mylog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail_clean_if</span><span class="params">(<span class="keyword">bool</span> condition, cleanup clean, <span class="keyword">void</span> *param, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        va_list args;</span><br><span class="line">        va_start(args, fmt);</span><br><span class="line">        <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">        va_end(args);</span><br><span class="line">        clean(param);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>



<h1 id="添加实际测试用例"><a href="#添加实际测试用例" class="headerlink" title="添加实际测试用例"></a>添加实际测试用例</h1><p>接下来我们来添加实际有意义的测试用例，这里以OpenSSL引擎的性能测试为例来进行说明。为了我们的代码更清晰，已经将具体测试相关的代码独立为一个源文件。<code>common.c</code>封装错误函数，<code>opt.c</code>处理命令行选项，<code>work.c</code>处理具体测试，<code>multi-process.c</code>则负责测试的主控。完整的代码如下：</p>
<ul>
<li><code>common.h</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADER_COMMON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADER_COMMON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span>    <span class="comment">// bool, true, false</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*cleanup)</span> <span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail_if</span><span class="params">(<span class="keyword">bool</span> condition, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mylog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail_clean_if</span><span class="params">(<span class="keyword">bool</span> condition, cleanup clean, <span class="keyword">void</span> *param, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HEADER_COMMON_H */</span></span></span><br></pre></td></tr></table></figure>



</div></div>

<ul>
<li><code>common.c</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>      <span class="comment">// stderr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span>     <span class="comment">// va_start, vfprintf, va_end</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>     <span class="comment">// exit</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail_if</span><span class="params">(<span class="keyword">bool</span> condition, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        va_list args;</span><br><span class="line">        va_start(args, fmt);</span><br><span class="line">        <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">        va_end(args);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mylog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail_clean_if</span><span class="params">(<span class="keyword">bool</span> condition, cleanup clean, <span class="keyword">void</span> *param, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        va_list args;</span><br><span class="line">        va_start(args, fmt);</span><br><span class="line">        <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">        va_end(args);</span><br><span class="line">        clean(param);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><code>opt.h</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADER_OPT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADER_OPT_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">test</span>&#123;</span></span><br><span class="line">    hash, sign, verify, enc, dec</span><br><span class="line">&#125; Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">options_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> procs;                 <span class="comment">// 进程数</span></span><br><span class="line">    <span class="keyword">long</span> duration;              <span class="comment">// 测试时间</span></span><br><span class="line">    <span class="keyword">long</span> interval;              <span class="comment">// 统计间隔</span></span><br><span class="line">    Test test;                  <span class="comment">// 测试类型</span></span><br><span class="line">    <span class="keyword">long</span> len;                   <span class="comment">// 摘要原文长度</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *key;            <span class="comment">// 密钥文件路径</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cert;           <span class="comment">// 证书文件路径</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *loglevel;       <span class="comment">// 日志等级</span></span><br><span class="line">&#125; Options;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理参数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process_options</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], Options *opt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HEADER_OPT_H */</span></span></span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><code>opt.c</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>     <span class="comment">// LONG_MIN, LONG_MAX, ULLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>     <span class="comment">// memset</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>     <span class="comment">// strtol, abort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span>     <span class="comment">// geropt_long</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span>     <span class="comment">// mylog</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowHelpInfo</span><span class="params">(<span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    mylog(<span class="string">&quot;Usage: %s [options]\n\n&quot;</span>, name);</span><br><span class="line">    mylog(<span class="string">&quot;  Options:\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -p/--proc         Number of processes (default: 1)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -d/--duration     Duration of test (unit: s, default: 10)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -i/--interval     Interval of statisics (unit: s, default: 1)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -t/--test         Test case (hash|sign|verify|enc|dec, default: hash)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -l/--len          Hash data len (unit: byte, default: 1024)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -k/--key          PEM Key file path (default: ./key.pem)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -c/--cert         PEM Cert file path (default: ./cert.pem)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -o/--loglevel     Engine log level (0-9, default: 0)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -h/--help         Show the help info\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;  Example:\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    %s -p 1 -d 30 -i 1 -t sign -k key.pem -c cert.pem\n&quot;</span>, name);</span><br><span class="line">    mylog(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理参数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process_options</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], Options *opt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> option_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> procs = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> duration = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">long</span> interval = <span class="number">1</span>;</span><br><span class="line">    Test test = hash;</span><br><span class="line">    <span class="keyword">long</span> len = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *key = <span class="string">&quot;./key.pem&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cert = <span class="string">&quot;./cert.pem&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *loglevel = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  定义命令行参数列表，option结构的含义如下（详见 man 3 getopt）：</span></span><br><span class="line"><span class="comment">     *  struct option &#123;</span></span><br><span class="line"><span class="comment">     *      const char *name;       // 参数的完整名称，对应命令中的 --xxx</span></span><br><span class="line"><span class="comment">     *      int  has_arg;           // 该参数是否带有一个值，如 –config xxx.conf</span></span><br><span class="line"><span class="comment">     *      int *flag;              // 一般设置为NULL</span></span><br><span class="line"><span class="comment">     *      int  val;               // 解析到该参数后getopt_long函数的返回值，</span></span><br><span class="line"><span class="comment">     *                      // 为了方便维护，一般对应getopt_long调用时第三个参数</span></span><br><span class="line"><span class="comment">     *  &#125;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">arg_options</span>[] =</span></span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">&quot;proc&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;p&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;duration&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;d&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;interval&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;i&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;test&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;t&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;len&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;l&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;key&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;k&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;cert&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;log&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;g&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;help&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="string">&#x27;h&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  注意：传递给getopt_long的第三个参数对应了命令行参数的缩写形式，如-h等，</span></span><br><span class="line"><span class="comment">     *  如果字符后面带有冒号&quot;:&quot;，则说明该参数后跟一个值，如-c xxxxxx</span></span><br><span class="line"><span class="comment">     *  如果开头有冒号&quot;:&quot;，则当一个选项缺少参数时，返回&quot;:&quot;，否则，返回&quot;?&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt_long(argc, argv, <span class="string">&quot;:p:d:i:t:l:k:c:g:h&quot;</span>, arg_options, &amp;option_index)</span><br><span class="line">            ) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//fprintf(stderr,&quot;option is -%c, optarv is %s\n&quot;, c, optarg);</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">            procs = strtol(optarg, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (procs == LONG_MIN || procs == LONG_MAX) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The number of processes (%s) is overflow\n\n&quot;</span>, optarg);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (procs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The number of processes must be &gt; 0\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            duration = strtol(optarg, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (duration == LONG_MIN || duration == LONG_MAX) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The duration of test (%s) is overflow\n\n&quot;</span>, optarg);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (duration &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The duration of test must be &gt; 0\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">            interval = strtol(optarg, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (interval == LONG_MIN || interval == LONG_MAX) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The interval of statistics (%s) is overflow\n\n&quot;</span>,</span><br><span class="line">                      optarg);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (interval &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The interval of statistics must be &gt; 0\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(!strcasecmp(<span class="string">&quot;hash&quot;</span>, optarg)) &#123;</span><br><span class="line">                test = hash;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!strcasecmp(<span class="string">&quot;sign&quot;</span>, optarg)) &#123;</span><br><span class="line">                test = sign;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!strcasecmp(<span class="string">&quot;verify&quot;</span>, optarg)) &#123;</span><br><span class="line">                test = verify;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!strcasecmp(<span class="string">&quot;enc&quot;</span>, optarg)) &#123;</span><br><span class="line">                test = enc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!strcasecmp(<span class="string">&quot;dec&quot;</span>, optarg)) &#123;</span><br><span class="line">                test = dec;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                mylog(<span class="string">&quot;Unknown test case type\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">            len = strtol(optarg, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (len == LONG_MIN || len == LONG_MAX) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The len of hash data (%s) is overflow\n\n&quot;</span>,</span><br><span class="line">                      optarg);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The len of hash data must be &gt; 0\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>:</span><br><span class="line">            key = optarg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">            cert = optarg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">            loglevel = optarg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            mylog(<span class="string">&quot;Unknown option -%c\n\n&quot;</span>, optopt);</span><br><span class="line">            ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">            mylog(<span class="string">&quot;Option -%c requires an argument\n\n&quot;</span>, optopt);</span><br><span class="line">            ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mylog(<span class="string">&quot;processes:  %ld\n&quot;</span>, procs);</span><br><span class="line">    mylog(<span class="string">&quot;duration:   %lds\n&quot;</span>, duration);</span><br><span class="line">    mylog(<span class="string">&quot;interval:   %lds\n&quot;</span>, interval);</span><br><span class="line">    mylog(<span class="string">&quot;test:       #%d\n&quot;</span>, test);</span><br><span class="line">    mylog(<span class="string">&quot;len:        %ld bytes\n&quot;</span>, len);</span><br><span class="line">    mylog(<span class="string">&quot;key:        %s\n&quot;</span>, key);</span><br><span class="line">    mylog(<span class="string">&quot;cert:       %s\n&quot;</span>, cert);</span><br><span class="line">    mylog(<span class="string">&quot;loglevel:   %s\n&quot;</span>, loglevel);</span><br><span class="line">    <span class="built_in">memset</span>(opt, <span class="number">0</span>, <span class="keyword">sizeof</span>(Options));</span><br><span class="line">    opt-&gt;procs = procs;</span><br><span class="line">    opt-&gt;duration = duration;</span><br><span class="line">    opt-&gt;interval = interval;</span><br><span class="line">    opt-&gt;test = test;</span><br><span class="line">    opt-&gt;len = len;</span><br><span class="line">    opt-&gt;key = key;</span><br><span class="line">    opt-&gt;cert = cert;</span><br><span class="line">    opt-&gt;loglevel = loglevel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><code>work.h</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADER_WORK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADER_WORK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义测试参数 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hash_param_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> data_len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> md[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> md_len;</span><br><span class="line">    EVP_MD_CTX *ctx;</span><br><span class="line">&#125; HashParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sign_param_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">size_t</span> data_len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sig[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">size_t</span> sig_len;</span><br><span class="line">    EVP_PKEY_CTX *ctx;</span><br><span class="line">    BIO *in;</span><br><span class="line">&#125; SignParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> SignParam VerifyParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">enc_param_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">size_t</span> data_len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> enc[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">size_t</span> enc_len;</span><br><span class="line">    EVP_PKEY_CTX *ctx;</span><br><span class="line">    BIO *in;</span><br><span class="line">&#125; EncParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> EncParam DecParam;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义测试结果 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">result_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> count;</span><br><span class="line">&#125; Result;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*init_fn)</span> <span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*work_fn)</span> <span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*clean_fn)</span> <span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> init_fn test_init;</span><br><span class="line"><span class="keyword">extern</span> work_fn test_work;</span><br><span class="line"><span class="keyword">extern</span> clean_fn test_clean;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">global_init</span><span class="params">(Options *opt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">global_clean</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HEADER_WORK_H */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><code>work.c</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;work.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/engine.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/pem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* so_path = <span class="string">&quot;/usr/local/ssl/lib/myengine.so&quot;</span>;</span><br><span class="line"></span><br><span class="line">init_fn test_init = <span class="literal">NULL</span>;</span><br><span class="line">work_fn test_work = <span class="literal">NULL</span>;</span><br><span class="line">clean_fn test_clean = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hash_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hash_work</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hash_clean</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sign_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sign_work</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sign_clean</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify_work</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify_clean</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encrypt_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encrypt_work</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encrypt_clean</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrypt_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrypt_work</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrypt_clean</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">global_init</span><span class="params">(Options *opt)</span> </span>&#123;</span><br><span class="line">    ENGINE *e = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (opt-&gt;test == hash) &#123;</span><br><span class="line">        test_init = hash_init;</span><br><span class="line">        test_work = hash_work;</span><br><span class="line">        test_clean = hash_clean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (opt-&gt;test == sign) &#123;</span><br><span class="line">        test_init = sign_init;</span><br><span class="line">        test_work = sign_work;</span><br><span class="line">        test_clean = sign_clean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (opt-&gt;test == verify) &#123;</span><br><span class="line">        test_init = verify_init;</span><br><span class="line">        test_work = verify_work;</span><br><span class="line">        test_clean = verify_clean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (opt-&gt;test == enc) &#123;</span><br><span class="line">        test_init = encrypt_init;</span><br><span class="line">        test_work = encrypt_work;</span><br><span class="line">        test_clean = encrypt_clean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (opt-&gt;test == dec) &#123;</span><br><span class="line">        test_init = decrypt_init;</span><br><span class="line">        test_work = decrypt_work;</span><br><span class="line">        test_clean = decrypt_clean;</span><br><span class="line">    &#125;</span><br><span class="line">    OpenSSL_add_all_algorithms();</span><br><span class="line">    <span class="comment">/* ENGINE INIT */</span></span><br><span class="line">    ENGINE_load_dynamic();</span><br><span class="line">    <span class="keyword">if</span> (!(e = ENGINE_by_id(<span class="string">&quot;dynamic&quot;</span>))) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_by_id(\&quot;dynamic\&quot;) fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ENGINE_ctrl_cmd_string(e, <span class="string">&quot;SO_PATH&quot;</span>, so_path, <span class="number">0</span>)) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_ctrl_cmd_string(\&quot;SO_PATH\&quot;) fail, so_path = %s\n&quot;</span>, </span><br><span class="line">             so_path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ENGINE_ctrl_cmd_string(e, <span class="string">&quot;LIST_ADD&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_ctrl_cmd_string(\&quot;LIST_ADD\&quot;) fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ENGINE_ctrl_cmd_string(e, <span class="string">&quot;LOAD&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_ctrl_cmd_string(\&quot;LOAD\&quot;) fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ENGINE_init(e)) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_init() fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ENGINE_ctrl_cmd_string( e, <span class="string">&quot;ENGINE_SET_LOGLEVEL&quot;</span>, opt-&gt;loglevel, <span class="number">0</span>)) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_ctrl_cmd_string(\&quot;ENGINE_SET_LOGLEVEL\&quot;) fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_set_default() fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ENGINE_free(e);</span><br><span class="line">    <span class="comment">/* ENGINE INIT */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">global_clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EVP_cleanup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hash_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span> </span>&#123;</span><br><span class="line">    HashParam *p;</span><br><span class="line">    p = OPENSSL_malloc(<span class="keyword">sizeof</span>(HashParam));</span><br><span class="line">    fail_if(!p, <span class="string">&quot;OPENSSL_malloc() fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(HashParam));</span><br><span class="line"></span><br><span class="line">    p-&gt;ctx = EVP_MD_CTX_create();</span><br><span class="line">    fail_clean_if(!p-&gt;ctx, hash_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;EVP_MD_CTX_create() fail\n&quot;</span>);</span><br><span class="line">    EVP_MD_CTX_init(p-&gt;ctx);</span><br><span class="line"></span><br><span class="line">    p-&gt;data = OPENSSL_malloc(opt-&gt;len);</span><br><span class="line">    fail_clean_if(!p-&gt;data, hash_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;OPENSSL_malloc() fail\n&quot;</span>);</span><br><span class="line">    fail_clean_if(RAND_bytes(p-&gt;data, <span class="keyword">sizeof</span>(opt-&gt;len)) &lt;= <span class="number">0</span>, hash_clean, (<span class="keyword">void</span> *)p,</span><br><span class="line">                  <span class="string">&quot;RAND_bytes() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;data_len = opt-&gt;len;</span><br><span class="line"></span><br><span class="line">    p-&gt;index = proc_index;</span><br><span class="line"></span><br><span class="line">    *param = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hash_work</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    HashParam *p = (HashParam *)param;</span><br><span class="line">    <span class="keyword">const</span> EVP_MD *md = EVP_get_digestbyname(<span class="string">&quot;SHASH&quot;</span>);</span><br><span class="line">    fail_clean_if(!md, hash_clean, param, </span><br><span class="line">                  <span class="string">&quot;EVP_get_digestbyname(\&quot;SHASH\&quot;) fail\n&quot;</span>);</span><br><span class="line">    fail_clean_if(!EVP_DigestInit_ex(p-&gt;ctx, md, <span class="literal">NULL</span>), </span><br><span class="line">                  hash_clean, param, <span class="string">&quot;EVP_DigestInit_ex() fail\n&quot;</span>);</span><br><span class="line">    fail_clean_if(!EVP_DigestUpdate(p-&gt;ctx, p-&gt;data, p-&gt;data_len),</span><br><span class="line">                  hash_clean, param, <span class="string">&quot;EVP_DigestUpdate() fail\n&quot;</span>);</span><br><span class="line">    fail_clean_if(!EVP_DigestFinal_ex(p-&gt;ctx, p-&gt;md, &amp;p-&gt;md_len),</span><br><span class="line">                  hash_clean, param, <span class="string">&quot;EVP_DigestFinal_ex() fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hash_clean</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    HashParam *p = (HashParam *)param;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;data)</span><br><span class="line">        OPENSSL_free(p-&gt;data);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ctx)</span><br><span class="line">        EVP_MD_CTX_destroy(p-&gt;ctx);</span><br><span class="line">    OPENSSL_free(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sign_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span> </span>&#123;</span><br><span class="line">    SignParam *p;</span><br><span class="line">    EVP_PKEY *pkey;</span><br><span class="line">    p = OPENSSL_malloc(<span class="keyword">sizeof</span>(SignParam));</span><br><span class="line">    fail_if(!p, <span class="string">&quot;OPENSSL_malloc() fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(SignParam));</span><br><span class="line"></span><br><span class="line">    p-&gt;in = BIO_new_file(opt-&gt;key, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fail_clean_if(!p-&gt;in, sign_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;BIO_new_file(%s) fail\n&quot;</span>, opt-&gt;key);</span><br><span class="line">    pkey = PEM_read_bio_PrivateKey(p-&gt;in, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    fail_clean_if(!pkey, sign_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;PEM_read_bio_PrivateKey() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;ctx = EVP_PKEY_CTX_new(pkey, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;ctx) &#123;</span><br><span class="line">        EVP_PKEY_free(pkey);</span><br><span class="line">        fail_clean_if(<span class="number">1</span>, sign_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;EVP_PKEY_CTX_new() fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_sign_init(p-&gt;ctx), sign_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_sign_init() fail\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fail_clean_if(RAND_bytes(p-&gt;data, <span class="keyword">sizeof</span>(p-&gt;data)) &lt;= <span class="number">0</span>, sign_clean, (<span class="keyword">void</span> *)p,</span><br><span class="line">                  <span class="string">&quot;RAND_bytes() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;data_len = <span class="keyword">sizeof</span>(p-&gt;data);</span><br><span class="line">    p-&gt;sig_len = <span class="keyword">sizeof</span>(p-&gt;sig);</span><br><span class="line"></span><br><span class="line">    p-&gt;index = proc_index;</span><br><span class="line">    *param = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sign_work</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    SignParam *p = (SignParam *)param;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_sign(p-&gt;ctx, p-&gt;sig, &amp;p-&gt;sig_len, p-&gt;data, </span><br><span class="line">                                 p-&gt;data_len), sign_clean, param,</span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_sign() fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sign_clean</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    SignParam *p = (SignParam *)param;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ctx)</span><br><span class="line">        EVP_PKEY_CTX_free(p-&gt;ctx);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;in)</span><br><span class="line">        BIO_free(p-&gt;in);</span><br><span class="line">    OPENSSL_free(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span> </span>&#123;</span><br><span class="line">    VerifyParam *p;</span><br><span class="line">    EVP_PKEY *pkey;</span><br><span class="line">    X509 *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">size_t</span> data_len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sig[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">size_t</span> sig_len;</span><br><span class="line">    <span class="comment">/* 先签名一次，获取数据 */</span></span><br><span class="line">    SignParam *sp;</span><br><span class="line">    sign_init(opt, (<span class="keyword">void</span> **)&amp;sp, (<span class="keyword">long</span>)<span class="number">0</span>);</span><br><span class="line">    sign_work(sp);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, sp-&gt;data, sp-&gt;data_len);</span><br><span class="line">    data_len = sp-&gt;data_len;</span><br><span class="line">    <span class="built_in">memcpy</span>(sig, sp-&gt;sig, sp-&gt;sig_len);</span><br><span class="line">    sig_len = sp-&gt;sig_len;</span><br><span class="line">    sign_clean(sp);</span><br><span class="line"></span><br><span class="line">    p = OPENSSL_malloc(<span class="keyword">sizeof</span>(VerifyParam));</span><br><span class="line">    fail_if(!p, <span class="string">&quot;OPENSSL_malloc() fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(VerifyParam));</span><br><span class="line">    </span><br><span class="line">    p-&gt;in = BIO_new_file(opt-&gt;cert, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fail_clean_if(!p-&gt;in, verify_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;BIO_new_file(%s) fail\n&quot;</span>, opt-&gt;cert);</span><br><span class="line">    x = PEM_read_bio_X509(p-&gt;in, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    fail_clean_if(!x, verify_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;PEM_read_bio_X509() fail\n&quot;</span>);</span><br><span class="line">    pkey = X509_get_pubkey(x);</span><br><span class="line">    X509_free(x);</span><br><span class="line">    fail_clean_if(!pkey, verify_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;X509_get_pubkey() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;ctx = EVP_PKEY_CTX_new(pkey, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;ctx) &#123;</span><br><span class="line">        EVP_PKEY_free(pkey);</span><br><span class="line">        fail_clean_if(<span class="number">1</span>, verify_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;EVP_PKEY_CTX_new() fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_verify_init(p-&gt;ctx), verify_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_verify_init() fail\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(p-&gt;data, data, data_len);</span><br><span class="line">    p-&gt;data_len = data_len;</span><br><span class="line">    <span class="built_in">memcpy</span>(p-&gt;sig, sig, sig_len);</span><br><span class="line">    p-&gt;sig_len = sig_len;</span><br><span class="line"></span><br><span class="line">    p-&gt;index = proc_index;</span><br><span class="line">    *param = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify_work</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    VerifyParam *p = (VerifyParam *)param;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_verify(p-&gt;ctx, p-&gt;sig, p-&gt;sig_len, p-&gt;data, </span><br><span class="line">                                 p-&gt;data_len), verify_clean, param,</span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_verify() fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify_clean</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    VerifyParam *p = (VerifyParam *)param;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ctx)</span><br><span class="line">        EVP_PKEY_CTX_free(p-&gt;ctx);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;in)</span><br><span class="line">        BIO_free(p-&gt;in);</span><br><span class="line">    OPENSSL_free(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encrypt_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span> </span>&#123;</span><br><span class="line">    EncParam *p;</span><br><span class="line">    EVP_PKEY *pkey;</span><br><span class="line">    X509 *x;</span><br><span class="line">    p = OPENSSL_malloc(<span class="keyword">sizeof</span>(EncParam));</span><br><span class="line">    fail_if(!p, <span class="string">&quot;OPENSSL_malloc() fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(EncParam));</span><br><span class="line"></span><br><span class="line">    p-&gt;in = BIO_new_file(opt-&gt;cert, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fail_clean_if(!p-&gt;in, encrypt_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;BIO_new_file(%s) fail\n&quot;</span>, opt-&gt;cert);</span><br><span class="line">    x = PEM_read_bio_X509(p-&gt;in, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    fail_clean_if(!x, encrypt_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;PEM_read_bio_X509() fail\n&quot;</span>);</span><br><span class="line">    pkey = X509_get_pubkey(x);</span><br><span class="line">    X509_free(x);</span><br><span class="line">    fail_clean_if(!pkey, encrypt_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;X509_get_pubkey() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;ctx = EVP_PKEY_CTX_new(pkey, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;ctx) &#123;</span><br><span class="line">        EVP_PKEY_free(pkey);</span><br><span class="line">        fail_clean_if(<span class="number">1</span>, encrypt_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;EVP_PKEY_CTX_new() fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_encrypt_init(p-&gt;ctx), encrypt_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_encrypt_init() fail\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fail_clean_if(RAND_bytes(p-&gt;data, <span class="keyword">sizeof</span>(p-&gt;data)) &lt;= <span class="number">0</span>, encrypt_clean, (<span class="keyword">void</span> *)p,</span><br><span class="line">                  <span class="string">&quot;RAND_bytes() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;data_len = <span class="keyword">sizeof</span>(p-&gt;data);</span><br><span class="line">    p-&gt;enc_len = <span class="keyword">sizeof</span>(p-&gt;enc);</span><br><span class="line"></span><br><span class="line">    p-&gt;index = proc_index;</span><br><span class="line">    *param = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encrypt_work</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    EncParam *p = (EncParam *)param;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_encrypt(p-&gt;ctx, p-&gt;enc, &amp;p-&gt;enc_len, p-&gt;data, </span><br><span class="line">                                 p-&gt;data_len), encrypt_clean, param,</span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_encrypt() fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encrypt_clean</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    EncParam *p = (EncParam *)param;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ctx)</span><br><span class="line">        EVP_PKEY_CTX_free(p-&gt;ctx);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;in)</span><br><span class="line">        BIO_free(p-&gt;in);</span><br><span class="line">    OPENSSL_free(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrypt_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span> </span>&#123;</span><br><span class="line">    DecParam *p;</span><br><span class="line">    EVP_PKEY *pkey;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">size_t</span> data_len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> enc[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">size_t</span> enc_len;</span><br><span class="line">    <span class="comment">/* 先加密一次，获取数据 */</span></span><br><span class="line">    EncParam *ep;</span><br><span class="line">    encrypt_init(opt, (<span class="keyword">void</span> **)&amp;ep, (<span class="keyword">long</span>)<span class="number">0</span>);</span><br><span class="line">    encrypt_work(ep);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, ep-&gt;data, ep-&gt;data_len);</span><br><span class="line">    data_len = ep-&gt;data_len;</span><br><span class="line">    <span class="built_in">memcpy</span>(enc, ep-&gt;enc, ep-&gt;enc_len);</span><br><span class="line">    enc_len = ep-&gt;enc_len;</span><br><span class="line">    encrypt_clean(ep);</span><br><span class="line"></span><br><span class="line">    p = OPENSSL_malloc(<span class="keyword">sizeof</span>(DecParam));</span><br><span class="line">    fail_if(!p, <span class="string">&quot;OPENSSL_malloc() fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(DecParam));</span><br><span class="line">    </span><br><span class="line">    p-&gt;in = BIO_new_file(opt-&gt;key, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fail_clean_if(!p-&gt;in, decrypt_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;BIO_new_file(%s) fail\n&quot;</span>, opt-&gt;key);</span><br><span class="line">    pkey = PEM_read_bio_PrivateKey(p-&gt;in, <span class="literal">NULL</span>, <span class="literal">NULL</span>, PEM_AUTO_KEYPASS);</span><br><span class="line">    fail_clean_if(!pkey, decrypt_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;PEM_read_bio_PrivateKey() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;ctx = EVP_PKEY_CTX_new(pkey, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;ctx) &#123;</span><br><span class="line">        EVP_PKEY_free(pkey);</span><br><span class="line">        fail_clean_if(<span class="number">1</span>, decrypt_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;EVP_PKEY_CTX_new() fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_decrypt_init(p-&gt;ctx), decrypt_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_decrypt_init() fail\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(p-&gt;data, data, data_len);</span><br><span class="line">    p-&gt;data_len = data_len;</span><br><span class="line">    <span class="built_in">memcpy</span>(p-&gt;enc, enc, enc_len);</span><br><span class="line">    p-&gt;enc_len = enc_len;</span><br><span class="line"></span><br><span class="line">    p-&gt;index = proc_index;</span><br><span class="line">    *param = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrypt_work</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    DecParam *p = (DecParam *)param;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_decrypt(p-&gt;ctx, p-&gt;data, &amp;p-&gt;data_len, p-&gt;enc, </span><br><span class="line">                                 p-&gt;enc_len), decrypt_clean, param,</span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_decrypt() fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrypt_clean</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    DecParam *p = (DecParam *)param;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ctx)</span><br><span class="line">        EVP_PKEY_CTX_free(p-&gt;ctx);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;in)</span><br><span class="line">        BIO_free(p-&gt;in);</span><br><span class="line">    OPENSSL_free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><code>multi-process.c</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span>   <span class="comment">// wait</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>  <span class="comment">// getpid, wait</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span>    <span class="comment">// shmget, shmat, shmctl, shmdt</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span>    <span class="comment">// shmget, shmat, shmctl, shmdt</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span>     <span class="comment">// sigaction, SIGLARM</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>     <span class="comment">// LONG_MIN, LONG_MAX, ULLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span>      <span class="comment">// errno</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>     <span class="comment">// getpid</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>     <span class="comment">// memset</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;work.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> isStop = <span class="number">0</span>;             <span class="comment">// 用于标记测试终止</span></span><br><span class="line">Options opt;                <span class="comment">// 命令行选项</span></span><br><span class="line"><span class="keyword">int</span> shmid;                  <span class="comment">// 共享内存id</span></span><br><span class="line">Result *shm = <span class="literal">NULL</span>;         <span class="comment">// 共享内存地址，用于存放测试结果</span></span><br><span class="line">Result res_total;</span><br><span class="line">Result res_last;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal_child</span><span class="params">(<span class="keyword">int</span> sigNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigNum == SIGALRM) &#123;</span><br><span class="line">        isStop = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal_parent</span><span class="params">(<span class="keyword">int</span> sigNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigNum == SIGALRM) &#123;</span><br><span class="line">        <span class="comment">/* DO REAL-TIME STATISTICS */</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;res_total, <span class="number">0</span>, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; opt.procs; ++i) &#123;</span><br><span class="line">            res_total.count += shm[i].count;</span><br><span class="line">        &#125;</span><br><span class="line">        mylog(<span class="string">&quot;total count %12llu,  average %12.0lf/s\n&quot;</span>,</span><br><span class="line">                res_total.count, (res_total.count - res_last.count)</span><br><span class="line">                / (<span class="keyword">double</span>)opt.interval);</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;res_last, &amp;res_total, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        <span class="comment">/* DO REAL-TIME STATISTICS */</span></span><br><span class="line">        alarm(opt.interval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行测试主循环函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTest</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    HashParam *pa = (HashParam *)param;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; ULLONG_MAX &amp;&amp; !isStop; ++i) &#123;</span><br><span class="line">        <span class="comment">/* DO YOUR WORK */</span></span><br><span class="line">        test_work(param);</span><br><span class="line">        ++shm[pa-&gt;index].count;</span><br><span class="line">        <span class="comment">/* DO YOUR WORK */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> proc_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> isParent = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> wstatus = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act_child</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act_parent</span>;</span></span><br><span class="line"></span><br><span class="line">    rv = process_options(argc, argv, &amp;opt);</span><br><span class="line">    <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mylog(<span class="string">&quot;\n-----------------------------Start Testing-----------------------&quot;</span></span><br><span class="line">          <span class="string">&quot;-------\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* COMMON INIT */</span></span><br><span class="line">    shmid = shmget(IPC_PRIVATE, <span class="keyword">sizeof</span>(<span class="keyword">sizeof</span>(Result) * opt.procs), <span class="number">0666</span>);</span><br><span class="line">    fail_if(<span class="number">-1</span> == shmid, <span class="string">&quot;shmget() failed\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;shmid = %d\n&quot;</span>, shmid);</span><br><span class="line">    shm = (Result*)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    fail_if((<span class="keyword">void</span> *) <span class="number">-1</span> == shm, <span class="string">&quot;shmat() failed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里直接进行IPC_RMID操作，进程退出之后会自动detach了, 从而释放共享内存 */</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(shm, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">sizeof</span>(Result) * opt.procs));</span><br><span class="line"></span><br><span class="line">    global_init(&amp;opt);</span><br><span class="line">    <span class="comment">/* COMMON INIT */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(isParent &amp;&amp; i &lt; opt.procs) &#123;</span><br><span class="line">        pid =  fork();</span><br><span class="line">        fail_if(<span class="number">-1</span> == pid, <span class="string">&quot;fork failed %d\n&quot;</span>, pid);    <span class="comment">/* error */</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;                                  <span class="comment">/* child */</span></span><br><span class="line">            isParent = <span class="number">0</span>;</span><br><span class="line">            proc_index = i;                             <span class="comment">// 记录进程索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;                                          <span class="comment">/* parent */</span></span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isParent) &#123;</span><br><span class="line">        <span class="comment">/* PARENT INIT */</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;act_parent, <span class="number">0</span>, <span class="keyword">sizeof</span>(act_parent));</span><br><span class="line">        act_parent.sa_handler = handle_signal_parent;</span><br><span class="line">        <span class="comment">/* 使wait被中断时可以自动恢复 */</span></span><br><span class="line">        act_parent.sa_flags = SA_RESTART;</span><br><span class="line">        rv = sigaction(SIGALRM, &amp;act_parent, <span class="literal">NULL</span>);     <span class="comment">// 用于定时统计结果</span></span><br><span class="line">        fail_if(rv, <span class="string">&quot;sigaction() failed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;res_last, <span class="number">0</span>, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        alarm(opt.interval);</span><br><span class="line">        <span class="comment">/* PARENT INIT */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* DO FINAL STATISTICS */</span></span><br><span class="line">        Result <span class="keyword">final</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;<span class="keyword">final</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        <span class="keyword">for</span>(i =<span class="number">0</span> ; i &lt; opt.procs; ++i) &#123;</span><br><span class="line">            pid = wait(&amp;wstatus);                       <span class="comment">// 等待子进程结束</span></span><br><span class="line">            alarm(<span class="number">0</span>);                                   <span class="comment">// 终止定时器</span></span><br><span class="line">            fail_if(<span class="number">-1</span> == pid, <span class="string">&quot;wait() failed, errno=%d\n&quot;</span>, errno);</span><br><span class="line">            mylog(<span class="string">&quot;process [pid = %6d] exit\n&quot;</span>, pid);</span><br><span class="line">            mylog(<span class="string">&quot;process [pid = %6u] count %12llu in %lus,&quot;</span></span><br><span class="line">                  <span class="string">&quot;  average %12.0lf/s\n&quot;</span>, pid, shm[i].count, opt.duration, </span><br><span class="line">                  shm[i].count / (<span class="keyword">double</span>)opt.duration);</span><br><span class="line">            <span class="keyword">final</span>.count += shm[i].count;</span><br><span class="line">        &#125;</span><br><span class="line">        mylog(<span class="string">&quot;total count %12llu in %lus,  average %12.0lf/s\n&quot;</span>, </span><br><span class="line">               <span class="keyword">final</span>.count, opt.duration, <span class="keyword">final</span>.count / (<span class="keyword">double</span>)opt.duration);</span><br><span class="line">        <span class="comment">/* DO FINAL STATISTICS */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* PARENT CLEANUP */</span></span><br><span class="line">        global_clean();</span><br><span class="line">        <span class="comment">/* PARENT CLEANUP */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* CHILD INIT */</span></span><br><span class="line">        <span class="keyword">void</span> *param;</span><br><span class="line">        test_init(&amp;opt, &amp;param, proc_index);</span><br><span class="line">        <span class="comment">/* CHILD INIT */</span></span><br><span class="line"></span><br><span class="line">        act_child.sa_handler = handle_signal_child;</span><br><span class="line">        sigemptyset(&amp;act_child.sa_mask);</span><br><span class="line">        act_child.sa_flags = SA_RESETHAND;</span><br><span class="line">        <span class="comment">/* 用于测试时间到时，通知子进程结束测试 */</span></span><br><span class="line">        rv = sigaction(SIGALRM, &amp;act_child, <span class="literal">NULL</span>);</span><br><span class="line">        fail_if(rv, <span class="string">&quot;sigaction() failed\n&quot;</span>);</span><br><span class="line">        alarm(opt.duration);                            <span class="comment">// 设置测试时长</span></span><br><span class="line">        doTest(param);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CHILD CLEANUP */</span></span><br><span class="line">        test_clean(param);</span><br><span class="line">        global_clean();</span><br><span class="line">        <span class="comment">/* CHILD CLEANUP */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">/* child finished work */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></div>




<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，一个多进程的测试程序就算完成了。读者可以根据自身测试需要，按如下步骤修改以进行自定义的测试。</p>
<ol>
<li>在<code>opt.c</code>和<code>opt.h</code>中，添加需要的命令行选项</li>
<li>在<code>work.c</code>和<code>work.h</code>中，<code>global_init()</code>和<code>global_clean()</code>内进行全局的初始化及全局的清理工作</li>
<li>在<code>work.c</code>和<code>work.h</code>中，添加自定义的测试函数，以及相应的测试参数和测试结果</li>
<li>主控<code>multi-process.c</code>通过<code>test_init()</code>、<code>test_work()</code>、<code>test_clean()</code>调用测试相关的初始化、执行及清理工作</li>
<li>主控<code>multi-process.c</code>中，修改测试结果的更新与统计操作。</li>
</ol>
<p>主控<code>multi-process.c</code>中：</p>
<ul>
<li><code>COMMON INIT</code>、<code>PARENT INIT</code>和<code>CHILD INIT</code>代码块处分别进行公共的初始化工作和父子进程特定的初始化工作。</li>
<li><code>PARENT CLEANUP</code>和<code>CHILD CLEANUP</code>代码块处则分别进行对应的清理工作。</li>
<li><code>DO YOUR WORK</code>处执行具体的测试，<code>DO REAL-TIME STATISTICS</code>和<code>DO FINAL STATISTICS</code>处进行测试结果的统计。</li>
</ul>
<p>当然本文还有一些不足之处，比如当前是用的OpenSSL1.0.2接口，没有兼容不同版本的OpenSSL。还有代码风格的问题，在函数命名和注释方式上不统一。但是考虑到这个是测试程序，就不计较这么多了（^。^）</p>
]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>多进程</tag>
        <tag>信号</tag>
        <tag>共享内存</tag>
      </tags>
  </entry>
</search>

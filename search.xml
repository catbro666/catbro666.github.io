<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>UNIX环境高级编程APUE练习3.2-不用fcntl实现dup2的功能</title>
    <url>/posts/2485f370/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>编写与<code>dup2</code>功能相同的函数，要求不调用<code>fcntl</code>函数，并且要有正确的出错处理。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>不能用<code>fcntl</code>，能够返回一个文件描述符的只有<code>open</code>和<code>dup</code>。而<code>open</code>会创建一个新的文件表项，返回的fd指向新的文件表项，与<code>dup2</code>的表现不符。<code>dup</code>基本能满足要求，但是返回的是最小的可用fd，需要进一步操作满足要求。另外需要自己添加错误处理，以及处理oldfd与newfd相等的情况等。具体地，</p>
<span id="more"></span>

<ol>
<li>当dup返回出错时，直接返回出错</li>
<li>当dup返回值等于newfd时，直接返回</li>
<li>当dup返回值小于newfd时，记录返回值，循环调用dup直到返回值等于newfd。关闭前面记录的所有fd，返回newfd</li>
<li>当dup返回值大于newfd时，关闭返回值的fd。如果oldfd等于newfd，直接返回newfd;如果不相等，关掉newfd，然后再dup（因为不是原子的，返回值需要再判断）</li>
</ol>
<h2 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h2><ol>
<li>oldfd的出错处理可以直接交给dup</li>
<li>newfd的出错处理，需要判断是否超出文件描述符范围(<code>RLIMIT_NOFILE</code> in getrlimit)</li>
<li>对于dup返回EMFILE的情况，newfd如果没超过进程可打开的最大文件数，则不影响</li>
<li>另外还有一个判断顺序问题，是先判断参数是否合法还是oldfd==newfd, 这个可以根据dup2函数实测来确定</li>
</ol>
<h2 id="4-测试用例"><a href="#4-测试用例" class="headerlink" title="4 测试用例"></a>4 测试用例</h2><h3 id="进程打开的文件数没满的情况下"><a href="#进程打开的文件数没满的情况下" class="headerlink" title="进程打开的文件数没满的情况下"></a>进程打开的文件数没满的情况下</h3><ol>
<li>都超出范围，相同（MAX+1，MAX+1）</li>
<li>未打开描述符，相同 (100, 100)</li>
<li>newfd超出范围 (1, MAX+1)</li>
<li>newfd正好没超出 (1, MAX)</li>
<li>oldfd和newfd相同 (2, 2)</li>
</ol>
<h3 id="进程打开的文件数满的情况下"><a href="#进程打开的文件数满的情况下" class="headerlink" title="进程打开的文件数满的情况下"></a>进程打开的文件数满的情况下</h3><ol>
<li>newfd正好超出范围 (1, MAX+1)</li>
<li>newfd正好没超出 (1, MAX)</li>
<li>oldfd和newfd相同 (2, 2)</li>
</ol>
<h2 id="5-开始撸码实测"><a href="#5-开始撸码实测" class="headerlink" title="5 开始撸码实测"></a>5 开始撸码实测</h2><h3 id="5-1-先验证dup2的判断顺序问题"><a href="#5-1-先验证dup2的判断顺序问题" class="headerlink" title="5.1 先验证dup2的判断顺序问题"></a>5.1 先验证dup2的判断顺序问题</h3><ul>
<li>测试源码</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">old_rlim</span>=</span>&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    getrlimit(RLIMIT_NOFILE, &amp;old_rlim);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NOFILE limits: soft=%lld; hard=%lld\n&quot;</span>,</span><br><span class="line">                   (<span class="keyword">long</span> <span class="keyword">long</span>) old_rlim.rlim_cur, (<span class="keyword">long</span> <span class="keyword">long</span>) old_rlim.rlim_max);</span><br><span class="line"></span><br><span class="line">    r = dup2(<span class="number">10000</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2(10000, 10000) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2(10000, 10000) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2(100, 100) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2(100, 100) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2(1, 10000) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2(1, 10000) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2(1, 100) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2(1, 100) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>MAC OSX下运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ./a.out</span><br><span class="line">NOFILE limits: soft=7168; hard=9223372036854775807</span><br><span class="line">dup2(10000, 10000) fail: : Bad file descriptor</span><br><span class="line">dup2(100, 100) fail: : Bad file descriptor</span><br><span class="line">dup2(1, 10000) fail: : Bad file descriptor</span><br><span class="line">dup2(1, 100) success return 100</span><br></pre></td></tr></table></figure>

<p>可见是参数出错判断是先于oldfd == newfd判断的</p>
<h3 id="5-2-测试进程打开的最大文件数到上限时，dup2是否能成功"><a href="#5-2-测试进程打开的最大文件数到上限时，dup2是否能成功" class="headerlink" title="5.2 测试进程打开的最大文件数到上限时，dup2是否能成功"></a>5.2 测试进程打开的最大文件数到上限时，dup2是否能成功</h3><ul>
<li>测试源码</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> max_fd = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">old_rlim</span>=</span>&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    getrlimit(RLIMIT_NOFILE, &amp;old_rlim);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NOFILE limits: soft=%lld; hard=%lld\n&quot;</span>,</span><br><span class="line">                   (<span class="keyword">long</span> <span class="keyword">long</span>) old_rlim.rlim_cur, (<span class="keyword">long</span> <span class="keyword">long</span>) old_rlim.rlim_max);</span><br><span class="line">    <span class="keyword">while</span>((r = dup(<span class="number">0</span>))!= <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        max_fd = r;</span><br><span class="line">    &#125;</span><br><span class="line">    perror(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max fd is %d\n&quot;</span>, max_fd);</span><br><span class="line"></span><br><span class="line">    r = dup2(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2(1, 10000) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2(1, 10000) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2(1, 100) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2(1, 100) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>MAC OSX下运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ./a.out</span><br><span class="line">NOFILE limits: soft=7168; hard=9223372036854775807</span><br><span class="line">Too many open files</span><br><span class="line">max fd is 7167</span><br><span class="line">dup2(1, 7168) fail: : Bad file descriptor</span><br><span class="line">dup2(1, 7167) success return 7167</span><br></pre></td></tr></table></figure>

<p>可见在进程打开文件数达到上限时，dup2替换已经打开的文件是可以的</p>
<h3 id="5-3-实现dup2的功能"><a href="#5-3-实现dup2的功能" class="headerlink" title="5.3 实现dup2的功能"></a>5.3 实现dup2的功能</h3><ul>
<li>源码</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*dup实现dup2的功能*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2_</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">7168</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">old_rlim</span>=</span>&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    getrlimit(RLIMIT_NOFILE, &amp;old_rlim);</span><br><span class="line">    <span class="keyword">if</span> (newfd &lt; <span class="number">0</span> || newfd &gt; old_rlim.rlim_cur - <span class="number">1</span>) &#123;</span><br><span class="line">        errno = EBADF;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        ret = dup(oldfd);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno != EMFILE) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno == EMFILE) &#123;</span><br><span class="line">            <span class="keyword">if</span>(oldfd == newfd) &#123;</span><br><span class="line">                <span class="keyword">return</span> newfd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;close(newfd)\n&quot;</span>);</span><br><span class="line">            close(newfd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(oldfd == newfd) &#123;</span><br><span class="line">                close(ret);</span><br><span class="line">                <span class="keyword">return</span> newfd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ret == newfd) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ret &lt; newfd) &#123;</span><br><span class="line">                <span class="built_in">stack</span>[count++] = ret;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                close(ret);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;close(newfd)\n&quot;</span>);</span><br><span class="line">                close(newfd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(count) &#123;</span><br><span class="line">        close(<span class="built_in">stack</span>[--count]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r, max_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">old_rlim</span>=</span>&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    getrlimit(RLIMIT_NOFILE, &amp;old_rlim);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NOFILE limits: soft=%lld; hard=%lld\n&quot;</span>,</span><br><span class="line">                   (<span class="keyword">long</span> <span class="keyword">long</span>) old_rlim.rlim_cur, (<span class="keyword">long</span> <span class="keyword">long</span>) old_rlim.rlim_max);</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">7168</span>, <span class="number">7168</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(7168, 7168) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(7168, 7168) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(100, 100) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(100, 100) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">1</span>, <span class="number">7168</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(1, 7168) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(1, 7168) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">1</span>, <span class="number">7167</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(1, 7167) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(1, 7167) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(2, 2) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(2, 2) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((r = dup(<span class="number">0</span>))!= <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        max_fd = r;</span><br><span class="line">    &#125;</span><br><span class="line">    perror(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max fd is %d\n&quot;</span>, max_fd);</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">1</span>, <span class="number">7168</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(1, 7168) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(1, 7168) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">1</span>, <span class="number">7167</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(1, 7167) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(1, 7167) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = dup2_(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2_(2, 2) fail: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2_(2, 2) success return %d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>MAC OSX下的运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NOFILE limits: soft=7168; hard=9223372036854775807</span><br><span class="line">dup2_(7168, 7168) fail: : Bad file descriptor</span><br><span class="line">dup2_(100, 100) fail: : Bad file descriptor</span><br><span class="line">dup2_(1, 7168) fail: : Bad file descriptor</span><br><span class="line">dup2_(1, 7167) success return 7167</span><br><span class="line">dup2_(2, 2) success return 2</span><br><span class="line">Too many open files</span><br><span class="line">max fd is 7167</span><br><span class="line">dup2_(1, 7168) fail: : Bad file descriptor</span><br><span class="line">close(newfd)</span><br><span class="line">dup2_(1, 7167) success return 7167</span><br><span class="line">close(newfd)</span><br><span class="line">dup2_(1, 100) success return 100</span><br><span class="line">dup2_(2, 2) success return 2</span><br></pre></td></tr></table></figure>

<p>结果都符合预期</p>
]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>UNIX</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT Tag 插件的使用</title>
    <url>/posts/29bfe8c9/</url>
    <content><![CDATA[<p><code>Tag Plugin</code> 是一种使 Hexo 支持特殊样式内容的方法。例如，我们无法在标准 Markdown 中显示具有自定义尺寸的图像。然后我们可以使用标签插件来解决它。 Hexo 有很多可以帮助用户的标签。 Hexo 还具有主题接口，使主题能够创建自己的标签。</p>
<span id="more"></span>

<h2 id="文本居中引用-Centered-Quote"><a href="#文本居中引用-Centered-Quote" class="headerlink" title="文本居中引用 - Centered Quote"></a>文本居中引用 - Centered Quote</h2><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% cq %&#125;因为我渺小的心灵里，容不下一个谜，一点悬而未决的东西&#123;% endcq %&#125;</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>因为我渺小的心灵里，容不下一个谜，一点悬而未决的东西</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>



<h2 id="提示块-Note"><a href="#提示块-Note" class="headerlink" title="提示块 - Note"></a>提示块 - Note</h2><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<div class="note default">
            <p>default 提示块标签</p>
          </div>

<div class="note primary">
            <p>primary 提示块标签</p>
          </div>

<div class="note success">
            <p>success 提示块标签</p>
          </div>

<div class="note info">
            <p>info 提示块标签</p>
          </div>

<div class="note warning">
            <p>warning 提示块标签</p>
          </div>

<div class="note danger">
            <p>danger 提示块标签</p>
          </div>



<p>可在主题配置文件中修改风格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Note tag (bs-callout)</span><br><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: flat</span><br><span class="line">  icons: true</span><br><span class="line">  # 圆角</span><br><span class="line">  border_radius: 3</span><br><span class="line">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span><br><span class="line">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span><br><span class="line">  light_bg_offset: 0</span><br></pre></td></tr></table></figure>



<h2 id="标签-Label"><a href="#标签-Label" class="headerlink" title="标签 - Label"></a>标签 - Label</h2><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% label default@默认 %&#125; &#123;% label primary@主要 %&#125; &#123;% label info@信息 %&#125; &#123;% label warning@警告 %&#125; &#123;% label danger@危险 %&#125; </span><br><span class="line">&#123;% label success@成功%&#125;</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<span class="label default">默认</span> <span class="label primary">主要</span> <span class="label info">信息</span> <span class="label warning">警告</span> <span class="label danger">危险</span> 
<span class="label success">成功</span>

<h2 id="选项卡-Tabs"><a href="#选项卡-Tabs" class="headerlink" title="选项卡 - Tabs"></a>选项卡 - Tabs</h2><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% tabs tab, 2 %&#125; 名字为tab，默认显示第1个选项卡，如果是-1则隐藏</span><br><span class="line">&lt;!-- tab 魏国--&gt;</span><br><span class="line">**曹操**</span><br><span class="line"></span><br><span class="line">司马懿 郭嘉 荀彧 荀攸 程昱 杨修 </span><br><span class="line"></span><br><span class="line">典韦 许褚 夏侯渊 夏侯惇 曹仁 于禁 张辽 徐晃</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab 蜀国--&gt;</span><br><span class="line">**刘备**</span><br><span class="line"></span><br><span class="line">诸葛亮 庞统 徐庶 姜维 法正 马良</span><br><span class="line"></span><br><span class="line">关羽 张飞 赵云 马超 黄忠 魏延 关兴 张苞</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab 吴国 --&gt;</span><br><span class="line">**孙权**</span><br><span class="line"></span><br><span class="line">周瑜 张昭 鲁肃 诸葛瑾 陆逊</span><br><span class="line"></span><br><span class="line">甘宁 太史慈 吕蒙 韩当 黄盖 程普  </span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab"><a href="#tab-1">魏国</a></li><li class="tab active"><a href="#tab-2">蜀国</a></li><li class="tab"><a href="#tab-3">吴国</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-1"><p><strong>曹操</strong></p>
<p>司马懿 郭嘉 荀彧 荀攸 程昱 杨修 </p>
<p>典韦 许褚 夏侯渊 夏侯惇 曹仁 于禁 张辽 徐晃</p></div><div class="tab-pane active" id="tab-2"><p><strong>刘备</strong></p>
<p>诸葛亮 庞统 徐庶 姜维 法正 马良</p>
<p>关羽 张飞 赵云 马超 黄忠 魏延 关兴 张苞</p></div><div class="tab-pane" id="tab-3"><p><strong>孙权</strong></p>
<p>周瑜 张昭 鲁肃 诸葛瑾 陆逊</p>
<p>甘宁 太史慈 吕蒙 韩当 黄盖 程普  </p></div></div></div>



<p>可在主题配置文件中修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Tabs tag</span><br><span class="line">tabs:</span><br><span class="line">  transition:</span><br><span class="line">    tabs: true</span><br><span class="line">    labels: true</span><br><span class="line">  border_radius: 3</span><br></pre></td></tr></table></figure>

<h2 id="按钮-Button"><a href="#按钮-Button" class="headerlink" title="按钮 - Button"></a>按钮 - Button</h2><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% button url, text, icon [class], [title] %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>url</code>: 本地或外部url</li>
<li><code>text</code>: 显示的文本，文本和图标至少指定一个</li>
<li><code>icon</code>: 显示的图标， FontAwesome 图标名称（开头没有’fa-‘）</li>
<li><code>[class]</code>: FontAwesome 类，可以取如下值<code>fa-fw | fa-lg | fa-2x | fa-3x | fa-4x | fa-5X</code></li>
<li><code>title</code>: 鼠标悬停时的提示信息</li>
</ul>
<p>注意：最好添加 <code>&lt;div&gt;</code> 标签，测试时没加 div，下面显示不完全，加上非常美观。</p>
<p>一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&#123;% button https://catbro666.github.io/ ,首页,home fa-fw,这是我的博客首页%&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<div><a class="btn" href="https://catbro666.github.io/ " title="这是我的博客首页">
            <i class="fa fa-home fa-fw"></i>首页
          </a></div>

<p>多个按钮的时候可以套两层div。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;text-center&quot;&gt;&lt;div&gt;&#123;% button https://catbro666.github.io/ ,首页,home fa-fw,这是我的博客首页%&#125;&#123;% button https://catbro666.github.io/archives ,归档, archive fa-lg&#125;&lt;/div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<div class="text-center"><div><a class="btn" href="https://catbro666.github.io/ " title="这是我的博客首页">
            <i class="fa fa-home fa-fw"></i>首页
          </a><a class="btn" href="https://catbro666.github.io/archives ">
            <i class="fa fa-archive fa-lg}</div></div>"></i>归档
          </a>]]></content>
      <categories>
        <category>工具向</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>test-post</title>
    <url>/posts/dce1f5ed/</url>
    <content><![CDATA[<div class="note primary">
            <p>文章摘要</p>
          </div>


<p><img src="https://cdn.jsdelivr.net/gh/catbro666/catbro666.github.io/posts/dce1f5ed/sea.jpg" alt="sea" loading="lazy"></p>
<span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>UNIX环境高级编程APUE练习4.6-实现类似cp(1)的程序，保留文件中的空洞</title>
    <url>/posts/aa99fc97/</url>
    <content><![CDATA[<h2 id="1-题面"><a href="#1-题面" class="headerlink" title="1 题面"></a>1 题面</h2><p>编写类似<code>cp(1)</code>的程序，它复制包含空洞的文件，但是不将字节0写到输出文件中去。</p>
<h2 id="2-基本思路"><a href="#2-基本思路" class="headerlink" title="2 基本思路"></a>2 基本思路</h2><ul>
<li>首先要搞清楚空洞的性质以判断一个文件是否有空洞，以及空洞的位置</li>
<li>知道了空洞的位置之后，读到源文件中的空洞部分时，在目标文件中<code>lseek</code>相应的长度</li>
</ul>
<span id="more"></span>

<h2 id="3-创建空洞文件，同时探索空洞性质"><a href="#3-创建空洞文件，同时探索空洞性质" class="headerlink" title="3 创建空洞文件，同时探索空洞性质"></a>3 创建空洞文件，同时探索空洞性质</h2><p>交替<code>lseek</code>和<code>write</code>，逐渐增大间隔长度。比较文件的大小和实际占用的block数目</p>
<ul>
<li>测试源码</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> holesize[]=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>, <span class="number">4096</span>, <span class="number">8192</span>, <span class="number">16384</span>, <span class="number">32</span>*<span class="number">1024</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> filesize = <span class="number">64</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, fd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">32</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">32</span>*<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">1</span>, <span class="number">32</span>*<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">for</span> (; i&lt; <span class="keyword">sizeof</span>(holesize)/ <span class="keyword">sizeof</span>(<span class="keyword">int</span>); ++i) &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(filename, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(filename, <span class="string">&quot;%s%d&quot;</span>, <span class="string">&quot;holesize&quot;</span>, holesize[i]);</span><br><span class="line">        fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;open file fail\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; filesize) &#123;</span><br><span class="line">            ret = lseek(fd, holesize[i], SEEK_CUR);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;lseek fail\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> remain = holesize[i];</span><br><span class="line">            <span class="keyword">while</span>(remain) &#123;</span><br><span class="line">                ret = write(fd, buf, remain);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;write fail\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                remain -= ret;</span><br><span class="line">            &#125;</span><br><span class="line">            count += holesize[i] * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>MAC OSX 10.1.4.6测试结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ll -s</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize1</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize1024</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize128</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize16</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize16384</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize2</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize2048</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize256</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize32</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize32768</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize4</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize4096</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize512</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize64</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize8</span><br><span class="line">128 -rw-r--r--   1 chenzf  staff  65536 12 28 20:08 holesize8192</span><br></pre></td></tr></table></figure>

<p>Mac OSX上创建不了空洞文件，因为默认的文件系统是HFS +，不支持稀疏文件</p>
<ul>
<li>Ubuntu18 4.15.0-60-generic测试结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ll -s</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize1</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize1024</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize128</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize16</span><br><span class="line">32 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize16384</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize2</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize2048</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize256</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize32</span><br><span class="line">32 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize32768</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize4</span><br><span class="line">32 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize4096</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize512</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize64</span><br><span class="line">64 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize8</span><br><span class="line">32 -rw-r--r-- 1 chen chen 65536 12月 25 00:08 holesize8192</span><br></pre></td></tr></table></figure>

<p>4KB以上才实际创建空洞。<br>因为在linux的文件系统中，磁盘分配的最小物理单元为簇。(即使文件大小不足以占用满一簇，该簇空余的磁盘存储仍旧是该文件的)</p>
<p>所以可以根据这个性质，判断文件是否是空洞文件。有空洞的文件，用文件大小计算的block数至少比实际占用的block数大1个簇的block数</p>
<h2 id="如何可移植地获取簇的大小"><a href="#如何可移植地获取簇的大小" class="headerlink" title="如何可移植地获取簇的大小"></a>如何可移植地获取簇的大小</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pagesize = sysconf(_SC_PAGESIZE);</span><br></pre></td></tr></table></figure>

<h2 id="初步实现功能"><a href="#初步实现功能" class="headerlink" title="初步实现功能"></a>初步实现功能</h2><ul>
<li>源码</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_cp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1 = <span class="number">-1</span>, fd2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> rev = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *start_pos = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">long</span> pagesize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> blocks, blksize, size;</span><br><span class="line">    <span class="keyword">int</span> read_num, write_num, remain_num, current_pos = <span class="number">0</span>, last_zero = <span class="number">-1</span>, last_nonzero = <span class="number">-1</span>, have_holes = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    fd1 = open(from, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fd1)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open file1 faild&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fstat(fd1, &amp;st) !=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat: &quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SC_PAGESIZE</span></span><br><span class="line">        pagesize = sysconf(_SC_PAGESIZE);</span><br><span class="line">        <span class="keyword">if</span> (pagesize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EINVAL) &#123;</span><br><span class="line">                    <span class="built_in">fputs</span>(<span class="string">&quot; (not supported)\n&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">                    pagesize = st.st_blksize;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    perror(<span class="string">&quot;sysconf error&quot;</span>);</span><br><span class="line">                    <span class="keyword">goto</span> err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">&quot; (no limit)\n&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">                pagesize = st.st_blksize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pagesize: %ld\n&quot;</span>, pagesize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        pagesize = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        blocks = st.st_blocks;</span><br><span class="line">        blksize = st.st_blksize;</span><br><span class="line">        size = st.st_size;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st.st_blocks: %lld\n&quot;</span>, blocks);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st.st_blksize: %lld\n&quot;</span>, blksize);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st.st_size: %lld\n&quot;</span>, size);</span><br><span class="line">        <span class="comment">/*块大小512，在不同平台上可能不兼容*/</span></span><br><span class="line">        <span class="keyword">if</span>(S_ISREG(st.st_mode) &amp;&amp; (size / pagesize + (size%pagesize?<span class="number">1</span>:<span class="number">0</span>)) * pagesize &gt; <span class="number">512</span> * blocks) &#123;</span><br><span class="line">            have_holes = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s is a sparse-block file!\n&quot;</span>, from);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            have_holes = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s is not a sparse-block file!\n&quot;</span>, from);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fd2 = open(to, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">-1</span> == fd2) &#123;</span><br><span class="line">        perror (<span class="string">&quot;open file2 faild&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer = <span class="built_in">malloc</span>(pagesize);</span><br><span class="line">    <span class="keyword">if</span>(buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror (<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, pagesize);</span><br><span class="line">    <span class="keyword">while</span>((read_num = read(fd1, buffer, pagesize)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 源文件有空洞 */</span></span><br><span class="line">        <span class="keyword">if</span>(have_holes)&#123;</span><br><span class="line">            last_zero = <span class="number">-1</span>;</span><br><span class="line">            last_nonzero = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(current_pos = <span class="number">0</span>; current_pos &lt; read_num; current_pos++)&#123;</span><br><span class="line">                <span class="comment">/* 逐字节判断，效率较低*/</span></span><br><span class="line">                <span class="keyword">if</span>(buffer[current_pos] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(last_nonzero &gt; last_zero)&#123;</span><br><span class="line">                        remain_num = last_nonzero - last_zero;</span><br><span class="line">                        start_pos = buffer + last_zero + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">while</span>(remain_num)&#123;</span><br><span class="line">                            write_num = write(fd2, start_pos, remain_num);</span><br><span class="line">                            <span class="keyword">if</span> ( <span class="number">-1</span> == write_num)&#123;</span><br><span class="line">                                perror( <span class="string">&quot;write file2 error&quot;</span>);</span><br><span class="line">                                <span class="keyword">goto</span> err;</span><br><span class="line">                            &#125;</span><br><span class="line">                            remain_num -= write_num;</span><br><span class="line">                            start_pos += write_num;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    last_zero = current_pos;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(last_zero &gt; last_nonzero)&#123;</span><br><span class="line">                        remain_num = last_zero - last_nonzero;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="number">-1</span> == lseek(fd2, remain_num, SEEK_CUR))&#123;</span><br><span class="line">                            perror(<span class="string">&quot;lseek file2 fail&quot;</span>);</span><br><span class="line">                            <span class="keyword">goto</span> err;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    last_nonzero = current_pos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 处理最后剩余数据*/</span></span><br><span class="line">            remain_num = (last_nonzero &gt; last_zero)?(last_nonzero - last_zero):(last_zero - last_nonzero);</span><br><span class="line">            start_pos = buffer + current_pos - remain_num;</span><br><span class="line">            <span class="keyword">if</span>(last_nonzero &gt; last_zero)&#123;</span><br><span class="line">                <span class="keyword">while</span>(remain_num)&#123;</span><br><span class="line">                    write_num = write(fd2, start_pos, remain_num);</span><br><span class="line">                    <span class="keyword">if</span> ( <span class="number">-1</span> == write_num)&#123;</span><br><span class="line">                        perror( <span class="string">&quot;write file2 error&quot;</span>);</span><br><span class="line">                        <span class="keyword">goto</span> err;</span><br><span class="line">                    &#125;</span><br><span class="line">                        remain_num -= write_num;</span><br><span class="line">                        start_pos += write_num;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">-1</span> == lseek(fd2, remain_num, SEEK_CUR))&#123;</span><br><span class="line">                    perror(<span class="string">&quot;lseek file2 fail&quot;</span>);</span><br><span class="line">                    <span class="keyword">goto</span> err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 源文件无空洞 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            remain_num = read_num;</span><br><span class="line">            start_pos = buffer;</span><br><span class="line">            <span class="keyword">while</span>(remain_num)&#123;</span><br><span class="line">                write_num = write(fd2, start_pos, remain_num);</span><br><span class="line">                <span class="keyword">if</span> ( <span class="number">-1</span> == write_num)&#123;</span><br><span class="line">                    perror( <span class="string">&quot;write file2 error&quot;</span>);</span><br><span class="line">                    <span class="keyword">goto</span> err;</span><br><span class="line">                &#125;</span><br><span class="line">                remain_num -= write_num;</span><br><span class="line">                start_pos += write_num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == read_num) &#123;</span><br><span class="line">        perror(<span class="string">&quot;read file1 error&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    rev = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span>(buffer) <span class="built_in">free</span>(buffer);</span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s file1 file2\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    my_cp(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>测试结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ./my_cp holesize2048 holesize2048.cp</span><br><span class="line">pagesize: 4096</span><br><span class="line">st.st_blocks: 128</span><br><span class="line">st.st_blksize: 4096</span><br><span class="line">st.st_size: 65536</span><br><span class="line">holesize2048 is not a sparse-block file!</span><br><span class="line">chen@ubuntu18:~/study/apue.3e/exercises/4</span><br><span class="line">^_^$ ./my_cp holesize4096 holesize4096.cp</span><br><span class="line">pagesize: 4096</span><br><span class="line">st.st_blocks: 72</span><br><span class="line">st.st_blksize: 4096</span><br><span class="line">st.st_size: 65536</span><br><span class="line">holesize4096 is a sparse-block file!</span><br><span class="line"></span><br><span class="line">^_^$ ll -s</span><br><span class="line">total 1708</span><br><span class="line">64 -rw-r--r-- 1 chen chen  65536 1月   6 17:27 holesize2048</span><br><span class="line">64 -rw-r--r-- 1 chen chen  65536 1月   6 17:27 holesize2048.cp</span><br><span class="line">36 -rw-r--r-- 1 chen chen  65536 1月   6 17:27 holesize4096</span><br><span class="line">32 -rw-r--r-- 1 chen chen  65536 1月   6 17:27 holesize4096.cp</span><br></pre></td></tr></table></figure>

<p>空洞文件可以正常拷贝</p>
<h2 id="尝试优化程序"><a href="#尝试优化程序" class="headerlink" title="尝试优化程序"></a>尝试优化程序</h2><p>上面的程序仅在判断文件是否含有空洞时利用的空洞的最小限制。而在实际读写时并没有利用该性质。</p>
<p>这样较短的0字节也会当成是空洞，导致系统调用次数的增加，性能的降低</p>
<p>要优化性能，必须进一步探究空洞的性质。在什么样的情况下才创建空洞(不实际占用磁盘空间的块)？</p>
<ul>
<li>测试程序源码</li>
</ul>
<p>此程序创建了3个文件：</p>
<pre><code>- 文件1先`write`了1K的非零数据，然后`lseek` 7K-1字节。循环2次。
- 文件2先`write`了1K的非零数据，然后`lseek` 7K字节。循环2次
- 文件3先`write`了1K的非零数据，然后`lseek` 7K+1字节。循环2次
</code></pre>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> holesize[]=&#123;<span class="number">4096</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> filesize = <span class="number">64</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, fd1 = <span class="number">0</span>, fd2 = <span class="number">0</span>, fd3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> filename1[<span class="number">32</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> filename2[<span class="number">32</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> filename3[<span class="number">32</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">32</span>*<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">1</span>, <span class="number">32</span>*<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">for</span> (; i&lt; <span class="keyword">sizeof</span>(holesize)/ <span class="keyword">sizeof</span>(<span class="keyword">int</span>); ++i) &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(filename1, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">        <span class="built_in">memset</span>(filename2, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">        <span class="built_in">memset</span>(filename3, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(filename1, <span class="string">&quot;%s%d-1&quot;</span>, <span class="string">&quot;holesize&quot;</span>, holesize[i]);</span><br><span class="line">        <span class="built_in">sprintf</span>(filename2, <span class="string">&quot;%s%d-2&quot;</span>, <span class="string">&quot;holesize&quot;</span>, holesize[i]);</span><br><span class="line">        <span class="built_in">sprintf</span>(filename3, <span class="string">&quot;%s%d-3&quot;</span>, <span class="string">&quot;holesize&quot;</span>, holesize[i]);</span><br><span class="line">        fd1 = open(filename1, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">        fd2 = open(filename2, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">        fd3 = open(filename3, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">        <span class="keyword">if</span>(fd1 &lt; <span class="number">0</span> || fd2 &lt; <span class="number">0</span> || fd3 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;open file fail\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> remain = holesize[i] * <span class="number">1</span> / <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">while</span>(remain) &#123;</span><br><span class="line">                ret = write(fd1, buf, remain);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;write fail\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                remain -= ret;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = lseek(fd1, holesize[i] * <span class="number">7</span> / <span class="number">4</span> - <span class="number">1</span>, SEEK_CUR);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;lseek fail\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> remain = holesize[i] * <span class="number">1</span> / <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">while</span>(remain) &#123;</span><br><span class="line">                ret = write(fd2, buf, remain);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;write fail\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                remain -= ret;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = lseek(fd2, holesize[i] * <span class="number">7</span> / <span class="number">4</span>, SEEK_CUR);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;lseek fail\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> remain = holesize[i] * <span class="number">1</span> / <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">while</span>(remain) &#123;</span><br><span class="line">                ret = write(fd3, buf, remain);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;write fail\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                remain -= ret;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = lseek(fd3, holesize[i] * <span class="number">7</span> / <span class="number">4</span> + <span class="number">1</span>, SEEK_CUR);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;lseek fail\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd1);</span><br><span class="line">        close(fd2);</span><br><span class="line">        close(fd3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>测试结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ll -s</span><br><span class="line">12 -rw-r--r-- 1 chen chen  9215 1月   6 15:07 holesize4096-1</span><br><span class="line"> 8 -rw-r--r-- 1 chen chen  9216 1月   6 15:07 holesize4096-2</span><br><span class="line"> 8 -rw-r--r-- 1 chen chen  9217 1月   6 15:07 holesize4096-3</span><br></pre></td></tr></table></figure>

<p>可见空洞必须从一页的起始位置开始计算,并且等于或超过pagesize，才不占用实际磁盘空间</p>
<h2 id="优化后程序"><a href="#优化后程序" class="headerlink" title="优化后程序"></a>优化后程序</h2><ul>
<li>源码</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read_ex</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbyte)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> read_remain = nbyte;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *read_start = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf;</span><br><span class="line">    <span class="keyword">ssize_t</span> read_num = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> total_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(read_remain) &#123;</span><br><span class="line">        read_num = read(fd, read_start, read_remain);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == read_num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == read_num)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            read_remain -= read_num;</span><br><span class="line">            read_start += read_num;</span><br><span class="line">            total_num += read_num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write_ex</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbyte)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> write_remain = nbyte;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *write_start = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf;</span><br><span class="line">    <span class="keyword">ssize_t</span> write_num = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> total_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(write_remain) &#123;</span><br><span class="line">        write_num = write(fd, write_start, write_remain);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == write_num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            write_remain -= write_num;</span><br><span class="line">            write_start += write_num;</span><br><span class="line">            total_num += write_num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total_num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_cp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1 = <span class="number">-1</span>, fd2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> rev = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer = <span class="literal">NULL</span>, *buffer_zero = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">long</span> pagesize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> blocks, blksize, size;</span><br><span class="line">    <span class="keyword">int</span> read_num, write_num, write_remain, have_holes = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    fd1 = open(from, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fd1)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open file1 faild&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fstat(fd1, &amp;st) !=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat: &quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SC_PAGESIZE</span></span><br><span class="line">        pagesize = sysconf(_SC_PAGESIZE);</span><br><span class="line">        <span class="keyword">if</span> (pagesize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EINVAL) &#123;</span><br><span class="line">                    <span class="built_in">fputs</span>(<span class="string">&quot; (not supported)\n&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">                    pagesize = st.st_blksize;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    perror(<span class="string">&quot;sysconf error&quot;</span>);</span><br><span class="line">                    <span class="keyword">goto</span> err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">&quot; (no limit)\n&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">                pagesize = st.st_blksize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pagesize: %ld\n&quot;</span>, pagesize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        pagesize = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        blocks = st.st_blocks;</span><br><span class="line">        blksize = st.st_blksize;</span><br><span class="line">        size = st.st_size;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st.st_blocks: %lld\n&quot;</span>, blocks);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st.st_blksize: %lld\n&quot;</span>, blksize);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st.st_size: %lld\n&quot;</span>, size);</span><br><span class="line">        <span class="comment">/*块大小512，在不同平台上可能不兼容*/</span></span><br><span class="line">        <span class="keyword">if</span>(S_ISREG(st.st_mode) &amp;&amp; (size / pagesize + (size%pagesize?<span class="number">1</span>:<span class="number">0</span>)) * pagesize &gt; <span class="number">512</span> * blocks) &#123;</span><br><span class="line">            have_holes = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s is a sparse-block file!\n&quot;</span>, from);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            have_holes = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s is not a sparse-block file!\n&quot;</span>, from);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer = <span class="built_in">malloc</span>(pagesize);</span><br><span class="line">    buffer_zero = <span class="built_in">malloc</span>(pagesize);</span><br><span class="line">    <span class="keyword">if</span>(buffer == <span class="literal">NULL</span> || buffer_zero == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror (<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, pagesize);</span><br><span class="line">    <span class="built_in">memset</span>(buffer_zero, <span class="string">&#x27;\0&#x27;</span>, pagesize);</span><br><span class="line"></span><br><span class="line">    fd2 = open(to, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fd2) &#123;</span><br><span class="line">        perror (<span class="string">&quot;open file2 faild&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((read_num = read_ex(fd1, buffer, pagesize)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 读取到空洞 */</span></span><br><span class="line">        <span class="keyword">if</span>(have_holes &amp;&amp; !<span class="built_in">memcmp</span>(buffer_zero, buffer, read_num))&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">-1</span> == lseek(fd2, read_num, SEEK_CUR))&#123;</span><br><span class="line">                perror(<span class="string">&quot;lseek file2 fail&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 非空洞 */</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            write_num = write_ex(fd2, buffer, read_num);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">-1</span> == write_num)&#123;</span><br><span class="line">                perror( <span class="string">&quot;write file2 error&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == read_num)&#123;</span><br><span class="line">        perror(<span class="string">&quot;read file1 error&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    rev = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span>(buffer) <span class="built_in">free</span>(buffer);</span><br><span class="line">    <span class="keyword">if</span>(buffer_zero) <span class="built_in">free</span>(buffer_zero);</span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s file1 file2\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    my_cp(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>对比测试</li>
</ul>
<p>构造一个文件，除了开头一个空洞，其余数据为0x00,0x01的100000次重复</p>
<p>用优化前的程序拷贝该文件10000次，大约2000s</p>
<p>用优化后的程序拷贝该文件10000次，大约30s</p>
]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>UNIX</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenResty Lua钩子调用完整流程</title>
    <url>/posts/30b81f82/</url>
    <content><![CDATA[<div class="note primary">
            <p>前面一篇文章介绍了<a href="../150430f0/">Openresty Lua协程调度机制</a>，主要关心的是核心调度函数<code>run_thread()</code>内部发生的事情，而对于外部的事情我们并没有涉及。本篇作为其姊妹篇，准备补上剩余的部分。本篇将通过一个例子，完整介绍OpenResty中Lua钩子的调用流程，包括初始化阶段的工作、新连接进来时如何进入钩子、I/O等待时如何出去、事件触发时如何恢复、钩子正常执行结束时的操作、钩子内出错的情况。本文同样是基于<code>stream-lua</code>模块的代码。</p>
          </div>

<span id="more"></span>

<h1 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h1><p>我们以<code>ssl_certificate_by_lua*</code>钩子为例来进行介绍，一来是因为它还涉及SSL握手，流程上更长一点。二来是因为在其上下文中是<code>YIELDABLE</code>的，支持的Lua API接口比较完整。</p>
<p>我将以下面两个配置为例来展开介绍。例子非常简单，第一个是正常的结束情况在<code>ssl_certificate_by_lua_block</code>里面调用了<code>ngx.sleep()</code>。第二个是出错中止的情况，多了一个<code>ngx.exit(ngx.ERROR)</code>。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="section">ssl_certificate_by_lua_block</span> &#123;</span><br><span class="line">        ngx.sleep(0.1)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> test.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> test.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="section">ssl_certificate_by_lua_block</span> &#123;</span><br><span class="line">        ngx.sleep(0.1)</span><br><span class="line">        ngx.exit(ngx.ERROR)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> test.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> test.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="配置项解析"><a href="#配置项解析" class="headerlink" title="配置项解析"></a>配置项解析</h2><p>解析到<code>ssl_certificate_by_lua_block</code>时会调用<code>ngx_stream_lua_ssl_cert_by_lua_block()</code>进行解析，里面会进行配置文件的词法分析，将代码块中的代码都合并到一个buffer之后，插入到参数数组的后面。然后调用<code>ngx_stream_lua_ssl_cert_by_lua()</code>。（如果是<code>by_lua_file</code>的情况会直接调用<code>ngx_stream_lua_ssl_cert_by_lua()</code>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_stream_lua_ssl_cert_by_lua_block</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> *conf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>        *rv;</span><br><span class="line">    <span class="keyword">ngx_conf_t</span>   save;</span><br><span class="line"></span><br><span class="line">    save = *cf;</span><br><span class="line">    cf-&gt;handler = ngx_stream_lua_ssl_cert_by_lua;</span><br><span class="line">    cf-&gt;handler_conf = conf;</span><br><span class="line"></span><br><span class="line">    rv = ngx_stream_lua_conf_lua_block_parse(cf, cmd);</span><br><span class="line"></span><br><span class="line">    *cf = save;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ngx_stream_lua_ssl_cert_by_lua()</code>主要工作是设置<code>lscf-&gt;srv.ssl_cert_src</code>以及创建Lua代码的key。如果是<code>by_lua_file</code>的情况，key以字符串<code>nhlf_</code>开头，后边是对文件路径计算的摘要十六进制值；而<code>by_lua_block</code>的情况，key以字符串<code>&quot;ssl_certificate_by_lua&quot;</code>开头，后边是对整个Lua代码块计算的摘要十六进制值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lscf-&gt;srv.ssl_cert_src = value[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">p = ngx_palloc(cf-&gt;pool,</span><br><span class="line">               <span class="keyword">sizeof</span>(<span class="string">&quot;ssl_certificate_by_lua&quot;</span>) +</span><br><span class="line">               NGX_STREAM_LUA_INLINE_KEY_LEN);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> NGX_CONF_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lscf-&gt;srv.ssl_cert_src_key = p;</span><br><span class="line"></span><br><span class="line">p = ngx_copy(p, <span class="string">&quot;ssl_certificate_by_lua&quot;</span>,</span><br><span class="line">             <span class="keyword">sizeof</span>(<span class="string">&quot;ssl_certificate_by_lua&quot;</span>) - <span class="number">1</span>);</span><br><span class="line">p = ngx_copy(p, NGX_STREAM_LUA_INLINE_TAG, NGX_STREAM_LUA_INLINE_TAG_LEN);</span><br><span class="line">p = ngx_stream_lua_digest_hex(p, value[<span class="number">1</span>].data, value[<span class="number">1</span>].len);</span><br><span class="line">*p = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="配置项合并"><a href="#配置项合并" class="headerlink" title="配置项合并"></a>配置项合并</h2><p>在配置合并阶段，由<code>ngx_stream_lua_merge_srv_conf()</code>把<code>cert_cb</code>回调函数<code>ngx_stream_lua_ssl_cert_handler()</code>设置到server的<code>SSL_CTX</code>上。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        <span class="comment">/* 先进行配置合并 */</span></span><br><span class="line">        <span class="keyword">if</span> (conf-&gt;srv.ssl_cert_src.len == <span class="number">0</span>) &#123;</span><br><span class="line">            conf-&gt;srv.ssl_cert_src = prev-&gt;srv.ssl_cert_src;</span><br><span class="line">            conf-&gt;srv.ssl_cert_src_key = prev-&gt;srv.ssl_cert_src_key;</span><br><span class="line">            conf-&gt;srv.ssl_cert_handler = prev-&gt;srv.ssl_cert_handler;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 如果设置了该配置 */</span></span><br><span class="line">        <span class="keyword">if</span> (conf-&gt;srv.ssl_cert_src.len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sscf-&gt;ssl.ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ngx_log_error(NGX_LOG_EMERG, cf-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                              <span class="string">&quot;no ssl configured for the server&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> NGX_CONF_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> OPENSSL_VERSION_NUMBER &gt;= 0x1000205fL</span></span><br><span class="line">            <span class="comment">/* 设置cert_cb回调 */</span></span><br><span class="line">            SSL_CTX_set_cert_cb(sscf-&gt;ssl.ctx, ngx_stream_lua_ssl_cert_handler, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置后处理-postconfiguration"><a href="#配置后处理-postconfiguration" class="headerlink" title="配置后处理 postconfiguration"></a>配置后处理 postconfiguration</h2><p>在postconfig阶段，会调用<code>ngx_stream_lua_init()</code>，它里面最关键的任务就是初始化Lua VM。（其实还会调用<code>init_by*</code>钩子，不过不在我们今天的讨论范围内。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rc = ngx_stream_lua_init_vm(&amp;lmcf-&gt;lua, <span class="literal">NULL</span>, cf-&gt;cycle, cf-&gt;pool,</span><br><span class="line">                            lmcf, cf-&gt;<span class="built_in">log</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>我们来看下<code>ngx_stream_lua_init_vm()</code>里面的实现，它先会创建Lua VM实例，然后注册其cleanup handler，如果有第三方模块的<code>preload_hooks</code>会注册之，然后会加载<code>resty.core</code>模块，最后会注入代码对全局变量的写操作加一个警告日志。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/* create new Lua VM instance */</span></span><br><span class="line">    L = ngx_stream_lua_new_state(parent_vm, cycle, lmcf, <span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* register cleanup handler for Lua VM */</span></span><br><span class="line">    cln-&gt;handler = ngx_stream_lua_cleanup_vm;</span><br><span class="line"></span><br><span class="line">    state = ngx_alloc(<span class="keyword">sizeof</span>(<span class="keyword">ngx_stream_lua_vm_state_t</span>), <span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    state-&gt;vm = L;</span><br><span class="line">    state-&gt;count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    cln-&gt;data = state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lmcf-&gt;vm_cleanup == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* this assignment will happen only once,</span></span><br><span class="line"><span class="comment">         * and also only for the main Lua VM */</span></span><br><span class="line">        lmcf-&gt;vm_cleanup = cln;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OPENRESTY_LUAJIT</span></span><br><span class="line">    <span class="comment">/* load FFI library first since cdata needs it */</span></span><br><span class="line">    luaopen_ffi(L);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lmcf-&gt;preload_hooks) &#123;</span><br><span class="line">        <span class="comment">/* 注册第三方preload_hooks */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *new_vm = L;</span><br><span class="line"></span><br><span class="line">    lua_getglobal(L, <span class="string">&quot;require&quot;</span>);</span><br><span class="line">    lua_pushstring(L, <span class="string">&quot;resty.core&quot;</span>);</span><br><span class="line"></span><br><span class="line">    rc = lua_pcall(L, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_DECLINED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OPENRESTY_LUAJIT</span></span><br><span class="line">    ngx_stream_lua_inject_global_write_guard(L, <span class="built_in">log</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NGX_OK;</span><br></pre></td></tr></table></figure>

<p>关键函数是创建Lua VM实例的<code>ngx_stream_lua_new_state()</code>，我们来一睹其芳容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建vm state*/</span></span><br><span class="line">L = luaL_newstate();</span><br><span class="line"><span class="comment">/* 打开标准库 */</span></span><br><span class="line">luaL_openlibs(L);</span><br><span class="line"><span class="comment">/* 获取package表 */</span></span><br><span class="line">lua_getglobal(L, <span class="string">&quot;package&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置package.path和package.cpath */</span></span><br><span class="line"></span><br><span class="line">lua_pop(L, <span class="number">1</span>); <span class="comment">/* remove the &quot;package&quot; table */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化registry */</span></span><br><span class="line">ngx_stream_lua_init_registry(L, <span class="built_in">log</span>);</span><br><span class="line"><span class="comment">/* 初始化globals */</span></span><br><span class="line">ngx_stream_lua_init_globals(L, cycle, lmcf, <span class="built_in">log</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> L;</span><br></pre></td></tr></table></figure>

<p>重点是最后的两个函数，它们分别初始化<code>registry</code>和<code>globals</code>。这个两个函数都不算太长，让我们来完整看下它们做了些什么。</p>
<p><code>ngx_stream_lua_init_registry()</code>创建了几个注册表项，分别用于存放协程、Lua的请求ctx、socket连接池、Lua预编译正则表达式对象cache及Lua代码cache。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ngx_stream_lua_init_registry(lua_State *L, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_log_debug0(NGX_LOG_DEBUG_STREAM, <span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="string">&quot;lua initializing lua registry&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &#123;&#123;&#123; register a table to anchor lua coroutines reliably:</span></span><br><span class="line"><span class="comment">     * &#123;([int]ref) = [cort]&#125; */</span></span><br><span class="line">    lua_pushlightuserdata(L, ngx_stream_lua_lightudata_mask(</span><br><span class="line">                          coroutines_key));</span><br><span class="line">    lua_createtable(L, <span class="number">0</span>, <span class="number">32</span> <span class="comment">/* nrec */</span>);</span><br><span class="line">    lua_rawset(L, LUA_REGISTRYINDEX);</span><br><span class="line">    <span class="comment">/* &#125;&#125;&#125; */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create the registry entry for the Lua request ctx data table */</span></span><br><span class="line">    lua_pushliteral(L, ngx_stream_lua_ctx_tables_key);</span><br><span class="line">    lua_createtable(L, <span class="number">0</span>, <span class="number">32</span> <span class="comment">/* nrec */</span>);</span><br><span class="line">    lua_rawset(L, LUA_REGISTRYINDEX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create the registry entry for the Lua socket connection pool table */</span></span><br><span class="line">    lua_pushlightuserdata(L, ngx_stream_lua_lightudata_mask(</span><br><span class="line">                          socket_pool_key));</span><br><span class="line">    lua_createtable(L, <span class="number">0</span>, <span class="number">8</span> <span class="comment">/* nrec */</span>);</span><br><span class="line">    lua_rawset(L, LUA_REGISTRYINDEX);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_PCRE)</span></span><br><span class="line">    <span class="comment">/* create the registry entry for the Lua precompiled regex object cache */</span></span><br><span class="line">    lua_pushlightuserdata(L, ngx_stream_lua_lightudata_mask(</span><br><span class="line">                          regex_cache_key));</span><br><span class="line">    lua_createtable(L, <span class="number">0</span>, <span class="number">16</span> <span class="comment">/* nrec */</span>);</span><br><span class="line">    lua_rawset(L, LUA_REGISTRYINDEX);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &#123;&#123;&#123; register table to cache user code:</span></span><br><span class="line"><span class="comment">     * &#123; [(string)cache_key] = &lt;code closure&gt; &#125; */</span></span><br><span class="line">    lua_pushlightuserdata(L, ngx_stream_lua_lightudata_mask(</span><br><span class="line">                          code_cache_key));</span><br><span class="line">    lua_createtable(L, <span class="number">0</span>, <span class="number">8</span> <span class="comment">/* nrec */</span>);</span><br><span class="line">    lua_rawset(L, LUA_REGISTRYINDEX);</span><br><span class="line">    <span class="comment">/* &#125;&#125;&#125; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ngx_stream_lua_init_globals()</code>则是创建了<code>ngx</code>表，接着把相关Lua API全部设置到表上了，其中就包括我们前面例子中的<code>ngx.sleep()</code>和<code>ngx.exit()</code>。然后把<code>ngx</code>表分别设为全局表项，同时也设到<code>package.loaded.ngx</code>了。另外提一嘴，原生的<code>coroutine</code>接口也在这里被替换了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_stream_lua_inject_ngx_api</span><span class="params">(lua_State *L, <span class="keyword">ngx_stream_lua_main_conf_t</span> *lmcf,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lua_createtable(L, <span class="number">0</span> <span class="comment">/* narr */</span>, <span class="number">113</span> <span class="comment">/* nrec */</span>);    <span class="comment">/* ngx.* */</span></span><br><span class="line"></span><br><span class="line">    lua_pushcfunction(L, ngx_stream_lua_get_raw_phase_context);</span><br><span class="line">    lua_setfield(L, <span class="number">-2</span>, <span class="string">&quot;_phase_ctx&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ngx_stream_lua_inject_core_consts(L);</span><br><span class="line"></span><br><span class="line">    ngx_stream_lua_inject_log_api(L);</span><br><span class="line">    ngx_stream_lua_inject_output_api(L);</span><br><span class="line">    ngx_stream_lua_inject_string_api(L);</span><br><span class="line">    ngx_stream_lua_inject_control_api(<span class="built_in">log</span>, L);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ngx_stream_lua_inject_sleep_api(L);</span><br><span class="line">    ngx_stream_lua_inject_phase_api(L);</span><br><span class="line"></span><br><span class="line">    ngx_stream_lua_inject_req_api(<span class="built_in">log</span>, L);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ngx_stream_lua_inject_shdict_api(lmcf, L);</span><br><span class="line">    ngx_stream_lua_inject_socket_tcp_api(<span class="built_in">log</span>, L);</span><br><span class="line">    ngx_stream_lua_inject_socket_udp_api(<span class="built_in">log</span>, L);</span><br><span class="line">    ngx_stream_lua_inject_uthread_api(<span class="built_in">log</span>, L);</span><br><span class="line">    ngx_stream_lua_inject_timer_api(L);</span><br><span class="line">    ngx_stream_lua_inject_config_api(L);</span><br><span class="line"></span><br><span class="line">    lua_getglobal(L, <span class="string">&quot;package&quot;</span>); <span class="comment">/* ngx package */</span></span><br><span class="line">    lua_getfield(L, <span class="number">-1</span>, <span class="string">&quot;loaded&quot;</span>); <span class="comment">/* ngx package loaded */</span></span><br><span class="line">    lua_pushvalue(L, <span class="number">-3</span>); <span class="comment">/* ngx package loaded ngx */</span></span><br><span class="line">    lua_setfield(L, <span class="number">-2</span>, <span class="string">&quot;ngx&quot;</span>); <span class="comment">/* ngx package loaded */</span></span><br><span class="line">    lua_pop(L, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    lua_setglobal(L, <span class="string">&quot;ngx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ngx_stream_lua_inject_coroutine_api(<span class="built_in">log</span>, L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>初始化阶段的主要工作就是这些，简单小结一下，配置项解析阶段完成了Lua代码key的创建，配置项合并阶段完成了Lua钩子回调的设置，postconfig阶段完成了Lua虚拟机的初始化，其中包括registry和globals的初始化。当master进程fork出worker子进程之后，每个worker都将有一个自己的Lua VM实例。</p>
<h1 id="进入Lua钩子"><a href="#进入Lua钩子" class="headerlink" title="进入Lua钩子"></a>进入Lua钩子</h1><p>接下来，我们来看连接发起阶段。当监听的socket接收到连接请求之后，会调用<code>accept</code>建立连接，因为是stream子系统调用到<code>ngx_stream_init_connection</code>，又因为是ssl server会先走到<code>ngx_stream_ssl_handler</code>，里面调用<code>ngx_ssl_create_connection</code>创建连接(<code>SSL_new(ssl-&gt;ctx)</code>)，最终会调用<code>SSL_do_handshake</code>进入SSL状态机。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( ;; ) &#123;</span><br><span class="line">    ngx_process_events_and_timers(cycle)</span><br><span class="line">    +-- ngx_epoll_process_events()</span><br><span class="line">        |-- epoll_wait()</span><br><span class="line">        +-- ngx_event_accept()</span><br><span class="line">            |-- accept4()</span><br><span class="line">            |-- ngx_get_connection()</span><br><span class="line">            +-- ngx_stream_init_connection()</span><br><span class="line">                +-- ngx_stream_session_handler()</span><br><span class="line">                    |-- s = ngx_pcalloc(c-&gt;pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_stream_session_t</span>))</span><br><span class="line">                    +-- ngx_stream_core_run_phases()</span><br><span class="line">                        +-- ngx_stream_core_generic_phase()</span><br><span class="line">                            +-- ngx_stream_ssl_handler()</span><br><span class="line">                                +-- ngx_stream_ssl_init_connection()</span><br><span class="line">                                    |-- ngx_ssl_create_connection()</span><br><span class="line">                                    |   +-- SSL_new(ssl-&gt;ctx)</span><br><span class="line">                                    +-- ngx_ssl_handshake()</span><br><span class="line">                                        |-- SSL_do_handshake()</span><br><span class="line">                                        |-- sslerr = SSL_get_error();</span><br><span class="line"></span><br><span class="line">                        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SSL状态机的部分不是我们今天的重点，这里暂且略过。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ossl_statem_accept()</span><br><span class="line">+-- state_machine()</span><br><span class="line">    +-- read_state_machine()</span><br><span class="line">        +-- ossl_statem_server_post_process_message()</span><br></pre></td></tr></table></figure>

<p>状态机最终会调用到<code>tls_post_process_client_hello()</code>里的<code>cert_cb</code>。这个回调我们已经在配置初始化阶段设置了，在创建SSL连接的时候又会拷贝到<code>SSL</code>结构体里。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tls_post_process_client_hello()</span><br><span class="line">+-- s-&gt;cert-&gt;cert_cb(); <span class="comment">// 即ngx_stream_lua_ssl_cert_handler</span></span><br><span class="line">    |   <span class="comment">/* 即ngx_stream_lua_ssl_cert_handler_inline */</span></span><br><span class="line">    +-- lscf-&gt;srv.ssl_cert_handler(r, lscf, L); </span><br><span class="line">        |-- ngx_stream_lua_cache_loadbuffer()</span><br><span class="line">        +-- ngx_stream_lua_ssl_cert_by_chunk()</span><br><span class="line">            |-- ngx_stream_lua_create_ctx()</span><br><span class="line">            |-- lua_xmove(L, co, <span class="number">1</span>);    <span class="comment">// 将代码闭包从L移到co上</span></span><br><span class="line">            |-- ngx_stream_lua_new_thread()</span><br><span class="line">            +-- ngx_stream_lua_run_thread() </span><br><span class="line">                |-- lua_resume()</span><br></pre></td></tr></table></figure>

<p>在<code>ngx_stream_lua_ssl_cert_handler</code>中会做一些初始化工作，如创建fake连接、fake会话、fake请求，设置默认的返回码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fc = ngx_stream_lua_create_fake_connection(<span class="literal">NULL</span>);</span><br><span class="line">fs = ngx_stream_lua_create_fake_session(fc);</span><br><span class="line">r = ngx_stream_lua_create_fake_request(fs);</span><br><span class="line">cctx-&gt;exit_code = <span class="number">1</span>;  <span class="comment">/* successful by default */</span></span><br><span class="line">cctx-&gt;connection = c;</span><br><span class="line">cctx-&gt;request = r;</span><br><span class="line">cctx-&gt;entered_cert_handler = <span class="number">1</span>;</span><br><span class="line">cctx-&gt;done = <span class="number">0</span>;</span><br><span class="line">SSL_set_ex_data(c-&gt;ssl-&gt;connection, ngx_stream_lua_ssl_ctx_index, </span><br><span class="line">                cctx)</span><br></pre></td></tr></table></figure>



<p>然后因为是用配置指令是<code>xxx_by_lua_block</code>所以调用<code>ngx_stream_lua_ssl_cert_handler_inline</code>，它里面会加载Lua代码。如果是第一次加载会把代码块加载为一个Lua函数闭包工厂，然后保存闭包工厂到虚拟机的注册表上并生成一个闭包到栈顶；后续会直接从虚拟机注册表上查找并生成闭包到栈顶。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ngx_int_t</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_stream_lua_ssl_cert_handler_inline</span><span class="params">(<span class="keyword">ngx_stream_lua_request_t</span> *r,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">ngx_stream_lua_srv_conf_t</span> *lscf, lua_State *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        rc = ngx_stream_lua_cache_loadbuffer(r-&gt;connection-&gt;<span class="built_in">log</span>, L,</span><br><span class="line">                                         lscf-&gt;srv.ssl_cert_src.data,</span><br><span class="line">                                         lscf-&gt;srv.ssl_cert_src.len,</span><br><span class="line">                                         lscf-&gt;srv.ssl_cert_src_key,</span><br><span class="line">                                         <span class="string">&quot;=ssl_certificate_by_lua&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ngx_stream_lua_ssl_cert_by_chunk(L, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是进入<code>by_chunk()</code>准备执行Lua代码了，这里首先创建<code>lua_ctx</code>，接着在虚拟机上创建一个入口协程，并把代码闭包从虚拟机栈上移到新线程的栈上，还在fake请求上挂了一个cleanup。然后就是调用<code>run_thread()</code>进入协程调度循环了。后面的事情我们已经在上一篇中讲到了，<code>lua_resume()</code>开始执行我们的Lua代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ctx = ngx_stream_lua_create_ctx(r-&gt;session);</span><br><span class="line">ctx-&gt;entered_content_phase = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 创建入口线程 */</span></span><br><span class="line">co = ngx_stream_lua_new_thread(r, L, &amp;co_ref);</span><br><span class="line"><span class="comment">/* 将代码闭包移到入口线程中 */</span></span><br><span class="line">lua_xmove(L, co, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 设置闭包的环境表为新协程的全局表 */</span></span><br><span class="line">ngx_stream_lua_get_globals_table(co);</span><br><span class="line">lua_setfenv(co, <span class="number">-2</span>);</span><br><span class="line"><span class="comment">/* 把nginx请求保存到协程全局表中 */</span></span><br><span class="line">ngx_stream_lua_set_req(co, r);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册请求的cleanup hooks */</span></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;cleanup == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    cln = ngx_stream_lua_cleanup_add(r, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (cln == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        rc = NGX_ERROR;</span><br><span class="line">        ngx_stream_lua_finalize_request(r, rc);</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cln-&gt;handler = ngx_stream_lua_request_cleanup_handler;</span><br><span class="line">    cln-&gt;data = ctx;</span><br><span class="line">    ctx-&gt;cleanup = &amp;cln-&gt;handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx-&gt;context = NGX_STREAM_LUA_CONTEXT_SSL_CERT;</span><br><span class="line">rc = ngx_stream_lua_run_thread(L, r, ctx, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h1 id="I-O等待挂起"><a href="#I-O等待挂起" class="headerlink" title="I/O等待挂起"></a>I/O等待挂起</h1><p>我们在初始化阶段已经将Lua API设置到全局表中了，所以<code>ngx.sleep()</code>会调用到对应的C函数<code>ngx_stream_lua_ngx_sleep()</code>，里面主要是设置了一个定时器，其事件的handler是<code>ngx_stream_lua_sleep_handler()</code>。挂完定时器，就直接<code>lua_yield()</code>了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">coctx-&gt;sleep.handler = ngx_stream_lua_sleep_handler;</span><br><span class="line">coctx-&gt;sleep.data = coctx;</span><br><span class="line">coctx-&gt;sleep.<span class="built_in">log</span> = r-&gt;connection-&gt;<span class="built_in">log</span>;</span><br><span class="line"></span><br><span class="line">ngx_add_timer(&amp;coctx-&gt;sleep, (<span class="keyword">ngx_msec_t</span>) delay);</span><br><span class="line"><span class="keyword">return</span> lua_yield(L, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>回到我们的主线程<code>run_thread()</code>之后，因为是IO等待就直接返回<code>NGX_AGAIN</code>了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rv = lua_resume(orig_coctx-&gt;co, nrets);</span><br><span class="line"><span class="keyword">switch</span> (rv) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_YIELD:</span><br><span class="line">        <span class="keyword">switch</span> (ctx-&gt;co_op) &#123;</span><br><span class="line">            <span class="keyword">case</span> NGX_STREAM_LUA_USER_CORO_NOP:</span><br><span class="line">                ctx-&gt;cur_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span> NGX_AGAIN;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样又回到了我们的<code>by_chunk()</code>函数，因为返回值是<code>NGX_AGAIN</code>所以会先队列里面有没有posted的线程，如果有的话会去恢复线程的执行，在我们这个例子是没有的，不过它的返回值<code>rc</code>改成了<code>NGX_DONE</code>，所以<code>ngx_stream_lua_finalize_request(r, rc);</code>里啥也没干就返回了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rc = ngx_stream_lua_run_thread(L, r, ctx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rc == NGX_ERROR || rc &gt;= NGX_OK) &#123;</span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == NGX_AGAIN) &#123;</span><br><span class="line">    rc = ngx_stream_lua_content_run_posted_threads(L, r, ctx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == NGX_DONE) &#123;</span><br><span class="line">    rc = ngx_stream_lua_content_run_posted_threads(L, r, ctx, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    rc = NGX_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_stream_lua_finalize_request(r, rc);</span><br><span class="line"><span class="keyword">return</span> rc;</span><br></pre></td></tr></table></figure>

<p>这个<code>NGX_DONE</code>的返回值往回传递到<code>ngx_stream_lua_ssl_cert_handler</code>，在这里会对不同返回值做不同处理。如果是完成<code>NGX_OK</code>或出错<code>NGX_ERROR</code>的情况，就意味着钩子的工作已经结束了。我们目前的返回值是<code>NGX_DONE</code>，说明工作还没有结束，它在返回<code>-1</code>之前，挂了两个cleanup。其中<code>_done()</code>的那个是挂在fake连接的pool上的，而<code>_aborted()</code>那个是是挂在前端连接上的。所以<code>_done()</code>函数上在钩子工作结束之后调用的，而<code>_aborted()</code>是在前端连接终止的时候调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> rc = lscf-&gt;srv.ssl_cert_handler(r, lscf, L);</span><br><span class="line"><span class="comment">/* 已经处理完毕或者出错的情况 */</span></span><br><span class="line"><span class="keyword">if</span> (rc &gt;= NGX_OK || rc == NGX_ERROR) &#123;</span><br><span class="line">    cctx-&gt;done = <span class="number">1</span>;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">return</span> cctx-&gt;exit_code;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* rc == NGX_DONE */</span></span><br><span class="line"></span><br><span class="line">cln = ngx_pool_cleanup_add(fc-&gt;pool, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">cln-&gt;handler = ngx_stream_lua_ssl_cert_done;</span><br><span class="line">cln-&gt;data = cctx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cctx-&gt;cleanup == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    cln = ngx_pool_cleanup_add(c-&gt;pool, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cln-&gt;data = cctx;</span><br><span class="line">    cctx-&gt;cleanup = &amp;cln-&gt;handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*cctx-&gt;cleanup = ngx_stream_lua_ssl_cert_aborted;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p>这样就回到了OpenSSL的领域，我们看看出去的流程是怎么样的。因为上层的返回值是<code>-1</code>，这里设置状态为<code>SSL_X509_LOOKUP</code>然后返回<code>WORK_MORE_B</code>，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> rv = s-&gt;cert-&gt;cert_cb(s, s-&gt;cert-&gt;cert_cb_arg);</span><br><span class="line"><span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    s-&gt;rwstate = SSL_X509_LOOKUP;</span><br><span class="line">    <span class="keyword">return</span> WORK_MORE_B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个返回值传递到<code>read_state_machine</code>，变成了返回<code>SUB_STATE_ERROR</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> READ_STATE_POST_PROCESS:</span><br><span class="line">    st-&gt;read_state_work = post_process_message(s, st-&gt;read_state_work);</span><br><span class="line">    <span class="keyword">switch</span> (st-&gt;read_state_work) &#123;</span><br><span class="line">    <span class="keyword">case</span> WORK_ERROR:</span><br><span class="line">        check_fatal(s, SSL_F_READ_STATE_MACHINE);</span><br><span class="line">        <span class="comment">/* Fall through */</span></span><br><span class="line">    <span class="keyword">case</span> WORK_MORE_A:</span><br><span class="line">    <span class="keyword">case</span> WORK_MORE_B:</span><br><span class="line">    <span class="keyword">case</span> WORK_MORE_C:</span><br><span class="line">        <span class="keyword">return</span> SUB_STATE_ERROR;</span><br></pre></td></tr></table></figure>

<p>传递到<code>state_machine</code>，变成了返回<code>-1</code>。最终<code>ossl_statem_accept</code>及<code>SSL_do_handshake()</code>都返回这个值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (st-&gt;state == MSG_FLOW_READING) &#123;</span><br><span class="line">    ssret = read_state_machine(s);</span><br><span class="line">    <span class="keyword">if</span> (ssret == SUB_STATE_FINISHED) &#123;</span><br><span class="line">        st-&gt;state = MSG_FLOW_WRITING;</span><br><span class="line">        init_write_state_machine(s);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* NBIO or error */</span></span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看看回到nginx之后做了什么，因为返回值是-1，所以会先去获取错误类型，因为之前在<code>cert_cb()</code>返回以后已经设置了<code>s-&gt;rwstate = SSL_X509_LOOKUP;</code>所以会返回<code>SSL_ERROR_WANT_X509_LOOKUP</code>，这里将读写事件的回调设置为ssl握手的回调以便下次恢复。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n = SSL_do_handshake(c-&gt;ssl-&gt;connection);</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">sslerr = SSL_get_error(c-&gt;ssl-&gt;connection, n);</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">if</span> (sslerr == SSL_ERROR_WANT_X509_LOOKUP)</span><br><span class="line">&#123;</span><br><span class="line">    c-&gt;read-&gt;handler = ngx_ssl_handshake_handler;</span><br><span class="line">    c-&gt;write-&gt;handler = ngx_ssl_handshake_handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ngx_handle_read_event(c-&gt;read, <span class="number">0</span>) != NGX_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ngx_handle_write_event(c-&gt;write, <span class="number">0</span>) != NGX_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NGX_AGAIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后<code>NGX_AGAIN</code>的返回值一直往上传递，直到<code>ngx_stream_core_generic_phase</code>变为<code>NGX_OK</code>。然后本次的事件处理就算结束了。</p>
<h1 id="事件触发时恢复"><a href="#事件触发时恢复" class="headerlink" title="事件触发时恢复"></a>事件触发时恢复</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ngx_process_events_and_timers</span><br><span class="line">|-- ngx_event_expire_timers</span><br><span class="line">    |-- ngx_stream_lua_sleep_handler</span><br><span class="line">        |-- ngx_stream_lua_sleep_resume</span><br><span class="line">            |-- ngx_stream_lua_run_thread</span><br></pre></td></tr></table></figure>

<p>等到定时器超时的时候，会执行我们之前设置的<code>ngx_stream_lua_sleep_handler</code>，里面会设置当前协程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">coctx = ev-&gt;data;</span><br><span class="line">ctx-&gt;cur_co_ctx = coctx;</span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;entered_content_phase) &#123;</span><br><span class="line">    (<span class="keyword">void</span>) ngx_stream_lua_sleep_resume(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>ngx_stream_lua_sleep_resume</code>里调用<code>ngx_stream_lua_run_thread</code>恢复协程的执行。这样就又回到了我们的Lua代码里。</p>
<h1 id="Lua钩子正常执行结束"><a href="#Lua钩子正常执行结束" class="headerlink" title="Lua钩子正常执行结束"></a>Lua钩子正常执行结束</h1><p>接下来Lua代码执行完毕，<code>lua_resume()</code>返回，因为是协程正常结束，且没有其他用户线程了，所以<code>run_thread()</code>直接返回<code>NGX_OK</code>。因此在<code>ngx_stream_lua_finalize_request</code>里就会实际清除fake请求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rc = ngx_stream_lua_run_thread(vm, r, ctx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rc == NGX_AGAIN) &#123;</span><br><span class="line">    <span class="keyword">return</span> ngx_stream_lua_run_posted_threads(c, vm, r, ctx, nreqs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rc == NGX_DONE) &#123;</span><br><span class="line">    ngx_stream_lua_finalize_request(r, NGX_DONE);</span><br><span class="line">    <span class="keyword">return</span> ngx_stream_lua_run_posted_threads(c, vm, r, ctx, nreqs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;entered_content_phase) &#123;</span><br><span class="line">    ngx_stream_lua_finalize_request(r, rc);</span><br><span class="line">    <span class="keyword">return</span> NGX_DONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rc;</span><br></pre></td></tr></table></figure>

<p>里面会调用到之前设置的cleanup函数，清理fake请求的时候调用<code>ngx_stream_lua_request_cleanup_handler</code>清理Lua线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cln = r-&gt;cleanup;</span><br><span class="line">r-&gt;cleanup = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (cln) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cln-&gt;handler) &#123;</span><br><span class="line">        cln-&gt;handler(cln-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cln = cln-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r-&gt;connection-&gt;destroyed = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>清理fake连接的时候调用<code>ngx_stream_lua_ssl_cert_done</code>。我们来看看<code>ngx_stream_lua_ssl_cert_done</code>里面做了什么。主要是设置了完成标志，然后把前端连接的写事件加入了<code>ngx_posted_events</code>队列里。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cctx-&gt;done = <span class="number">1</span>;</span><br><span class="line">ngx_post_event(c-&gt;write, &amp;ngx_posted_events);</span><br></pre></td></tr></table></figure>

<p>定时器超时事件完成之后返回到外层，处理后续的posted队列事件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">void</span>) ngx_process_events(cycle, timer, flags);</span><br><span class="line"></span><br><span class="line">delta = ngx_current_msec - delta;</span><br><span class="line"></span><br><span class="line">ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">               <span class="string">&quot;timer delta: %M&quot;</span>, delta);</span><br><span class="line"></span><br><span class="line">ngx_event_process_posted(cycle, &amp;ngx_posted_accept_events);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">    ngx_shmtx_unlock(&amp;ngx_accept_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (delta) &#123;</span><br><span class="line">    ngx_event_expire_timers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_event_process_posted(cycle, &amp;ngx_posted_events);</span><br></pre></td></tr></table></figure>

<p>因为前端连接的写事件已经设置成<code>ngx_ssl_handshake_handler</code>，所以会再次调用到<code>ngx_ssl_handshake-SSL_do_handshake</code>，这样就再次进入了SSL状态机，又会来到<code>ngx_stream_lua_ssl_cert_handler</code>中。因为是第二次进入了，且已经设置了<code>cctx-&gt;done</code>，所以就直接返回离开码了，其中<code>cctx-&gt;exit_code</code>就是<code>ngx.exit()</code>时的参数，<code>cctx-&gt;exit_code</code>初始化时的默认值时0，但是注意到前面第一次进入<code>ngx_stream_lua_ssl_cert_handler</code>的时候已经将默认值设为1了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cctx &amp;&amp; cctx-&gt;entered_cert_handler) &#123;</span><br><span class="line">    <span class="comment">/* not the first time */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cctx-&gt;done) &#123;</span><br><span class="line">        ngx_log_debug1(NGX_LOG_DEBUG_STREAM, c-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                       <span class="string">&quot;stream lua_certificate_by_lua:&quot;</span></span><br><span class="line">                       <span class="string">&quot; cert cb exit code: %d&quot;</span>,</span><br><span class="line">                       cctx-&gt;exit_code);</span><br><span class="line"></span><br><span class="line">        dd(<span class="string">&quot;lua ssl cert done, finally&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> cctx-&gt;exit_code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，回到了<code>tls_post_process_client_hello()</code>继续后面的握手流程了。</p>
<h1 id="Lua钩子内出错的情况"><a href="#Lua钩子内出错的情况" class="headerlink" title="Lua钩子内出错的情况"></a>Lua钩子内出错的情况</h1><p>出错的流程跟正常结束类似，只不过返回值不一样。<code>ngx.exit()</code>的实现如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ngx.<span class="built_in">exit</span> = function (rc)</span><br><span class="line">    local err = get_string_buf(ERR_BUF_SIZE)</span><br><span class="line">    local errlen = get_size_ptr()</span><br><span class="line">    local r = get_request()</span><br><span class="line">    <span class="keyword">if</span> r == nil then</span><br><span class="line">        error(<span class="string">&quot;no request found&quot;</span>)</span><br><span class="line">    end</span><br><span class="line">    errlen[<span class="number">0</span>] = ERR_BUF_SIZE</span><br><span class="line">    rc = ngx_lua_ffi_exit(r, rc, err, errlen)</span><br><span class="line">    <span class="keyword">if</span> rc == <span class="number">0</span> then</span><br><span class="line">        -- print(<span class="string">&quot;yielding...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">co_yield</span>()</span><br><span class="line">    end</span><br><span class="line">    <span class="keyword">if</span> rc == FFI_DONE then</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    end</span><br><span class="line">    error(ffi_string(err, errlen[<span class="number">0</span>]), <span class="number">2</span>)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>里面会调用ffi函数<code>ngx_stream_lua_ffi_exit()</code>，在其中设置<code>ctx-&gt;exit_code</code>，然后返回<code>NGX_OK</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx-&gt;context &amp; (NGX_STREAM_LUA_CONTEXT_SSL_CERT</span><br><span class="line">                    | NGX_STREAM_LUA_CONTEXT_SSL_CLIENT_HELLO ))</span><br><span class="line">&#123;</span><br><span class="line">    ctx-&gt;exit_code = status;</span><br><span class="line">    ctx-&gt;exited = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到<code>ngx.exit()</code>函数之后，就调用原生的<code>coroutine.yield()</code>，回到我们的主线程<code>run_thread()</code>之后，因为设置了<code>ctx-&gt;exited</code>会调用<code>ngx_stream_lua_handle_exit</code>返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rv = lua_resume(orig_coctx-&gt;co, nrets);</span><br><span class="line"><span class="keyword">switch</span> (rv) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_YIELD:</span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;exited) &#123;</span><br><span class="line">            <span class="keyword">return</span> ngx_stream_lua_handle_exit(L, r, ctx);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ngx_stream_lua_request_cleanup</code>里主要就是清理线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ctx-&gt;cur_co_ctx-&gt;co_status = NGX_STREAM_LUA_CO_DEAD;</span><br><span class="line">ngx_stream_lua_request_cleanup(ctx, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> ctx-&gt;exit_code;</span><br></pre></td></tr></table></figure>

<p>然后返回到<code>sleep_resume</code>，此时<code>rc</code>为<code>ctx-&gt;exit_code</code>，即<code>ngx.ERROR</code>，接下来跟正常结束时一样也是结束我们的请求</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rc = ngx_stream_lua_run_thread(L, r, ctx, <span class="number">0</span>);</span><br><span class="line">...;</span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;entered_content_phase) &#123;</span><br><span class="line">    ngx_stream_lua_finalize_request(r, rc);</span><br><span class="line">    <span class="keyword">return</span> NGX_DONE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rc;</span><br></pre></td></tr></table></figure>

<p>因为是fake请求，<code>ngx_stream_lua_finalize_request</code>调用<code>ngx_stream_lua_finalize_fake_request</code>，里面将<code>cctx-&gt;exit_code</code>设为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (rc == NGX_ERROR || rc &gt;= NGX_STREAM_BAD_REQUEST) &#123;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;connection-&gt;ssl) &#123;</span><br><span class="line">        ssl_conn = r-&gt;connection-&gt;ssl-&gt;connection;</span><br><span class="line">        <span class="keyword">if</span> (ssl_conn) &#123;</span><br><span class="line">            c = ngx_ssl_get_connection(ssl_conn);</span><br><span class="line">            <span class="keyword">if</span> (c &amp;&amp; c-&gt;ssl) &#123;</span><br><span class="line">                cctx = ngx_stream_lua_ssl_get_ctx(c-&gt;ssl-&gt;connection);</span><br><span class="line">                <span class="keyword">if</span> (cctx != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    cctx-&gt;exit_code = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ngx_stream_lua_close_fake_request(r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在清理fake请求的时候调用<code>ngx_stream_lua_request_cleanup_handler</code>清理Lua线程，在清理fake连接的时候会触发<code>ngx_stream_lua_ssl_cert_done</code>，跟正常完成时一样，也是设置完成标志，然后把前端连接的写事件加入了<code>ngx_posted_events</code>队列里。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cctx-&gt;done = <span class="number">1</span>;</span><br><span class="line">ngx_post_event(c-&gt;write, &amp;ngx_posted_events);</span><br></pre></td></tr></table></figure>

<p>到此定时器的事件就结束了，开始处理后续的posted队列事件。同样地，也会再次调用<code>ngx_ssl_handshake_handler</code>最终调到到<code>ngx_stream_lua_ssl_cert_handler</code>中。因为是第二次进入了，且已经设置了<code>cctx-&gt;done</code>，所以就直接返回离开码了，而本次因为是出错<code>cctx-&gt;exit_code</code>的值是0.</p>
<p>返回到OpenSSL之后，一路往上传递错误码。。。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> rv = s-&gt;cert-&gt;cert_cb(s, s-&gt;cert-&gt;cert_cb_arg);</span><br><span class="line"><span class="keyword">if</span> (rv == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">err:</span><br><span class="line"><span class="keyword">return</span> WORK_ERROR;</span><br></pre></td></tr></table></figure>

<p>最终，<code>SSL_do_handshake</code>返回错误值，结束SSL握手。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = SSL_do_handshake(c-&gt;ssl-&gt;connection);</span><br><span class="line">sslerr = SSL_get_error(c-&gt;ssl-&gt;connection, n);</span><br><span class="line">return NGX_ERROR;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们本篇是以一个定时器为例子，对于IO等待其实也是类似的流程。只不过触发事件由定时器超时变成了相应的fd的读写事件，协程的恢复由定时器时的直接恢复变成了完成本次IO任务（或者出错）之后恢复协程。</p>
]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>OpenResty</tag>
        <tag>Nginx</tag>
        <tag>Lua</tag>
        <tag>钩子</tag>
      </tags>
  </entry>
  <entry>
    <title>Openresty Lua协程调度机制</title>
    <url>/posts/150430f0/</url>
    <content><![CDATA[<div class="note primary">
            <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>OpenResty（后面简称：OR）是一个基于Nginx和Lua的高性能Web平台，它内部集成大量的Lua API以及第三方模块，可以利用它快速搭建支持高并发、极具动态性和扩展性的Web应用、Web服务或动态网关。</p><p>OR最大的特点就是，将Lua协程与Nginx事件驱动模型及非阻塞I/O结合起来。使用户可以在handler中使用 <strong>同步但是依然是非阻塞</strong> 的方式编写其应用代码，而无需关心底层的协程调度以及与Nginx事件驱动模型的交互。</p><p>本文将先从总体上介绍OR的协程调度机制，然后结合源码以及Lua栈的情况来详细了解各个部分是如何实现的，包括其异常保护、协程初始化、协程的恢复和执行、协程的挂起、协程的执行结束、协程出错的情况。</p><p>本文主要关注调度函数内部的逻辑，如果想了解外部的调用流程。可以参看<a href="../30b81f82/">Openresty Lua钩子调用完整流程</a></p>
          </div>

<span id="more"></span>

<div class="note default">
            <p>注：<code>lua-nginx</code>模块与<code>stream-lua-nginx</code>模块的主体部分类似，后者实现相对简单一点。下面的讨论将基于<code>stream-lua</code>模块。</p><p>文中用到的一些术语明确一下：</p><ul><li><code>主线程</code>：表示外层调用<code>run_thread()</code>的线程</li><li><code>入口线程</code>：每个handler被调用时会创建一个入口线程，用于执行lua代码</li><li><code>用户线程</code>：用户在Lua代码中通过<code>ngx.thread.spawn()</code>创建的线程</li><li><code>用户协程</code>：用户在Lua代码中通过<code>coroutine.create()</code>创建的协程</li><li><code>协程</code>：泛指所有协程，包括入口线程、用户线程和用户协程</li><li><code>vm</code>：表示Lua虚拟机</li><li><code>L</code>：视出现的上下文，一般表示父协程，在创建入口线程的时候表示Lua VM</li><li><code>co</code>：一般表示新创建的协程</li><li><code>L栈： |顶|新协程|协程表|</code>：表示Lua栈结构，最左边是栈顶</li></ul>
          </div>

<h1 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h1><p>在深入了解协程调度机制之前，我们先来认识一下主要的数据结构：</p>
<ul>
<li>协程上下文：<code>ngx_stream_lua_co_ctx_t</code><ul>
<li>协程内部栈的数据（<code>coctx-&gt;co</code>）</li>
<li>维护协程状态的数据（<code>coctx-&gt;co_status</code>）</li>
<li>维护协程之间关系的数据（父协程<code>coctx-&gt;parent_co_ctx</code>、僵尸子线程<code>coctx-&gt;zombie_child_threads</code>）</li>
<li>用户相关数据（<code>coctx-&gt;data</code>）</li>
<li>在Lua的registry表中对应的该协程指针的引用值（<code>co_ref</code>）</li>
<li>一些状态标记（是否用户线程<code>is_uthread</code>、是否创建新线程<code>thread_spawn_yielded</code>被yield)</li>
</ul>
</li>
<li>全局变量：<code>ngx_stream_lua_ctx_t</code><ul>
<li><code>ctx-&gt;cur_co_ctx</code>（当前调度协程上下文）</li>
<li><code>ctx-&gt;co_op</code>（协程是以何种方式YIELD）</li>
</ul>
</li>
<li>核心调度函数：<code>ngx_stream_lua_run_thread()</code></li>
</ul>
<h1 id="协程调度"><a href="#协程调度" class="headerlink" title="协程调度"></a>协程调度</h1><p>首先你可能很好奇OR为什么要在C引擎层面自己实现协程的调度？或者说这么做的好处是什么？我觉得最主要的原因还是减轻开发者的负担。</p>
<h2 id="如果用纯Lua实现"><a href="#如果用纯Lua实现" class="headerlink" title="如果用纯Lua实现"></a>如果用纯Lua实现</h2><p>我们知道Lua是个非常轻巧的语言，它不像Go有自己的调度器。Lua原生的对协程的操作无非就是<code>coroutine.resume()</code>和<code>coroutine.yield()</code>。试想如果你用纯Lua来处理handler内的所有操作，你的协程的拓扑将是一个复杂的树状结构，非常难以管理调度。万一在某个协程中出错了，你将如何进行清理工作？你如何实现同步但是非阻塞的操作？是不是需要在Lua层自己定义所有的事件及相应的回调？</p>
<h2 id="OpenResty实现"><a href="#OpenResty实现" class="headerlink" title="OpenResty实现"></a>OpenResty实现</h2><p>OR在C引擎层帮我们把这些事情都做了，你无须再关心所有这些，只需专心写你的业务逻辑。为了接管协程的调度，OR重写了<code>coroutine</code>的接口函数，并在<code>coroutine</code>基础上封装抽象出了<code>thread</code>的概念。OR中<code>coroutine</code>的接口行为与原生的类似，<code>yield()</code>和<code>resume()</code>成对出现。而<code>thread</code>则由调度器进行调度，提供了<code>spawn()</code>、<code>wait()</code>等接口。</p>
<div class="note primary">
            <p>OR在对协程调度上，最核心的改动是其创建新协程时的行为（<code>coroutine.resume()</code>, <code>ngx.thread.spawn()</code>）。它不会直接调用<code>lua_resume()</code>，而是先<code>lua_yield()</code>回到主线程，然后由调度器再<code>lua_resume()</code>。Lua代码域内从来不会直接调用<code>lua_resume()</code>，理解了这一点你就理解了OpenResty协程调度的精髓。</p>
          </div>

<p>所以OR中协程拓扑是一个单层的结构，它只有<strong>一个入口点</strong>。这样使得协程调度更加灵活，I/O事件的触发时回调函数也更容易实现。</p>
<p>OR调度器根据<code>lua_resume()</code>的返回值，确定协程是挂起了、结束了还是出错了。因为OR改动了创建新协程时行为，同时又抽象了thread概念，所以如果是协程挂起的情况，还需要知道是什么原因挂起，以便做相应的不同处理。是继续调度？还是返回上层？我们后面会提到的<code>ctx-&gt;co_op</code>便是做这个用途。</p>
<h2 id="协程调度逻辑"><a href="#协程调度逻辑" class="headerlink" title="协程调度逻辑"></a>协程调度逻辑</h2><p>协程的调度在核心调度函数<code>ngx_stream_lua_run_thread()</code>中进行，它是创建或恢复协程的唯一入口点。它里面实现了一个调度循环，循环里面先从<code>ctx-&gt;cur_co_ctx</code>获取下一个待resume的协程上下文，然后<code>lua_resume()</code>执行或恢复该协程，其返回值<code>LUA_YIELD</code>表示协程挂起，<code>0</code>表示协程执行结束，其余的表示协程出错了。其中协程挂起又分为几种不同的情况：即等待I/O、新建thread、<code>coroutine.resume</code>和<code>coroutine.yield</code>。根据不同的情况，决定是跳到循环前面继续调度，还是返回上层函数。</p>
<p>下图是一个协程调度的主要逻辑示意图，可以看到Lua代码域无论是新建、挂起或恢复协程，都是先调用<code>lua_yield()</code>回到主线程。I/O操作例如<code>ngx.tcp.send()</code>如果碰到了I/O等待，会在内部主动<code>lua_yield()</code>，事件触发时恢复未完成的I/O操作，结束之后<code>lua_resume()</code>恢复之前的调用协程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">                                    C region            :   Lua Region</span><br><span class="line">                            &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;:&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<span class="function">v</span></span><br><span class="line"><span class="function"><span class="title">xx_handler</span><span class="params">()</span>                ^                           :   never directly  v</span></span><br><span class="line"><span class="function">+-- <span class="title">by_chunk</span><span class="params">()</span>              ^                           :    <span class="title">lua_resume</span><span class="params">()</span>   v</span></span><br><span class="line"><span class="function">    |-- <span class="title">new_thread</span><span class="params">()</span>        ^                           :   in Lua Region,  v</span></span><br><span class="line"><span class="function">    |-- <span class="title">run_thread</span><span class="params">()</span>        ^                           :    always be      v</span></span><br><span class="line"><span class="function">    |   |-- <span class="title">for</span><span class="params">(;;)</span> </span>&#123;       ^                           :   lua_yield()     v</span><br><span class="line">    |   |-- rv = lua_resume()&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; lua_yield()&lt;&lt;&lt;&lt;&lt;&lt;:&lt;&lt;&lt;&lt;               v</span><br><span class="line">    |   |-- <span class="keyword">switch</span>(rv)                      ^           :   ^               v</span><br><span class="line">    |   |                                   ^           :   ^               v</span><br><span class="line">    |   |-- <span class="keyword">case</span> LUA_YIELD                  ^           :   ^               v</span><br><span class="line">    |   |   |                       (I/O interruption)&lt;&lt;:&lt;&lt;(ngx.tcp.send)   v</span><br><span class="line">    |   |   |-- <span class="keyword">switch</span> (ctx-&gt;co_op)         |           :   ^               v</span><br><span class="line">    |   |   |                               |           :   ^               v</span><br><span class="line">    |   |   |-- <span class="keyword">case</span> NGX_STREAM_LUA_USER_CORO_NOP       :   ^               v</span><br><span class="line">    |   |   |   +-- <span class="keyword">return</span> NGX_AGAIN                    :   ^               v</span><br><span class="line">    |   |   |                                           :   ^               v</span><br><span class="line">    |   |   |-- <span class="keyword">case</span> NGX_STREAM_LUA_USER_THREAD_RESUME--:--(ngx.thread.spwan)</span><br><span class="line">    |   |   |                                           :</span><br><span class="line">    |   |   |-- <span class="keyword">case</span> NGX_STREAM_LUA_USER_CORO_RESUME----:--(coroutine.resume)</span><br><span class="line">    |   |   |                                           :</span><br><span class="line">    |   |   +-- <span class="keyword">case</span> NGX_STREAM_LUA_USER_CORO_YIELD-----:--(coroutine.yield)</span><br><span class="line">    |   |                                               :</span><br><span class="line">    |   |-- <span class="keyword">case</span> <span class="number">0</span> (coroutine finish work)</span><br><span class="line">    |   |</span><br><span class="line">    |   |-- <span class="keyword">case</span> XXX_ERR (error)                </span><br><span class="line">    |   +-- &#125;   <span class="comment">/* for&#123;;;&#125; */</span>                   OpenResty Coroutine</span><br><span class="line">    |                                               Schedule</span><br><span class="line">    |-- run_posted_threads()                       by catbro666</span><br><span class="line">    |   |-- run_thread()                            <span class="number">2021.07</span><span class="number">.02</span></span><br><span class="line">    +-- <span class="keyword">return</span>                                      </span><br></pre></td></tr></table></figure>







<h1 id="异常保护"><a href="#异常保护" class="headerlink" title="异常保护"></a>异常保护</h1><p>作为一个调度器，OpenResty扮演者类似操作系统内核的角色，不过它的调度对象是Lua协程。作为一个“内核”，无论其调度对象出了什么问题，都不应该使这个系统崩溃，而是应该将错误信息打印出来。</p>
<p>Openresty内部就做了一个这样的异常保护，其原理就是用<code>setjmp</code>、<code>longjmp</code>包住了<code>run_thread()</code>里面的整个协程调度逻辑。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 首先注册虚拟机的panic回调 */</span></span><br><span class="line">lua_atpanic(L, ngx_stream_lua_atpanic);</span><br><span class="line"><span class="comment">/* setjmp保存环境 */</span></span><br><span class="line">NGX_LUA_EXCEPTION_TRY &#123;</span><br><span class="line">    <span class="comment">/* 执行调度逻辑 */</span></span><br><span class="line">&#125; NGX_LUA_EXCEPTION_CATCH &#123;</span><br><span class="line">    <span class="comment">/* 出现异常时走到这里 */</span></span><br><span class="line">    dd(<span class="string">&quot;nginx execution restored&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ngx_stream_lua_atpanic()</code>的实现也非常简单，只是简单地打印崩溃日志，然后调用<code>NGX_LUA_EXCEPTION_THROW(1);</code>恢复nginx的执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_stream_lua_atpanic</span><span class="params">(lua_State *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NGX_LUA_ABORT_AT_PANIC</span></span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    u_char                  *s = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span>                   len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lua_type(L, <span class="number">-1</span>) == LUA_TSTRING) &#123;</span><br><span class="line">        s = (u_char *) lua_tolstring(L, <span class="number">-1</span>, &amp;len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        s = (u_char *) <span class="string">&quot;unknown reason&quot;</span>;</span><br><span class="line">        len = <span class="keyword">sizeof</span>(<span class="string">&quot;unknown reason&quot;</span>) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_log_stderr(<span class="number">0</span>, <span class="string">&quot;lua atpanic: Lua VM crashed, reason: %*s&quot;</span>, len, s);</span><br><span class="line">    ngx_quit = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  restore nginx execution */</span></span><br><span class="line">    NGX_LUA_EXCEPTION_THROW(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* impossible to reach here */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这几个宏定义分别如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_LUA_EXCEPTION_TRY                                                \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (setjmp(ngx_stream_lua_exception) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_LUA_EXCEPTION_CATCH                                              \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_LUA_EXCEPTION_THROW(x)                                           \</span></span><br><span class="line"><span class="meta">    longjmp(ngx_stream_lua_exception, (x))</span></span><br></pre></td></tr></table></figure>



<h1 id="协程初始化"><a href="#协程初始化" class="headerlink" title="协程初始化"></a>协程初始化</h1><h2 id="钩子的入口线程"><a href="#钩子的入口线程" class="headerlink" title="钩子的入口线程"></a>钩子的入口线程</h2><p><code>ngx_stream_lua_new_thread()</code>用于创建入口线程</p>
<p>OR中需要在Registry表中存储每个创建出来的Lua线程的reference，这个存储协程的表在Registry表中对应的key是全局变量<code>ngx_stream_lua_coroutines_key</code>的地址，因此下面这段代码就是从Registry表中查询这个储存协程的表，返回到栈顶：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 返回栈顶元素的索引，等于栈中元素的个数 */</span></span><br><span class="line">base = lua_gettop(L);</span><br><span class="line"><span class="comment">/* 将存储协程的表对应的key压栈 */</span></span><br><span class="line">lua_pushlightuserdata(L, ngx_stream_lua_lightudata_mask(</span><br><span class="line">                      coroutines_key));</span><br><span class="line"><span class="comment">/* 将key出栈，获取Registry表中key对应的元素，然后将结果入栈 */</span></span><br><span class="line">lua_rawget(L, LUA_REGISTRYINDEX);</span><br></pre></td></tr></table></figure>

<p>接下来创建一个新的协程，同时初始化其全局表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建Lua协程，返回的新lua_State跟原有的lua_State共享所有的全局对象（如表），</span></span><br><span class="line"><span class="comment">   但是有一个独立的执行栈。 协程依赖垃圾回收销毁 */</span></span><br><span class="line"><span class="comment">/* L栈： |顶|新协程|协程表| */</span></span><br><span class="line">co = lua_newthread(L);  </span><br><span class="line"><span class="comment">/* 创建该协程的全局表，设置_G field为全局表自己 */</span></span><br><span class="line"><span class="comment">/* L栈： |顶|协程新的全局表|新协程|协程表| */</span></span><br><span class="line">ngx_stream_lua_create_new_globals_table(co, <span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line"><span class="comment">/* 再创建一个新表 */</span></span><br><span class="line"><span class="comment">/* L栈： |顶|新表|协程新的全局表|新协程|协程表| */</span></span><br><span class="line">lua_createtable(co, <span class="number">0</span>, <span class="number">1</span>);  </span><br><span class="line"><span class="comment">/* 拿到全局表 */</span></span><br><span class="line"><span class="comment">/* L栈： |顶|旧全局表|新表|协程新的全局表|新协程|协程表| */</span></span><br><span class="line">ngx_stream_lua_get_globals_table(co);   </span><br><span class="line"><span class="comment">/* 新表的__index的值为栈顶的值，也即就全局表 */</span></span><br><span class="line"><span class="comment">/* L栈： |顶|新表|协程新的全局表|新协程|协程表| */</span></span><br><span class="line">lua_setfield(co, <span class="number">-2</span>, <span class="string">&quot;__index&quot;</span>);    </span><br><span class="line"><span class="comment">/* 新表出栈，将其设为-2即协程新的全局表的新元表 */</span></span><br><span class="line"><span class="comment">/* L栈： |顶|协程新的全局表|新协程|协程表| */</span></span><br><span class="line">lua_setmetatable(co, <span class="number">-2</span>);</span><br><span class="line"><span class="comment">/* 设置协程新的全局表到对应索引，其_G field是自己，</span></span><br><span class="line"><span class="comment">   其元表是新表，新表的__index是父协程的全局表 */</span></span><br><span class="line"><span class="comment">/* L栈： |顶|新协程|协程表| */</span></span><br><span class="line">ngx_stream_lua_set_globals_table(co);</span><br></pre></td></tr></table></figure>

<p>这一块的逻辑有点绕，我们来稍微理一下，其实就是用新建的全局表替换了旧的全局表，其中新的全局表的<code>_G</code>字段是它自己，新全局表的元表中<code>__index</code>是旧的全局表。</p>
<p>此时的Lua虚拟机栈顶情况如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L-&gt;top      |   栈顶    |</span><br><span class="line">L-&gt;top - 1  |Lua_State*|    新创建的协程</span><br><span class="line">L-&gt;top -2   | Lua Table|    存储协程引用的表</span><br></pre></td></tr></table></figure>

<p>下面一步就是在Lua虚拟机中创建一个reference保存这个新创建的协程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 为栈顶对象（即新协程），创建并返回一个协程表中的引用 */</span></span><br><span class="line"><span class="comment">/* 当前栈： |顶|协程表| */</span></span><br><span class="line">*ref = luaL_ref(L, <span class="number">-2</span>);</span><br><span class="line"><span class="keyword">if</span> (*ref == LUA_NOREF) &#123;</span><br><span class="line">    lua_settop(L, base);  <span class="comment">/* restore main thread stack */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后恢复堆栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置栈顶索引 */</span></span><br><span class="line"><span class="comment">/* 当前栈： |顶| */</span></span><br><span class="line">lua_settop(L, base);    </span><br><span class="line"><span class="keyword">return</span> co;</span><br></pre></td></tr></table></figure>

<p>以上步骤还只是创建了一个什么都不能做的Lua协程，回到<code>_by_chunk()</code>函数之后还需要把入口函数放入协程中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将lua虚拟机VM的入口函数closure move到新创建的协程上面，</span></span><br><span class="line"><span class="comment">   这样协程就有了虚拟机已经解析完毕的代码了。*/</span></span><br><span class="line">lua_xmove(L, co, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 拿到co全局表，放到栈顶 */</span></span><br><span class="line"><span class="comment">/* 当前栈： |顶|全局表|入口closure| */</span></span><br><span class="line">ngx_stream_lua_get_globals_table(co);</span><br><span class="line"><span class="comment">/* 将全局表设为入口closure的环境表 */</span></span><br><span class="line"><span class="comment">/* 当前栈： |顶|入口closure| */</span></span><br><span class="line">lua_setfenv(co, <span class="number">-2</span>);</span><br></pre></td></tr></table></figure>

<p>至此，协程入口函数以及环境表已经设置好。接下来就是让它能够运行起来，让调度器能够调度它运行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将nginx请求保存到协程全局表 */</span></span><br><span class="line">ngx_stream_lua_set_req(co, r);</span><br><span class="line"></span><br><span class="line">ctx-&gt;cur_co_ctx = &amp;ctx-&gt;entry_co_ctx;</span><br><span class="line">ctx-&gt;cur_co_ctx-&gt;co = co;</span><br><span class="line">ctx-&gt;cur_co_ctx-&gt;co_ref = co_ref;</span><br></pre></td></tr></table></figure>

<p>接下来就是设置cleanup，然后<code>ngx_stream_lua_run_thread()</code>。</p>
<h2 id="用户创建的uthread"><a href="#用户创建的uthread" class="headerlink" title="用户创建的uthread"></a>用户创建的uthread</h2><p><code>ngx.thread.spawn()</code>，对应的实现是<code>ngx_stream_lua_uthread_spawn</code>()。首先它会调<code>ngx_stream_lua_coroutine_create_helper()</code>创建一个新的协程。</p>
<h3 id="创建协程"><a href="#创建协程" class="headerlink" title="创建协程"></a>创建协程</h3><p>注意协程都是在worker的虚拟机上创建的，在Lua层面协程只有两层父子关系。但是用户协程会继承父协程的全局表，其父子关系由OR进行维护。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取虚拟机 */</span></span><br><span class="line">vm = ngx_stream_lua_get_lua_vm(r, ctx);</span><br><span class="line"><span class="comment">/* 创建新协程 */</span></span><br><span class="line"></span><br><span class="line">co = lua_newthread(vm);</span><br><span class="line"><span class="comment">/* 然后创建coctx，设置其co、co_status值 */</span></span><br><span class="line">coctx = ngx_stream_lua_create_co_ctx;</span><br><span class="line">coctx-&gt;co = co;</span><br><span class="line">coctx-&gt;co_status = NGX_STREAM_LUA_CO_SUSPENDED;</span><br></pre></td></tr></table></figure>

<p>此时父协程的栈如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 当前栈: |顶|args|entry_func| */</span><br></pre></td></tr></table></figure>

<p>接下来将父协程的全局表给新创建的协程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* make new coroutine share globals of the parent coroutine.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> globals don&#x27;t have to be separated! */</span></span><br><span class="line"><span class="comment">/* 拷贝父协程的全局表到栈上 */</span></span><br><span class="line"><span class="comment">/* L栈: |顶|全局表|args|entry_func| */</span></span><br><span class="line">ngx_stream_lua_get_globals_table(L);</span><br><span class="line"><span class="comment">/* 将全局表移动到新创建的协程co的栈上 */</span></span><br><span class="line"><span class="comment">/* L栈: |顶|args|entry_func| */</span></span><br><span class="line">lua_xmove(L, co, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 从新协程栈上写入其的全局表 */</span></span><br><span class="line">ngx_stream_lua_set_globals_table(co);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将新协程从进程虚拟机，移动到父协程中 */</span></span><br><span class="line"><span class="comment">/* L栈: |顶|新协程|args|entry_func| */</span></span><br><span class="line">lua_xmove(vm, L, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 入口函数拷贝到L栈顶 */</span></span><br><span class="line"><span class="comment">/* L栈: |顶|entry_func|新协程|args|entry_func| */</span></span><br><span class="line">lua_pushvalue(L, <span class="number">1</span>); </span><br><span class="line"><span class="comment">/* 将入口函数从L移到co栈中 */</span></span><br><span class="line"><span class="comment">/* L栈: |顶|新协程|args|entry_func| */</span></span><br><span class="line"><span class="comment">/* co栈: |顶|entry_func|*/</span></span><br><span class="line">lua_xmove(L, co, <span class="number">1</span>);  </span><br></pre></td></tr></table></figure>

<p><code>create_helper</code>函数返回之后，L的栈顶是新协程，co的栈顶是入口函数。</p>
<h3 id="初始化uthread"><a href="#初始化uthread" class="headerlink" title="初始化uthread"></a>初始化uthread</h3><p><code>ngx_stream_lua_coroutine_create_helper</code>返回之后，进行uthread的初始化。</p>
<p>此时，父协程L是这样的：</p>
<ul>
<li>栈顶是新创建的协程</li>
<li>然后是参数和入口函数</li>
</ul>
<p>在此之前，先在registry表中保存一个该协程的ref。（到现在还没搞明白这个ref是干嘛用的？除了创建线程和删除线程，貌似只有检查线程是否活着的时候会查一下这个ref，只是检查状态用<code>coctx-&gt;co_status</code>不是也能做到么）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* anchor the newly created coroutine into the Lua registry */</span></span><br><span class="line"><span class="comment">/* 把新创建的协程写入Lua registry表中 */</span></span><br><span class="line"><span class="comment">/* 将ngx_stream_lua_coroutines_key的地址压入栈中 */</span></span><br><span class="line">lua_pushlightuserdata(L, &amp;ngx_stream_lua_coroutines_key);</span><br><span class="line"><span class="comment">/* 从registry表中获取协程表 */</span></span><br><span class="line"><span class="comment">/* L栈: |顶|协程表|新协程|args|entry_func| */</span></span><br><span class="line">lua_rawget(L, LUA_REGISTRYINDEX);</span><br><span class="line"><span class="comment">/* 将新协程压栈 */</span></span><br><span class="line"><span class="comment">/* L栈: |顶|新协程|协程表|新协程|args|entry_func| */</span></span><br><span class="line">lua_pushvalue(L, <span class="number">-2</span>);</span><br><span class="line"><span class="comment">/* -2位置是注册表，为新协程创建在报表中的索引 */</span></span><br><span class="line"><span class="comment">/* L栈: |顶|协程表|新协程|args|entry_func| */</span></span><br><span class="line">coctx-&gt;co_ref = luaL_ref(L, <span class="number">-2</span>);    <span class="comment">// </span></span><br><span class="line"><span class="comment">/* 弹出协程表 */</span></span><br><span class="line"><span class="comment">/* L栈: |顶|新协程|args|entry_func| */</span></span><br><span class="line">lua_pop(L, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>接下来是初始化运行环境：</p>
<p>此时的，L的栈情况如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|新协程|参数n|...|参数1|entry_func|</span><br><span class="line">  - 1   -2  ...   2      1</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 由于lua函数压栈顺序是从左到右</span></span><br><span class="line"><span class="comment">     * 因此1就是压入的第一个参数，而spawn的第一个参数就是入口函数</span></span><br><span class="line"><span class="comment">     * 把栈顶元素（即新协程）拷贝到1，覆盖入口函数，入口函数前面已经拷贝到新协程栈上了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* L栈: |顶|args|新协程| */</span></span><br><span class="line">    lua_replace(L, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 将参数压入新协程栈中 */</span></span><br><span class="line">    <span class="comment">/* L栈: |顶|新协程| */</span></span><br><span class="line">    <span class="comment">/* co栈: |顶|args|入口函数| */</span></span><br><span class="line">    lua_xmove(L, coctx-&gt;co, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存状态，设置协程的父子关系，设置新协程为下一个调度的线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置状态 */</span></span><br><span class="line">coctx-&gt;co_status = NGX_STREAM_LUA_CO_RUNNING;</span><br><span class="line">ctx-&gt;co_op = NGX_STREAM_LUA_USER_THREAD_RESUME;</span><br><span class="line">ctx-&gt;cur_co_ctx-&gt;thread_spawn_yielded = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将父协程放入post_thread队列中 */</span></span><br><span class="line">ngx_stream_lua_post_thread(r, ctx, ctx-&gt;cur_co_ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存子线程的父协程上下文为当前协程 */</span></span><br><span class="line">coctx-&gt;parent_co_ctx = ctx-&gt;cur_co_ctx;</span><br><span class="line"><span class="comment">/* 切换当前协程为新创建的协程 */</span></span><br><span class="line">ctx-&gt;cur_co_ctx = coctx;</span><br></pre></td></tr></table></figure>

<p>最后，spawn函数的返回值是新创建的协程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将原协程的执行权切换出去，这里的参数1表示栈上留了一个值，这里是指新创建的协程</span></span><br><span class="line"><span class="comment"> * 主线程并不会取这个值，而是等到新线程spawn返回时作为返回值。</span></span><br><span class="line"><span class="comment"> * 此时L栈中是新协程，co栈中是参数和入口函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> lua_yield(L, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="用户创建的coroutine"><a href="#用户创建的coroutine" class="headerlink" title="用户创建的coroutine"></a>用户创建的coroutine</h2><p>OR替换了原生的coroutine接口，当存在<code>getfenv(0).__ngx_req</code>时，使用新的修改后的coroutine接口函数。</p>
<p><code>create()</code>创建新协程部分跟uthread是一样的，都是调用<code>ngx_stream_lua_coroutine_create_helper()</code>。Lua函数返回新协程。此时新协程栈中是入口函数。</p>
<p><code>resume()</code>用于开始或恢复新协程，其调用C函数<code>ngx_http_lua_coroutine_resume()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 首先，获取到协程 */</span></span><br><span class="line"><span class="comment">/* L栈: |参数|co|,  co栈: |入口函数| */</span></span><br><span class="line">co = lua_tothread(L, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 然后设置状态和父子关系 */</span></span><br><span class="line"><span class="comment">/* 父协程为normal */</span></span><br><span class="line">p_coctx-&gt;co_status = NGX_HTTP_LUA_CO_NORMAL;</span><br><span class="line"></span><br><span class="line">coctx-&gt;parent_co_ctx = p_coctx;</span><br><span class="line"></span><br><span class="line">dd(<span class="string">&quot;set coroutine to running&quot;</span>);</span><br><span class="line"><span class="comment">/* 子协程为running */</span></span><br><span class="line">coctx-&gt;co_status = NGX_HTTP_LUA_CO_RUNNING;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置co_op告知主线程yield类型 */</span></span><br><span class="line">ctx-&gt;co_op = NGX_HTTP_LUA_USER_CORO_RESUME;</span><br><span class="line"><span class="comment">/* 设置下一个调度协程为新协程 */</span></span><br><span class="line">ctx-&gt;cur_co_ctx = coctx;</span><br></pre></td></tr></table></figure>

<p>接下来，将控制权交还给主协程，并把参数传给主线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此时L栈: |参数|co|， co栈: |入口函数| */</span></span><br><span class="line"><span class="comment">/* lua_gettop(L) - 1表示留在栈中的返回值个数，</span></span><br><span class="line"><span class="comment"> * 由主线程取用之后，在lua_resume新协程时传递 */</span></span><br><span class="line"><span class="comment">/* 减一个，表示不传底下的co */</span></span><br><span class="line"><span class="keyword">return</span> lua_yield(L, lua_gettop(L) - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h1 id="协程执行和恢复"><a href="#协程执行和恢复" class="headerlink" title="协程执行和恢复"></a>协程执行和恢复</h1><p>OR中协程的执行和恢复总是由主线程来进行，不管是<code>coroutine.resume()</code>还是<code>ngx.thread.spawn()</code>，都是先<code>lua_yield()</code>回到主线程之后，在主线程中<code>lua_resume()</code>。</p>
<p>注意到前面创建阶段，thread是<code>lua_yield(L, 1)</code>，coroutine是<code>lua_yield(L, lua_gettop(L) - 1)</code>。yield到主线程之后，我们继续看调度程序的处理。</p>
<h2 id="uthread"><a href="#uthread" class="headerlink" title="uthread"></a>uthread</h2><p>先获取参数个数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 因为入口函数和参数已经在新线程栈中了,所以从新协程中获取参数个数，-1是除掉入口函数 */</span></span><br><span class="line">nrets = lua_gettop(ctx-&gt;cur_co_ctx-&gt;co) - <span class="number">1</span>;    </span><br></pre></td></tr></table></figure>

<p>然后跳到主循环的前面，执行新线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 保存新协程coctx */</span></span><br><span class="line">orig_coctx = ctx-&gt;cur_co_ctx;</span><br><span class="line"><span class="comment">/* 执行新线程，其中nrets为参数个数 */</span></span><br><span class="line">rv = lua_resume(orig_coctx-&gt;co, nrets);</span><br></pre></td></tr></table></figure>

<p>在<code>lua_resume</code>中就会开始新线程的执行。</p>
<h2 id="coroutine"><a href="#coroutine" class="headerlink" title="coroutine"></a>coroutine</h2><p>同样是先获取参数个数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取父协程 */</span></span><br><span class="line">old_co = ctx-&gt;cur_co_ctx-&gt;parent_co_ctx-&gt;co;</span><br><span class="line"><span class="comment">/* 因为参数还在父协程栈中，所以从父协程栈中获取参数个数 */</span></span><br><span class="line">nrets = lua_gettop(old_co);</span><br><span class="line"><span class="keyword">if</span> (nrets) &#123;</span><br><span class="line">    <span class="comment">/* 将参数从父协程移到子协程 */</span></span><br><span class="line">    lua_xmove(old_co, ctx-&gt;cur_co_ctx-&gt;co, nrets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时子协程栈中是参数和入口函数。</p>
<p>然后跳到主循环的前面，执行新协程，跟前面uthread时一样。</p>
<h1 id="协程挂起"><a href="#协程挂起" class="headerlink" title="协程挂起"></a>协程挂起</h1><p>协程的挂起分为两种情况：</p>
<ul>
<li>一种是内部在I/O等待时自动挂起，这种情况用户不用参与，OR会自动将相应的事件及其handler挂到事件驱动上，当事件被唤醒时由调度器恢复对应协程的执行。</li>
<li>另一种是用户在Lua层主动调用<code>coroutine.yield()</code>挂起。此时由调度器根据情况决定执行下一个执行的协程。(<code>ngx.thread.spawn()</code>和<code>coroutine.resume()</code>也会导致父协程挂起，这种情况我们已经归到前一章《协程执行和恢复》里面了)</li>
</ul>
<h2 id="显式主动挂起"><a href="#显式主动挂起" class="headerlink" title="显式主动挂起"></a>显式主动挂起</h2><p>我们先来看用户主动挂起的情况，<code>coroutine.yield()</code>会调用到<code>ngx_stream_lua_coroutine_yield()</code>。我们先来看看它里面干了些什么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 首先修改当前协程的状态为挂起 */</span></span><br><span class="line">coctx = ctx-&gt;cur_co_ctx;</span><br><span class="line">coctx-&gt;co_status = NGX_STREAM_LUA_CO_SUSPENDED;</span><br><span class="line"><span class="comment">/* 设置co_op */</span></span><br><span class="line">ctx-&gt;co_op = NGX_STREAM_LUA_USER_CORO_YIELD;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果不是用户线程，且有父协程，也即是普通coroutine，</span></span><br><span class="line"><span class="comment">   将其父协程状态设置为running */</span></span><br><span class="line"><span class="keyword">if</span> (!coctx-&gt;is_uthread &amp;&amp; coctx-&gt;parent_co_ctx) &#123;</span><br><span class="line">    coctx-&gt;parent_co_ctx-&gt;co_status = NGX_STREAM_LUA_CO_RUNNING;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 最后将控制权交还主线程，将所有参数传递给主线程 */</span></span><br><span class="line"><span class="comment">/* yield and pass retvals to main thread,</span></span><br><span class="line"><span class="comment"> * and resume parent coroutine there */</span></span><br><span class="line"><span class="keyword">return</span> lua_yield(L, lua_gettop(L));</span><br></pre></td></tr></table></figure>

<p>回到主线程之后，根据待挂起协程是thread还是corotine进行不同处理。</p>
<h3 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ngx_stream_lua_is_thread(ctx)) &#123;</span><br><span class="line">    <span class="comment">/* 丢弃coroutine.yield()的任何参数 */</span></span><br><span class="line">    lua_settop(ctx-&gt;cur_co_ctx-&gt;co, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 因为thread由调度器负责调度，所以将当前线程的状态改为running，为什么不在一起改？*/</span></span><br><span class="line">    ctx-&gt;cur_co_ctx-&gt;co_status = NGX_STREAM_LUA_CO_RUNNING;</span><br><span class="line">    <span class="comment">/* 如果已经有pending的线程，则放到队列中 */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;posted_threads) &#123;</span><br><span class="line">        ngx_stream_lua_post_thread(r, ctx, ctx-&gt;cur_co_ctx);</span><br><span class="line">        ctx-&gt;cur_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 否则，立即恢复线程 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="coroutine-1"><a href="#coroutine-1" class="headerlink" title="coroutine"></a>coroutine</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取当前栈的高度，也即coroutine.yield()的参数个数 */</span></span><br><span class="line">nrets = lua_gettop(ctx-&gt;cur_co_ctx-&gt;co);</span><br><span class="line"><span class="comment">/* 设置父协程为下一个调度的协程 */</span></span><br><span class="line">next_coctx = ctx-&gt;cur_co_ctx-&gt;parent_co_ctx;</span><br><span class="line">next_co = next_coctx-&gt;co;</span><br><span class="line"><span class="comment">/* 将参数从子协程栈中移到父协程栈中 */</span></span><br><span class="line"><span class="keyword">if</span> (nrets) &#123;</span><br><span class="line">    dd(<span class="string">&quot;moving %d return values to next co&quot;</span>, nrets);</span><br><span class="line">    lua_xmove(ctx-&gt;cur_co_ctx-&gt;co, next_co, nrets);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NGX_LUA_USE_ASSERT</span></span><br><span class="line">    ctx-&gt;cur_co_ctx-&gt;co_top -= nrets;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*) 如果不是wrap封装的，还要加一个true，作为第一个参数 */</span></span><br><span class="line"><span class="keyword">if</span> (!ctx-&gt;cur_co_ctx-&gt;is_wrap) &#123;</span><br><span class="line">    <span class="comment">/* prepare return values for coroutine.resume</span></span><br><span class="line"><span class="comment">     * (true plus any retvals)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lua_pushboolean(next_co, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 插入1的位置，作为第一个参数 */</span></span><br><span class="line">    lua_insert(next_co, <span class="number">1</span>);</span><br><span class="line">    nrets++; <span class="comment">/* add the true boolean value */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx-&gt;cur_co_ctx = next_coctx;</span><br><span class="line"><span class="comment">/* 回到主循环的前面，resume父协程 */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h2 id="I-O等待场景"><a href="#I-O等待场景" class="headerlink" title="I/O等待场景"></a>I/O等待场景</h2><p>I/O等待的场景有很多，不过其背后的原理都差不多：</p>
<ul>
<li>定义一个事件，设置恢复时的handler及对应协程上下文，然后<code>lua_yield()</code>回到<code>run_thread</code>。</li>
<li>主线程将<code>ctx-&gt;cur_co_ctx</code>设为空之后，直接返回<code>NGX_AGAIN</code>，如果有<code>posted_thread</code>会继续执行，否则将控制权交还给nginx层</li>
<li>后续当事件发生时，将保存的协程上下文设为<code>ctx-&gt;cur_co_ctx</code>，然后调用<code>ngx_stream_lua_run_thread()</code>恢复协程的调度执行。</li>
</ul>
<p>这里举两个典型的例子:</p>
<h3 id="ngx-sleep"><a href="#ngx-sleep" class="headerlink" title="ngx.sleep()"></a>ngx.sleep()</h3><p>它的C函数实现是<code>ngx_stream_lua_ngx_sleep()</code>，先定义设置好handler和coctx，挂上定时器，然后<code>lua_yield()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    ngx_stream_lua_cleanup_pending_operation(coctx);</span><br><span class="line">    coctx-&gt;cleanup = ngx_stream_lua_sleep_cleanup;</span><br><span class="line">    coctx-&gt;data = r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 保存恢复时的handler和协程上下文 */</span></span><br><span class="line">    coctx-&gt;sleep.handler = ngx_stream_lua_sleep_handler;</span><br><span class="line">    coctx-&gt;sleep.data = coctx;</span><br><span class="line">    coctx-&gt;sleep.<span class="built_in">log</span> = r-&gt;connection-&gt;<span class="built_in">log</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当delay为0时，放入post_event队列或添加定时器 */</span></span><br><span class="line">    <span class="keyword">if</span> (delay == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_POSTED_DELAYED_EVENTS_PATCH</span></span><br><span class="line">        dd(<span class="string">&quot;posting 0 sec sleep event to head of delayed queue&quot;</span>);</span><br><span class="line"></span><br><span class="line">        coctx-&gt;sleep.delayed = <span class="number">1</span>;</span><br><span class="line">        ngx_post_event(&amp;coctx-&gt;sleep, &amp;ngx_posted_delayed_events);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        ngx_log_error(NGX_LOG_WARN, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;ngx.sleep(0)&quot;</span></span><br><span class="line">                      <span class="string">&quot; called without delayed events patch, this will&quot;</span></span><br><span class="line">                      <span class="string">&quot; hurt performance&quot;</span>);</span><br><span class="line">        ngx_add_timer(&amp;coctx-&gt;sleep, (<span class="keyword">ngx_msec_t</span>) delay);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">/* 添加定时器 */</span></span><br><span class="line">        ngx_add_timer(&amp;coctx-&gt;sleep, (<span class="keyword">ngx_msec_t</span>) delay);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 外层函数*/</span></span><br><span class="line">    <span class="keyword">return</span> lua_yield(L, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在<code>run_thread()</code>里将当前协程上下文置为<code>NULL</code>，然后返回<code>NGX_AGAIN</code></p>
<p>在<code>by_chunk()</code>里会先检查有没有在post队列里的线程，如果没有则返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rc = ngx_stream_lua_run_thread(L, r, ctx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rc == NGX_ERROR || rc &gt;= NGX_OK) &#123;</span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == NGX_AGAIN) &#123;</span><br><span class="line">    rc = ngx_stream_lua_content_run_posted_threads(L, r, ctx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == NGX_DONE) &#123; <span class="comment">/* 这里DONE的情况只有HTTP子请求的时候会出现 */</span></span><br><span class="line">    rc = ngx_stream_lua_content_run_posted_threads(L, r, ctx, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    rc = NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当定时器超时时，它会执行<code>sleep_handler()</code>，设置<code>ctx-&gt;cur_co_ctx</code>然后执行<code>run_thread()</code>恢复协程调度。</p>
<h3 id="ngx-tcp-receive"><a href="#ngx-tcp-receive" class="headerlink" title="ngx.tcp.receive()"></a>ngx.tcp.receive()</h3><p>其对应的C函数实现是<code>ngx_stream_lua_socket_tcp_receive()</code>，里面会调<code>ngx_stream_lua_socket_tcp_receive_helper()</code>。碰到读等待的情况，也是先设置好handler和coctx，然后<code>lua_yield()</code>。我们来看下里面代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这里0表示还未进行协程切换 */</span></span><br><span class="line">u-&gt;read_waiting = <span class="number">0</span>;</span><br><span class="line">u-&gt;read_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取的主要逻辑由此函数处理 */</span></span><br><span class="line">rc = ngx_stream_lua_socket_tcp_read(r, u);</span><br><span class="line"><span class="comment">/* 不管是成功、出错或等待I/O，肯定会返回 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* rc == NGX_AGAIN */</span></span><br><span class="line"><span class="comment">/* 如果是等待I/O的情况，设置事件触发时的handler、当前协程上下文 */</span></span><br><span class="line">u-&gt;read_event_handler = ngx_stream_lua_socket_read_handler;</span><br><span class="line">coctx = lctx-&gt;cur_co_ctx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置请求的写事件handler，这个是返回到Lua层前调用的handler */</span></span><br><span class="line">r-&gt;write_event_handler = ngx_stream_lua_content_wev_handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存当前协程上下文到u上 */</span></span><br><span class="line">u-&gt;read_co_ctx = coctx;</span><br><span class="line"><span class="comment">/* 表示是后续是需要协程恢复的 */</span></span><br><span class="line">u-&gt;read_waiting = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 设置准备返回值的回调 */</span></span><br><span class="line">u-&gt;read_prepare_retvals = ngx_stream_lua_socket_tcp_receive_retval_handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lua_yield(L, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>回到<code>run_thread()</code>，同样是将当前协程上下文置为<code>NULL</code>，然后返回<code>NGX_AGAIN</code>。</p>
<p>当事件被触发时，执行前面设置的<code>ngx_stream_lua_socket_read_handler()</code>，里面又会调用读取操作核心函数<code>ngx_stream_lua_socket_tcp_read()</code>。如果继续碰到等待I/O，handler直接结束，等待下一次事件。如果是完成或出错，会执行如下操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 恢复该值为0 */</span></span><br><span class="line">u-&gt;read_waiting = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 获取协程上下文 */</span></span><br><span class="line">coctx = u-&gt;read_co_ctx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置协程恢复的handler */</span></span><br><span class="line">ctx-&gt;resume_handler = ngx_stream_lua_socket_tcp_read_resume;</span><br><span class="line"><span class="comment">/* 设置下一个调度的上下文，为之前调用读取操作的协程 */</span></span><br><span class="line">ctx-&gt;cur_co_ctx = coctx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个handler就是yield之前设置的那个，它里面调用 ctx-&gt;resume_handler */</span></span><br><span class="line">r-&gt;write_event_handler(r);  </span><br></pre></td></tr></table></figure>

<p><code>r-&gt;write_event_handler(r);</code>是返回Lua层前调用的handler，里面会调用<code>resume_handler</code>。<code>ngx_stream_lua_socket_tcp_read_resume()</code>只是封装了一下，最终都是调用的<code>ngx_stream_lua_socket_tcp_resume_helper()</code>，我们看来下它的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 待恢复协程上下文 */</span></span><br><span class="line">coctx = ctx-&gt;cur_co_ctx;</span><br><span class="line"></span><br><span class="line">u = coctx-&gt;data;</span><br><span class="line">prepare_retvals = u-&gt;read_prepare_retvals;</span><br><span class="line"><span class="comment">/* 准备返回值 */</span></span><br><span class="line">nret = prepare_retvals(r, u, ctx-&gt;cur_co_ctx-&gt;co);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复协程调度，回到Lua层 */</span></span><br><span class="line">rc = ngx_stream_lua_run_thread(vm, r, ctx, nret);</span><br></pre></td></tr></table></figure>

<p>至于完成的条件，取决与不同的调用方式。如果是读取固定字节数的话，会维护一个剩余待读取的字节数<code>u-&gt;rest</code>。如果是读取一行，则读取到<code>\n</code>就结束。如果是readall，则一直读到<code>u-&gt;eof</code>为止。</p>
<h1 id="协程执行完毕"><a href="#协程执行完毕" class="headerlink" title="协程执行完毕"></a>协程执行完毕</h1><p>为了不失完整性，再说一下正常结束和出错时的情况。正常执行完毕时，会设置协程状态，然后清理它的僵尸子线程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将当前协程状态置为DEAD */</span></span><br><span class="line">ctx-&gt;cur_co_ctx-&gt;co_status = NGX_STREAM_LUA_CO_DEAD;</span><br><span class="line"><span class="comment">/* 如果子线程有僵尸线程，则清理之 */</span></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;cur_co_ctx-&gt;zombie_child_threads) &#123;</span><br><span class="line">    ngx_stream_lua_cleanup_zombie_child_uthreads(</span><br><span class="line">        r, L, ctx, ctx-&gt;cur_co_ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，根据结束的协程的类型不同执行不同的操作：</p>
<h2 id="入口线程"><a href="#入口线程" class="headerlink" title="入口线程"></a>入口线程</h2><p>此时直接删除线程即可，然后根据是否还有用户线程，选择返回<code>NGX_AGAIN</code>或<code>NGX_OK</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ngx_stream_lua_is_entry_thread(ctx)) &#123;</span><br><span class="line">    <span class="comment">/* 将虚拟机栈清空 */</span></span><br><span class="line">    lua_settop(L, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 删除当前线程，会从REGISTY表中解引用当前协程的`coctx-&gt;co_ref` */</span></span><br><span class="line">    ngx_stream_lua_del_thread(r, L, ctx, ctx-&gt;cur_co_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果还有其他用户线程，返回NGX_AGAIN */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;uthreads) &#123;</span><br><span class="line">        ctx-&gt;cur_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> NGX_AGAIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* all user threads terminated already */</span></span><br><span class="line">    <span class="keyword">goto</span> done;      <span class="comment">/* 到这就圆满结束了 return NGX_OK; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h2><p>此时如果父协程已经死了，处理方式跟入口线程一样，即删除线程，然后根据是否还有任何用户线程或入口线程，选择返回<code>NGX_AGAIN</code>或<code>NGX_OK</code>。</p>
<p>如果父协程还活着，并且已经在wait它了，直接恢复父协程。否则，加入到父协程的僵尸线程列表中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx-&gt;cur_co_ctx-&gt;is_uthread) &#123;</span><br><span class="line">    <span class="comment">/* 清空虚拟机栈 */</span></span><br><span class="line">    lua_settop(L, <span class="number">0</span>); </span><br><span class="line">    <span class="comment">/* 获取父协程 */</span></span><br><span class="line">    parent_coctx = ctx-&gt;cur_co_ctx-&gt;parent_co_ctx;</span><br><span class="line">    <span class="comment">/* 如果父协程还活着 */</span></span><br><span class="line">    <span class="keyword">if</span> (ngx_stream_lua_coroutine_alive(parent_coctx)) &#123;</span><br><span class="line">        <span class="comment">/* 并且在wait当前线程，则恢复父协程 */</span></span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;cur_co_ctx-&gt;waited_by_parent) &#123;</span><br><span class="line">            ngx_stream_lua_probe_info(<span class="string">&quot;parent already waiting&quot;</span>);</span><br><span class="line">            ctx-&gt;cur_co_ctx-&gt;waited_by_parent = <span class="number">0</span>;</span><br><span class="line">            success = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> user_co_done;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 否则将当前线程挂到父协程的僵尸子线程中 */</span></span><br><span class="line">        <span class="keyword">if</span> (ngx_stream_lua_post_zombie_thread(r, parent_coctx,</span><br><span class="line">                                              ctx-&gt;cur_co_ctx)</span><br><span class="line">            != NGX_OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 压入第一个返回值true，以备后续wait时返回 */</span></span><br><span class="line">        lua_pushboolean(ctx-&gt;cur_co_ctx-&gt;co, <span class="number">1</span>);</span><br><span class="line">        lua_insert(ctx-&gt;cur_co_ctx-&gt;co, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* 设置当前线程状态为ZOMBIE */</span></span><br><span class="line">        ctx-&gt;cur_co_ctx-&gt;co_status = NGX_STREAM_LUA_CO_ZOMBIE;</span><br><span class="line">        ctx-&gt;cur_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> NGX_AGAIN;       <span class="comment">/* 返回上层 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果父协程已经死了，直接删除当前线程</span></span><br><span class="line"><span class="comment">     * 会从REGISTY表中解引用当前协程的`coctx-&gt;co_ref` */</span></span><br><span class="line">    ngx_stream_lua_del_thread(r, L, ctx, ctx-&gt;cur_co_ctx);</span><br><span class="line">    ctx-&gt;uthreads--;</span><br><span class="line">    <span class="comment">/* 如果没有用户线程了 */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;uthreads == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 入口线程在活着，返回上层 */</span></span><br><span class="line">        <span class="keyword">if</span> (ngx_stream_lua_entry_thread_alive(ctx)) &#123;</span><br><span class="line">            ctx-&gt;cur_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> NGX_AGAIN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* all threads terminated already */</span></span><br><span class="line">        <span class="keyword">goto</span> done;  <span class="comment">/* 到这就圆满结束了 return NGX_OK; */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果还有其他用户线程，返回上层 */</span></span><br><span class="line">    ctx-&gt;cur_co_ctx = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> NGX_AGAIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户协程"><a href="#用户协程" class="headerlink" title="用户协程"></a>用户协程</h2><p>剩下的就是用户协程的情况，这个情况跟用户线程被父协程wait的情况是一样的。主要是将返回值移动到父协程栈中，然后跳到主循环前面恢复父协程的执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">success = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 获取返回值个数 */</span></span><br><span class="line">nrets = lua_gettop(ctx-&gt;cur_co_ctx-&gt;co);</span><br><span class="line">next_coctx = ctx-&gt;cur_co_ctx-&gt;parent_co_ctx;</span><br><span class="line">next_co = next_coctx-&gt;co;</span><br><span class="line"><span class="comment">/* 将返回值移到父协程栈中 */</span></span><br><span class="line"><span class="keyword">if</span> (nrets) &#123;</span><br><span class="line">    lua_xmove(ctx-&gt;cur_co_ctx-&gt;co, next_co, nrets);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 如果是用户线程，删除之 */</span></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;cur_co_ctx-&gt;is_uthread) &#123;</span><br><span class="line">    ngx_stream_lua_del_thread(r, L, ctx, ctx-&gt;cur_co_ctx);</span><br><span class="line">    ctx-&gt;uthreads--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 除了wrap的用户协程，加上第一个true的返回值 */</span></span><br><span class="line"><span class="keyword">if</span> (!ctx-&gt;cur_co_ctx-&gt;is_wrap) &#123;</span><br><span class="line">    <span class="comment">/* ended successfully, coroutine.resume returns true plus</span></span><br><span class="line"><span class="comment">     * any return values</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lua_pushboolean(next_co, success);</span><br><span class="line">    lua_insert(next_co, <span class="number">1</span>);</span><br><span class="line">    nrets++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置父协程的状态为RUNNING */</span></span><br><span class="line">ctx-&gt;cur_co_ctx = next_coctx;</span><br><span class="line">next_coctx-&gt;co_status = NGX_STREAM_LUA_CO_RUNNING;</span><br><span class="line"><span class="comment">/* 回到主循环前面，恢复父协程的执行 */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>



<h1 id="出错的情况"><a href="#出错的情况" class="headerlink" title="出错的情况"></a>出错的情况</h1><p>大致处理步骤是，恢复<code>cur_co_ctx</code>，获取虚拟机L栈上错误信息，获取当前协程栈中错误信息，后面的操作类似协程执行完毕时，根据不同的情况选择恢复父协程或者返回上层。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 恢复cur_co_ctx */</span></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;cur_co_ctx != orig_coctx) &#123;</span><br><span class="line">    ctx-&gt;cur_co_ctx = orig_coctx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 设置当前协程状态为DEAD */</span></span><br><span class="line">ctx-&gt;cur_co_ctx-&gt;co_status = NGX_HTTP_LUA_CO_DEAD;</span><br><span class="line"><span class="comment">/* 获取错误信息 */</span></span><br><span class="line"><span class="keyword">if</span> (orig_coctx-&gt;is_uthread</span><br><span class="line">    || orig_coctx-&gt;is_wrap</span><br><span class="line">    || ngx_http_lua_is_entry_thread(ctx))</span><br><span class="line">&#123;</span><br><span class="line">    ngx_http_lua_thread_traceback(L, orig_coctx-&gt;co, orig_coctx);</span><br><span class="line">    trace = lua_tostring(L, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lua_isstring(orig_coctx-&gt;co, <span class="number">-1</span>)) &#123;</span><br><span class="line">        msg = lua_tostring(orig_coctx-&gt;co, <span class="number">-1</span>);</span><br><span class="line">        dd(<span class="string">&quot;user custom error msg: %s&quot;</span>, msg);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg = <span class="string">&quot;unknown reason&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户线程-1"><a href="#用户线程-1" class="headerlink" title="用户线程"></a>用户线程</h2><p>跟正常结束的处理一样，除了第一个返回值是false。</p>
<p>此时如果父协程已经死了，直接删除线程，然后根据是否还有任何用户线程或入口线程，选择返回<code>NGX_AGAIN</code>或<code>NGX_OK</code>。</p>
<p>如果父协程还活着，并且已经在wait它了，直接恢复父协程。否则，加入到父协程的僵尸线程列表中。</p>
<h2 id="入口线程-1"><a href="#入口线程-1" class="headerlink" title="入口线程"></a>入口线程</h2><p><code>ngx_stream_lua_request_cleanup()</code>清理当前请求，里面会清理掉所有的用户创建的协程，然后清理入口协程自己。最后返回错误码。</p>
<h2 id="用户协程-1"><a href="#用户协程-1" class="headerlink" title="用户协程"></a>用户协程</h2><p>如果是wrap的协程，将错误传递给父协程（就好像是父协程出错了，然后父协程重新走一遍上面的出错处理流程）。</p>
<p>如果是普通协程，则恢复父协程的执行，返回false和错误信息。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://openresty-reference.readthedocs.io/en/latest/Lua_Nginx_API/">Lua-Ngx-API</a></li>
<li><a href="https://github.com/openresty/stream-lua-nginx-module">stream-lua-nginx源码</a></li>
<li><a href="https://www.lua.org/manual/5.1/manual.html">lua-5.1-manual</a></li>
<li><a href="https://www.codedump.info/post/20190501-lua-stream/">lua stream实现分析</a></li>
</ul>
]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>OpenResty</tag>
        <tag>Nginx</tag>
        <tag>Lua</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>如何编写一个多进程性能测试程序</title>
    <url>/posts/e416d910/</url>
    <content><![CDATA[<div class="note primary">
            <p>在工作中经常碰到需要写一些多进程/多线程的测试程序，用来测试接口的性能。本文将会从零开始一点点增加代码，最终完成一个简易的多进程测试程序编写。该程序支持实时打印测试进结果和最终测试结果的统计。</p><p>同时，本文还涵盖了以下知识点，可以作为学习参考：</p><ul><li>使用<code>getopt_long()</code>处理命令行选项和参数</li><li>使用<code>fork()</code>和<code>wait()</code>处理多进程</li><li>使用<code>sigaction()</code>配合<code>alarm()</code>处理定时信号<code>SIGALRM</code></li><li>使用<code>shmget()</code>、<code>shmat()</code>、<code>shmdt()</code>、<code>shmctl()</code>等通过共享内存进行进程间通信</li><li>使用<code>sigaction()</code>捕获<code>SIGINT</code>和<code>SIGQUIT</code>信号，在程序终止前做共享内存清理工作</li></ul>
          </div>

<span id="more"></span>

<p>本文源码已开源<a href="https://github.com/catbro666/multi-process-test-demo">Github</a></p>
<h1 id="选项和参数的处理"><a href="#选项和参数的处理" class="headerlink" title="选项和参数的处理"></a>选项和参数的处理</h1><p>为了使测试程序更高的可用性，我们<code>getopt</code>来处理选项和参数。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>      <span class="comment">// printf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span>     <span class="comment">// getopt_long</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>     <span class="comment">// strtol, abort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>     <span class="comment">// LONG_MIN, LONG_MAX</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowHelpInfo</span><span class="params">(<span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [options]\n\n&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Options:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    -p/--proc         Number of processes (default: 1)\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    -d/--duration     Duration of test (unit: s, default: 10)\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    -h/--help         Show the help info\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Example:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    %s -p 4 -d 30\n&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> option_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> procs = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> duration = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  定义命令行参数列表，option结构的含义如下（详见 man 3 getopt）：</span></span><br><span class="line"><span class="comment">     *  struct option &#123;</span></span><br><span class="line"><span class="comment">     *      const char *name;       // 参数的完整名称，对应命令中的 --xxx</span></span><br><span class="line"><span class="comment">     *      int  has_arg;           // 该参数是否带有一个值，如 –-config xxx.conf</span></span><br><span class="line"><span class="comment">     *      int *flag;              // 一般设置为NULL</span></span><br><span class="line"><span class="comment">     *      int  val;               // 解析到该参数后getopt_long函数的返回值，</span></span><br><span class="line"><span class="comment">     *                      // 为了方便维护，一般对应getopt_long调用时第三个参数</span></span><br><span class="line"><span class="comment">     *  &#125;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">arg_options</span>[] =</span></span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">&quot;proc&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;p&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;duration&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;d&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;help&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="string">&#x27;h&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  注意：传递给getopt_long的第三个参数对应了命令行参数的缩写形式，如-h等，</span></span><br><span class="line"><span class="comment">     *  如果字符后面带有冒号&quot;:&quot;，则说明该参数后跟一个值，如-c xxxxxx</span></span><br><span class="line"><span class="comment">     *  如果开头有冒号&quot;:&quot;，则当一个选项缺少参数时，返回&quot;:&quot;，否则，返回&quot;?&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt_long(argc, argv, <span class="string">&quot;:p:d:h&quot;</span>, arg_options, &amp;option_index)</span><br><span class="line">            ) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//fprintf(stdout,&quot;option is -%c, optarv is %s\n&quot;, c, optarg);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">            procs = strtol(optarg, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (procs == LONG_MIN || procs == LONG_MAX) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The number of processes (%s) is overflow\n\n&quot;</span>,</span><br><span class="line">                        optarg);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (procs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The number of processes must be &gt; 0\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            duration = strtol(optarg, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (duration == LONG_MIN || duration == LONG_MAX) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The duration of test (%s) is overflow\n\n&quot;</span>,</span><br><span class="line">                        optarg);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (procs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The duration of test must be &gt; 0\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;Unknown option -%c\n\n&quot;</span>, optopt);</span><br><span class="line">            ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">           <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;Option -%c requires an argument\n\n&quot;</span>, optopt);</span><br><span class="line">           ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;processes:  %ld\n&quot;</span>, procs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;duration:   %lds\n&quot;</span>, duration);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n-----------------------------Start Testing----------------------&quot;</span></span><br><span class="line">           <span class="string">&quot;--------\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

</div></div>



<div class="note info">
            <p>注意：传递给getopt_long的第三个参数对应了命令行参数的缩写形式，如-h, -v, -c等。</p><p>如果字符后面带有冒号”:”，则说明该参数后跟一个值，如-c xxxxxx</p><p>如果开头有冒号”:”，则当一个选项缺少参数时，返回”:”，否则，返回”?”</p>
          </div>



<p><strong>效果如下</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">^_^$ make</span><br><span class="line">gcc <span class="string">&quot;-g&quot;</span> -c multi-process.c -o multi-process.o</span><br><span class="line">gcc  -o <span class="built_in">test</span> multi-process.o</span><br><span class="line"></span><br><span class="line">^_^$ ./<span class="built_in">test</span></span><br><span class="line">processes:  1</span><br><span class="line">duration:   10s</span><br><span class="line"></span><br><span class="line">-----------------------------Start Testing------------------------------</span><br><span class="line"></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>



<p><strong>选项或参数错误时</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ./test -p</span><br><span class="line">Option -p requires an argument</span><br><span class="line"></span><br><span class="line">Usage: ./test [options]</span><br><span class="line"></span><br><span class="line">  Options:</span><br><span class="line">    -p/--proc         Number of processes (default: 1)</span><br><span class="line">    -d/--duration     Duration of test (unit: s, default: 10)</span><br><span class="line">    -h/--help         Show the help info</span><br><span class="line"></span><br><span class="line">  Example:</span><br><span class="line">    ./test -p 4 -d 30</span><br></pre></td></tr></table></figure>



<h1 id="增加多进程的支持"><a href="#增加多进程的支持" class="headerlink" title="增加多进程的支持"></a>增加多进程的支持</h1><p>主进程<code>fork</code>出n个子进程后<code>wait</code>子进程，子进程则通过<code>sigaction</code>和<code>alarm</code>设置一个定时器，然后进行业务测试。</p>
<p>为了简洁，已经把选项参数处理的部分独立出去了。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>      <span class="comment">// printf, fprintf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span>   <span class="comment">// wait</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>  <span class="comment">// getpid, wait</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span>     <span class="comment">// sigaction, SIGLARM</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>     <span class="comment">// LONG_MIN, LONG_MAX, ULLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>     <span class="comment">// getpid</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>     <span class="comment">// memset</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;multi-process.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> isStop = <span class="number">0</span>;             <span class="comment">// 用于标记测试终止</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">param_st</span> &#123;</span>   <span class="comment">// 自定义测试参数</span></span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">&#125; Param;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal_child</span><span class="params">(<span class="keyword">int</span> sigNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigNum == SIGALRM) &#123;</span><br><span class="line">        isStop = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实际业务测试函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTest</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    Param *pa = (Param *)param;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; ULLONG_MAX &amp;&amp; !isStop; ++i) &#123;</span><br><span class="line">        <span class="comment">/* DO YOUR WORK */</span></span><br><span class="line">        <span class="comment">/* DO YOUR WORK */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;process [pid = %6u] result: %llu\n&quot;</span>, getpid(), i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> proc_index = <span class="number">0</span>;</span><br><span class="line">    Options opt;</span><br><span class="line">    <span class="keyword">int</span> isParent = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> wstatus = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act_child</span>;</span></span><br><span class="line"></span><br><span class="line">    rv = process_options(argc, argv, &amp;opt);</span><br><span class="line">    <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n-----------------------------Start Testing----------------------&quot;</span></span><br><span class="line">           <span class="string">&quot;--------\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* COMMON INIT */</span></span><br><span class="line">    <span class="comment">/* COMMON INIT */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(isParent &amp;&amp; i &lt; opt.procs) &#123;</span><br><span class="line">        pid =  fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>) &#123;         <span class="comment">/* error */</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed %d\n&quot;</span>, pid);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;     <span class="comment">/* child */</span></span><br><span class="line">            isParent = <span class="number">0</span>;</span><br><span class="line">            proc_index = i;     <span class="comment">// 记录进程索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;                  <span class="comment">/* parent */</span></span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isParent) &#123;</span><br><span class="line">        <span class="comment">/* PARENT INIT */</span></span><br><span class="line">        <span class="comment">/* PARENT INIT */</span></span><br><span class="line">        <span class="keyword">for</span>(i =<span class="number">0</span> ; i &lt; opt.procs; ++i) &#123;</span><br><span class="line">            pid = wait(&amp;wstatus);                       <span class="comment">// 等待子进程结束</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process [pid = %6d] exit\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* CHILD INIT */</span></span><br><span class="line">        Param param;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;param, <span class="number">0</span>, <span class="keyword">sizeof</span>(Param));</span><br><span class="line">        param.index = proc_index;</span><br><span class="line">        <span class="comment">/* CHILD INIT */</span></span><br><span class="line"></span><br><span class="line">        act_child.sa_handler = handle_signal_child;</span><br><span class="line">        sigemptyset(&amp;act_child.sa_mask);</span><br><span class="line">        act_child.sa_flags = SA_RESETHAND;</span><br><span class="line">        <span class="comment">/* 用于测试时间到时，通知子进程结束测试 */</span></span><br><span class="line">        rv = sigaction(SIGALRM, &amp;act_child, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;sigaction() failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//signal(SIGALRM, handle_signal_child);</span></span><br><span class="line">        alarm(opt.duration);                            <span class="comment">// 设置测试时长</span></span><br><span class="line">        doTest(&amp;param);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">/* child finished work */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></div>



<p><strong>效果如下</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ./test -p 4 -d 2</span><br><span class="line">processes:  4</span><br><span class="line">duration:   2s</span><br><span class="line"></span><br><span class="line">-----------------------------Start Testing------------------------------</span><br><span class="line"></span><br><span class="line">process [pid =  11942] result: 446930553</span><br><span class="line">process [pid =  11942] exit</span><br><span class="line">process [pid =  11939] result: 434385097</span><br><span class="line">process [pid =  11939] exit</span><br><span class="line">process [pid =  11940] result: 442246977</span><br><span class="line">process [pid =  11940] exit</span><br><span class="line">process [pid =  11941] result: 442418811</span><br><span class="line">process [pid =  11941] exit</span><br></pre></td></tr></table></figure>



<p>这样已经可以实现简单的多进程测试，简单起见，示例代码里只是简单地进行了计数操作。读者如果想要进行自己特定的测试，只要在Param中增加需要的测试参数，接着在<code>/* CHILD INIT */</code>处进行参数初始化，然后在<code>/* DO YOUR WORK */</code>处添加实际的测试逻辑即可。</p>
<h1 id="增加实时的结果统计及最终的结果汇总"><a href="#增加实时的结果统计及最终的结果汇总" class="headerlink" title="增加实时的结果统计及最终的结果汇总"></a>增加实时的结果统计及最终的结果汇总</h1><p>为了使测试程序更加人性化，使其可以实时统计测试结果，结束时自动计算总的结果。这就需要引入父子进程间通信，我们选用共享内存的方式来实现。为了避免进程间同步对测试带来的影响，在共享内存中为每个子进程开辟了一个空间，每个子进程根据索引在自己的空间里写数据，由父进程进行结果的汇总。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>      <span class="comment">// printf, fprintf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span>   <span class="comment">// wait</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>  <span class="comment">// getpid, wait</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span>    <span class="comment">// shmget, shmat, shmctl, shmdt</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span>    <span class="comment">// shmget, shmat, shmctl, shmdt</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span>     <span class="comment">// sigaction, SIGLARM</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>     <span class="comment">// LONG_MIN, LONG_MAX, ULLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span>      <span class="comment">// errno</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>     <span class="comment">// getpid</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>     <span class="comment">// memset</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;multi-process.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">param_st</span> &#123;</span>   <span class="comment">// 自定义测试参数</span></span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">&#125; Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">result_st</span> &#123;</span>   <span class="comment">// 自定义测试结果</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> count;</span><br><span class="line">&#125; Result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> isStop = <span class="number">0</span>;             <span class="comment">// 用于标记测试终止</span></span><br><span class="line">Options opt;                <span class="comment">// 命令行选项</span></span><br><span class="line"><span class="keyword">int</span> shmid;                  <span class="comment">// 共享内存id</span></span><br><span class="line">Result *shm = <span class="literal">NULL</span>;         <span class="comment">// 共享内存地址，用于存放测试结果</span></span><br><span class="line">Result res_total;</span><br><span class="line">Result res_last;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal_child</span><span class="params">(<span class="keyword">int</span> sigNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigNum == SIGALRM) &#123;</span><br><span class="line">        isStop = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal_parent</span><span class="params">(<span class="keyword">int</span> sigNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigNum == SIGALRM) &#123;</span><br><span class="line">        <span class="comment">/* DO REAL-TIME STATISTICS */</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;res_total, <span class="number">0</span>, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; opt.procs; ++i) &#123;</span><br><span class="line">            res_total.count += shm[i].count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;total count %12llu,  average %12.0lf/s\n&quot;</span>,</span><br><span class="line">                res_total.count, (res_total.count - res_last.count)</span><br><span class="line">                / (<span class="keyword">double</span>)opt.interval);</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;res_last, &amp;res_total, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        <span class="comment">/* DO REAL-TIME STATISTICS */</span></span><br><span class="line">        alarm(opt.interval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实际业务测试函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTest</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    Param *pa = (Param *)param;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; ULLONG_MAX &amp;&amp; !isStop; ++i) &#123;</span><br><span class="line">        <span class="comment">/* DO YOUR WORK */</span></span><br><span class="line">        ++shm[pa-&gt;index].count;</span><br><span class="line">        <span class="comment">/* DO YOUR WORK */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> proc_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> isParent = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> wstatus = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act_child</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act_parent</span>;</span></span><br><span class="line"></span><br><span class="line">    rv = process_options(argc, argv, &amp;opt);</span><br><span class="line">    <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n-----------------------------Start Testing-------------&quot;</span></span><br><span class="line">            <span class="string">&quot;-----------------\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* COMMON INIT */</span></span><br><span class="line">    shmid = shmget(IPC_PRIVATE, <span class="keyword">sizeof</span>(<span class="keyword">sizeof</span>(Result) * opt.procs), <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == shmid) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;shmget() failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;shmid = %d\n&quot;</span>, shmid);</span><br><span class="line">    shm = (Result*)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">void</span> *) <span class="number">-1</span> == shm) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;shmat() failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(shm, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">sizeof</span>(Result) * opt.procs));</span><br><span class="line">    <span class="comment">/* COMMON INIT */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(isParent &amp;&amp; i &lt; opt.procs) &#123;</span><br><span class="line">        pid =  fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>) &#123;         <span class="comment">/* error */</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed %d\n&quot;</span>, pid);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;     <span class="comment">/* child */</span></span><br><span class="line">            isParent = <span class="number">0</span>;</span><br><span class="line">            proc_index = i;     <span class="comment">// 记录进程索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;                  <span class="comment">/* parent */</span></span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isParent) &#123;</span><br><span class="line">        <span class="comment">/* PARENT INIT */</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;act_parent, <span class="number">0</span>, <span class="keyword">sizeof</span>(act_parent));</span><br><span class="line">        act_parent.sa_handler = handle_signal_parent;</span><br><span class="line">        <span class="comment">/* 使wait被中断时可以自动恢复 */</span></span><br><span class="line">        act_parent.sa_flags = SA_RESTART;</span><br><span class="line">        rv = sigaction(SIGALRM, &amp;act_parent, <span class="literal">NULL</span>);     <span class="comment">// 用于定时统计结果</span></span><br><span class="line">        <span class="comment">//signal(SIGALRM, handle_signal_parent);</span></span><br><span class="line">        <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;sigaction() failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;res_last, <span class="number">0</span>, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        alarm(opt.interval);</span><br><span class="line">        <span class="comment">/* PARENT INIT */</span></span><br><span class="line">        <span class="comment">/* DO FINAL STATISTICS */</span></span><br><span class="line">        Result <span class="keyword">final</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;<span class="keyword">final</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        <span class="keyword">for</span>(i =<span class="number">0</span> ; i &lt; opt.procs; ++i) &#123;</span><br><span class="line">            pid = wait(&amp;wstatus);                       <span class="comment">// 等待子进程结束</span></span><br><span class="line">            alarm(<span class="number">0</span>);                                   <span class="comment">// 终止定时器</span></span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;wait() failed, errno=%d\n&quot;</span>, errno);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;process [pid = %6d] exit\n&quot;</span>, pid);</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;process [pid = %6u] count %12llu in %lus,  &quot;</span></span><br><span class="line">                    <span class="string">&quot;average %12.0lf/s\n&quot;</span>, pid, shm[i].count, opt.duration, </span><br><span class="line">                    shm[i].count / (<span class="keyword">double</span>)opt.duration);</span><br><span class="line">            <span class="keyword">final</span>.count += shm[i].count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;total count %12llu in %lus,  average %12.0lf/s\n&quot;</span>,</span><br><span class="line">               <span class="keyword">final</span>.count, opt.duration, <span class="keyword">final</span>.count / (<span class="keyword">double</span>)opt.duration);</span><br><span class="line">        <span class="comment">/* DO FINAL STATISTICS */</span></span><br><span class="line">        shmdt((<span class="keyword">void</span>*)shm);</span><br><span class="line">        <span class="comment">/* 子进程退出之后自动detach了, 所以这里不需要通过IPC_STAT进行判断 */</span></span><br><span class="line">        shmctl(shmid, IPC_RMID, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* CHILD INIT */</span></span><br><span class="line">        Param param;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;param, <span class="number">0</span>, <span class="keyword">sizeof</span>(Param));</span><br><span class="line">        param.index = proc_index;</span><br><span class="line">        <span class="comment">/* CHILD INIT */</span></span><br><span class="line"></span><br><span class="line">        act_child.sa_handler = handle_signal_child;</span><br><span class="line">        sigemptyset(&amp;act_child.sa_mask);</span><br><span class="line">        <span class="comment">//sigaddset(&amp;act_child.sa_mask, SIGQUIT);</span></span><br><span class="line">        <span class="comment">//sigaddset(&amp;act_child.sa_mask, SIGTERM);</span></span><br><span class="line">        act_child.sa_flags = SA_RESETHAND;</span><br><span class="line">        <span class="comment">/* 用于测试时间到时，通知子进程结束测试 */</span></span><br><span class="line">        rv = sigaction(SIGALRM, &amp;act_child, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;sigaction() failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//signal(SIGALRM, handle_signal_child);</span></span><br><span class="line">        alarm(opt.duration);                            <span class="comment">// 设置测试时长</span></span><br><span class="line">        doTest(&amp;param);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">/* child finished work */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></div>



<p><strong>测试效果如下</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^_^$ ./test -p 4 -d 8 -i 1</span><br><span class="line">processes:  4</span><br><span class="line">duration:   8s</span><br><span class="line">interval:   1s</span><br><span class="line"></span><br><span class="line">-----------------------------Start Testing------------------------------</span><br><span class="line"></span><br><span class="line">shmid = 2654220</span><br><span class="line">total count    344235932,  average    344235932/s</span><br><span class="line">total count    679573681,  average    335337749/s</span><br><span class="line">total count   1026283924,  average    346710243/s</span><br><span class="line">total count   1368302354,  average    342018430/s</span><br><span class="line">total count   1708471662,  average    340169308/s</span><br><span class="line">total count   2057211138,  average    348739476/s</span><br><span class="line">total count   2398403059,  average    341191921/s</span><br><span class="line">process [pid =  25124] exit</span><br><span class="line">process [pid =  25124] count    688504473 in 8s,  average     86063059/s</span><br><span class="line">process [pid =  25123] exit</span><br><span class="line">process [pid =  25123] count    682379115 in 8s,  average     85297389/s</span><br><span class="line">process [pid =  25125] exit</span><br><span class="line">process [pid =  25125] count    682467102 in 8s,  average     85308388/s</span><br><span class="line">process [pid =  25126] exit</span><br><span class="line">process [pid =  25126] count    688159459 in 8s,  average     86019932/s</span><br><span class="line">total count   2741510149 in 8s,  average    342688769/s</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>这里需要特别提一下<code>wait()</code>和<code>sigaction()</code>系统调用，默认情况下<code>wait()</code>会阻塞直到有任意一个子进程改变了其状态，或者有一个信号处理函数中断了<code>wait()</code>调用。所以我们程序中的<code>wait()</code>调用就会被自己的<code>SIGALRM</code>信号中断，返回<code>-1</code>同时<code>errno</code>为<code>EINTR</code>。这样我们就需要在<code>wait()</code>外面加一层循环来处理<code>wait()</code>被信号中断的情况。</p><p>通过在<code>sigaction()</code>时增加<code>SA_RESTART</code>标志，被中断的系统调用可以自动重开，也就省去了那个外层循环。另外，<code>signal()</code>封装了<code>sigaction()</code>，它里面默认就是设置了<code>SA_RESTART</code>，不过除非你有确切的理由，不然不建议使用<code>signal()</code>了。</p>
          </div>

<h1 id="增加SIGINT和SIGQUIT信号捕获"><a href="#增加SIGINT和SIGQUIT信号捕获" class="headerlink" title="增加SIGINT和SIGQUIT信号捕获"></a>增加SIGINT和SIGQUIT信号捕获</h1><p>截止目前，我们已经完成了多进程的测试及结果统计。但其实还有一个潜在的问题，在实际测试中，我们经常会在测试还没完成时就手动<code>^C</code>终止程序执行。这样我们在程序中申请的共享内存就会得不到释放，造成内存泄漏。所以需要增加对<code>SIGINT</code>和<code>SIGQUIT</code>信号的处理函数，在里面做清理工作，释放共享内存。</p>
<div class="note default">
            <p>如果已经不小心造成了共享内存的泄漏，可以通过如下命令手动进行删除。<code>ipcrm shm &lt;id&gt;</code>，如果是显式指定key的话也可以通过<code>ipcrm -M &lt;key&gt;</code>来进行删除。</p>
          </div>

<div class="note info">
            <p>今天，突然想到了，其实有一种更加简单的方法，即在<code>shmat()</code>之后立即进行<code>shmctl(shmid, IPC_RMID, 0);</code>。这样不仅简单，而且中间的空窗期也更短，cool！这样我们再也不用担心，<code>^C</code>造成内存泄漏了哈。</p>
          </div>

<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="meta">@@ -88,12 +88,14 @@</span> int main(int argc, char *argv[]) &#123;</span><br><span class="line">         fprintf(stderr, &quot;shmget() failed\n&quot;);</span><br><span class="line">         return -1;</span><br><span class="line">     &#125;</span><br><span class="line">     fprintf(stderr, &quot;shmid = %d\n&quot;, shmid);</span><br><span class="line">     shm = (Result*)shmat(shmid, 0, 0);</span><br><span class="line">     if ((void *) -1 == shm) &#123;</span><br><span class="line">         fprintf(stderr, &quot;shmat() failed\n&quot;);</span><br><span class="line">         return -1;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="addition">+    /* 这里直接进行IPC_RMID操作，进程退出后会自动detach了, 从而释放共享内存 */</span></span><br><span class="line"><span class="addition">+    shmctl(shmid, IPC_RMID, 0);</span></span><br><span class="line">     memset(shm, 0, sizeof(sizeof(Result) * opt.procs));</span><br><span class="line">     /* COMMON INIT */</span><br><span class="line"></span><br><span class="line"><span class="meta">@@ -156,10 +135,6 @@</span> int main(int argc, char *argv[]) &#123;</span><br><span class="line">         fprintf(stderr, &quot;total count %12llu in %lus,  average %12.0lf/s\n&quot;,</span><br><span class="line">                final.count, opt.duration, final.count / (double)opt.duration);</span><br><span class="line">         /* DO FINAL STATISTICS */</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-        shmdt((void*)shm);</span></span><br><span class="line"><span class="deletion">-        /* 子进程退出之后自动detach了, 所以这里不需要通过IPC_STAT进行判断 */</span></span><br><span class="line"><span class="deletion">-        shmctl(shmid, IPC_RMID, 0);</span></span><br><span class="line">     &#125;</span><br><span class="line">     else &#123;</span><br><span class="line">         /* CHILD INIT */</span><br></pre></td></tr></table></figure>



<h1 id="封装错误判断函数"><a href="#封装错误判断函数" class="headerlink" title="封装错误判断函数"></a>封装错误判断函数</h1><p>为了使代码看起来更加简洁，避免每个函数调用后面跟着一个<code>if()&#123;&#125;</code>判断块，我们对错误判断及日志打印函数进行了一个简单的封装。封装的函数如下：</p>
<p>其中<code>mylog()</code>单纯打印日志，<code>fail()</code>打印日志后退出进程，<code>fail_if()</code>先判断条件，如果成立打印日志退出，<code>fail_clean_if()</code>也是先判断条件，条件成立则打印日志，执行传入的清理函数。然后退出进程。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>      <span class="comment">// stderr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span>     <span class="comment">// va_start, vfprintf, va_end</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>     <span class="comment">// exit</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail_if</span><span class="params">(<span class="keyword">bool</span> condition, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        va_list args;</span><br><span class="line">        va_start(args, fmt);</span><br><span class="line">        <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">        va_end(args);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mylog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail_clean_if</span><span class="params">(<span class="keyword">bool</span> condition, cleanup clean, <span class="keyword">void</span> *param, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        va_list args;</span><br><span class="line">        va_start(args, fmt);</span><br><span class="line">        <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">        va_end(args);</span><br><span class="line">        clean(param);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>



<h1 id="添加实际测试用例"><a href="#添加实际测试用例" class="headerlink" title="添加实际测试用例"></a>添加实际测试用例</h1><p>接下来我们来添加实际有意义的测试用例，这里以OpenSSL引擎的性能测试为例来进行说明。为了我们的代码更清晰，已经将具体测试相关的代码独立为一个源文件。<code>common.c</code>封装错误函数，<code>opt.c</code>处理命令行选项，<code>work.c</code>处理具体测试，<code>multi-process.c</code>则负责测试的主控。完整的代码如下：</p>
<ul>
<li><code>common.h</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADER_COMMON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADER_COMMON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span>    <span class="comment">// bool, true, false</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*cleanup)</span> <span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail_if</span><span class="params">(<span class="keyword">bool</span> condition, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mylog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail_clean_if</span><span class="params">(<span class="keyword">bool</span> condition, cleanup clean, <span class="keyword">void</span> *param, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HEADER_COMMON_H */</span></span></span><br></pre></td></tr></table></figure>



</div></div>

<ul>
<li><code>common.c</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>      <span class="comment">// stderr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span>     <span class="comment">// va_start, vfprintf, va_end</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>     <span class="comment">// exit</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail_if</span><span class="params">(<span class="keyword">bool</span> condition, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        va_list args;</span><br><span class="line">        va_start(args, fmt);</span><br><span class="line">        <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">        va_end(args);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mylog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail_clean_if</span><span class="params">(<span class="keyword">bool</span> condition, cleanup clean, <span class="keyword">void</span> *param, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        va_list args;</span><br><span class="line">        va_start(args, fmt);</span><br><span class="line">        <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, args);</span><br><span class="line">        va_end(args);</span><br><span class="line">        clean(param);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><code>opt.h</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADER_OPT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADER_OPT_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">test</span>&#123;</span></span><br><span class="line">    hash, sign, verify, enc, dec</span><br><span class="line">&#125; Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">options_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> procs;                 <span class="comment">// 进程数</span></span><br><span class="line">    <span class="keyword">long</span> duration;              <span class="comment">// 测试时间</span></span><br><span class="line">    <span class="keyword">long</span> interval;              <span class="comment">// 统计间隔</span></span><br><span class="line">    Test test;                  <span class="comment">// 测试类型</span></span><br><span class="line">    <span class="keyword">long</span> len;                   <span class="comment">// 摘要原文长度</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *key;            <span class="comment">// 密钥文件路径</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cert;           <span class="comment">// 证书文件路径</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *loglevel;       <span class="comment">// 日志等级</span></span><br><span class="line">&#125; Options;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理参数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process_options</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], Options *opt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HEADER_OPT_H */</span></span></span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><code>opt.c</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>     <span class="comment">// LONG_MIN, LONG_MAX, ULLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>     <span class="comment">// memset</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>     <span class="comment">// strtol, abort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span>     <span class="comment">// geropt_long</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span>     <span class="comment">// mylog</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowHelpInfo</span><span class="params">(<span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    mylog(<span class="string">&quot;Usage: %s [options]\n\n&quot;</span>, name);</span><br><span class="line">    mylog(<span class="string">&quot;  Options:\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -p/--proc         Number of processes (default: 1)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -d/--duration     Duration of test (unit: s, default: 10)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -i/--interval     Interval of statisics (unit: s, default: 1)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -t/--test         Test case (hash|sign|verify|enc|dec, default: hash)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -l/--len          Hash data len (unit: byte, default: 1024)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -k/--key          PEM Key file path (default: ./key.pem)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -c/--cert         PEM Cert file path (default: ./cert.pem)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -o/--loglevel     Engine log level (0-9, default: 0)\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    -h/--help         Show the help info\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;  Example:\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;    %s -p 1 -d 30 -i 1 -t sign -k key.pem -c cert.pem\n&quot;</span>, name);</span><br><span class="line">    mylog(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理参数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process_options</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], Options *opt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> option_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> procs = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> duration = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">long</span> interval = <span class="number">1</span>;</span><br><span class="line">    Test test = hash;</span><br><span class="line">    <span class="keyword">long</span> len = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *key = <span class="string">&quot;./key.pem&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cert = <span class="string">&quot;./cert.pem&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *loglevel = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  定义命令行参数列表，option结构的含义如下（详见 man 3 getopt）：</span></span><br><span class="line"><span class="comment">     *  struct option &#123;</span></span><br><span class="line"><span class="comment">     *      const char *name;       // 参数的完整名称，对应命令中的 --xxx</span></span><br><span class="line"><span class="comment">     *      int  has_arg;           // 该参数是否带有一个值，如 –config xxx.conf</span></span><br><span class="line"><span class="comment">     *      int *flag;              // 一般设置为NULL</span></span><br><span class="line"><span class="comment">     *      int  val;               // 解析到该参数后getopt_long函数的返回值，</span></span><br><span class="line"><span class="comment">     *                      // 为了方便维护，一般对应getopt_long调用时第三个参数</span></span><br><span class="line"><span class="comment">     *  &#125;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">arg_options</span>[] =</span></span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">&quot;proc&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;p&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;duration&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;d&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;interval&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;i&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;test&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;t&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;len&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;l&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;key&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;k&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;cert&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;log&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="string">&#x27;g&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;help&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="string">&#x27;h&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  注意：传递给getopt_long的第三个参数对应了命令行参数的缩写形式，如-h等，</span></span><br><span class="line"><span class="comment">     *  如果字符后面带有冒号&quot;:&quot;，则说明该参数后跟一个值，如-c xxxxxx</span></span><br><span class="line"><span class="comment">     *  如果开头有冒号&quot;:&quot;，则当一个选项缺少参数时，返回&quot;:&quot;，否则，返回&quot;?&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt_long(argc, argv, <span class="string">&quot;:p:d:i:t:l:k:c:g:h&quot;</span>, arg_options, &amp;option_index)</span><br><span class="line">            ) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//fprintf(stderr,&quot;option is -%c, optarv is %s\n&quot;, c, optarg);</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">            procs = strtol(optarg, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (procs == LONG_MIN || procs == LONG_MAX) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The number of processes (%s) is overflow\n\n&quot;</span>, optarg);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (procs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The number of processes must be &gt; 0\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            duration = strtol(optarg, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (duration == LONG_MIN || duration == LONG_MAX) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The duration of test (%s) is overflow\n\n&quot;</span>, optarg);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (duration &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The duration of test must be &gt; 0\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">            interval = strtol(optarg, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (interval == LONG_MIN || interval == LONG_MAX) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The interval of statistics (%s) is overflow\n\n&quot;</span>,</span><br><span class="line">                      optarg);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (interval &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The interval of statistics must be &gt; 0\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(!strcasecmp(<span class="string">&quot;hash&quot;</span>, optarg)) &#123;</span><br><span class="line">                test = hash;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!strcasecmp(<span class="string">&quot;sign&quot;</span>, optarg)) &#123;</span><br><span class="line">                test = sign;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!strcasecmp(<span class="string">&quot;verify&quot;</span>, optarg)) &#123;</span><br><span class="line">                test = verify;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!strcasecmp(<span class="string">&quot;enc&quot;</span>, optarg)) &#123;</span><br><span class="line">                test = enc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!strcasecmp(<span class="string">&quot;dec&quot;</span>, optarg)) &#123;</span><br><span class="line">                test = dec;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                mylog(<span class="string">&quot;Unknown test case type\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">            len = strtol(optarg, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (len == LONG_MIN || len == LONG_MAX) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The len of hash data (%s) is overflow\n\n&quot;</span>,</span><br><span class="line">                      optarg);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mylog(<span class="string">&quot;The len of hash data must be &gt; 0\n\n&quot;</span>);</span><br><span class="line">                ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>:</span><br><span class="line">            key = optarg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">            cert = optarg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">            loglevel = optarg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            mylog(<span class="string">&quot;Unknown option -%c\n\n&quot;</span>, optopt);</span><br><span class="line">            ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">            mylog(<span class="string">&quot;Option -%c requires an argument\n\n&quot;</span>, optopt);</span><br><span class="line">            ShowHelpInfo(argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mylog(<span class="string">&quot;processes:  %ld\n&quot;</span>, procs);</span><br><span class="line">    mylog(<span class="string">&quot;duration:   %lds\n&quot;</span>, duration);</span><br><span class="line">    mylog(<span class="string">&quot;interval:   %lds\n&quot;</span>, interval);</span><br><span class="line">    mylog(<span class="string">&quot;test:       #%d\n&quot;</span>, test);</span><br><span class="line">    mylog(<span class="string">&quot;len:        %ld bytes\n&quot;</span>, len);</span><br><span class="line">    mylog(<span class="string">&quot;key:        %s\n&quot;</span>, key);</span><br><span class="line">    mylog(<span class="string">&quot;cert:       %s\n&quot;</span>, cert);</span><br><span class="line">    mylog(<span class="string">&quot;loglevel:   %s\n&quot;</span>, loglevel);</span><br><span class="line">    <span class="built_in">memset</span>(opt, <span class="number">0</span>, <span class="keyword">sizeof</span>(Options));</span><br><span class="line">    opt-&gt;procs = procs;</span><br><span class="line">    opt-&gt;duration = duration;</span><br><span class="line">    opt-&gt;interval = interval;</span><br><span class="line">    opt-&gt;test = test;</span><br><span class="line">    opt-&gt;len = len;</span><br><span class="line">    opt-&gt;key = key;</span><br><span class="line">    opt-&gt;cert = cert;</span><br><span class="line">    opt-&gt;loglevel = loglevel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><code>work.h</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADER_WORK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADER_WORK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义测试参数 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hash_param_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> data_len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> md[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> md_len;</span><br><span class="line">    EVP_MD_CTX *ctx;</span><br><span class="line">&#125; HashParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sign_param_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">size_t</span> data_len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sig[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">size_t</span> sig_len;</span><br><span class="line">    EVP_PKEY_CTX *ctx;</span><br><span class="line">    BIO *in;</span><br><span class="line">&#125; SignParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> SignParam VerifyParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">enc_param_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">size_t</span> data_len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> enc[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">size_t</span> enc_len;</span><br><span class="line">    EVP_PKEY_CTX *ctx;</span><br><span class="line">    BIO *in;</span><br><span class="line">&#125; EncParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> EncParam DecParam;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义测试结果 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">result_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> count;</span><br><span class="line">&#125; Result;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*init_fn)</span> <span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*work_fn)</span> <span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*clean_fn)</span> <span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> init_fn test_init;</span><br><span class="line"><span class="keyword">extern</span> work_fn test_work;</span><br><span class="line"><span class="keyword">extern</span> clean_fn test_clean;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">global_init</span><span class="params">(Options *opt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">global_clean</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HEADER_WORK_H */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><code>work.c</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;work.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/engine.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/pem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* so_path = <span class="string">&quot;/usr/local/ssl/lib/myengine.so&quot;</span>;</span><br><span class="line"></span><br><span class="line">init_fn test_init = <span class="literal">NULL</span>;</span><br><span class="line">work_fn test_work = <span class="literal">NULL</span>;</span><br><span class="line">clean_fn test_clean = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hash_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hash_work</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hash_clean</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sign_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sign_work</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sign_clean</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify_work</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify_clean</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encrypt_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encrypt_work</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encrypt_clean</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrypt_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrypt_work</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrypt_clean</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">global_init</span><span class="params">(Options *opt)</span> </span>&#123;</span><br><span class="line">    ENGINE *e = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (opt-&gt;test == hash) &#123;</span><br><span class="line">        test_init = hash_init;</span><br><span class="line">        test_work = hash_work;</span><br><span class="line">        test_clean = hash_clean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (opt-&gt;test == sign) &#123;</span><br><span class="line">        test_init = sign_init;</span><br><span class="line">        test_work = sign_work;</span><br><span class="line">        test_clean = sign_clean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (opt-&gt;test == verify) &#123;</span><br><span class="line">        test_init = verify_init;</span><br><span class="line">        test_work = verify_work;</span><br><span class="line">        test_clean = verify_clean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (opt-&gt;test == enc) &#123;</span><br><span class="line">        test_init = encrypt_init;</span><br><span class="line">        test_work = encrypt_work;</span><br><span class="line">        test_clean = encrypt_clean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (opt-&gt;test == dec) &#123;</span><br><span class="line">        test_init = decrypt_init;</span><br><span class="line">        test_work = decrypt_work;</span><br><span class="line">        test_clean = decrypt_clean;</span><br><span class="line">    &#125;</span><br><span class="line">    OpenSSL_add_all_algorithms();</span><br><span class="line">    <span class="comment">/* ENGINE INIT */</span></span><br><span class="line">    ENGINE_load_dynamic();</span><br><span class="line">    <span class="keyword">if</span> (!(e = ENGINE_by_id(<span class="string">&quot;dynamic&quot;</span>))) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_by_id(\&quot;dynamic\&quot;) fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ENGINE_ctrl_cmd_string(e, <span class="string">&quot;SO_PATH&quot;</span>, so_path, <span class="number">0</span>)) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_ctrl_cmd_string(\&quot;SO_PATH\&quot;) fail, so_path = %s\n&quot;</span>, </span><br><span class="line">             so_path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ENGINE_ctrl_cmd_string(e, <span class="string">&quot;LIST_ADD&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_ctrl_cmd_string(\&quot;LIST_ADD\&quot;) fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ENGINE_ctrl_cmd_string(e, <span class="string">&quot;LOAD&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_ctrl_cmd_string(\&quot;LOAD\&quot;) fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ENGINE_init(e)) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_init() fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ENGINE_ctrl_cmd_string( e, <span class="string">&quot;ENGINE_SET_LOGLEVEL&quot;</span>, opt-&gt;loglevel, <span class="number">0</span>)) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_ctrl_cmd_string(\&quot;ENGINE_SET_LOGLEVEL\&quot;) fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) &#123;</span><br><span class="line">        fail(<span class="string">&quot;ENGINE_set_default() fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ENGINE_free(e);</span><br><span class="line">    <span class="comment">/* ENGINE INIT */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">global_clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EVP_cleanup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hash_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span> </span>&#123;</span><br><span class="line">    HashParam *p;</span><br><span class="line">    p = OPENSSL_malloc(<span class="keyword">sizeof</span>(HashParam));</span><br><span class="line">    fail_if(!p, <span class="string">&quot;OPENSSL_malloc() fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(HashParam));</span><br><span class="line"></span><br><span class="line">    p-&gt;ctx = EVP_MD_CTX_create();</span><br><span class="line">    fail_clean_if(!p-&gt;ctx, hash_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;EVP_MD_CTX_create() fail\n&quot;</span>);</span><br><span class="line">    EVP_MD_CTX_init(p-&gt;ctx);</span><br><span class="line"></span><br><span class="line">    p-&gt;data = OPENSSL_malloc(opt-&gt;len);</span><br><span class="line">    fail_clean_if(!p-&gt;data, hash_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;OPENSSL_malloc() fail\n&quot;</span>);</span><br><span class="line">    fail_clean_if(RAND_bytes(p-&gt;data, <span class="keyword">sizeof</span>(opt-&gt;len)) &lt;= <span class="number">0</span>, hash_clean, (<span class="keyword">void</span> *)p,</span><br><span class="line">                  <span class="string">&quot;RAND_bytes() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;data_len = opt-&gt;len;</span><br><span class="line"></span><br><span class="line">    p-&gt;index = proc_index;</span><br><span class="line"></span><br><span class="line">    *param = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hash_work</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    HashParam *p = (HashParam *)param;</span><br><span class="line">    <span class="keyword">const</span> EVP_MD *md = EVP_get_digestbyname(<span class="string">&quot;SHASH&quot;</span>);</span><br><span class="line">    fail_clean_if(!md, hash_clean, param, </span><br><span class="line">                  <span class="string">&quot;EVP_get_digestbyname(\&quot;SHASH\&quot;) fail\n&quot;</span>);</span><br><span class="line">    fail_clean_if(!EVP_DigestInit_ex(p-&gt;ctx, md, <span class="literal">NULL</span>), </span><br><span class="line">                  hash_clean, param, <span class="string">&quot;EVP_DigestInit_ex() fail\n&quot;</span>);</span><br><span class="line">    fail_clean_if(!EVP_DigestUpdate(p-&gt;ctx, p-&gt;data, p-&gt;data_len),</span><br><span class="line">                  hash_clean, param, <span class="string">&quot;EVP_DigestUpdate() fail\n&quot;</span>);</span><br><span class="line">    fail_clean_if(!EVP_DigestFinal_ex(p-&gt;ctx, p-&gt;md, &amp;p-&gt;md_len),</span><br><span class="line">                  hash_clean, param, <span class="string">&quot;EVP_DigestFinal_ex() fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hash_clean</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    HashParam *p = (HashParam *)param;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;data)</span><br><span class="line">        OPENSSL_free(p-&gt;data);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ctx)</span><br><span class="line">        EVP_MD_CTX_destroy(p-&gt;ctx);</span><br><span class="line">    OPENSSL_free(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sign_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span> </span>&#123;</span><br><span class="line">    SignParam *p;</span><br><span class="line">    EVP_PKEY *pkey;</span><br><span class="line">    p = OPENSSL_malloc(<span class="keyword">sizeof</span>(SignParam));</span><br><span class="line">    fail_if(!p, <span class="string">&quot;OPENSSL_malloc() fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(SignParam));</span><br><span class="line"></span><br><span class="line">    p-&gt;in = BIO_new_file(opt-&gt;key, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fail_clean_if(!p-&gt;in, sign_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;BIO_new_file(%s) fail\n&quot;</span>, opt-&gt;key);</span><br><span class="line">    pkey = PEM_read_bio_PrivateKey(p-&gt;in, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    fail_clean_if(!pkey, sign_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;PEM_read_bio_PrivateKey() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;ctx = EVP_PKEY_CTX_new(pkey, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;ctx) &#123;</span><br><span class="line">        EVP_PKEY_free(pkey);</span><br><span class="line">        fail_clean_if(<span class="number">1</span>, sign_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;EVP_PKEY_CTX_new() fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_sign_init(p-&gt;ctx), sign_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_sign_init() fail\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fail_clean_if(RAND_bytes(p-&gt;data, <span class="keyword">sizeof</span>(p-&gt;data)) &lt;= <span class="number">0</span>, sign_clean, (<span class="keyword">void</span> *)p,</span><br><span class="line">                  <span class="string">&quot;RAND_bytes() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;data_len = <span class="keyword">sizeof</span>(p-&gt;data);</span><br><span class="line">    p-&gt;sig_len = <span class="keyword">sizeof</span>(p-&gt;sig);</span><br><span class="line"></span><br><span class="line">    p-&gt;index = proc_index;</span><br><span class="line">    *param = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sign_work</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    SignParam *p = (SignParam *)param;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_sign(p-&gt;ctx, p-&gt;sig, &amp;p-&gt;sig_len, p-&gt;data, </span><br><span class="line">                                 p-&gt;data_len), sign_clean, param,</span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_sign() fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sign_clean</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    SignParam *p = (SignParam *)param;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ctx)</span><br><span class="line">        EVP_PKEY_CTX_free(p-&gt;ctx);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;in)</span><br><span class="line">        BIO_free(p-&gt;in);</span><br><span class="line">    OPENSSL_free(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span> </span>&#123;</span><br><span class="line">    VerifyParam *p;</span><br><span class="line">    EVP_PKEY *pkey;</span><br><span class="line">    X509 *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">size_t</span> data_len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sig[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">size_t</span> sig_len;</span><br><span class="line">    <span class="comment">/* 先签名一次，获取数据 */</span></span><br><span class="line">    SignParam *sp;</span><br><span class="line">    sign_init(opt, (<span class="keyword">void</span> **)&amp;sp, (<span class="keyword">long</span>)<span class="number">0</span>);</span><br><span class="line">    sign_work(sp);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, sp-&gt;data, sp-&gt;data_len);</span><br><span class="line">    data_len = sp-&gt;data_len;</span><br><span class="line">    <span class="built_in">memcpy</span>(sig, sp-&gt;sig, sp-&gt;sig_len);</span><br><span class="line">    sig_len = sp-&gt;sig_len;</span><br><span class="line">    sign_clean(sp);</span><br><span class="line"></span><br><span class="line">    p = OPENSSL_malloc(<span class="keyword">sizeof</span>(VerifyParam));</span><br><span class="line">    fail_if(!p, <span class="string">&quot;OPENSSL_malloc() fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(VerifyParam));</span><br><span class="line">    </span><br><span class="line">    p-&gt;in = BIO_new_file(opt-&gt;cert, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fail_clean_if(!p-&gt;in, verify_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;BIO_new_file(%s) fail\n&quot;</span>, opt-&gt;cert);</span><br><span class="line">    x = PEM_read_bio_X509(p-&gt;in, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    fail_clean_if(!x, verify_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;PEM_read_bio_X509() fail\n&quot;</span>);</span><br><span class="line">    pkey = X509_get_pubkey(x);</span><br><span class="line">    X509_free(x);</span><br><span class="line">    fail_clean_if(!pkey, verify_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;X509_get_pubkey() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;ctx = EVP_PKEY_CTX_new(pkey, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;ctx) &#123;</span><br><span class="line">        EVP_PKEY_free(pkey);</span><br><span class="line">        fail_clean_if(<span class="number">1</span>, verify_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;EVP_PKEY_CTX_new() fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_verify_init(p-&gt;ctx), verify_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_verify_init() fail\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(p-&gt;data, data, data_len);</span><br><span class="line">    p-&gt;data_len = data_len;</span><br><span class="line">    <span class="built_in">memcpy</span>(p-&gt;sig, sig, sig_len);</span><br><span class="line">    p-&gt;sig_len = sig_len;</span><br><span class="line"></span><br><span class="line">    p-&gt;index = proc_index;</span><br><span class="line">    *param = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify_work</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    VerifyParam *p = (VerifyParam *)param;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_verify(p-&gt;ctx, p-&gt;sig, p-&gt;sig_len, p-&gt;data, </span><br><span class="line">                                 p-&gt;data_len), verify_clean, param,</span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_verify() fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify_clean</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    VerifyParam *p = (VerifyParam *)param;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ctx)</span><br><span class="line">        EVP_PKEY_CTX_free(p-&gt;ctx);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;in)</span><br><span class="line">        BIO_free(p-&gt;in);</span><br><span class="line">    OPENSSL_free(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encrypt_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span> </span>&#123;</span><br><span class="line">    EncParam *p;</span><br><span class="line">    EVP_PKEY *pkey;</span><br><span class="line">    X509 *x;</span><br><span class="line">    p = OPENSSL_malloc(<span class="keyword">sizeof</span>(EncParam));</span><br><span class="line">    fail_if(!p, <span class="string">&quot;OPENSSL_malloc() fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(EncParam));</span><br><span class="line"></span><br><span class="line">    p-&gt;in = BIO_new_file(opt-&gt;cert, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fail_clean_if(!p-&gt;in, encrypt_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;BIO_new_file(%s) fail\n&quot;</span>, opt-&gt;cert);</span><br><span class="line">    x = PEM_read_bio_X509(p-&gt;in, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    fail_clean_if(!x, encrypt_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;PEM_read_bio_X509() fail\n&quot;</span>);</span><br><span class="line">    pkey = X509_get_pubkey(x);</span><br><span class="line">    X509_free(x);</span><br><span class="line">    fail_clean_if(!pkey, encrypt_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;X509_get_pubkey() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;ctx = EVP_PKEY_CTX_new(pkey, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;ctx) &#123;</span><br><span class="line">        EVP_PKEY_free(pkey);</span><br><span class="line">        fail_clean_if(<span class="number">1</span>, encrypt_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;EVP_PKEY_CTX_new() fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_encrypt_init(p-&gt;ctx), encrypt_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_encrypt_init() fail\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fail_clean_if(RAND_bytes(p-&gt;data, <span class="keyword">sizeof</span>(p-&gt;data)) &lt;= <span class="number">0</span>, encrypt_clean, (<span class="keyword">void</span> *)p,</span><br><span class="line">                  <span class="string">&quot;RAND_bytes() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;data_len = <span class="keyword">sizeof</span>(p-&gt;data);</span><br><span class="line">    p-&gt;enc_len = <span class="keyword">sizeof</span>(p-&gt;enc);</span><br><span class="line"></span><br><span class="line">    p-&gt;index = proc_index;</span><br><span class="line">    *param = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encrypt_work</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    EncParam *p = (EncParam *)param;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_encrypt(p-&gt;ctx, p-&gt;enc, &amp;p-&gt;enc_len, p-&gt;data, </span><br><span class="line">                                 p-&gt;data_len), encrypt_clean, param,</span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_encrypt() fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encrypt_clean</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    EncParam *p = (EncParam *)param;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ctx)</span><br><span class="line">        EVP_PKEY_CTX_free(p-&gt;ctx);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;in)</span><br><span class="line">        BIO_free(p-&gt;in);</span><br><span class="line">    OPENSSL_free(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrypt_init</span><span class="params">(Options *opt, <span class="keyword">void</span> **param, <span class="keyword">long</span> proc_index)</span> </span>&#123;</span><br><span class="line">    DecParam *p;</span><br><span class="line">    EVP_PKEY *pkey;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">size_t</span> data_len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> enc[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">size_t</span> enc_len;</span><br><span class="line">    <span class="comment">/* 先加密一次，获取数据 */</span></span><br><span class="line">    EncParam *ep;</span><br><span class="line">    encrypt_init(opt, (<span class="keyword">void</span> **)&amp;ep, (<span class="keyword">long</span>)<span class="number">0</span>);</span><br><span class="line">    encrypt_work(ep);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, ep-&gt;data, ep-&gt;data_len);</span><br><span class="line">    data_len = ep-&gt;data_len;</span><br><span class="line">    <span class="built_in">memcpy</span>(enc, ep-&gt;enc, ep-&gt;enc_len);</span><br><span class="line">    enc_len = ep-&gt;enc_len;</span><br><span class="line">    encrypt_clean(ep);</span><br><span class="line"></span><br><span class="line">    p = OPENSSL_malloc(<span class="keyword">sizeof</span>(DecParam));</span><br><span class="line">    fail_if(!p, <span class="string">&quot;OPENSSL_malloc() fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(DecParam));</span><br><span class="line">    </span><br><span class="line">    p-&gt;in = BIO_new_file(opt-&gt;key, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fail_clean_if(!p-&gt;in, decrypt_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;BIO_new_file(%s) fail\n&quot;</span>, opt-&gt;key);</span><br><span class="line">    pkey = PEM_read_bio_PrivateKey(p-&gt;in, <span class="literal">NULL</span>, <span class="literal">NULL</span>, PEM_AUTO_KEYPASS);</span><br><span class="line">    fail_clean_if(!pkey, decrypt_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;PEM_read_bio_PrivateKey() fail\n&quot;</span>);</span><br><span class="line">    p-&gt;ctx = EVP_PKEY_CTX_new(pkey, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;ctx) &#123;</span><br><span class="line">        EVP_PKEY_free(pkey);</span><br><span class="line">        fail_clean_if(<span class="number">1</span>, decrypt_clean, (<span class="keyword">void</span> *)p, <span class="string">&quot;EVP_PKEY_CTX_new() fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_decrypt_init(p-&gt;ctx), decrypt_clean, (<span class="keyword">void</span> *)p, </span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_decrypt_init() fail\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(p-&gt;data, data, data_len);</span><br><span class="line">    p-&gt;data_len = data_len;</span><br><span class="line">    <span class="built_in">memcpy</span>(p-&gt;enc, enc, enc_len);</span><br><span class="line">    p-&gt;enc_len = enc_len;</span><br><span class="line"></span><br><span class="line">    p-&gt;index = proc_index;</span><br><span class="line">    *param = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrypt_work</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    DecParam *p = (DecParam *)param;</span><br><span class="line">    fail_clean_if(!EVP_PKEY_decrypt(p-&gt;ctx, p-&gt;data, &amp;p-&gt;data_len, p-&gt;enc, </span><br><span class="line">                                 p-&gt;enc_len), decrypt_clean, param,</span><br><span class="line">                  <span class="string">&quot;EVP_PKEY_decrypt() fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrypt_clean</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    DecParam *p = (DecParam *)param;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ctx)</span><br><span class="line">        EVP_PKEY_CTX_free(p-&gt;ctx);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;in)</span><br><span class="line">        BIO_free(p-&gt;in);</span><br><span class="line">    OPENSSL_free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><code>multi-process.c</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span>   <span class="comment">// wait</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>  <span class="comment">// getpid, wait</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span>    <span class="comment">// shmget, shmat, shmctl, shmdt</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span>    <span class="comment">// shmget, shmat, shmctl, shmdt</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span>     <span class="comment">// sigaction, SIGLARM</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>     <span class="comment">// LONG_MIN, LONG_MAX, ULLONG_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span>      <span class="comment">// errno</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>     <span class="comment">// getpid</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>     <span class="comment">// memset</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;work.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> isStop = <span class="number">0</span>;             <span class="comment">// 用于标记测试终止</span></span><br><span class="line">Options opt;                <span class="comment">// 命令行选项</span></span><br><span class="line"><span class="keyword">int</span> shmid;                  <span class="comment">// 共享内存id</span></span><br><span class="line">Result *shm = <span class="literal">NULL</span>;         <span class="comment">// 共享内存地址，用于存放测试结果</span></span><br><span class="line">Result res_total;</span><br><span class="line">Result res_last;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal_child</span><span class="params">(<span class="keyword">int</span> sigNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigNum == SIGALRM) &#123;</span><br><span class="line">        isStop = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal_parent</span><span class="params">(<span class="keyword">int</span> sigNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigNum == SIGALRM) &#123;</span><br><span class="line">        <span class="comment">/* DO REAL-TIME STATISTICS */</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;res_total, <span class="number">0</span>, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; opt.procs; ++i) &#123;</span><br><span class="line">            res_total.count += shm[i].count;</span><br><span class="line">        &#125;</span><br><span class="line">        mylog(<span class="string">&quot;total count %12llu,  average %12.0lf/s\n&quot;</span>,</span><br><span class="line">                res_total.count, (res_total.count - res_last.count)</span><br><span class="line">                / (<span class="keyword">double</span>)opt.interval);</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;res_last, &amp;res_total, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        <span class="comment">/* DO REAL-TIME STATISTICS */</span></span><br><span class="line">        alarm(opt.interval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行测试主循环函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTest</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    HashParam *pa = (HashParam *)param;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; ULLONG_MAX &amp;&amp; !isStop; ++i) &#123;</span><br><span class="line">        <span class="comment">/* DO YOUR WORK */</span></span><br><span class="line">        test_work(param);</span><br><span class="line">        ++shm[pa-&gt;index].count;</span><br><span class="line">        <span class="comment">/* DO YOUR WORK */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> proc_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> isParent = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> wstatus = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act_child</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act_parent</span>;</span></span><br><span class="line"></span><br><span class="line">    rv = process_options(argc, argv, &amp;opt);</span><br><span class="line">    <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mylog(<span class="string">&quot;\n-----------------------------Start Testing-----------------------&quot;</span></span><br><span class="line">          <span class="string">&quot;-------\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* COMMON INIT */</span></span><br><span class="line">    shmid = shmget(IPC_PRIVATE, <span class="keyword">sizeof</span>(<span class="keyword">sizeof</span>(Result) * opt.procs), <span class="number">0666</span>);</span><br><span class="line">    fail_if(<span class="number">-1</span> == shmid, <span class="string">&quot;shmget() failed\n&quot;</span>);</span><br><span class="line">    mylog(<span class="string">&quot;shmid = %d\n&quot;</span>, shmid);</span><br><span class="line">    shm = (Result*)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    fail_if((<span class="keyword">void</span> *) <span class="number">-1</span> == shm, <span class="string">&quot;shmat() failed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里直接进行IPC_RMID操作，进程退出之后会自动detach了, 从而释放共享内存 */</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(shm, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">sizeof</span>(Result) * opt.procs));</span><br><span class="line"></span><br><span class="line">    global_init(&amp;opt);</span><br><span class="line">    <span class="comment">/* COMMON INIT */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(isParent &amp;&amp; i &lt; opt.procs) &#123;</span><br><span class="line">        pid =  fork();</span><br><span class="line">        fail_if(<span class="number">-1</span> == pid, <span class="string">&quot;fork failed %d\n&quot;</span>, pid);    <span class="comment">/* error */</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;                                  <span class="comment">/* child */</span></span><br><span class="line">            isParent = <span class="number">0</span>;</span><br><span class="line">            proc_index = i;                             <span class="comment">// 记录进程索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;                                          <span class="comment">/* parent */</span></span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isParent) &#123;</span><br><span class="line">        <span class="comment">/* PARENT INIT */</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;act_parent, <span class="number">0</span>, <span class="keyword">sizeof</span>(act_parent));</span><br><span class="line">        act_parent.sa_handler = handle_signal_parent;</span><br><span class="line">        <span class="comment">/* 使wait被中断时可以自动恢复 */</span></span><br><span class="line">        act_parent.sa_flags = SA_RESTART;</span><br><span class="line">        rv = sigaction(SIGALRM, &amp;act_parent, <span class="literal">NULL</span>);     <span class="comment">// 用于定时统计结果</span></span><br><span class="line">        fail_if(rv, <span class="string">&quot;sigaction() failed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;res_last, <span class="number">0</span>, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        alarm(opt.interval);</span><br><span class="line">        <span class="comment">/* PARENT INIT */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* DO FINAL STATISTICS */</span></span><br><span class="line">        Result <span class="keyword">final</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;<span class="keyword">final</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(Result));</span><br><span class="line">        <span class="keyword">for</span>(i =<span class="number">0</span> ; i &lt; opt.procs; ++i) &#123;</span><br><span class="line">            pid = wait(&amp;wstatus);                       <span class="comment">// 等待子进程结束</span></span><br><span class="line">            alarm(<span class="number">0</span>);                                   <span class="comment">// 终止定时器</span></span><br><span class="line">            fail_if(<span class="number">-1</span> == pid, <span class="string">&quot;wait() failed, errno=%d\n&quot;</span>, errno);</span><br><span class="line">            mylog(<span class="string">&quot;process [pid = %6d] exit\n&quot;</span>, pid);</span><br><span class="line">            mylog(<span class="string">&quot;process [pid = %6u] count %12llu in %lus,&quot;</span></span><br><span class="line">                  <span class="string">&quot;  average %12.0lf/s\n&quot;</span>, pid, shm[i].count, opt.duration, </span><br><span class="line">                  shm[i].count / (<span class="keyword">double</span>)opt.duration);</span><br><span class="line">            <span class="keyword">final</span>.count += shm[i].count;</span><br><span class="line">        &#125;</span><br><span class="line">        mylog(<span class="string">&quot;total count %12llu in %lus,  average %12.0lf/s\n&quot;</span>, </span><br><span class="line">               <span class="keyword">final</span>.count, opt.duration, <span class="keyword">final</span>.count / (<span class="keyword">double</span>)opt.duration);</span><br><span class="line">        <span class="comment">/* DO FINAL STATISTICS */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* PARENT CLEANUP */</span></span><br><span class="line">        global_clean();</span><br><span class="line">        <span class="comment">/* PARENT CLEANUP */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* CHILD INIT */</span></span><br><span class="line">        <span class="keyword">void</span> *param;</span><br><span class="line">        test_init(&amp;opt, &amp;param, proc_index);</span><br><span class="line">        <span class="comment">/* CHILD INIT */</span></span><br><span class="line"></span><br><span class="line">        act_child.sa_handler = handle_signal_child;</span><br><span class="line">        sigemptyset(&amp;act_child.sa_mask);</span><br><span class="line">        act_child.sa_flags = SA_RESETHAND;</span><br><span class="line">        <span class="comment">/* 用于测试时间到时，通知子进程结束测试 */</span></span><br><span class="line">        rv = sigaction(SIGALRM, &amp;act_child, <span class="literal">NULL</span>);</span><br><span class="line">        fail_if(rv, <span class="string">&quot;sigaction() failed\n&quot;</span>);</span><br><span class="line">        alarm(opt.duration);                            <span class="comment">// 设置测试时长</span></span><br><span class="line">        doTest(param);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CHILD CLEANUP */</span></span><br><span class="line">        test_clean(param);</span><br><span class="line">        global_clean();</span><br><span class="line">        <span class="comment">/* CHILD CLEANUP */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">/* child finished work */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></div>




<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，一个多进程的测试程序就算完成了。读者可以根据自身测试需要，按如下步骤修改以进行自定义的测试。</p>
<ol>
<li>在<code>opt.c</code>和<code>opt.h</code>中，添加需要的命令行选项</li>
<li>在<code>work.c</code>和<code>work.h</code>中，<code>global_init()</code>和<code>global_clean()</code>内进行全局的初始化及全局的清理工作</li>
<li>在<code>work.c</code>和<code>work.h</code>中，添加自定义的测试函数，以及相应的测试参数和测试结果</li>
<li>主控<code>multi-process.c</code>通过<code>test_init()</code>、<code>test_work()</code>、<code>test_clean()</code>调用测试相关的初始化、执行及清理工作</li>
<li>主控<code>multi-process.c</code>中，修改测试结果的更新与统计操作。</li>
</ol>
<p>主控<code>multi-process.c</code>中：</p>
<ul>
<li><code>COMMON INIT</code>、<code>PARENT INIT</code>和<code>CHILD INIT</code>代码块处分别进行公共的初始化工作和父子进程特定的初始化工作。</li>
<li><code>PARENT CLEANUP</code>和<code>CHILD CLEANUP</code>代码块处则分别进行对应的清理工作。</li>
<li><code>DO YOUR WORK</code>处执行具体的测试，<code>DO REAL-TIME STATISTICS</code>和<code>DO FINAL STATISTICS</code>处进行测试结果的统计。</li>
</ul>
<p>当然本文还有一些不足之处，比如当前是用的OpenSSL1.0.2接口，没有兼容不同版本的OpenSSL。还有代码风格的问题，在函数命名和注释方式上不统一。但是考虑到这个是测试程序，就不计较这么多了（^。^）</p>
]]></content>
      <categories>
        <category>技术向</category>
      </categories>
      <tags>
        <tag>多进程</tag>
        <tag>信号</tag>
        <tag>共享内存</tag>
      </tags>
  </entry>
</search>
